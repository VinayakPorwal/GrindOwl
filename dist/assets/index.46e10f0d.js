var zj=Object.defineProperty,Uj=Object.defineProperties;var Vj=Object.getOwnPropertyDescriptors;var Q0=Object.getOwnPropertySymbols;var ok=Object.prototype.hasOwnProperty,ak=Object.prototype.propertyIsEnumerable;var lk=(e,t,n)=>t in e?zj(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,ue=(e,t)=>{for(var n in t||(t={}))ok.call(t,n)&&lk(e,n,t[n]);if(Q0)for(var n of Q0(t))ak.call(t,n)&&lk(e,n,t[n]);return e},De=(e,t)=>Uj(e,Vj(t));var qh=(e,t)=>{var n={};for(var s in e)ok.call(e,s)&&t.indexOf(s)<0&&(n[s]=e[s]);if(e!=null&&Q0)for(var s of Q0(e))t.indexOf(s)<0&&ak.call(e,s)&&(n[s]=e[s]);return n};var Gj=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports);import{j as Bw,r as he,u as Wj,a as al,L as Xh,R as ck,c as uu,B as Hj,b as jj,d as ca,e as qj}from"./vendor.95bf6527.js";var e9e=Gj((Ui,Vi)=>{function Xj(e,t){return t.forEach(function(n){n&&typeof n!="string"&&!Array.isArray(n)&&Object.keys(n).forEach(function(s){if(s!=="default"&&!(s in e)){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(e,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}})}),Object.freeze(e)}const Kj=function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function n(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerpolicy&&(i.referrerPolicy=r.referrerpolicy),r.crossorigin==="use-credentials"?i.credentials="include":r.crossorigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=n(r);fetch(r.href,i)}};Kj();var Qr="/assets/logopng.784ee2f5.png";const k=Bw.exports.jsx,ne=Bw.exports.jsxs,vn=Bw.exports.Fragment;function Yj(e){const{bgcolor:t}=he.exports.useContext(Ve),{Pcolor:n}=he.exports.useContext(Ve),{user:s}=he.exports.useContext(Ve),{token:r}=he.exports.useContext(Ve),{setUserData:i}=he.exports.useContext(Ve),o=[{name:"Dashboard",href:"/",current:!0},{name:"Projects",href:"/project",current:!1},{name:"Profile",href:`/profile/?id=${sessionStorage.getItem("id")}`,current:!1},{name:"About",href:"/about",current:!1}];let a=Wj();he.exports.useEffect(async()=>{console.log(a)},[a]),he.exports.useEffect(()=>{async function p(){const f=sessionStorage.getItem("token"),m=await(await fetch("https://server-ten-iota.vercel.app/auth/getuser",{method:"POST",headers:{"auth-token":f,"Content-Type":"application/json"}})).json();return c(m.Wallet),i(m),m}p()},[r,s]);var[l,c]=he.exports.useState("50");let h=al();var u=!0;e.user=="true"?u=!0:u=!1;function d(){document.getElementById("sidebar").style.display=="none"?(document.getElementById("sidebar").style.display="flex",document.getElementById("hambar").style.transform="rotate(90deg)",document.getElementById("myBar").style.height="2px !important",document.getElementById("mytrack").style.background="var(--grey)",document.getElementById("mytrack").style.height="1px !important"):(document.getElementById("sidebar").style.display="none",document.getElementById("hambar").style.transform="rotate(0deg)",document.getElementById("myBar").style.height="3px ",document.getElementById("mytrack").style.background="var(--lightblack)",document.getElementById("mytrack").style.height="3px")}return k(vn,{children:ne("nav",{className:"navbar",style:{background:t},children:[k("div",{style:{maxWidth:"1200px",background:t,margin:"auto",padding:"0 10px"},children:ne("div",{className:"rightside",style:{background:"none"},children:[ne("div",{className:"logo",style:{background:"none"},children:[k("i",{id:"hambar",className:"fa fa-bars",style:{fontFamily:"FontAwesome",background:"none",color:n},onClick:d}),k("img",{src:Qr,alt:"Workflow"}),ne("div",{className:"WalletSideNav",children:[u&&ne("div",{style:{background:"none",display:"flex",justifyContent:"center",alignItems:"center"},children:[k("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor",className:"w-5 h-5",style:{background:"none"},children:k("path",{fillRule:"evenodd",d:"M1 4a1 1 0 011-1h16a1 1 0 011 1v8a1 1 0 01-1 1H2a1 1 0 01-1-1V4zm12 4a3 3 0 11-6 0 3 3 0 016 0zM4 9a1 1 0 100-2 1 1 0 000 2zm13-1a1 1 0 11-2 0 1 1 0 012 0zM1.75 14.5a.75.75 0 000 1.5c4.417 0 8.693.603 12.749 1.73 1.111.309 2.251-.512 2.251-1.696v-.784a.75.75 0 00-1.5 0v.784a.272.272 0 01-.35.25A49.043 49.043 0 001.75 14.5z",clipRule:"evenodd"})}),ne("p",{style:{background:"none",color:n},children:[" ",l]})]}),k("i",{id:"authicon",className:`fa-light fa-${e.mode}`,style:{fontFamily:"FontAwesome",background:t,color:n,fontStyle:"normal",fontSize:"1.3rem"},onClick:()=>{e.mode==="moon"?(e.setMode("lightbulb"),e.setBgcolor("black"),e.setPcolor("white"),e.setSecondaryColor("#111111")):(e.setMode("moon"),e.setBgcolor("#f8f9fb"),e.setPcolor("black"),e.setSecondaryColor("#ECF3F9"))}})]})]}),k("div",{className:"navtab",style:{background:"none"},children:k("div",{className:"tabgroup",style:{background:"none"},children:o.map(p=>k(Xh,{className:`${a.pathname===p.href?"current":"tab"}`,style:{background:"none"},to:p.href,children:p.name},p.name))})}),ne("div",{className:"credin",style:{background:t},children:[u&&ne(vn,{children:[k("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.5,stroke:"currentColor",className:"w-6 h-6",style:{background:"none"},children:k("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M2.25 18.75a60.07 60.07 0 0115.797 2.101c.727.198 1.453-.342 1.453-1.096V18.75M3.75 4.5v.75A.75.75 0 013 6h-.75m0 0v-.375c0-.621.504-1.125 1.125-1.125H20.25M2.25 6v9m18-10.5v.75c0 .414.336.75.75.75h.75m-1.5-1.5h.375c.621 0 1.125.504 1.125 1.125v9.75c0 .621-.504 1.125-1.125 1.125h-.375m1.5-1.5H21a.75.75 0 00-.75.75v.75m0 0H3.75m0 0h-.375a1.125 1.125 0 01-1.125-1.125V15m1.5 1.5v-.75A.75.75 0 003 15h-.75M15 10.5a3 3 0 11-6 0 3 3 0 016 0zm3 0h.008v.008H18V10.5zm-12 0h.008v.008H6V10.5z",clipRule:"evenodd"})}),ne("p",{style:{background:"none",color:n},children:[" ",l]})]}),k("i",{className:`fa-light fa-${e.mode}`,style:{fontFamily:"FontAwesome",background:t,color:n,fontStyle:"normal",fontSize:"1.3rem"},onClick:()=>{e.mode==="moon"?(e.setMode("lightbulb"),e.setBgcolor("black"),e.setPcolor("white"),e.setSecondaryColor("#111111")):(e.setMode("moon"),e.setBgcolor("#f8f9fb"),e.setPcolor("black"),e.setSecondaryColor("#ECF3F9"))}}),u?k(vn,{children:k("button",{id:"logoutbtn",onClick:()=>{sessionStorage.setItem("Loggedin",!1),sessionStorage.setItem("token",""),sessionStorage.setItem("id",""),h("/login"),e.setUser(!1),console.log(!e.user)},children:"Logout"})}):ne(vn,{children:[k(Xh,{to:"/login",style:{background:"none"},children:k("button",{id:"loginbtn",children:"login"})}),k(Xh,{to:"/signup",style:{background:"none"},children:k("button",{id:"signinbtn",children:"signup"})})]})]})]})}),ne("div",{id:"sidebar",style:{background:t},children:[k("hr",{}),o.map(p=>k(Xh,{style:{background:"none"},className:`${a.pathname===p.href?"current":"sidetab"}`,to:p.href,onClick:()=>d(),children:p.name},p.name)),u?k("div",{className:"sidetab",style:{background:t},children:k("button",{id:"sidelogoutbtn",style:{background:"none"},onClick:()=>{sessionStorage.setItem("Loggedin",!1),h("/login"),e.setUser(!1),console.log(!e.user),d()},children:"Logout"})}):ne("div",{className:"sidetab",style:{background:t},children:[k(Xh,{to:"/login",style:{background:"none"},children:k("button",{id:"sideloginbtn",onClick:()=>d(),children:"login"})}),k(Xh,{to:"/signup",style:{background:"none"},children:k("button",{id:"sidesigninbtn",onClick:()=>d(),children:"signup"})})]})]})]})})}var Eo="/assets/teamillustr2.f7638e3b.png";function uk(){const{bgcolor:e}=he.exports.useContext(Ve);return he.exports.useContext(Ve),he.exports.useContext(Ve),k("div",{className:"slider",children:ne("div",{className:"slide-track",children:[k("div",{className:"slide",children:k("img",{src:Eo,alt:"",style:{background:e}})}),k("div",{className:"slide",children:k("img",{src:Eo,alt:"",style:{background:e}})}),k("div",{className:"slide",children:k("img",{src:Eo,alt:"",style:{background:e}})}),k("div",{className:"slide",children:k("img",{src:Eo,alt:"",style:{background:e}})}),k("div",{className:"slide",children:k("img",{src:Eo,alt:"",style:{background:e}})})]})})}function hk(){const{bgcolor:e}=he.exports.useContext(Ve);return he.exports.useContext(Ve),he.exports.useContext(Ve),k("div",{className:"sliderS",children:ne("div",{className:"slide-trackS",children:[k("div",{className:"slideS",children:k("img",{src:Eo,alt:"",style:{background:e}})}),k("div",{className:"slideS",children:k("img",{src:Eo,alt:"",style:{background:e}})}),k("div",{className:"slideS",children:k("img",{src:Eo,alt:"",style:{background:e}})}),k("div",{className:"slideS",children:k("img",{src:Eo,alt:"",style:{background:e}})}),k("div",{className:"slideS",children:k("img",{src:Eo,alt:"",style:{background:e}})}),k("div",{className:"slideS",children:k("img",{src:Eo,alt:"",style:{background:e}})})]})})}var Qj="/assets/team6.0e8424a0.svg";function Zj(){const{myFunction:e}=he.exports.useContext(Ve);he.exports.useContext(Ve),al(),he.exports.useEffect(()=>{console.log("About")},[]),window.onscroll=function(){e()};const{bgcolor:t}=he.exports.useContext(Ve),{Pcolor:n}=he.exports.useContext(Ve);return he.exports.useContext(Ve),ne("div",{className:"about",children:[ne("div",{className:"containerMainR",style:{display:"flex",alignItems:"center",margin:"0px",background:t},children:[ne("div",{className:"aboutrow",style:{background:t,color:n},children:[k("h3",{className:"abouthead",style:{background:t,color:n},children:"ABOUT US"}),ne("div",{className:"aboutpara",style:{background:"none",color:n},children:["Hey! We at Craft-X are building a series of APIs that will make it much easier to build and operate Decentralized applications. ",k("br",{})," ","We are the community in search for a better web.",k("br",{})," The world is pretty big, but it can be a whole lot smaller when you stop looking at screens."]})]}),k("div",{className:"aboutillus",style:{background:t},children:k("lottie-player",{src:"https://assets3.lottiefiles.com/packages/lf20_bKe7QcfThB.json",background:"transparent",speed:"1",style:{background:"none"},loop:!0,autoplay:!0})})]}),k(uk,{}),k("div",{style:{background:t,fontSize:"xxx-large",height:"200px",display:"flex",justifyContent:"center",alignItems:"center",color:n},children:"Stay Tuned For Api-Section"})]})}var Z0="/assets/member.c60d5dd4.svg";const Jj=[{name:"sujoy",tag:"Developer",role:"Engineer"},{name:"Vijay",tag:"Developer",role:"Engineer"},{name:"Ajay",tag:"Developer",role:"Engineer"},{name:"Parajay",tag:"Developer",role:"Engineer"}];function e6(){const{myFunction:e}=he.exports.useContext(Ve),{user:t}=he.exports.useContext(Ve),{bgcolor:n}=he.exports.useContext(Ve),{Pcolor:s}=he.exports.useContext(Ve),{SecondaryColor:r}=he.exports.useContext(Ve);let i=al();return he.exports.useEffect(()=>{var o=t;o=="true"?console.log("Team"):i("/login")},[]),window.onscroll=function(){e()},ne(vn,{children:[k("div",{className:"header",children:k("div",{className:"progress-container",id:"mytrack",children:k("div",{className:"progress-bar",id:"myBar"})})}),ne("div",{className:"containerMain",style:{display:"flex",background:n},children:[ne("div",{className:"Cardillustration",style:{backgroundColor:n,color:s},children:[k("h3",{className:"Cardhead",style:{background:n,color:s},children:"OUR TEAM"}),k("img",{src:Qj,alt:"",className:"CardillustrationImg"})]}),k(hk,{}),k("div",{className:"CardData",style:{height:"auto",background:"none"},children:Jj.map(o=>k("div",{className:"team",style:{background:"none"},children:k("div",{className:"pcontainer left",style:{background:"none"},children:ne("div",{className:"ChildCard",style:{background:r},children:[k("div",{style:{padding:"5px 10px 0 0",background:"none"},children:k("img",{src:Qr,alt:"Jane",style:{height:"30px",marginRight:"0"}})}),k("img",{src:Z0,alt:"Jane",style:{height:"100px",borderRadius:"5px"}}),ne("div",{style:{background:"none",color:s},children:[k("h2",{style:{background:"none"},children:o.name}),k("p",{className:"title",style:{background:"none",color:s},children:o.role}),k("p",{style:{background:"none"},children:o.tag})]}),k("button",{children:"Contact"})]})})},o.name))})]})]})}function dk(){const[e,t]=he.exports.useState(!1);he.exports.useContext(Ve);const{Pcolor:n}=he.exports.useContext(Ve),{SecondaryColor:s}=he.exports.useContext(Ve);document.querySelector(".input_text");var r=document.querySelector("#name"),i=document.querySelector(".temp");document.querySelector(".feeltemp");var o=document.querySelector(".desc"),a=document.querySelector(".pres"),l=document.querySelector(".hum"),c=document.querySelector(".clouds");document.querySelector("#submit");const[h,u]=he.exports.useState("http://openweathermap.org/img/w/01d.png"),[d,p]=he.exports.useState(""),[f,g]=he.exports.useState(),m=async()=>{if(t(!0),!d)return;const b=await(await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${d}&appid=75604dabe1d443f2296dedb386f124a4`)).json();if(console.log(b),b.cod===200){u("http://openweathermap.org/img/w/"+b.weather[0].icon+".png"),g("");var x=b.main.temp;b.main.feels_like;var w=b.name,S=b.weather[0].description,C=b.clouds.all,_=b.main.pressure,T=b.main.humidity,E=x-273.15;E=Math.round(E*100)/100,t(!1),p(""),r.innerHTML=w,o.innerHTML="Desc - "+S,l.innerHTML="humadity - "+T,a.innerHTML="pressure - "+_,i.innerHTML="Temp - "+E+"\xB0C",c.innerHTML="Clouds - "+C}else t(!1),g(b.message)};function y(v){v.keyCode===13&&(console.log("Enter"),m())}return ne("div",{style:{background:"none",margin:"10vh 0 0 0"},children:[k("h2",{className:"Cardhead",style:{color:n},children:"Weather API"}),k("br",{}),ne("div",{className:"main",children:[ne("div",{className:"input-group",children:[k("input",{type:"text",className:"input",id:"Email",placeholder:"Type Your City Name...",autoComplete:"off",value:d,onChange:v=>p(v.target.value),onKeyDown:y,style:{color:n}}),k("button",{className:"button--submit",onClick:m,children:k("i",{className:"fa fa-search",style:{color:"white",background:"none"}})})]}),k("p",{style:{background:"none",color:n,textAlign:"center"},children:f}),e&&k("div",{style:{margin:"auto",maxWidth:"500px"},className:"Ytloader"})]}),ne("div",{className:"output",children:[k("div",{className:"card card1",style:{background:"var(--dblue)",color:n},children:k("img",{className:"weathericon",src:h,alt:""})}),ne("div",{className:"card card2",style:{background:s,color:n},children:[k("h1",{className:"name",id:"name",style:{color:"var(--dblue)"},children:"City"}),k("p",{className:"temp",children:"Temp : 00"}),k("p",{className:"clouds",children:"Clouds : none"}),k("p",{className:"desc",children:"Description : none"}),k("p",{className:"pres",children:"Pressure : none"}),k("p",{className:"hum",children:" Humadity : none"})]})]})]})}function t6(e){return he.exports.createElement("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor","aria-hidden":"true"},e),he.exports.createElement("path",{fillRule:"evenodd",d:"M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",clipRule:"evenodd"}))}function pk(e){return he.exports.createElement("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor","aria-hidden":"true"},e),he.exports.createElement("path",{d:"M11 3a1 1 0 100 2h2.586l-6.293 6.293a1 1 0 101.414 1.414L15 6.414V9a1 1 0 102 0V4a1 1 0 00-1-1h-5z"}),he.exports.createElement("path",{d:"M5 5a2 2 0 00-2 2v8a2 2 0 002 2h8a2 2 0 002-2v-3a1 1 0 10-2 0v3H5V7h3a1 1 0 000-2H5z"}))}function n6(e){return he.exports.createElement("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor","aria-hidden":"true"},e),he.exports.createElement("path",{fillRule:"evenodd",d:"M3 7a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 13a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z",clipRule:"evenodd"}))}function s6(e){return he.exports.createElement("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor","aria-hidden":"true"},e),he.exports.createElement("path",{d:"M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z"}))}function fk(e){return he.exports.createElement("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor","aria-hidden":"true"},e),he.exports.createElement("path",{fillRule:"evenodd",d:"M8 4a3 3 0 00-3 3v4a5 5 0 0010 0V7a1 1 0 112 0v4a7 7 0 11-14 0V7a5 5 0 0110 0v4a3 3 0 11-6 0V7a1 1 0 012 0v4a1 1 0 102 0V7a3 3 0 00-3-3z",clipRule:"evenodd"}))}function mk(e){return he.exports.createElement("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor","aria-hidden":"true"},e),he.exports.createElement("path",{d:"M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z"}))}function r6(e){return he.exports.createElement("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor","aria-hidden":"true"},e),he.exports.createElement("path",{d:"M9 6a3 3 0 11-6 0 3 3 0 016 0zM17 6a3 3 0 11-6 0 3 3 0 016 0zM12.93 17c.046-.327.07-.66.07-1a6.97 6.97 0 00-1.5-4.33A5 5 0 0119 16v1h-6.07zM6 11a5 5 0 015 5v1H1v-1a5 5 0 015-5z"}))}function i6(e){return he.exports.createElement("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor","aria-hidden":"true"},e),he.exports.createElement("path",{fillRule:"evenodd",d:"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",clipRule:"evenodd"}))}function o6(){const[e,t]=he.exports.useState(!1),[n,s]=he.exports.useState(),[r,i]=he.exports.useState(),{setToken:o}=he.exports.useContext(Ve),{bgcolor:a}=he.exports.useContext(Ve),{Pcolor:l}=he.exports.useContext(Ve),{SecondaryColor:c}=he.exports.useContext(Ve);let h;function u(m){m.textContent="",h=setInterval(()=>{m.textContent+=".",m.textContent==="...."&&(m.textContent="")},300)}function d(){const m=Date.now(),v=Math.random().toString(16);return`id-${m}-${v}`}function p(m,y){let v=0,b=setInterval(()=>{v<y.length?(m.innerHTML+=y.charAt(v),v++):clearInterval(b)},20)}function f(m,y,v){return`<div class="wrap ${m?"bot":"User"}">
    <p class="${m?"botFace":"UserFace"}">
    <i class="fa fa-${m?"robot":"user"}"></i>
    </p>
    <li class="message" id=${v} >${y}</li>
    </div>`}async function g(){const m=document.querySelector(".message-list");m.innerHTML+=f(!1,n),console.log(n),s("");const y=d();m.innerHTML+=f(!0," ",y),t(!0),m.scrollTop=m.scrollHeight;const v=document.getElementById(y);u(v);try{var b=await(await fetch("https://server-ten-iota.vercel.app/Ai/chat",{method:"POST",headers:{mode:"no-cors","Access-Control-Allow-Origin":"*","Access-Control-Allow-Credentials":!0,"Content-Type":"application/json","auth-token":sessionStorage.getItem("token")},body:`{"prompt":"${n}"}`})).json();console.log(b);var x;b.error?x=b.error:x=b.data[0].text,clearInterval(h),v.innerHTML=" ",p(v,x),x=x.replace(/\n/g,"<br/>"),i(x),t(!1);const S=Date.now();o(S)}catch(w){x=w,console.log(w),clearInterval(h),v.innerHTML=" ",p(v,"We appologize for Your inconvenience!! Server is down try after Some period of time."),t(!1)}}return ne(vn,{children:[ne("h2",{className:"Cardhead",style:{marginTop:"10vh",background:a,color:l,marginBottom:"0px"},children:["Ask Anything with ChatGPT"," ",k("p",{className:"botFace",style:{display:"inline-flex"},children:k("i",{className:"fa fa-robot"})})]}),ne("h2",{style:{background:"none",textAlign:"center",fontSize:"large",margin:"0 0 10px 0",color:l},children:["A GPT-3 Model by ",k("b",{children:"OpenAi"})]}),ne("div",{className:"Chatcard",children:[ne("div",{className:"chat-header",style:{background:a,color:l},children:["ChatGPT",ne("div",{style:{background:"none",float:"right",display:"flex",alignItems:"center",color:l},children:["1",k("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.5,stroke:"currentColor",className:"w-6 h-6",style:{background:"none",margin:"5px",color:"var(--dblue)"},children:k("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M2.25 18.75a60.07 60.07 0 0115.797 2.101c.727.198 1.453-.342 1.453-1.096V18.75M3.75 4.5v.75A.75.75 0 013 6h-.75m0 0v-.375c0-.621.504-1.125 1.125-1.125H20.25M2.25 6v9m18-10.5v.75c0 .414.336.75.75.75h.75m-1.5-1.5h.375c.621 0 1.125.504 1.125 1.125v9.75c0 .621-.504 1.125-1.125 1.125h-.375m1.5-1.5H21a.75.75 0 00-.75.75v.75m0 0H3.75m0 0h-.375a1.125 1.125 0 01-1.125-1.125V15m1.5 1.5v-.75A.75.75 0 003 15h-.75M15 10.5a3 3 0 11-6 0 3 3 0 016 0zm3 0h.008v.008H18V10.5zm-12 0h.008v.008H6V10.5z",clipRule:"evenodd"})})," "]})]}),ne("div",{className:"chat-window",style:{background:c,color:l},children:[ne("div",{className:"wrap User",style:{display:"flex",justifyContent:"space-around",border:`2px dashed ${l}`,margin:"2px 4px",background:"none"},children:[k("p",{className:"botFace",children:k("i",{className:"fa fa-robot"})}),k("li",{className:"message",style:{width:"auto",color:l},children:"Ask Anything"}),k("p",{className:"UserFace",children:k("i",{className:"fa fa-user"})})]}),k("ul",{className:"message-list",children:e&&k(vn,{})}),ne("div",{className:"wrap bot",id:"format",style:{display:"none"},children:[k("p",{className:"botFace",children:k("i",{className:"fa fa-robot"})}),k("li",{dangerouslySetInnerHTML:{__html:r},className:"message"})]}),k("div",{id:"endScroll"})]}),ne("div",{className:"chat-input",style:{background:a,color:l,borderRadius:"0 0 5px 5px"},children:[k("input",{type:"text",className:"message-input",placeholder:"Type your message here",value:n,onChange:m=>s(m.target.value),onKeyDown:m=>{m.key==="Enter"&&g()},style:{background:c,outline:"none",border:"1px solid rgb(17,17,17)"}}),k("button",{className:"send-button",onClick:g,style:{background:"none"},children:k(s6,{className:"flex-shrink-0 h-5 w-5 text-gray-400","aria-hidden":"true",style:{background:"none",color:"var(--dblue)",transform:"rotate(90deg)"}})})]})]})]})}function a6(){const[e,t]=he.exports.useState(),[n,s]=he.exports.useState(Qr),[r,i]=he.exports.useState(Qr),[o,a]=he.exports.useState(!1),[l,c]=he.exports.useState(!1),[h,u]=he.exports.useState(!1),[d,p]=he.exports.useState(!1),[f,g]=he.exports.useState(),{setToken:m}=he.exports.useContext(Ve),{bgcolor:y}=he.exports.useContext(Ve),{Pcolor:v}=he.exports.useContext(Ve),{SecondaryColor:b}=he.exports.useContext(Ve);async function x(){a(!0),c(!0),console.log(e);var S=await(await fetch("https://server-ten-iota.vercel.app/Ai/image",{method:"POST",headers:{mode:"no-cors","Access-Control-Allow-Origin":"*","Access-Control-Allow-Credentials":!0,"auth-token":sessionStorage.getItem("token"),"Content-Type":"application/json"},body:`{"prompt":"${e}"}`})).json();if(console.log(S),S.data){s(S.data.data[0].url),i(S.data.data[1].url),a(!1),c(!1),p(!0),u(!0);const C=Date.now();m(C)}else g(S.error),a(!1),c(!1)}return ne(vn,{children:[k("h2",{className:"Cardhead",style:{background:y,color:v,marginBottom:"0px"},children:"Generate Your IMAGINATION"}),ne("h2",{style:{background:"none",textAlign:"center",fontSize:"large",margin:"0 0 10px 0",color:v},children:["Dalle-2 Model by ",k("b",{children:"OpenAi"})]}),ne("div",{className:"input-group",children:[k("input",{type:"text",className:"input",id:"Email",placeholder:"Start Imagining...",autoComplete:"off",value:e,onChange:w=>t(w.target.value),onKeyDown:w=>{w.key==="Enter"&&x()},style:{color:v}}),k("button",{className:"button--submit",onClick:x,children:"Generate"})]}),k("p",{style:{background:"none",color:v,textAlign:"center"},children:f}),ne("div",{className:"CodeCard",style:{backgroundColor:b},children:[ne("div",{className:"tools",style:{backgroundColor:v},children:[k("div",{className:"circle",children:k("span",{className:"red box"})}),k("div",{className:"circle",children:k("span",{className:"yellow box"})}),k("div",{className:"circle",children:k("span",{className:"green box"})}),ne("div",{style:{background:"none",marginLeft:"auto",display:"flex",alignItems:"center",color:y},children:["1",k("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.5,stroke:"currentColor",className:"w-6 h-6",style:{background:"none",margin:"5px",color:"var(--dblue)"},children:k("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M2.25 18.75a60.07 60.07 0 0115.797 2.101c.727.198 1.453-.342 1.453-1.096V18.75M3.75 4.5v.75A.75.75 0 013 6h-.75m0 0v-.375c0-.621.504-1.125 1.125-1.125H20.25M2.25 6v9m18-10.5v.75c0 .414.336.75.75.75h.75m-1.5-1.5h.375c.621 0 1.125.504 1.125 1.125v9.75c0 .621-.504 1.125-1.125 1.125h-.375m1.5-1.5H21a.75.75 0 00-.75.75v.75m0 0H3.75m0 0h-.375a1.125 1.125 0 01-1.125-1.125V15m1.5 1.5v-.75A.75.75 0 003 15h-.75M15 10.5a3 3 0 11-6 0 3 3 0 016 0zm3 0h.008v.008H18V10.5zm-12 0h.008v.008H6V10.5z",clipRule:"evenodd"})})," "]})]}),ne("div",{className:"card__content",children:[ne("div",{className:"Status  Cardhead",style:{color:v},children:[o&&k(vn,{children:" Generating..."}),h&&k(vn,{children:" Loading..."})]}),ne("div",{style:{display:"flex",background:"none",flexWrap:"wrap",width:"80vw",maxWidth:"700px"},children:[ne("div",{className:"Colorcard",children:[ne("div",{className:"Colorcard__content",children:[k("img",{src:n,alt:"",className:"link",onLoad:()=>u(!1),style:{display:h?"none":"block"}}),o&&k("div",{className:"spinner",children:k("div",{className:"spinnerin"})}),h&&k("div",{className:"Imgloader",children:k("div",{className:"Imgwrapper",children:k("div",{className:"line-1",children:k("img",{src:Qr,alt:""})})})})]}),k("div",{className:"blob"}),k("div",{className:"blob"}),k("div",{className:"blob"}),k("div",{className:"blob"})]}),ne("div",{className:"Colorcard",children:[ne("div",{className:"Colorcard__content",children:[" ",k("img",{src:r,alt:"",className:"link",onLoad:()=>p(!1),style:{display:d?"none":"block"}}),l&&k("div",{className:"spinner",children:k("div",{className:"spinnerin"})}),d&&k("div",{className:"Imgloader",children:k("div",{className:"Imgwrapper",children:k("div",{className:"line-1",children:k("img",{src:Qr,alt:""})})})})]}),k("div",{className:"blob"}),k("div",{className:"blob"}),k("div",{className:"blob"}),k("div",{className:"blob"})]})]})]})]})]})}function l6(){const[e,t]=he.exports.useState("Luck is what happens when preparation meets opportunity."),[n,s]=he.exports.useState("Seneca");he.exports.useContext(Ve);const{Pcolor:r}=he.exports.useContext(Ve);he.exports.useContext(Ve);async function i(){document.getElementById("QouteCard").style.transform="rotate(2deg)";var a=await(await fetch("https://server-ten-iota.vercel.app/Qoutes/random")).json();t(a.qoute),s(a.author),console.log(n,e),document.getElementById("QouteCard").style.transform="rotate(0deg)"}return ne(vn,{children:[k("h2",{className:"Cardhead",style:{color:r},children:"Qoutes API"}),k("br",{}),ne("div",{style:{background:"none",display:"flex",alignItems:"center",width:"80vw",maxWidth:"700px",margin:"auto",flexWrap:"wrap",justifyContent:"space-evenly"},children:[ne("div",{style:{background:"none",color:r},children:[k("h2",{className:"Cardhead",style:{color:r,fontSize:"x-large"},children:"EndPoints"}),ne("h1",{className:"Status",style:{fontSize:"large"},children:[k("a",{style:{background:"none",color:"var(--dblue)"},children:"API "}),"/Qoutes"]}),ne("h1",{className:"Status",style:{fontSize:"large"},children:[k("a",{style:{background:"none",color:"var(--dblue)"},children:"API "}),"/Qoutes/random"]}),k("br",{})]}),ne("div",{className:"Qoutecard",id:"QouteCard",onClick:()=>{i()},children:[k("div",{className:"card-name",children:"Tap for New QOUTE"}),k("div",{className:"quote",children:k("svg",{width:"90",height:"100",viewBox:"0 0 330 307",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:k("path",{d:"M302.258 176.221C320.678 176.221 329.889 185.432 329.889 203.853V278.764C329.889 297.185 320.678 306.395 302.258 306.395H231.031C212.61 306.395 203.399 297.185 203.399 278.764V203.853C203.399 160.871 207.902 123.415 216.908 91.4858C226.323 59.1472 244.539 30.902 271.556 6.75027C280.562 -1.02739 288.135 -2.05076 294.275 3.68014L321.906 29.4692C328.047 35.2001 326.614 42.1591 317.608 50.3461C303.69 62.6266 292.228 80.4334 283.223 103.766C274.626 126.69 270.328 150.842 270.328 176.221H302.258ZM99.629 176.221C118.05 176.221 127.26 185.432 127.26 203.853V278.764C127.26 297.185 118.05 306.395 99.629 306.395H28.402C9.98126 306.395 0.770874 297.185 0.770874 278.764V203.853C0.770874 160.871 5.27373 123.415 14.2794 91.4858C23.6945 59.1472 41.9106 30.902 68.9277 6.75027C77.9335 -1.02739 85.5064 -2.05076 91.6467 3.68014L119.278 29.4692C125.418 35.2001 123.985 42.1591 114.98 50.3461C101.062 62.6266 89.6 80.4334 80.5942 103.766C71.9979 126.69 67.6997 150.842 67.6997 176.221H99.629Z",fill:"currentColor"})})}),ne("div",{className:"body-text",children:[e," ",k("br",{}),k("div",{className:"author",children:ne("span",{children:[" - ",n]})})]})]})]})]})}function c6(){const[e,t]=he.exports.useState(),[n,s]=he.exports.useState(),[r,i]=he.exports.useState(!1),[o,a]=he.exports.useState(),{bgcolor:l}=he.exports.useContext(Ve),{Pcolor:c}=he.exports.useContext(Ve);he.exports.useContext(Ve);async function h(u){i(!0),console.log(n);const p=await(await fetch(`https://server-ten-iota.vercel.app/download/?url=${n}`,{"Access-Control-Allow-Origin":"*","Access-Control-Allow-Credentials":!0})).json();console.log(p),t(p.info),a(p.url),i(!1)}return ne(vn,{children:[k("h2",{className:"Cardhead",style:{background:l,color:c},children:"Download Youtube Videos"}),ne("div",{className:"input-group",children:[k("input",{type:"text",className:"input",id:"Email",placeholder:"Paste your Video Link...",autoComplete:"off",value:n,onChange:u=>s(u.target.value),onKeyDown:u=>{u.key==="Enter"&&h()},style:{color:c}}),k("button",{className:"button--submit",onClick:h,children:k("i",{className:"fa fa-download",style:{background:"none"}})})]}),r&&k("div",{style:{margin:"auto",maxWidth:"600px"},className:"Ytloader"}),k("div",{style:{height:"50vh",overflow:"scroll",width:"80vw",maxWidth:"500px",margin:"auto",background:"none"},children:e&&e.map((u,d)=>ne("div",{style:{padding:"10px 0",background:"none"},download:!0,children:[k("a",{href:u.url,style:{padding:"0 0 0 10px",color:"var(--dblue)",background:"none"},children:"Download"}),u&&ne("a",{href:u.url,download:!0,style:{padding:"0 20px",color:c,background:"none"},children:[u.mimeType.split(";")[0]," ",u.hasVideo?u.height+"p":"",!u.hasAudio&&k("i",{className:"fa fa-volume-mute text-danger",style:{background:"none",color:"var(--yellow)"}})]})]},d))})]})}var u6=Object.create,zw=Object.defineProperty,h6=Object.getOwnPropertyDescriptor,d6=Object.getOwnPropertyNames,p6=Object.getPrototypeOf,f6=Object.prototype.hasOwnProperty,Uw=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),m6=(e,t)=>{for(var n in t)zw(e,n,{get:t[n],enumerable:!0})},g6=(e,t,n,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of d6(t))!f6.call(e,r)&&r!==n&&zw(e,r,{get:()=>t[r],enumerable:!(s=h6(t,r))||s.enumerable});return e},J0=(e,t,n)=>(n=e!=null?u6(p6(e)):{},g6(t||!e||!e.__esModule?zw(n,"default",{value:e,enumerable:!0}):n,e)),y6=Uw((e,t)=>{(function(n,s){typeof e=="object"?t.exports=s():typeof define=="function"&&define.amd?define(s):n.Alea=s()})(e,function(){return n.importState=function(r){var i=new n;return i.importState(r),i},n;function n(){return function(r){var i=0,o=0,a=0,l=1;r.length==0&&(r=[+new Date]);var c=s();i=c(" "),o=c(" "),a=c(" ");for(var h=0;h<r.length;h++)i-=c(r[h]),i<0&&(i+=1),o-=c(r[h]),o<0&&(o+=1),a-=c(r[h]),a<0&&(a+=1);c=null;var u=function(){var d=2091639*i+l*23283064365386963e-26;return i=o,o=a,a=d-(l=d|0)};return u.next=u,u.uint32=function(){return u()*4294967296},u.fract53=function(){return u()+(u()*2097152|0)*11102230246251565e-32},u.version="Alea 0.9",u.args=r,u.exportState=function(){return[i,o,a,l]},u.importState=function(d){i=+d[0]||0,o=+d[1]||0,a=+d[2]||0,l=+d[3]||0},u}(Array.prototype.slice.call(arguments))}function s(){var r=4022871197,i=function(o){o=o.toString();for(var a=0;a<o.length;a++){r+=o.charCodeAt(a);var l=.02519603282416938*r;r=l>>>0,l-=r,l*=r,r=l>>>0,l-=r,r+=l*4294967296}return(r>>>0)*23283064365386963e-26};return i.version="Mash 0.9",i}})}),gk=Uw((e,t)=>{(function(n,s){typeof e=="object"&&typeof t<"u"?s(e):typeof define=="function"&&define.amd?define(["exports"],s):s((n=typeof globalThis<"u"?globalThis:n||self).SVDJS={})})(e,function(n){n.SVD=function(s,r,i,o,a){if(r=r===void 0||r,i=i===void 0||i,a=1e-64/(o=o||Math.pow(2,-52)),!s)throw new TypeError("Matrix a is not defined");var l,c,h,u,d,p,f,g,m,y,v,b,x=s[0].length,w=s.length;if(w<x)throw new TypeError("Invalid matrix: m < n");for(var S=[],C=[],_=[],T=r==="f"?w:x,E=y=f=0;E<w;E++)C[E]=new Array(T).fill(0);for(E=0;E<x;E++)_[E]=new Array(x).fill(0);var A,D=new Array(x).fill(0);for(E=0;E<w;E++)for(l=0;l<x;l++)C[E][l]=s[E][l];for(E=0;E<x;E++){for(S[E]=f,m=0,h=E+1,l=E;l<w;l++)m+=Math.pow(C[l][E],2);if(m<a)f=0;else for(g=(p=C[E][E])*(f=p<0?Math.sqrt(m):-Math.sqrt(m))-m,C[E][E]=p-f,l=h;l<x;l++){for(m=0,c=E;c<w;c++)m+=C[c][E]*C[c][l];for(p=m/g,c=E;c<w;c++)C[c][l]=C[c][l]+p*C[c][E]}for(D[E]=f,m=0,l=h;l<x;l++)m+=Math.pow(C[E][l],2);if(m<a)f=0;else{for(g=(p=C[E][E+1])*(f=p<0?Math.sqrt(m):-Math.sqrt(m))-m,C[E][E+1]=p-f,l=h;l<x;l++)S[l]=C[E][l]/g;for(l=h;l<w;l++){for(m=0,c=h;c<x;c++)m+=C[l][c]*C[E][c];for(c=h;c<x;c++)C[l][c]=C[l][c]+m*S[c]}}y<(v=Math.abs(D[E])+Math.abs(S[E]))&&(y=v)}if(i)for(E=x-1;0<=E;E--){if(f!==0){for(g=C[E][E+1]*f,l=h;l<x;l++)_[l][E]=C[E][l]/g;for(l=h;l<x;l++){for(m=0,c=h;c<x;c++)m+=C[E][c]*_[c][l];for(c=h;c<x;c++)_[c][l]=_[c][l]+m*_[c][E]}}for(l=h;l<x;l++)_[E][l]=0,_[l][E]=0;_[E][E]=1,f=S[E],h=E}if(r){if(r==="f")for(E=x;E<w;E++){for(l=x;l<w;l++)C[E][l]=0;C[E][E]=1}for(E=x-1;0<=E;E--){for(h=E+1,f=D[E],l=h;l<T;l++)C[E][l]=0;if(f!==0){for(g=C[E][E]*f,l=h;l<T;l++){for(m=0,c=h;c<w;c++)m+=C[c][E]*C[c][l];for(p=m/g,c=E;c<w;c++)C[c][l]=C[c][l]+p*C[c][E]}for(l=E;l<w;l++)C[l][E]=C[l][E]/f}else for(l=E;l<w;l++)C[l][E]=0;C[E][E]=C[E][E]+1}}for(o*=y,c=x-1;0<=c;c--)for(var O=0;O<50;O++){for(A=!1,h=c;0<=h;h--){if(Math.abs(S[h])<=o){A=!0;break}if(Math.abs(D[h-1])<=o)break}if(!A){for(d=0,u=h-(m=1),E=h;E<c+1&&(p=m*S[E],S[E]=d*S[E],!(Math.abs(p)<=o));E++)if(f=D[E],D[E]=Math.sqrt(p*p+f*f),d=f/(g=D[E]),m=-p/g,r)for(l=0;l<w;l++)v=C[l][u],b=C[l][E],C[l][u]=v*d+b*m,C[l][E]=-v*m+b*d}if(b=D[c],h===c){if(b<0&&(D[c]=-b,i))for(l=0;l<x;l++)_[l][c]=-_[l][c];break}for(y=D[h],p=(((v=D[c-1])-b)*(v+b)+((f=S[c-1])-(g=S[c]))*(f+g))/(2*g*v),f=Math.sqrt(p*p+1),p=((y-b)*(y+b)+g*(v/(p<0?p-f:p+f)-g))/y,E=h+(m=d=1);E<c+1;E++){if(f=S[E],v=D[E],g=m*f,f*=d,b=Math.sqrt(p*p+g*g),p=y*(d=p/(S[E-1]=b))+f*(m=g/b),f=-y*m+f*d,g=v*m,v*=d,i)for(l=0;l<x;l++)y=_[l][E-1],b=_[l][E],_[l][E-1]=y*d+b*m,_[l][E]=-y*m+b*d;if(b=Math.sqrt(p*p+g*g),p=(d=p/(D[E-1]=b))*f+(m=g/b)*v,y=-m*f+d*v,r)for(l=0;l<w;l++)v=C[l][E-1],b=C[l][E],C[l][E-1]=v*d+b*m,C[l][E]=-v*m+b*d}S[h]=0,S[c]=p,D[c]=y}for(E=0;E<x;E++)D[E]<o&&(D[E]=0);return{u:C,q:D,v:_}},n.VERSION="1.1.1",Object.defineProperty(n,"__esModule",{value:!0})})}),v6=Uw(e=>{(function(){var t=function(){this.init()};t.prototype={init:function(){var u=this||n;return u._counter=1e3,u._html5AudioPool=[],u.html5PoolSize=10,u._codecs={},u._howls=[],u._muted=!1,u._volume=1,u._canPlayEvent="canplaythrough",u._navigator=typeof window<"u"&&window.navigator?window.navigator:null,u.masterGain=null,u.noAudio=!1,u.usingWebAudio=!0,u.autoSuspend=!0,u.ctx=null,u.autoUnlock=!0,u._setup(),u},volume:function(u){var d=this||n;if(u=parseFloat(u),d.ctx||h(),typeof u<"u"&&u>=0&&u<=1){if(d._volume=u,d._muted)return d;d.usingWebAudio&&d.masterGain.gain.setValueAtTime(u,n.ctx.currentTime);for(var p=0;p<d._howls.length;p++)if(!d._howls[p]._webAudio)for(var f=d._howls[p]._getSoundIds(),g=0;g<f.length;g++){var m=d._howls[p]._soundById(f[g]);m&&m._node&&(m._node.volume=m._volume*u)}return d}return d._volume},mute:function(u){var d=this||n;d.ctx||h(),d._muted=u,d.usingWebAudio&&d.masterGain.gain.setValueAtTime(u?0:d._volume,n.ctx.currentTime);for(var p=0;p<d._howls.length;p++)if(!d._howls[p]._webAudio)for(var f=d._howls[p]._getSoundIds(),g=0;g<f.length;g++){var m=d._howls[p]._soundById(f[g]);m&&m._node&&(m._node.muted=u?!0:m._muted)}return d},stop:function(){for(var u=this||n,d=0;d<u._howls.length;d++)u._howls[d].stop();return u},unload:function(){for(var u=this||n,d=u._howls.length-1;d>=0;d--)u._howls[d].unload();return u.usingWebAudio&&u.ctx&&typeof u.ctx.close<"u"&&(u.ctx.close(),u.ctx=null,h()),u},codecs:function(u){return(this||n)._codecs[u.replace(/^x-/,"")]},_setup:function(){var u=this||n;if(u.state=u.ctx&&u.ctx.state||"suspended",u._autoSuspend(),!u.usingWebAudio)if(typeof Audio<"u")try{var d=new Audio;typeof d.oncanplaythrough>"u"&&(u._canPlayEvent="canplay")}catch{u.noAudio=!0}else u.noAudio=!0;try{var d=new Audio;d.muted&&(u.noAudio=!0)}catch{}return u.noAudio||u._setupCodecs(),u},_setupCodecs:function(){var u=this||n,d=null;try{d=typeof Audio<"u"?new Audio:null}catch{return u}if(!d||typeof d.canPlayType!="function")return u;var p=d.canPlayType("audio/mpeg;").replace(/^no$/,""),f=u._navigator?u._navigator.userAgent:"",g=f.match(/OPR\/([0-6].)/g),m=g&&parseInt(g[0].split("/")[1],10)<33,y=f.indexOf("Safari")!==-1&&f.indexOf("Chrome")===-1,v=f.match(/Version\/(.*?) /),b=y&&v&&parseInt(v[1],10)<15;return u._codecs={mp3:!!(!m&&(p||d.canPlayType("audio/mp3;").replace(/^no$/,""))),mpeg:!!p,opus:!!d.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/,""),ogg:!!d.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),oga:!!d.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),wav:!!(d.canPlayType('audio/wav; codecs="1"')||d.canPlayType("audio/wav")).replace(/^no$/,""),aac:!!d.canPlayType("audio/aac;").replace(/^no$/,""),caf:!!d.canPlayType("audio/x-caf;").replace(/^no$/,""),m4a:!!(d.canPlayType("audio/x-m4a;")||d.canPlayType("audio/m4a;")||d.canPlayType("audio/aac;")).replace(/^no$/,""),m4b:!!(d.canPlayType("audio/x-m4b;")||d.canPlayType("audio/m4b;")||d.canPlayType("audio/aac;")).replace(/^no$/,""),mp4:!!(d.canPlayType("audio/x-mp4;")||d.canPlayType("audio/mp4;")||d.canPlayType("audio/aac;")).replace(/^no$/,""),weba:!!(!b&&d.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,"")),webm:!!(!b&&d.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,"")),dolby:!!d.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/,""),flac:!!(d.canPlayType("audio/x-flac;")||d.canPlayType("audio/flac;")).replace(/^no$/,"")},u},_unlockAudio:function(){var u=this||n;if(!(u._audioUnlocked||!u.ctx)){u._audioUnlocked=!1,u.autoUnlock=!1,!u._mobileUnloaded&&u.ctx.sampleRate!==44100&&(u._mobileUnloaded=!0,u.unload()),u._scratchBuffer=u.ctx.createBuffer(1,1,22050);var d=function(p){for(;u._html5AudioPool.length<u.html5PoolSize;)try{var f=new Audio;f._unlocked=!0,u._releaseHtml5Audio(f)}catch{u.noAudio=!0;break}for(var g=0;g<u._howls.length;g++)if(!u._howls[g]._webAudio)for(var m=u._howls[g]._getSoundIds(),y=0;y<m.length;y++){var v=u._howls[g]._soundById(m[y]);v&&v._node&&!v._node._unlocked&&(v._node._unlocked=!0,v._node.load())}u._autoResume();var b=u.ctx.createBufferSource();b.buffer=u._scratchBuffer,b.connect(u.ctx.destination),typeof b.start>"u"?b.noteOn(0):b.start(0),typeof u.ctx.resume=="function"&&u.ctx.resume(),b.onended=function(){b.disconnect(0),u._audioUnlocked=!0,document.removeEventListener("touchstart",d,!0),document.removeEventListener("touchend",d,!0),document.removeEventListener("click",d,!0),document.removeEventListener("keydown",d,!0);for(var x=0;x<u._howls.length;x++)u._howls[x]._emit("unlock")}};return document.addEventListener("touchstart",d,!0),document.addEventListener("touchend",d,!0),document.addEventListener("click",d,!0),document.addEventListener("keydown",d,!0),u}},_obtainHtml5Audio:function(){var u=this||n;if(u._html5AudioPool.length)return u._html5AudioPool.pop();var d=new Audio().play();return d&&typeof Promise<"u"&&(d instanceof Promise||typeof d.then=="function")&&d.catch(function(){console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")}),new Audio},_releaseHtml5Audio:function(u){var d=this||n;return u._unlocked&&d._html5AudioPool.push(u),d},_autoSuspend:function(){var u=this;if(!(!u.autoSuspend||!u.ctx||typeof u.ctx.suspend>"u"||!n.usingWebAudio)){for(var d=0;d<u._howls.length;d++)if(u._howls[d]._webAudio){for(var p=0;p<u._howls[d]._sounds.length;p++)if(!u._howls[d]._sounds[p]._paused)return u}return u._suspendTimer&&clearTimeout(u._suspendTimer),u._suspendTimer=setTimeout(function(){if(u.autoSuspend){u._suspendTimer=null,u.state="suspending";var f=function(){u.state="suspended",u._resumeAfterSuspend&&(delete u._resumeAfterSuspend,u._autoResume())};u.ctx.suspend().then(f,f)}},3e4),u}},_autoResume:function(){var u=this;if(!(!u.ctx||typeof u.ctx.resume>"u"||!n.usingWebAudio))return u.state==="running"&&u.ctx.state!=="interrupted"&&u._suspendTimer?(clearTimeout(u._suspendTimer),u._suspendTimer=null):u.state==="suspended"||u.state==="running"&&u.ctx.state==="interrupted"?(u.ctx.resume().then(function(){u.state="running";for(var d=0;d<u._howls.length;d++)u._howls[d]._emit("resume")}),u._suspendTimer&&(clearTimeout(u._suspendTimer),u._suspendTimer=null)):u.state==="suspending"&&(u._resumeAfterSuspend=!0),u}};var n=new t,s=function(u){var d=this;if(!u.src||u.src.length===0){console.error("An array of source files must be passed with any new Howl.");return}d.init(u)};s.prototype={init:function(u){var d=this;return n.ctx||h(),d._autoplay=u.autoplay||!1,d._format=typeof u.format!="string"?u.format:[u.format],d._html5=u.html5||!1,d._muted=u.mute||!1,d._loop=u.loop||!1,d._pool=u.pool||5,d._preload=typeof u.preload=="boolean"||u.preload==="metadata"?u.preload:!0,d._rate=u.rate||1,d._sprite=u.sprite||{},d._src=typeof u.src!="string"?u.src:[u.src],d._volume=u.volume!==void 0?u.volume:1,d._xhr={method:u.xhr&&u.xhr.method?u.xhr.method:"GET",headers:u.xhr&&u.xhr.headers?u.xhr.headers:null,withCredentials:u.xhr&&u.xhr.withCredentials?u.xhr.withCredentials:!1},d._duration=0,d._state="unloaded",d._sounds=[],d._endTimers={},d._queue=[],d._playLock=!1,d._onend=u.onend?[{fn:u.onend}]:[],d._onfade=u.onfade?[{fn:u.onfade}]:[],d._onload=u.onload?[{fn:u.onload}]:[],d._onloaderror=u.onloaderror?[{fn:u.onloaderror}]:[],d._onplayerror=u.onplayerror?[{fn:u.onplayerror}]:[],d._onpause=u.onpause?[{fn:u.onpause}]:[],d._onplay=u.onplay?[{fn:u.onplay}]:[],d._onstop=u.onstop?[{fn:u.onstop}]:[],d._onmute=u.onmute?[{fn:u.onmute}]:[],d._onvolume=u.onvolume?[{fn:u.onvolume}]:[],d._onrate=u.onrate?[{fn:u.onrate}]:[],d._onseek=u.onseek?[{fn:u.onseek}]:[],d._onunlock=u.onunlock?[{fn:u.onunlock}]:[],d._onresume=[],d._webAudio=n.usingWebAudio&&!d._html5,typeof n.ctx<"u"&&n.ctx&&n.autoUnlock&&n._unlockAudio(),n._howls.push(d),d._autoplay&&d._queue.push({event:"play",action:function(){d.play()}}),d._preload&&d._preload!=="none"&&d.load(),d},load:function(){var u=this,d=null;if(n.noAudio){u._emit("loaderror",null,"No audio support.");return}typeof u._src=="string"&&(u._src=[u._src]);for(var p=0;p<u._src.length;p++){var f,g;if(u._format&&u._format[p])f=u._format[p];else{if(g=u._src[p],typeof g!="string"){u._emit("loaderror",null,"Non-string found in selected audio sources - ignoring.");continue}f=/^data:audio\/([^;,]+);/i.exec(g),f||(f=/\.([^.]+)$/.exec(g.split("?",1)[0])),f&&(f=f[1].toLowerCase())}if(f||console.warn('No file extension was found. Consider using the "format" property or specify an extension.'),f&&n.codecs(f)){d=u._src[p];break}}if(!d){u._emit("loaderror",null,"No codec support for selected audio sources.");return}return u._src=d,u._state="loading",window.location.protocol==="https:"&&d.slice(0,5)==="http:"&&(u._html5=!0,u._webAudio=!1),new r(u),u._webAudio&&o(u),u},play:function(u,d){var p=this,f=null;if(typeof u=="number")f=u,u=null;else{if(typeof u=="string"&&p._state==="loaded"&&!p._sprite[u])return null;if(typeof u>"u"&&(u="__default",!p._playLock)){for(var g=0,m=0;m<p._sounds.length;m++)p._sounds[m]._paused&&!p._sounds[m]._ended&&(g++,f=p._sounds[m]._id);g===1?u=null:f=null}}var y=f?p._soundById(f):p._inactiveSound();if(!y)return null;if(f&&!u&&(u=y._sprite||"__default"),p._state!=="loaded"){y._sprite=u,y._ended=!1;var v=y._id;return p._queue.push({event:"play",action:function(){p.play(v)}}),v}if(f&&!y._paused)return d||p._loadQueue("play"),y._id;p._webAudio&&n._autoResume();var b=Math.max(0,y._seek>0?y._seek:p._sprite[u][0]/1e3),x=Math.max(0,(p._sprite[u][0]+p._sprite[u][1])/1e3-b),w=x*1e3/Math.abs(y._rate),S=p._sprite[u][0]/1e3,C=(p._sprite[u][0]+p._sprite[u][1])/1e3;y._sprite=u,y._ended=!1;var _=function(){y._paused=!1,y._seek=b,y._start=S,y._stop=C,y._loop=!!(y._loop||p._sprite[u][2])};if(b>=C){p._ended(y);return}var T=y._node;if(p._webAudio){var E=function(){p._playLock=!1,_(),p._refreshBuffer(y);var P=y._muted||p._muted?0:y._volume;T.gain.setValueAtTime(P,n.ctx.currentTime),y._playStart=n.ctx.currentTime,typeof T.bufferSource.start>"u"?y._loop?T.bufferSource.noteGrainOn(0,b,86400):T.bufferSource.noteGrainOn(0,b,x):y._loop?T.bufferSource.start(0,b,86400):T.bufferSource.start(0,b,x),w!==1/0&&(p._endTimers[y._id]=setTimeout(p._ended.bind(p,y),w)),d||setTimeout(function(){p._emit("play",y._id),p._loadQueue()},0)};n.state==="running"&&n.ctx.state!=="interrupted"?E():(p._playLock=!0,p.once("resume",E),p._clearTimer(y._id))}else{var A=function(){T.currentTime=b,T.muted=y._muted||p._muted||n._muted||T.muted,T.volume=y._volume*n.volume(),T.playbackRate=y._rate;try{var P=T.play();if(P&&typeof Promise<"u"&&(P instanceof Promise||typeof P.then=="function")?(p._playLock=!0,_(),P.then(function(){p._playLock=!1,T._unlocked=!0,d?p._loadQueue():p._emit("play",y._id)}).catch(function(){p._playLock=!1,p._emit("playerror",y._id,"Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."),y._ended=!0,y._paused=!0})):d||(p._playLock=!1,_(),p._emit("play",y._id)),T.playbackRate=y._rate,T.paused){p._emit("playerror",y._id,"Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");return}u!=="__default"||y._loop?p._endTimers[y._id]=setTimeout(p._ended.bind(p,y),w):(p._endTimers[y._id]=function(){p._ended(y),T.removeEventListener("ended",p._endTimers[y._id],!1)},T.addEventListener("ended",p._endTimers[y._id],!1))}catch(L){p._emit("playerror",y._id,L)}};T.src==="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"&&(T.src=p._src,T.load());var D=window&&window.ejecta||!T.readyState&&n._navigator.isCocoonJS;if(T.readyState>=3||D)A();else{p._playLock=!0,p._state="loading";var O=function(){p._state="loaded",A(),T.removeEventListener(n._canPlayEvent,O,!1)};T.addEventListener(n._canPlayEvent,O,!1),p._clearTimer(y._id)}}return y._id},pause:function(u){var d=this;if(d._state!=="loaded"||d._playLock)return d._queue.push({event:"pause",action:function(){d.pause(u)}}),d;for(var p=d._getSoundIds(u),f=0;f<p.length;f++){d._clearTimer(p[f]);var g=d._soundById(p[f]);if(g&&!g._paused&&(g._seek=d.seek(p[f]),g._rateSeek=0,g._paused=!0,d._stopFade(p[f]),g._node))if(d._webAudio){if(!g._node.bufferSource)continue;typeof g._node.bufferSource.stop>"u"?g._node.bufferSource.noteOff(0):g._node.bufferSource.stop(0),d._cleanBuffer(g._node)}else(!isNaN(g._node.duration)||g._node.duration===1/0)&&g._node.pause();arguments[1]||d._emit("pause",g?g._id:null)}return d},stop:function(u,d){var p=this;if(p._state!=="loaded"||p._playLock)return p._queue.push({event:"stop",action:function(){p.stop(u)}}),p;for(var f=p._getSoundIds(u),g=0;g<f.length;g++){p._clearTimer(f[g]);var m=p._soundById(f[g]);m&&(m._seek=m._start||0,m._rateSeek=0,m._paused=!0,m._ended=!0,p._stopFade(f[g]),m._node&&(p._webAudio?m._node.bufferSource&&(typeof m._node.bufferSource.stop>"u"?m._node.bufferSource.noteOff(0):m._node.bufferSource.stop(0),p._cleanBuffer(m._node)):(!isNaN(m._node.duration)||m._node.duration===1/0)&&(m._node.currentTime=m._start||0,m._node.pause(),m._node.duration===1/0&&p._clearSound(m._node))),d||p._emit("stop",m._id))}return p},mute:function(u,d){var p=this;if(p._state!=="loaded"||p._playLock)return p._queue.push({event:"mute",action:function(){p.mute(u,d)}}),p;if(typeof d>"u")if(typeof u=="boolean")p._muted=u;else return p._muted;for(var f=p._getSoundIds(d),g=0;g<f.length;g++){var m=p._soundById(f[g]);m&&(m._muted=u,m._interval&&p._stopFade(m._id),p._webAudio&&m._node?m._node.gain.setValueAtTime(u?0:m._volume,n.ctx.currentTime):m._node&&(m._node.muted=n._muted?!0:u),p._emit("mute",m._id))}return p},volume:function(){var u=this,d=arguments,p,f;if(d.length===0)return u._volume;if(d.length===1||d.length===2&&typeof d[1]>"u"){var g=u._getSoundIds(),m=g.indexOf(d[0]);m>=0?f=parseInt(d[0],10):p=parseFloat(d[0])}else d.length>=2&&(p=parseFloat(d[0]),f=parseInt(d[1],10));var y;if(typeof p<"u"&&p>=0&&p<=1){if(u._state!=="loaded"||u._playLock)return u._queue.push({event:"volume",action:function(){u.volume.apply(u,d)}}),u;typeof f>"u"&&(u._volume=p),f=u._getSoundIds(f);for(var v=0;v<f.length;v++)y=u._soundById(f[v]),y&&(y._volume=p,d[2]||u._stopFade(f[v]),u._webAudio&&y._node&&!y._muted?y._node.gain.setValueAtTime(p,n.ctx.currentTime):y._node&&!y._muted&&(y._node.volume=p*n.volume()),u._emit("volume",y._id))}else return y=f?u._soundById(f):u._sounds[0],y?y._volume:0;return u},fade:function(u,d,p,f){var g=this;if(g._state!=="loaded"||g._playLock)return g._queue.push({event:"fade",action:function(){g.fade(u,d,p,f)}}),g;u=Math.min(Math.max(0,parseFloat(u)),1),d=Math.min(Math.max(0,parseFloat(d)),1),p=parseFloat(p),g.volume(u,f);for(var m=g._getSoundIds(f),y=0;y<m.length;y++){var v=g._soundById(m[y]);if(v){if(f||g._stopFade(m[y]),g._webAudio&&!v._muted){var b=n.ctx.currentTime,x=b+p/1e3;v._volume=u,v._node.gain.setValueAtTime(u,b),v._node.gain.linearRampToValueAtTime(d,x)}g._startFadeInterval(v,u,d,p,m[y],typeof f>"u")}}return g},_startFadeInterval:function(u,d,p,f,g,m){var y=this,v=d,b=p-d,x=Math.abs(b/.01),w=Math.max(4,x>0?f/x:f),S=Date.now();u._fadeTo=p,u._interval=setInterval(function(){var C=(Date.now()-S)/f;S=Date.now(),v+=b*C,v=Math.round(v*100)/100,b<0?v=Math.max(p,v):v=Math.min(p,v),y._webAudio?u._volume=v:y.volume(v,u._id,!0),m&&(y._volume=v),(p<d&&v<=p||p>d&&v>=p)&&(clearInterval(u._interval),u._interval=null,u._fadeTo=null,y.volume(p,u._id),y._emit("fade",u._id))},w)},_stopFade:function(u){var d=this,p=d._soundById(u);return p&&p._interval&&(d._webAudio&&p._node.gain.cancelScheduledValues(n.ctx.currentTime),clearInterval(p._interval),p._interval=null,d.volume(p._fadeTo,u),p._fadeTo=null,d._emit("fade",u)),d},loop:function(){var u=this,d=arguments,p,f,g;if(d.length===0)return u._loop;if(d.length===1)if(typeof d[0]=="boolean")p=d[0],u._loop=p;else return g=u._soundById(parseInt(d[0],10)),g?g._loop:!1;else d.length===2&&(p=d[0],f=parseInt(d[1],10));for(var m=u._getSoundIds(f),y=0;y<m.length;y++)g=u._soundById(m[y]),g&&(g._loop=p,u._webAudio&&g._node&&g._node.bufferSource&&(g._node.bufferSource.loop=p,p&&(g._node.bufferSource.loopStart=g._start||0,g._node.bufferSource.loopEnd=g._stop,u.playing(m[y])&&(u.pause(m[y],!0),u.play(m[y],!0)))));return u},rate:function(){var u=this,d=arguments,p,f;if(d.length===0)f=u._sounds[0]._id;else if(d.length===1){var g=u._getSoundIds(),m=g.indexOf(d[0]);m>=0?f=parseInt(d[0],10):p=parseFloat(d[0])}else d.length===2&&(p=parseFloat(d[0]),f=parseInt(d[1],10));var y;if(typeof p=="number"){if(u._state!=="loaded"||u._playLock)return u._queue.push({event:"rate",action:function(){u.rate.apply(u,d)}}),u;typeof f>"u"&&(u._rate=p),f=u._getSoundIds(f);for(var v=0;v<f.length;v++)if(y=u._soundById(f[v]),y){u.playing(f[v])&&(y._rateSeek=u.seek(f[v]),y._playStart=u._webAudio?n.ctx.currentTime:y._playStart),y._rate=p,u._webAudio&&y._node&&y._node.bufferSource?y._node.bufferSource.playbackRate.setValueAtTime(p,n.ctx.currentTime):y._node&&(y._node.playbackRate=p);var b=u.seek(f[v]),x=(u._sprite[y._sprite][0]+u._sprite[y._sprite][1])/1e3-b,w=x*1e3/Math.abs(y._rate);(u._endTimers[f[v]]||!y._paused)&&(u._clearTimer(f[v]),u._endTimers[f[v]]=setTimeout(u._ended.bind(u,y),w)),u._emit("rate",y._id)}}else return y=u._soundById(f),y?y._rate:u._rate;return u},seek:function(){var u=this,d=arguments,p,f;if(d.length===0)u._sounds.length&&(f=u._sounds[0]._id);else if(d.length===1){var g=u._getSoundIds(),m=g.indexOf(d[0]);m>=0?f=parseInt(d[0],10):u._sounds.length&&(f=u._sounds[0]._id,p=parseFloat(d[0]))}else d.length===2&&(p=parseFloat(d[0]),f=parseInt(d[1],10));if(typeof f>"u")return 0;if(typeof p=="number"&&(u._state!=="loaded"||u._playLock))return u._queue.push({event:"seek",action:function(){u.seek.apply(u,d)}}),u;var y=u._soundById(f);if(y)if(typeof p=="number"&&p>=0){var v=u.playing(f);v&&u.pause(f,!0),y._seek=p,y._ended=!1,u._clearTimer(f),!u._webAudio&&y._node&&!isNaN(y._node.duration)&&(y._node.currentTime=p);var b=function(){v&&u.play(f,!0),u._emit("seek",f)};if(v&&!u._webAudio){var x=function(){u._playLock?setTimeout(x,0):b()};setTimeout(x,0)}else b()}else if(u._webAudio){var w=u.playing(f)?n.ctx.currentTime-y._playStart:0,S=y._rateSeek?y._rateSeek-y._seek:0;return y._seek+(S+w*Math.abs(y._rate))}else return y._node.currentTime;return u},playing:function(u){var d=this;if(typeof u=="number"){var p=d._soundById(u);return p?!p._paused:!1}for(var f=0;f<d._sounds.length;f++)if(!d._sounds[f]._paused)return!0;return!1},duration:function(u){var d=this,p=d._duration,f=d._soundById(u);return f&&(p=d._sprite[f._sprite][1]/1e3),p},state:function(){return this._state},unload:function(){for(var u=this,d=u._sounds,p=0;p<d.length;p++)d[p]._paused||u.stop(d[p]._id),u._webAudio||(u._clearSound(d[p]._node),d[p]._node.removeEventListener("error",d[p]._errorFn,!1),d[p]._node.removeEventListener(n._canPlayEvent,d[p]._loadFn,!1),d[p]._node.removeEventListener("ended",d[p]._endFn,!1),n._releaseHtml5Audio(d[p]._node)),delete d[p]._node,u._clearTimer(d[p]._id);var f=n._howls.indexOf(u);f>=0&&n._howls.splice(f,1);var g=!0;for(p=0;p<n._howls.length;p++)if(n._howls[p]._src===u._src||u._src.indexOf(n._howls[p]._src)>=0){g=!1;break}return i&&g&&delete i[u._src],n.noAudio=!1,u._state="unloaded",u._sounds=[],u=null,null},on:function(u,d,p,f){var g=this,m=g["_on"+u];return typeof d=="function"&&m.push(f?{id:p,fn:d,once:f}:{id:p,fn:d}),g},off:function(u,d,p){var f=this,g=f["_on"+u],m=0;if(typeof d=="number"&&(p=d,d=null),d||p)for(m=0;m<g.length;m++){var y=p===g[m].id;if(d===g[m].fn&&y||!d&&y){g.splice(m,1);break}}else if(u)f["_on"+u]=[];else{var v=Object.keys(f);for(m=0;m<v.length;m++)v[m].indexOf("_on")===0&&Array.isArray(f[v[m]])&&(f[v[m]]=[])}return f},once:function(u,d,p){var f=this;return f.on(u,d,p,1),f},_emit:function(u,d,p){for(var f=this,g=f["_on"+u],m=g.length-1;m>=0;m--)(!g[m].id||g[m].id===d||u==="load")&&(setTimeout(function(y){y.call(this,d,p)}.bind(f,g[m].fn),0),g[m].once&&f.off(u,g[m].fn,g[m].id));return f._loadQueue(u),f},_loadQueue:function(u){var d=this;if(d._queue.length>0){var p=d._queue[0];p.event===u&&(d._queue.shift(),d._loadQueue()),u||p.action()}return d},_ended:function(u){var d=this,p=u._sprite;if(!d._webAudio&&u._node&&!u._node.paused&&!u._node.ended&&u._node.currentTime<u._stop)return setTimeout(d._ended.bind(d,u),100),d;var f=!!(u._loop||d._sprite[p][2]);if(d._emit("end",u._id),!d._webAudio&&f&&d.stop(u._id,!0).play(u._id),d._webAudio&&f){d._emit("play",u._id),u._seek=u._start||0,u._rateSeek=0,u._playStart=n.ctx.currentTime;var g=(u._stop-u._start)*1e3/Math.abs(u._rate);d._endTimers[u._id]=setTimeout(d._ended.bind(d,u),g)}return d._webAudio&&!f&&(u._paused=!0,u._ended=!0,u._seek=u._start||0,u._rateSeek=0,d._clearTimer(u._id),d._cleanBuffer(u._node),n._autoSuspend()),!d._webAudio&&!f&&d.stop(u._id,!0),d},_clearTimer:function(u){var d=this;if(d._endTimers[u]){if(typeof d._endTimers[u]!="function")clearTimeout(d._endTimers[u]);else{var p=d._soundById(u);p&&p._node&&p._node.removeEventListener("ended",d._endTimers[u],!1)}delete d._endTimers[u]}return d},_soundById:function(u){for(var d=this,p=0;p<d._sounds.length;p++)if(u===d._sounds[p]._id)return d._sounds[p];return null},_inactiveSound:function(){var u=this;u._drain();for(var d=0;d<u._sounds.length;d++)if(u._sounds[d]._ended)return u._sounds[d].reset();return new r(u)},_drain:function(){var u=this,d=u._pool,p=0,f=0;if(!(u._sounds.length<d)){for(f=0;f<u._sounds.length;f++)u._sounds[f]._ended&&p++;for(f=u._sounds.length-1;f>=0;f--){if(p<=d)return;u._sounds[f]._ended&&(u._webAudio&&u._sounds[f]._node&&u._sounds[f]._node.disconnect(0),u._sounds.splice(f,1),p--)}}},_getSoundIds:function(u){var d=this;if(typeof u>"u"){for(var p=[],f=0;f<d._sounds.length;f++)p.push(d._sounds[f]._id);return p}else return[u]},_refreshBuffer:function(u){var d=this;return u._node.bufferSource=n.ctx.createBufferSource(),u._node.bufferSource.buffer=i[d._src],u._panner?u._node.bufferSource.connect(u._panner):u._node.bufferSource.connect(u._node),u._node.bufferSource.loop=u._loop,u._loop&&(u._node.bufferSource.loopStart=u._start||0,u._node.bufferSource.loopEnd=u._stop||0),u._node.bufferSource.playbackRate.setValueAtTime(u._rate,n.ctx.currentTime),d},_cleanBuffer:function(u){var d=this,p=n._navigator&&n._navigator.vendor.indexOf("Apple")>=0;if(n._scratchBuffer&&u.bufferSource&&(u.bufferSource.onended=null,u.bufferSource.disconnect(0),p))try{u.bufferSource.buffer=n._scratchBuffer}catch{}return u.bufferSource=null,d},_clearSound:function(u){var d=/MSIE |Trident\//.test(n._navigator&&n._navigator.userAgent);d||(u.src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")}};var r=function(u){this._parent=u,this.init()};r.prototype={init:function(){var u=this,d=u._parent;return u._muted=d._muted,u._loop=d._loop,u._volume=d._volume,u._rate=d._rate,u._seek=0,u._paused=!0,u._ended=!0,u._sprite="__default",u._id=++n._counter,d._sounds.push(u),u.create(),u},create:function(){var u=this,d=u._parent,p=n._muted||u._muted||u._parent._muted?0:u._volume;return d._webAudio?(u._node=typeof n.ctx.createGain>"u"?n.ctx.createGainNode():n.ctx.createGain(),u._node.gain.setValueAtTime(p,n.ctx.currentTime),u._node.paused=!0,u._node.connect(n.masterGain)):n.noAudio||(u._node=n._obtainHtml5Audio(),u._errorFn=u._errorListener.bind(u),u._node.addEventListener("error",u._errorFn,!1),u._loadFn=u._loadListener.bind(u),u._node.addEventListener(n._canPlayEvent,u._loadFn,!1),u._endFn=u._endListener.bind(u),u._node.addEventListener("ended",u._endFn,!1),u._node.src=d._src,u._node.preload=d._preload===!0?"auto":d._preload,u._node.volume=p*n.volume(),u._node.load()),u},reset:function(){var u=this,d=u._parent;return u._muted=d._muted,u._loop=d._loop,u._volume=d._volume,u._rate=d._rate,u._seek=0,u._rateSeek=0,u._paused=!0,u._ended=!0,u._sprite="__default",u._id=++n._counter,u},_errorListener:function(){var u=this;u._parent._emit("loaderror",u._id,u._node.error?u._node.error.code:0),u._node.removeEventListener("error",u._errorFn,!1)},_loadListener:function(){var u=this,d=u._parent;d._duration=Math.ceil(u._node.duration*10)/10,Object.keys(d._sprite).length===0&&(d._sprite={__default:[0,d._duration*1e3]}),d._state!=="loaded"&&(d._state="loaded",d._emit("load"),d._loadQueue()),u._node.removeEventListener(n._canPlayEvent,u._loadFn,!1)},_endListener:function(){var u=this,d=u._parent;d._duration===1/0&&(d._duration=Math.ceil(u._node.duration*10)/10,d._sprite.__default[1]===1/0&&(d._sprite.__default[1]=d._duration*1e3),d._ended(u)),u._node.removeEventListener("ended",u._endFn,!1)}};var i={},o=function(u){var d=u._src;if(i[d]){u._duration=i[d].duration,c(u);return}if(/^data:[^;]+;base64,/.test(d)){for(var p=atob(d.split(",")[1]),f=new Uint8Array(p.length),g=0;g<p.length;++g)f[g]=p.charCodeAt(g);l(f.buffer,u)}else{var m=new XMLHttpRequest;m.open(u._xhr.method,d,!0),m.withCredentials=u._xhr.withCredentials,m.responseType="arraybuffer",u._xhr.headers&&Object.keys(u._xhr.headers).forEach(function(y){m.setRequestHeader(y,u._xhr.headers[y])}),m.onload=function(){var y=(m.status+"")[0];if(y!=="0"&&y!=="2"&&y!=="3"){u._emit("loaderror",null,"Failed loading audio file with status: "+m.status+".");return}l(m.response,u)},m.onerror=function(){u._webAudio&&(u._html5=!0,u._webAudio=!1,u._sounds=[],delete i[d],u.load())},a(m)}},a=function(u){try{u.send()}catch{u.onerror()}},l=function(u,d){var p=function(){d._emit("loaderror",null,"Decoding audio data failed.")},f=function(g){g&&d._sounds.length>0?(i[d._src]=g,c(d,g)):p()};typeof Promise<"u"&&n.ctx.decodeAudioData.length===1?n.ctx.decodeAudioData(u).then(f).catch(p):n.ctx.decodeAudioData(u,f,p)},c=function(u,d){d&&!u._duration&&(u._duration=d.duration),Object.keys(u._sprite).length===0&&(u._sprite={__default:[0,u._duration*1e3]}),u._state!=="loaded"&&(u._state="loaded",u._emit("load"),u._loadQueue())},h=function(){if(n.usingWebAudio){try{typeof AudioContext<"u"?n.ctx=new AudioContext:typeof webkitAudioContext<"u"?n.ctx=new webkitAudioContext:n.usingWebAudio=!1}catch{n.usingWebAudio=!1}n.ctx||(n.usingWebAudio=!1);var u=/iP(hone|od|ad)/.test(n._navigator&&n._navigator.platform),d=n._navigator&&n._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),p=d?parseInt(d[1],10):null;if(u&&p&&p<9){var f=/safari/.test(n._navigator&&n._navigator.userAgent.toLowerCase());n._navigator&&!f&&(n.usingWebAudio=!1)}n.usingWebAudio&&(n.masterGain=typeof n.ctx.createGain>"u"?n.ctx.createGainNode():n.ctx.createGain(),n.masterGain.gain.setValueAtTime(n._muted?0:n._volume,n.ctx.currentTime),n.masterGain.connect(n.ctx.destination)),n._setup()}};typeof define=="function"&&define.amd&&define([],function(){return{Howler:n,Howl:s}}),typeof e<"u"&&(e.Howler=n,e.Howl=s),typeof global<"u"?(global.HowlerGlobal=t,global.Howler=n,global.Howl=s,global.Sound=r):typeof window<"u"&&(window.HowlerGlobal=t,window.Howler=n,window.Howl=s,window.Sound=r)})(),function(){HowlerGlobal.prototype._pos=[0,0,0],HowlerGlobal.prototype._orientation=[0,0,-1,0,1,0],HowlerGlobal.prototype.stereo=function(n){var s=this;if(!s.ctx||!s.ctx.listener)return s;for(var r=s._howls.length-1;r>=0;r--)s._howls[r].stereo(n);return s},HowlerGlobal.prototype.pos=function(n,s,r){var i=this;if(!i.ctx||!i.ctx.listener)return i;if(s=typeof s!="number"?i._pos[1]:s,r=typeof r!="number"?i._pos[2]:r,typeof n=="number")i._pos=[n,s,r],typeof i.ctx.listener.positionX<"u"?(i.ctx.listener.positionX.setTargetAtTime(i._pos[0],Howler.ctx.currentTime,.1),i.ctx.listener.positionY.setTargetAtTime(i._pos[1],Howler.ctx.currentTime,.1),i.ctx.listener.positionZ.setTargetAtTime(i._pos[2],Howler.ctx.currentTime,.1)):i.ctx.listener.setPosition(i._pos[0],i._pos[1],i._pos[2]);else return i._pos;return i},HowlerGlobal.prototype.orientation=function(n,s,r,i,o,a){var l=this;if(!l.ctx||!l.ctx.listener)return l;var c=l._orientation;if(s=typeof s!="number"?c[1]:s,r=typeof r!="number"?c[2]:r,i=typeof i!="number"?c[3]:i,o=typeof o!="number"?c[4]:o,a=typeof a!="number"?c[5]:a,typeof n=="number")l._orientation=[n,s,r,i,o,a],typeof l.ctx.listener.forwardX<"u"?(l.ctx.listener.forwardX.setTargetAtTime(n,Howler.ctx.currentTime,.1),l.ctx.listener.forwardY.setTargetAtTime(s,Howler.ctx.currentTime,.1),l.ctx.listener.forwardZ.setTargetAtTime(r,Howler.ctx.currentTime,.1),l.ctx.listener.upX.setTargetAtTime(i,Howler.ctx.currentTime,.1),l.ctx.listener.upY.setTargetAtTime(o,Howler.ctx.currentTime,.1),l.ctx.listener.upZ.setTargetAtTime(a,Howler.ctx.currentTime,.1)):l.ctx.listener.setOrientation(n,s,r,i,o,a);else return c;return l},Howl.prototype.init=function(n){return function(s){var r=this;return r._orientation=s.orientation||[1,0,0],r._stereo=s.stereo||null,r._pos=s.pos||null,r._pannerAttr={coneInnerAngle:typeof s.coneInnerAngle<"u"?s.coneInnerAngle:360,coneOuterAngle:typeof s.coneOuterAngle<"u"?s.coneOuterAngle:360,coneOuterGain:typeof s.coneOuterGain<"u"?s.coneOuterGain:0,distanceModel:typeof s.distanceModel<"u"?s.distanceModel:"inverse",maxDistance:typeof s.maxDistance<"u"?s.maxDistance:1e4,panningModel:typeof s.panningModel<"u"?s.panningModel:"HRTF",refDistance:typeof s.refDistance<"u"?s.refDistance:1,rolloffFactor:typeof s.rolloffFactor<"u"?s.rolloffFactor:1},r._onstereo=s.onstereo?[{fn:s.onstereo}]:[],r._onpos=s.onpos?[{fn:s.onpos}]:[],r._onorientation=s.onorientation?[{fn:s.onorientation}]:[],n.call(this,s)}}(Howl.prototype.init),Howl.prototype.stereo=function(n,s){var r=this;if(!r._webAudio)return r;if(r._state!=="loaded")return r._queue.push({event:"stereo",action:function(){r.stereo(n,s)}}),r;var i=typeof Howler.ctx.createStereoPanner>"u"?"spatial":"stereo";if(typeof s>"u")if(typeof n=="number")r._stereo=n,r._pos=[n,0,0];else return r._stereo;for(var o=r._getSoundIds(s),a=0;a<o.length;a++){var l=r._soundById(o[a]);if(l)if(typeof n=="number")l._stereo=n,l._pos=[n,0,0],l._node&&(l._pannerAttr.panningModel="equalpower",(!l._panner||!l._panner.pan)&&t(l,i),i==="spatial"?typeof l._panner.positionX<"u"?(l._panner.positionX.setValueAtTime(n,Howler.ctx.currentTime),l._panner.positionY.setValueAtTime(0,Howler.ctx.currentTime),l._panner.positionZ.setValueAtTime(0,Howler.ctx.currentTime)):l._panner.setPosition(n,0,0):l._panner.pan.setValueAtTime(n,Howler.ctx.currentTime)),r._emit("stereo",l._id);else return l._stereo}return r},Howl.prototype.pos=function(n,s,r,i){var o=this;if(!o._webAudio)return o;if(o._state!=="loaded")return o._queue.push({event:"pos",action:function(){o.pos(n,s,r,i)}}),o;if(s=typeof s!="number"?0:s,r=typeof r!="number"?-.5:r,typeof i>"u")if(typeof n=="number")o._pos=[n,s,r];else return o._pos;for(var a=o._getSoundIds(i),l=0;l<a.length;l++){var c=o._soundById(a[l]);if(c)if(typeof n=="number")c._pos=[n,s,r],c._node&&((!c._panner||c._panner.pan)&&t(c,"spatial"),typeof c._panner.positionX<"u"?(c._panner.positionX.setValueAtTime(n,Howler.ctx.currentTime),c._panner.positionY.setValueAtTime(s,Howler.ctx.currentTime),c._panner.positionZ.setValueAtTime(r,Howler.ctx.currentTime)):c._panner.setPosition(n,s,r)),o._emit("pos",c._id);else return c._pos}return o},Howl.prototype.orientation=function(n,s,r,i){var o=this;if(!o._webAudio)return o;if(o._state!=="loaded")return o._queue.push({event:"orientation",action:function(){o.orientation(n,s,r,i)}}),o;if(s=typeof s!="number"?o._orientation[1]:s,r=typeof r!="number"?o._orientation[2]:r,typeof i>"u")if(typeof n=="number")o._orientation=[n,s,r];else return o._orientation;for(var a=o._getSoundIds(i),l=0;l<a.length;l++){var c=o._soundById(a[l]);if(c)if(typeof n=="number")c._orientation=[n,s,r],c._node&&(c._panner||(c._pos||(c._pos=o._pos||[0,0,-.5]),t(c,"spatial")),typeof c._panner.orientationX<"u"?(c._panner.orientationX.setValueAtTime(n,Howler.ctx.currentTime),c._panner.orientationY.setValueAtTime(s,Howler.ctx.currentTime),c._panner.orientationZ.setValueAtTime(r,Howler.ctx.currentTime)):c._panner.setOrientation(n,s,r)),o._emit("orientation",c._id);else return c._orientation}return o},Howl.prototype.pannerAttr=function(){var n=this,s=arguments,r,i,o;if(!n._webAudio)return n;if(s.length===0)return n._pannerAttr;if(s.length===1)if(typeof s[0]=="object")r=s[0],typeof i>"u"&&(r.pannerAttr||(r.pannerAttr={coneInnerAngle:r.coneInnerAngle,coneOuterAngle:r.coneOuterAngle,coneOuterGain:r.coneOuterGain,distanceModel:r.distanceModel,maxDistance:r.maxDistance,refDistance:r.refDistance,rolloffFactor:r.rolloffFactor,panningModel:r.panningModel}),n._pannerAttr={coneInnerAngle:typeof r.pannerAttr.coneInnerAngle<"u"?r.pannerAttr.coneInnerAngle:n._coneInnerAngle,coneOuterAngle:typeof r.pannerAttr.coneOuterAngle<"u"?r.pannerAttr.coneOuterAngle:n._coneOuterAngle,coneOuterGain:typeof r.pannerAttr.coneOuterGain<"u"?r.pannerAttr.coneOuterGain:n._coneOuterGain,distanceModel:typeof r.pannerAttr.distanceModel<"u"?r.pannerAttr.distanceModel:n._distanceModel,maxDistance:typeof r.pannerAttr.maxDistance<"u"?r.pannerAttr.maxDistance:n._maxDistance,refDistance:typeof r.pannerAttr.refDistance<"u"?r.pannerAttr.refDistance:n._refDistance,rolloffFactor:typeof r.pannerAttr.rolloffFactor<"u"?r.pannerAttr.rolloffFactor:n._rolloffFactor,panningModel:typeof r.pannerAttr.panningModel<"u"?r.pannerAttr.panningModel:n._panningModel});else return o=n._soundById(parseInt(s[0],10)),o?o._pannerAttr:n._pannerAttr;else s.length===2&&(r=s[0],i=parseInt(s[1],10));for(var a=n._getSoundIds(i),l=0;l<a.length;l++)if(o=n._soundById(a[l]),o){var c=o._pannerAttr;c={coneInnerAngle:typeof r.coneInnerAngle<"u"?r.coneInnerAngle:c.coneInnerAngle,coneOuterAngle:typeof r.coneOuterAngle<"u"?r.coneOuterAngle:c.coneOuterAngle,coneOuterGain:typeof r.coneOuterGain<"u"?r.coneOuterGain:c.coneOuterGain,distanceModel:typeof r.distanceModel<"u"?r.distanceModel:c.distanceModel,maxDistance:typeof r.maxDistance<"u"?r.maxDistance:c.maxDistance,refDistance:typeof r.refDistance<"u"?r.refDistance:c.refDistance,rolloffFactor:typeof r.rolloffFactor<"u"?r.rolloffFactor:c.rolloffFactor,panningModel:typeof r.panningModel<"u"?r.panningModel:c.panningModel};var h=o._panner;h?(h.coneInnerAngle=c.coneInnerAngle,h.coneOuterAngle=c.coneOuterAngle,h.coneOuterGain=c.coneOuterGain,h.distanceModel=c.distanceModel,h.maxDistance=c.maxDistance,h.refDistance=c.refDistance,h.rolloffFactor=c.rolloffFactor,h.panningModel=c.panningModel):(o._pos||(o._pos=n._pos||[0,0,-.5]),t(o,"spatial"))}return n},Sound.prototype.init=function(n){return function(){var s=this,r=s._parent;s._orientation=r._orientation,s._stereo=r._stereo,s._pos=r._pos,s._pannerAttr=r._pannerAttr,n.call(this),s._stereo?r.stereo(s._stereo):s._pos&&r.pos(s._pos[0],s._pos[1],s._pos[2],s._id)}}(Sound.prototype.init),Sound.prototype.reset=function(n){return function(){var s=this,r=s._parent;return s._orientation=r._orientation,s._stereo=r._stereo,s._pos=r._pos,s._pannerAttr=r._pannerAttr,s._stereo?r.stereo(s._stereo):s._pos?r.pos(s._pos[0],s._pos[1],s._pos[2],s._id):s._panner&&(s._panner.disconnect(0),s._panner=void 0,r._refreshBuffer(s)),n.call(this)}}(Sound.prototype.reset);var t=function(n,s){s=s||"spatial",s==="spatial"?(n._panner=Howler.ctx.createPanner(),n._panner.coneInnerAngle=n._pannerAttr.coneInnerAngle,n._panner.coneOuterAngle=n._pannerAttr.coneOuterAngle,n._panner.coneOuterGain=n._pannerAttr.coneOuterGain,n._panner.distanceModel=n._pannerAttr.distanceModel,n._panner.maxDistance=n._pannerAttr.maxDistance,n._panner.refDistance=n._pannerAttr.refDistance,n._panner.rolloffFactor=n._pannerAttr.rolloffFactor,n._panner.panningModel=n._pannerAttr.panningModel,typeof n._panner.positionX<"u"?(n._panner.positionX.setValueAtTime(n._pos[0],Howler.ctx.currentTime),n._panner.positionY.setValueAtTime(n._pos[1],Howler.ctx.currentTime),n._panner.positionZ.setValueAtTime(n._pos[2],Howler.ctx.currentTime)):n._panner.setPosition(n._pos[0],n._pos[1],n._pos[2]),typeof n._panner.orientationX<"u"?(n._panner.orientationX.setValueAtTime(n._orientation[0],Howler.ctx.currentTime),n._panner.orientationY.setValueAtTime(n._orientation[1],Howler.ctx.currentTime),n._panner.orientationZ.setValueAtTime(n._orientation[2],Howler.ctx.currentTime)):n._panner.setOrientation(n._orientation[0],n._orientation[1],n._orientation[2])):(n._panner=Howler.ctx.createStereoPanner(),n._panner.pan.setValueAtTime(n._stereo,Howler.ctx.currentTime)),n._panner.connect(n._node),n._paused||n._parent.pause(n._id,!0).play(n._id,!0)}}()}),_f="142",Gi={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},x6=0,yk=1,b6=2,Vw=1,vk=2,Cf=3,jl=0,dr=1,Ao=2,w6=1,nr=0,Kh=1,xk=2,bk=3,wk=4,S6=5,Yh=100,_6=101,C6=102,Sk=103,_k=104,T6=200,E6=201,A6=202,I6=203,Ck=204,Tk=205,N6=206,k6=207,D6=208,M6=209,P6=210,O6=0,R6=1,L6=2,Gw=3,F6=4,$6=5,B6=6,z6=7,Ek=0,U6=1,V6=2,ll=0,G6=1,W6=2,H6=3,j6=4,q6=5,Ak=300,hu=301,du=302,Ww=303,Hw=304,Tf=306,Ef=1e3,yi=1001,jw=1002,ns=1003,Ik=1004,Nk=1005,xn=1006,X6=1007,Af=1008,pr=1009,K6=1010,Y6=1011,kk=1012,Q6=1013,ql=1014,Xl=1015,If=1016,Z6=1017,J6=1018,pu=1020,e8=1021,t8=1022,ua=1023,n8=1024,s8=1025,fu=1026,mu=1027,r8=1028,i8=1029,o8=1030,a8=1031,l8=1033,qw=33776,Xw=33777,Kw=33778,Yw=33779,Dk=35840,Mk=35841,Pk=35842,Ok=35843,c8=36196,Rk=37492,Lk=37496,Fk=37808,$k=37809,Bk=37810,zk=37811,Uk=37812,Vk=37813,Gk=37814,Wk=37815,Hk=37816,jk=37817,qk=37818,Xk=37819,Kk=37820,Yk=37821,Qk=36492,ha=3e3,Gt=3001,cl=3200,Zk=3201,u8=0,h8=1,ul="srgb",gu="srgb-linear",Qw=7680,d8=519,Zw=35044,Jk="300 es",Jw=1035,Zr=class{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});let n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;let n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;let n=this._listeners[e];if(n!==void 0){let s=n.indexOf(t);s!==-1&&n.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;let t=this._listeners[e.type];if(t!==void 0){e.target=this;let n=t.slice(0);for(let s=0,r=n.length;s<r;s++)n[s].call(this,e);e.target=null}}},fr=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"],eD=1234567,Nf=Math.PI/180,kf=180/Math.PI;function da(){let e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(fr[e&255]+fr[e>>8&255]+fr[e>>16&255]+fr[e>>24&255]+"-"+fr[t&255]+fr[t>>8&255]+"-"+fr[t>>16&15|64]+fr[t>>24&255]+"-"+fr[n&63|128]+fr[n>>8&255]+"-"+fr[n>>16&255]+fr[n>>24&255]+fr[s&255]+fr[s>>8&255]+fr[s>>16&255]+fr[s>>24&255]).toLowerCase()}function ks(e,t,n){return Math.max(t,Math.min(n,e))}function eS(e,t){return(e%t+t)%t}function p8(e,t,n,s,r){return s+(e-t)*(r-s)/(n-t)}function f8(e,t,n){return e!==t?(n-e)/(t-e):0}function Df(e,t,n){return(1-n)*e+n*t}function m8(e,t,n,s){return Df(e,t,1-Math.exp(-n*s))}function g8(e,t=1){return t-Math.abs(eS(e,t*2)-t)}function y8(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t),e*e*(3-2*e))}function v8(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t),e*e*e*(e*(e*6-15)+10))}function x8(e,t){return e+Math.floor(Math.random()*(t-e+1))}function b8(e,t){return e+Math.random()*(t-e)}function w8(e){return e*(.5-Math.random())}function S8(e){e!==void 0&&(eD=e);let t=eD+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}function _8(e){return e*Nf}function C8(e){return e*kf}function tS(e){return(e&e-1)==0&&e!==0}function T8(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))}function ey(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}function E8(e,t,n,s,r){let i=Math.cos,o=Math.sin,a=i(n/2),l=o(n/2),c=i((t+s)/2),h=o((t+s)/2),u=i((t-s)/2),d=o((t-s)/2),p=i((s-t)/2),f=o((s-t)/2);switch(r){case"XYX":e.set(a*h,l*u,l*d,a*c);break;case"YZY":e.set(l*d,a*h,l*u,a*c);break;case"ZXZ":e.set(l*u,l*d,a*h,a*c);break;case"XZX":e.set(a*h,l*f,l*p,a*c);break;case"YXY":e.set(l*p,a*h,l*f,a*c);break;case"ZYZ":e.set(l*f,l*p,a*h,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}function A8(e,t){switch(t.constructor){case Float32Array:return e;case Uint16Array:return e/65535;case Uint8Array:return e/255;case Int16Array:return Math.max(e/32767,-1);case Int8Array:return Math.max(e/127,-1);default:throw new Error("Invalid component type.")}}function I8(e,t){switch(t.constructor){case Float32Array:return e;case Uint16Array:return Math.round(e*65535);case Uint8Array:return Math.round(e*255);case Int16Array:return Math.round(e*32767);case Int8Array:return Math.round(e*127);default:throw new Error("Invalid component type.")}}var Kt=Object.freeze({__proto__:null,DEG2RAD:Nf,RAD2DEG:kf,generateUUID:da,clamp:ks,euclideanModulo:eS,mapLinear:p8,inverseLerp:f8,lerp:Df,damp:m8,pingpong:g8,smoothstep:y8,smootherstep:v8,randInt:x8,randFloat:b8,randFloatSpread:w8,seededRandom:S8,degToRad:_8,radToDeg:C8,isPowerOfTwo:tS,ceilPowerOfTwo:T8,floorPowerOfTwo:ey,setQuaternionFromProperEuler:E8,normalize:I8,denormalize:A8}),se=class{constructor(e=0,t=0){se.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){let t=this.x,n=this.y,s=e.elements;return this.x=s[0]*t+s[3]*n+s[6],this.y=s[1]*t+s[4]*n+s[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){let n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){let t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){let n=Math.cos(t),s=Math.sin(t),r=this.x-e.x,i=this.y-e.y;return this.x=r*n-i*s+e.x,this.y=r*s+i*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}},Or=class{constructor(){Or.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,s,r,i,o,a,l){let c=this.elements;return c[0]=e,c[1]=s,c[2]=o,c[3]=t,c[4]=r,c[5]=a,c[6]=n,c[7]=i,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){let t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){let t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){let n=e.elements,s=t.elements,r=this.elements,i=n[0],o=n[3],a=n[6],l=n[1],c=n[4],h=n[7],u=n[2],d=n[5],p=n[8],f=s[0],g=s[3],m=s[6],y=s[1],v=s[4],b=s[7],x=s[2],w=s[5],S=s[8];return r[0]=i*f+o*y+a*x,r[3]=i*g+o*v+a*w,r[6]=i*m+o*b+a*S,r[1]=l*f+c*y+h*x,r[4]=l*g+c*v+h*w,r[7]=l*m+c*b+h*S,r[2]=u*f+d*y+p*x,r[5]=u*g+d*v+p*w,r[8]=u*m+d*b+p*S,this}multiplyScalar(e){let t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){let e=this.elements,t=e[0],n=e[1],s=e[2],r=e[3],i=e[4],o=e[5],a=e[6],l=e[7],c=e[8];return t*i*c-t*o*l-n*r*c+n*o*a+s*r*l-s*i*a}invert(){let e=this.elements,t=e[0],n=e[1],s=e[2],r=e[3],i=e[4],o=e[5],a=e[6],l=e[7],c=e[8],h=c*i-o*l,u=o*a-c*r,d=l*r-i*a,p=t*h+n*u+s*d;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);let f=1/p;return e[0]=h*f,e[1]=(s*l-c*n)*f,e[2]=(o*n-s*i)*f,e[3]=u*f,e[4]=(c*t-s*a)*f,e[5]=(s*r-o*t)*f,e[6]=d*f,e[7]=(n*a-l*t)*f,e[8]=(i*t-n*r)*f,this}transpose(){let e,t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){let t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,s,r,i,o){let a=Math.cos(r),l=Math.sin(r);return this.set(n*a,n*l,-n*(a*i+l*o)+i+e,-s*l,s*a,-s*(-l*i+a*o)+o+t,0,0,1),this}scale(e,t){let n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){let t=Math.cos(e),n=Math.sin(e),s=this.elements,r=s[0],i=s[3],o=s[6],a=s[1],l=s[4],c=s[7];return s[0]=t*r+n*a,s[3]=t*i+n*l,s[6]=t*o+n*c,s[1]=-n*r+t*a,s[4]=-n*i+t*l,s[7]=-n*o+t*c,this}translate(e,t){let n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){let t=this.elements,n=e.elements;for(let s=0;s<9;s++)if(t[s]!==n[s])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){let n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}};function tD(e){for(let t=e.length-1;t>=0;--t)if(e[t]>65535)return!0;return!1}var N8={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function ty(e,t){return new N8[e](t)}function ny(e){return document.createElementNS("http://www.w3.org/1999/xhtml",e)}function yu(e){return e<.04045?e*.0773993808:Math.pow(e*.9478672986+.0521327014,2.4)}function sy(e){return e<.0031308?e*12.92:1.055*Math.pow(e,.41666)-.055}var nS={[ul]:{[gu]:yu},[gu]:{[ul]:sy}},Io={legacyMode:!0,get workingColorSpace(){return gu},set workingColorSpace(e){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(e,t,n){if(this.legacyMode||t===n||!t||!n)return e;if(nS[t]&&nS[t][n]!==void 0){let s=nS[t][n];return e.r=s(e.r),e.g=s(e.g),e.b=s(e.b),e}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(e,t){return this.convert(e,this.workingColorSpace,t)},toWorkingColorSpace:function(e,t){return this.convert(e,t,this.workingColorSpace)}},nD={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Ds={r:0,g:0,b:0},No={h:0,s:0,l:0},ry={h:0,s:0,l:0};function sS(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+(t-e)*6*n:n<1/2?t:n<2/3?e+(t-e)*6*(2/3-n):e}function iy(e,t){return t.r=e.r,t.g=e.g,t.b=e.b,t}var _t=class{constructor(e,t,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,t===void 0&&n===void 0?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=ul){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Io.toWorkingColorSpace(this,t),this}setRGB(e,t,n,s=gu){return this.r=e,this.g=t,this.b=n,Io.toWorkingColorSpace(this,s),this}setHSL(e,t,n,s=gu){if(e=eS(e,1),t=ks(t,0,1),n=ks(n,0,1),t===0)this.r=this.g=this.b=n;else{let r=n<=.5?n*(1+t):n+t-n*t,i=2*n-r;this.r=sS(i,r,e+1/3),this.g=sS(i,r,e),this.b=sS(i,r,e-1/3)}return Io.toWorkingColorSpace(this,s),this}setStyle(e,t=ul){function n(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let s;if(s=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let r,i=s[1],o=s[2];switch(i){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,Io.toWorkingColorSpace(this,t),n(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,Io.toWorkingColorSpace(this,t),n(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){let a=parseFloat(r[1])/360,l=parseInt(r[2],10)/100,c=parseInt(r[3],10)/100;return n(r[4]),this.setHSL(a,l,c,t)}break}}else if(s=/^\#([A-Fa-f\d]+)$/.exec(e)){let r=s[1],i=r.length;if(i===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,Io.toWorkingColorSpace(this,t),this;if(i===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,Io.toWorkingColorSpace(this,t),this}return e&&e.length>0?this.setColorName(e,t):this}setColorName(e,t=ul){let n=nD[e.toLowerCase()];return n!==void 0?this.setHex(n,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=yu(e.r),this.g=yu(e.g),this.b=yu(e.b),this}copyLinearToSRGB(e){return this.r=sy(e.r),this.g=sy(e.g),this.b=sy(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=ul){return Io.fromWorkingColorSpace(iy(this,Ds),e),ks(Ds.r*255,0,255)<<16^ks(Ds.g*255,0,255)<<8^ks(Ds.b*255,0,255)<<0}getHexString(e=ul){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=gu){Io.fromWorkingColorSpace(iy(this,Ds),t);let n=Ds.r,s=Ds.g,r=Ds.b,i=Math.max(n,s,r),o=Math.min(n,s,r),a,l,c=(o+i)/2;if(o===i)a=0,l=0;else{let h=i-o;switch(l=c<=.5?h/(i+o):h/(2-i-o),i){case n:a=(s-r)/h+(s<r?6:0);break;case s:a=(r-n)/h+2;break;case r:a=(n-s)/h+4;break}a/=6}return e.h=a,e.s=l,e.l=c,e}getRGB(e,t=gu){return Io.fromWorkingColorSpace(iy(this,Ds),t),e.r=Ds.r,e.g=Ds.g,e.b=Ds.b,e}getStyle(e=ul){return Io.fromWorkingColorSpace(iy(this,Ds),e),e!==ul?`color(${e} ${Ds.r} ${Ds.g} ${Ds.b})`:`rgb(${Ds.r*255|0},${Ds.g*255|0},${Ds.b*255|0})`}offsetHSL(e,t,n){return this.getHSL(No),No.h+=e,No.s+=t,No.l+=n,this.setHSL(No.h,No.s,No.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(No),e.getHSL(ry);let n=Df(No.h,ry.h,t),s=Df(No.s,ry.s,t),r=Df(No.l,ry.l,t);return this.setHSL(n,s,r),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}};_t.NAMES=nD;var Qh,sD=class{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Qh===void 0&&(Qh=ny("canvas")),Qh.width=e.width,Qh.height=e.height;let n=Qh.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=Qh}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){let t=ny("canvas");t.width=e.width,t.height=e.height;let n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);let s=n.getImageData(0,0,e.width,e.height),r=s.data;for(let i=0;i<r.length;i++)r[i]=yu(r[i]/255)*255;return n.putImageData(s,0,0),t}else if(e.data){let t=e.data.slice(0);for(let n=0;n<t.length;n++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[n]=Math.floor(yu(t[n]/255)*255):t[n]=yu(t[n]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}},rD=class{constructor(e=null){this.isSource=!0,this.uuid=da(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){let t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];let n={uuid:this.uuid,url:""},s=this.data;if(s!==null){let r;if(Array.isArray(s)){r=[];for(let i=0,o=s.length;i<o;i++)s[i].isDataTexture?r.push(rS(s[i].image)):r.push(rS(s[i]))}else r=rS(s);n.url=r}return t||(e.images[this.uuid]=n),n}};function rS(e){return typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap?sD.getDataURL(e):e.data?{data:Array.from(e.data),width:e.width,height:e.height,type:e.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}var k8=0,mr=class extends Zr{constructor(e=mr.DEFAULT_IMAGE,t=mr.DEFAULT_MAPPING,n=yi,s=yi,r=xn,i=Af,o=ua,a=pr,l=1,c=ha){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:k8++}),this.uuid=da(),this.name="",this.source=new rD(e),this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=s,this.magFilter=r,this.minFilter=i,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=a,this.offset=new se(0,0),this.repeat=new se(1,1),this.center=new se(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Or,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){let t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];let n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==Ak)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Ef:e.x=e.x-Math.floor(e.x);break;case yi:e.x=e.x<0?0:1;break;case jw:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Ef:e.y=e.y-Math.floor(e.y);break;case yi:e.y=e.y<0?0:1;break;case jw:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}};mr.DEFAULT_IMAGE=null;mr.DEFAULT_MAPPING=Ak;var Bt=class{constructor(e=0,t=0,n=0,s=1){Bt.prototype.isVector4=!0,this.x=e,this.y=t,this.z=n,this.w=s}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,s){return this.x=e,this.y=t,this.z=n,this.w=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){let t=this.x,n=this.y,s=this.z,r=this.w,i=e.elements;return this.x=i[0]*t+i[4]*n+i[8]*s+i[12]*r,this.y=i[1]*t+i[5]*n+i[9]*s+i[13]*r,this.z=i[2]*t+i[6]*n+i[10]*s+i[14]*r,this.w=i[3]*t+i[7]*n+i[11]*s+i[15]*r,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);let t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,s,r,i=e.elements,o=i[0],a=i[4],l=i[8],c=i[1],h=i[5],u=i[9],d=i[2],p=i[6],f=i[10];if(Math.abs(a-c)<.01&&Math.abs(l-d)<.01&&Math.abs(u-p)<.01){if(Math.abs(a+c)<.1&&Math.abs(l+d)<.1&&Math.abs(u+p)<.1&&Math.abs(o+h+f-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;let m=(o+1)/2,y=(h+1)/2,v=(f+1)/2,b=(a+c)/4,x=(l+d)/4,w=(u+p)/4;return m>y&&m>v?m<.01?(n=0,s=.707106781,r=.707106781):(n=Math.sqrt(m),s=b/n,r=x/n):y>v?y<.01?(n=.707106781,s=0,r=.707106781):(s=Math.sqrt(y),n=b/s,r=w/s):v<.01?(n=.707106781,s=.707106781,r=0):(r=Math.sqrt(v),n=x/r,s=w/r),this.set(n,s,r,t),this}let g=Math.sqrt((p-u)*(p-u)+(l-d)*(l-d)+(c-a)*(c-a));return Math.abs(g)<.001&&(g=1),this.x=(p-u)/g,this.y=(l-d)/g,this.z=(c-a)/g,this.w=Math.acos((o+h+f-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){let n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}},hs=class extends Zr{constructor(e,t,n={}){super(),this.isWebGLRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new Bt(0,0,e,t),this.scissorTest=!1,this.viewport=new Bt(0,0,e,t);let s={width:e,height:t,depth:1};this.texture=new mr(s,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:xn,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null,this.samples=n.samples!==void 0?n.samples:0}setSize(e,t,n=1){(this.width!==e||this.height!==t||this.depth!==n)&&(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;let t=Object.assign({},e.texture.image);return this.texture.source=new rD(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}},iD=class extends mr{constructor(e=null,t=1,n=1,s=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:n,depth:s},this.magFilter=ns,this.minFilter=ns,this.wrapR=yi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}},D8=class extends mr{constructor(e=null,t=1,n=1,s=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:n,depth:s},this.magFilter=ns,this.minFilter=ns,this.wrapR=yi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}},un=class{constructor(e=0,t=0,n=0,s=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=n,this._w=s}static slerp(e,t,n,s){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(e,t,s)}static slerpFlat(e,t,n,s,r,i,o){let a=n[s+0],l=n[s+1],c=n[s+2],h=n[s+3],u=r[i+0],d=r[i+1],p=r[i+2],f=r[i+3];if(o===0){e[t+0]=a,e[t+1]=l,e[t+2]=c,e[t+3]=h;return}if(o===1){e[t+0]=u,e[t+1]=d,e[t+2]=p,e[t+3]=f;return}if(h!==f||a!==u||l!==d||c!==p){let g=1-o,m=a*u+l*d+c*p+h*f,y=m>=0?1:-1,v=1-m*m;if(v>Number.EPSILON){let x=Math.sqrt(v),w=Math.atan2(x,m*y);g=Math.sin(g*w)/x,o=Math.sin(o*w)/x}let b=o*y;if(a=a*g+u*b,l=l*g+d*b,c=c*g+p*b,h=h*g+f*b,g===1-o){let x=1/Math.sqrt(a*a+l*l+c*c+h*h);a*=x,l*=x,c*=x,h*=x}}e[t]=a,e[t+1]=l,e[t+2]=c,e[t+3]=h}static multiplyQuaternionsFlat(e,t,n,s,r,i){let o=n[s],a=n[s+1],l=n[s+2],c=n[s+3],h=r[i],u=r[i+1],d=r[i+2],p=r[i+3];return e[t]=o*p+c*h+a*d-l*u,e[t+1]=a*p+c*u+l*h-o*d,e[t+2]=l*p+c*d+o*u-a*h,e[t+3]=c*p-o*h-a*u-l*d,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,s){return this._x=e,this._y=t,this._z=n,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");let n=e._x,s=e._y,r=e._z,i=e._order,o=Math.cos,a=Math.sin,l=o(n/2),c=o(s/2),h=o(r/2),u=a(n/2),d=a(s/2),p=a(r/2);switch(i){case"XYZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"YXZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"ZXY":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"ZYX":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"YZX":this._x=u*c*h+l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h-u*d*p;break;case"XZY":this._x=u*c*h-l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h+u*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+i)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){let n=t/2,s=Math.sin(n);return this._x=e.x*s,this._y=e.y*s,this._z=e.z*s,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){let t=e.elements,n=t[0],s=t[4],r=t[8],i=t[1],o=t[5],a=t[9],l=t[2],c=t[6],h=t[10],u=n+o+h;if(u>0){let d=.5/Math.sqrt(u+1);this._w=.25/d,this._x=(c-a)*d,this._y=(r-l)*d,this._z=(i-s)*d}else if(n>o&&n>h){let d=2*Math.sqrt(1+n-o-h);this._w=(c-a)/d,this._x=.25*d,this._y=(s+i)/d,this._z=(r+l)/d}else if(o>h){let d=2*Math.sqrt(1+o-n-h);this._w=(r-l)/d,this._x=(s+i)/d,this._y=.25*d,this._z=(a+c)/d}else{let d=2*Math.sqrt(1+h-n-o);this._w=(i-s)/d,this._x=(r+l)/d,this._y=(a+c)/d,this._z=.25*d}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(ks(this.dot(e),-1,1)))}rotateTowards(e,t){let n=this.angleTo(e);if(n===0)return this;let s=Math.min(1,t/n);return this.slerp(e,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){let n=e._x,s=e._y,r=e._z,i=e._w,o=t._x,a=t._y,l=t._z,c=t._w;return this._x=n*c+i*o+s*l-r*a,this._y=s*c+i*a+r*o-n*l,this._z=r*c+i*l+n*a-s*o,this._w=i*c-n*o-s*a-r*l,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);let n=this._x,s=this._y,r=this._z,i=this._w,o=i*e._w+n*e._x+s*e._y+r*e._z;if(o<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,o=-o):this.copy(e),o>=1)return this._w=i,this._x=n,this._y=s,this._z=r,this;let a=1-o*o;if(a<=Number.EPSILON){let d=1-t;return this._w=d*i+t*this._w,this._x=d*n+t*this._x,this._y=d*s+t*this._y,this._z=d*r+t*this._z,this.normalize(),this._onChangeCallback(),this}let l=Math.sqrt(a),c=Math.atan2(l,o),h=Math.sin((1-t)*c)/l,u=Math.sin(t*c)/l;return this._w=i*h+this._w*u,this._x=n*h+this._x*u,this._y=s*h+this._y*u,this._z=r*h+this._z*u,this._onChangeCallback(),this}slerpQuaternions(e,t,n){return this.copy(e).slerp(t,n)}random(){let e=Math.random(),t=Math.sqrt(1-e),n=Math.sqrt(e),s=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(t*Math.cos(s),n*Math.sin(r),n*Math.cos(r),t*Math.sin(s))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}},I=class{constructor(e=0,t=0,n=0){I.prototype.isVector3=!0,this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(oD.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(oD.setFromAxisAngle(e,t))}applyMatrix3(e){let t=this.x,n=this.y,s=this.z,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6]*s,this.y=r[1]*t+r[4]*n+r[7]*s,this.z=r[2]*t+r[5]*n+r[8]*s,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){let t=this.x,n=this.y,s=this.z,r=e.elements,i=1/(r[3]*t+r[7]*n+r[11]*s+r[15]);return this.x=(r[0]*t+r[4]*n+r[8]*s+r[12])*i,this.y=(r[1]*t+r[5]*n+r[9]*s+r[13])*i,this.z=(r[2]*t+r[6]*n+r[10]*s+r[14])*i,this}applyQuaternion(e){let t=this.x,n=this.y,s=this.z,r=e.x,i=e.y,o=e.z,a=e.w,l=a*t+i*s-o*n,c=a*n+o*t-r*s,h=a*s+r*n-i*t,u=-r*t-i*n-o*s;return this.x=l*a+u*-r+c*-o-h*-i,this.y=c*a+u*-i+h*-r-l*-o,this.z=h*a+u*-o+l*-i-c*-r,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){let t=this.x,n=this.y,s=this.z,r=e.elements;return this.x=r[0]*t+r[4]*n+r[8]*s,this.y=r[1]*t+r[5]*n+r[9]*s,this.z=r[2]*t+r[6]*n+r[10]*s,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){let n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){let n=e.x,s=e.y,r=e.z,i=t.x,o=t.y,a=t.z;return this.x=s*a-r*o,this.y=r*i-n*a,this.z=n*o-s*i,this}projectOnVector(e){let t=e.lengthSq();if(t===0)return this.set(0,0,0);let n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return iS.copy(this).projectOnVector(e),this.sub(iS)}reflect(e){return this.sub(iS.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){let t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;let n=this.dot(e)/t;return Math.acos(ks(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){let t=this.x-e.x,n=this.y-e.y,s=this.z-e.z;return t*t+n*n+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){let s=Math.sin(t)*e;return this.x=s*Math.sin(n),this.y=Math.cos(t)*e,this.z=s*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){let t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){let t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),s=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=s,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){let e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,n=Math.sqrt(1-e**2);return this.x=n*Math.cos(t),this.y=n*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}},iS=new I,oD=new un,Ss=class{constructor(e=new I(1/0,1/0,1/0),t=new I(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,s=1/0,r=-1/0,i=-1/0,o=-1/0;for(let a=0,l=e.length;a<l;a+=3){let c=e[a],h=e[a+1],u=e[a+2];c<t&&(t=c),h<n&&(n=h),u<s&&(s=u),c>r&&(r=c),h>i&&(i=h),u>o&&(o=u)}return this.min.set(t,n,s),this.max.set(r,i,o),this}setFromBufferAttribute(e){let t=1/0,n=1/0,s=1/0,r=-1/0,i=-1/0,o=-1/0;for(let a=0,l=e.count;a<l;a++){let c=e.getX(a),h=e.getY(a),u=e.getZ(a);c<t&&(t=c),h<n&&(n=h),u<s&&(s=u),c>r&&(r=c),h>i&&(i=h),u>o&&(o=u)}return this.min.set(t,n,s),this.max.set(r,i,o),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){let n=vu.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);let n=e.geometry;if(n!==void 0)if(t&&n.attributes!=null&&n.attributes.position!==void 0){let r=n.attributes.position;for(let i=0,o=r.count;i<o;i++)vu.fromBufferAttribute(r,i).applyMatrix4(e.matrixWorld),this.expandByPoint(vu)}else n.boundingBox===null&&n.computeBoundingBox(),oS.copy(n.boundingBox),oS.applyMatrix4(e.matrixWorld),this.union(oS);let s=e.children;for(let r=0,i=s.length;r<i;r++)this.expandByObject(s[r],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,vu),vu.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Mf),oy.subVectors(this.max,Mf),Zh.subVectors(e.a,Mf),Jh.subVectors(e.b,Mf),ed.subVectors(e.c,Mf),Kl.subVectors(Jh,Zh),Yl.subVectors(ed,Jh),xu.subVectors(Zh,ed);let t=[0,-Kl.z,Kl.y,0,-Yl.z,Yl.y,0,-xu.z,xu.y,Kl.z,0,-Kl.x,Yl.z,0,-Yl.x,xu.z,0,-xu.x,-Kl.y,Kl.x,0,-Yl.y,Yl.x,0,-xu.y,xu.x,0];return!aS(t,Zh,Jh,ed,oy)||(t=[1,0,0,0,1,0,0,0,1],!aS(t,Zh,Jh,ed,oy))?!1:(ay.crossVectors(Kl,Yl),t=[ay.x,ay.y,ay.z],aS(t,Zh,Jh,ed,oy))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return vu.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=this.getSize(vu).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(hl[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),hl[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),hl[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),hl[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),hl[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),hl[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),hl[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),hl[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(hl),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}},hl=[new I,new I,new I,new I,new I,new I,new I,new I],vu=new I,oS=new Ss,Zh=new I,Jh=new I,ed=new I,Kl=new I,Yl=new I,xu=new I,Mf=new I,oy=new I,ay=new I,bu=new I;function aS(e,t,n,s,r){for(let i=0,o=e.length-3;i<=o;i+=3){bu.fromArray(e,i);let a=r.x*Math.abs(bu.x)+r.y*Math.abs(bu.y)+r.z*Math.abs(bu.z),l=t.dot(bu),c=n.dot(bu),h=s.dot(bu);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>a)return!1}return!0}var M8=new Ss,aD=new I,ly=new I,lS=new I,Wi=class{constructor(e=new I,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){let n=this.center;t!==void 0?n.copy(t):M8.setFromPoints(e).getCenter(n);let s=0;for(let r=0,i=e.length;r<i;r++)s=Math.max(s,n.distanceToSquared(e[r]));return this.radius=Math.sqrt(s),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){let t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){let n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){lS.subVectors(e,this.center);let t=lS.lengthSq();if(t>this.radius*this.radius){let n=Math.sqrt(t),s=(n-this.radius)*.5;this.center.add(lS.multiplyScalar(s/n)),this.radius+=s}return this}union(e){return this.center.equals(e.center)===!0?ly.set(0,0,1).multiplyScalar(e.radius):ly.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(aD.copy(e.center).add(ly)),this.expandByPoint(aD.copy(e.center).sub(ly)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}},dl=new I,cS=new I,cy=new I,Ql=new I,uS=new I,uy=new I,hS=new I,td=class{constructor(e=new I,t=new I(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,dl)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);let n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){let t=dl.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(dl.copy(this.direction).multiplyScalar(t).add(this.origin),dl.distanceToSquared(e))}distanceSqToSegment(e,t,n,s){cS.copy(e).add(t).multiplyScalar(.5),cy.copy(t).sub(e).normalize(),Ql.copy(this.origin).sub(cS);let r=e.distanceTo(t)*.5,i=-this.direction.dot(cy),o=Ql.dot(this.direction),a=-Ql.dot(cy),l=Ql.lengthSq(),c=Math.abs(1-i*i),h,u,d,p;if(c>0)if(h=i*a-o,u=i*o-a,p=r*c,h>=0)if(u>=-p)if(u<=p){let f=1/c;h*=f,u*=f,d=h*(h+i*u+2*o)+u*(i*h+u+2*a)+l}else u=r,h=Math.max(0,-(i*u+o)),d=-h*h+u*(u+2*a)+l;else u=-r,h=Math.max(0,-(i*u+o)),d=-h*h+u*(u+2*a)+l;else u<=-p?(h=Math.max(0,-(-i*r+o)),u=h>0?-r:Math.min(Math.max(-r,-a),r),d=-h*h+u*(u+2*a)+l):u<=p?(h=0,u=Math.min(Math.max(-r,-a),r),d=u*(u+2*a)+l):(h=Math.max(0,-(i*r+o)),u=h>0?r:Math.min(Math.max(-r,-a),r),d=-h*h+u*(u+2*a)+l);else u=i>0?-r:r,h=Math.max(0,-(i*u+o)),d=-h*h+u*(u+2*a)+l;return n&&n.copy(this.direction).multiplyScalar(h).add(this.origin),s&&s.copy(cy).multiplyScalar(u).add(cS),d}intersectSphere(e,t){dl.subVectors(e.center,this.origin);let n=dl.dot(this.direction),s=dl.dot(dl)-n*n,r=e.radius*e.radius;if(s>r)return null;let i=Math.sqrt(r-s),o=n-i,a=n+i;return o<0&&a<0?null:o<0?this.at(a,t):this.at(o,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){let t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;let n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){let n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){let t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,s,r,i,o,a,l=1/this.direction.x,c=1/this.direction.y,h=1/this.direction.z,u=this.origin;return l>=0?(n=(e.min.x-u.x)*l,s=(e.max.x-u.x)*l):(n=(e.max.x-u.x)*l,s=(e.min.x-u.x)*l),c>=0?(r=(e.min.y-u.y)*c,i=(e.max.y-u.y)*c):(r=(e.max.y-u.y)*c,i=(e.min.y-u.y)*c),n>i||r>s||((r>n||n!==n)&&(n=r),(i<s||s!==s)&&(s=i),h>=0?(o=(e.min.z-u.z)*h,a=(e.max.z-u.z)*h):(o=(e.max.z-u.z)*h,a=(e.min.z-u.z)*h),n>a||o>s)||((o>n||n!==n)&&(n=o),(a<s||s!==s)&&(s=a),s<0)?null:this.at(n>=0?n:s,t)}intersectsBox(e){return this.intersectBox(e,dl)!==null}intersectTriangle(e,t,n,s,r){uS.subVectors(t,e),uy.subVectors(n,e),hS.crossVectors(uS,uy);let i=this.direction.dot(hS),o;if(i>0){if(s)return null;o=1}else if(i<0)o=-1,i=-i;else return null;Ql.subVectors(this.origin,e);let a=o*this.direction.dot(uy.crossVectors(Ql,uy));if(a<0)return null;let l=o*this.direction.dot(uS.cross(Ql));if(l<0||a+l>i)return null;let c=-o*Ql.dot(hS);return c<0?null:this.at(c/i,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}},et=class{constructor(){et.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,s,r,i,o,a,l,c,h,u,d,p,f,g){let m=this.elements;return m[0]=e,m[4]=t,m[8]=n,m[12]=s,m[1]=r,m[5]=i,m[9]=o,m[13]=a,m[2]=l,m[6]=c,m[10]=h,m[14]=u,m[3]=d,m[7]=p,m[11]=f,m[15]=g,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new et().fromArray(this.elements)}copy(e){let t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){let t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){let t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){let t=this.elements,n=e.elements,s=1/nd.setFromMatrixColumn(e,0).length(),r=1/nd.setFromMatrixColumn(e,1).length(),i=1/nd.setFromMatrixColumn(e,2).length();return t[0]=n[0]*s,t[1]=n[1]*s,t[2]=n[2]*s,t[3]=0,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=0,t[8]=n[8]*i,t[9]=n[9]*i,t[10]=n[10]*i,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");let t=this.elements,n=e.x,s=e.y,r=e.z,i=Math.cos(n),o=Math.sin(n),a=Math.cos(s),l=Math.sin(s),c=Math.cos(r),h=Math.sin(r);if(e.order==="XYZ"){let u=i*c,d=i*h,p=o*c,f=o*h;t[0]=a*c,t[4]=-a*h,t[8]=l,t[1]=d+p*l,t[5]=u-f*l,t[9]=-o*a,t[2]=f-u*l,t[6]=p+d*l,t[10]=i*a}else if(e.order==="YXZ"){let u=a*c,d=a*h,p=l*c,f=l*h;t[0]=u+f*o,t[4]=p*o-d,t[8]=i*l,t[1]=i*h,t[5]=i*c,t[9]=-o,t[2]=d*o-p,t[6]=f+u*o,t[10]=i*a}else if(e.order==="ZXY"){let u=a*c,d=a*h,p=l*c,f=l*h;t[0]=u-f*o,t[4]=-i*h,t[8]=p+d*o,t[1]=d+p*o,t[5]=i*c,t[9]=f-u*o,t[2]=-i*l,t[6]=o,t[10]=i*a}else if(e.order==="ZYX"){let u=i*c,d=i*h,p=o*c,f=o*h;t[0]=a*c,t[4]=p*l-d,t[8]=u*l+f,t[1]=a*h,t[5]=f*l+u,t[9]=d*l-p,t[2]=-l,t[6]=o*a,t[10]=i*a}else if(e.order==="YZX"){let u=i*a,d=i*l,p=o*a,f=o*l;t[0]=a*c,t[4]=f-u*h,t[8]=p*h+d,t[1]=h,t[5]=i*c,t[9]=-o*c,t[2]=-l*c,t[6]=d*h+p,t[10]=u-f*h}else if(e.order==="XZY"){let u=i*a,d=i*l,p=o*a,f=o*l;t[0]=a*c,t[4]=-h,t[8]=l*c,t[1]=u*h+f,t[5]=i*c,t[9]=d*h-p,t[2]=p*h-d,t[6]=o*c,t[10]=f*h+u}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(P8,e,O8)}lookAt(e,t,n){let s=this.elements;return vi.subVectors(e,t),vi.lengthSq()===0&&(vi.z=1),vi.normalize(),Zl.crossVectors(n,vi),Zl.lengthSq()===0&&(Math.abs(n.z)===1?vi.x+=1e-4:vi.z+=1e-4,vi.normalize(),Zl.crossVectors(n,vi)),Zl.normalize(),hy.crossVectors(vi,Zl),s[0]=Zl.x,s[4]=hy.x,s[8]=vi.x,s[1]=Zl.y,s[5]=hy.y,s[9]=vi.y,s[2]=Zl.z,s[6]=hy.z,s[10]=vi.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){let n=e.elements,s=t.elements,r=this.elements,i=n[0],o=n[4],a=n[8],l=n[12],c=n[1],h=n[5],u=n[9],d=n[13],p=n[2],f=n[6],g=n[10],m=n[14],y=n[3],v=n[7],b=n[11],x=n[15],w=s[0],S=s[4],C=s[8],_=s[12],T=s[1],E=s[5],A=s[9],D=s[13],O=s[2],P=s[6],L=s[10],B=s[14],F=s[3],M=s[7],U=s[11],z=s[15];return r[0]=i*w+o*T+a*O+l*F,r[4]=i*S+o*E+a*P+l*M,r[8]=i*C+o*A+a*L+l*U,r[12]=i*_+o*D+a*B+l*z,r[1]=c*w+h*T+u*O+d*F,r[5]=c*S+h*E+u*P+d*M,r[9]=c*C+h*A+u*L+d*U,r[13]=c*_+h*D+u*B+d*z,r[2]=p*w+f*T+g*O+m*F,r[6]=p*S+f*E+g*P+m*M,r[10]=p*C+f*A+g*L+m*U,r[14]=p*_+f*D+g*B+m*z,r[3]=y*w+v*T+b*O+x*F,r[7]=y*S+v*E+b*P+x*M,r[11]=y*C+v*A+b*L+x*U,r[15]=y*_+v*D+b*B+x*z,this}multiplyScalar(e){let t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){let e=this.elements,t=e[0],n=e[4],s=e[8],r=e[12],i=e[1],o=e[5],a=e[9],l=e[13],c=e[2],h=e[6],u=e[10],d=e[14],p=e[3],f=e[7],g=e[11],m=e[15];return p*(+r*a*h-s*l*h-r*o*u+n*l*u+s*o*d-n*a*d)+f*(+t*a*d-t*l*u+r*i*u-s*i*d+s*l*c-r*a*c)+g*(+t*l*h-t*o*d-r*i*h+n*i*d+r*o*c-n*l*c)+m*(-s*o*c-t*a*h+t*o*u+s*i*h-n*i*u+n*a*c)}transpose(){let e=this.elements,t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){let s=this.elements;return e.isVector3?(s[12]=e.x,s[13]=e.y,s[14]=e.z):(s[12]=e,s[13]=t,s[14]=n),this}invert(){let e=this.elements,t=e[0],n=e[1],s=e[2],r=e[3],i=e[4],o=e[5],a=e[6],l=e[7],c=e[8],h=e[9],u=e[10],d=e[11],p=e[12],f=e[13],g=e[14],m=e[15],y=h*g*l-f*u*l+f*a*d-o*g*d-h*a*m+o*u*m,v=p*u*l-c*g*l-p*a*d+i*g*d+c*a*m-i*u*m,b=c*f*l-p*h*l+p*o*d-i*f*d-c*o*m+i*h*m,x=p*h*a-c*f*a-p*o*u+i*f*u+c*o*g-i*h*g,w=t*y+n*v+s*b+r*x;if(w===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);let S=1/w;return e[0]=y*S,e[1]=(f*u*r-h*g*r-f*s*d+n*g*d+h*s*m-n*u*m)*S,e[2]=(o*g*r-f*a*r+f*s*l-n*g*l-o*s*m+n*a*m)*S,e[3]=(h*a*r-o*u*r-h*s*l+n*u*l+o*s*d-n*a*d)*S,e[4]=v*S,e[5]=(c*g*r-p*u*r+p*s*d-t*g*d-c*s*m+t*u*m)*S,e[6]=(p*a*r-i*g*r-p*s*l+t*g*l+i*s*m-t*a*m)*S,e[7]=(i*u*r-c*a*r+c*s*l-t*u*l-i*s*d+t*a*d)*S,e[8]=b*S,e[9]=(p*h*r-c*f*r-p*n*d+t*f*d+c*n*m-t*h*m)*S,e[10]=(i*f*r-p*o*r+p*n*l-t*f*l-i*n*m+t*o*m)*S,e[11]=(c*o*r-i*h*r-c*n*l+t*h*l+i*n*d-t*o*d)*S,e[12]=x*S,e[13]=(c*f*s-p*h*s+p*n*u-t*f*u-c*n*g+t*h*g)*S,e[14]=(p*o*s-i*f*s-p*n*a+t*f*a+i*n*g-t*o*g)*S,e[15]=(i*h*s-c*o*s+c*n*a-t*h*a-i*n*u+t*o*u)*S,this}scale(e){let t=this.elements,n=e.x,s=e.y,r=e.z;return t[0]*=n,t[4]*=s,t[8]*=r,t[1]*=n,t[5]*=s,t[9]*=r,t[2]*=n,t[6]*=s,t[10]*=r,t[3]*=n,t[7]*=s,t[11]*=r,this}getMaxScaleOnAxis(){let e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],s=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,s))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){let t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){let t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){let t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){let n=Math.cos(t),s=Math.sin(t),r=1-n,i=e.x,o=e.y,a=e.z,l=r*i,c=r*o;return this.set(l*i+n,l*o-s*a,l*a+s*o,0,l*o+s*a,c*o+n,c*a-s*i,0,l*a-s*o,c*a+s*i,r*a*a+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,s,r,i){return this.set(1,n,r,0,e,1,i,0,t,s,1,0,0,0,0,1),this}compose(e,t,n){let s=this.elements,r=t._x,i=t._y,o=t._z,a=t._w,l=r+r,c=i+i,h=o+o,u=r*l,d=r*c,p=r*h,f=i*c,g=i*h,m=o*h,y=a*l,v=a*c,b=a*h,x=n.x,w=n.y,S=n.z;return s[0]=(1-(f+m))*x,s[1]=(d+b)*x,s[2]=(p-v)*x,s[3]=0,s[4]=(d-b)*w,s[5]=(1-(u+m))*w,s[6]=(g+y)*w,s[7]=0,s[8]=(p+v)*S,s[9]=(g-y)*S,s[10]=(1-(u+f))*S,s[11]=0,s[12]=e.x,s[13]=e.y,s[14]=e.z,s[15]=1,this}decompose(e,t,n){let s=this.elements,r=nd.set(s[0],s[1],s[2]).length(),i=nd.set(s[4],s[5],s[6]).length(),o=nd.set(s[8],s[9],s[10]).length();this.determinant()<0&&(r=-r),e.x=s[12],e.y=s[13],e.z=s[14],ko.copy(this);let a=1/r,l=1/i,c=1/o;return ko.elements[0]*=a,ko.elements[1]*=a,ko.elements[2]*=a,ko.elements[4]*=l,ko.elements[5]*=l,ko.elements[6]*=l,ko.elements[8]*=c,ko.elements[9]*=c,ko.elements[10]*=c,t.setFromRotationMatrix(ko),n.x=r,n.y=i,n.z=o,this}makePerspective(e,t,n,s,r,i){i===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");let o=this.elements,a=2*r/(t-e),l=2*r/(n-s),c=(t+e)/(t-e),h=(n+s)/(n-s),u=-(i+r)/(i-r),d=-2*i*r/(i-r);return o[0]=a,o[4]=0,o[8]=c,o[12]=0,o[1]=0,o[5]=l,o[9]=h,o[13]=0,o[2]=0,o[6]=0,o[10]=u,o[14]=d,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(e,t,n,s,r,i){let o=this.elements,a=1/(t-e),l=1/(n-s),c=1/(i-r),h=(t+e)*a,u=(n+s)*l,d=(i+r)*c;return o[0]=2*a,o[4]=0,o[8]=0,o[12]=-h,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-u,o[2]=0,o[6]=0,o[10]=-2*c,o[14]=-d,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(e){let t=this.elements,n=e.elements;for(let s=0;s<16;s++)if(t[s]!==n[s])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){let n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}},nd=new I,ko=new et,P8=new I(0,0,0),O8=new I(1,1,1),Zl=new I,hy=new I,vi=new I,lD=new et,cD=new un,gr=class{constructor(e=0,t=0,n=0,s=gr.DefaultOrder){this.isEuler=!0,this._x=e,this._y=t,this._z=n,this._order=s}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,s=this._order){return this._x=e,this._y=t,this._z=n,this._order=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){let s=e.elements,r=s[0],i=s[4],o=s[8],a=s[1],l=s[5],c=s[9],h=s[2],u=s[6],d=s[10];switch(t){case"XYZ":this._y=Math.asin(ks(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-i,r)):(this._x=Math.atan2(u,l),this._z=0);break;case"YXZ":this._x=Math.asin(-ks(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(o,d),this._z=Math.atan2(a,l)):(this._y=Math.atan2(-h,r),this._z=0);break;case"ZXY":this._x=Math.asin(ks(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-h,d),this._z=Math.atan2(-i,l)):(this._y=0,this._z=Math.atan2(a,r));break;case"ZYX":this._y=Math.asin(-ks(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(a,r)):(this._x=0,this._z=Math.atan2(-i,l));break;case"YZX":this._z=Math.asin(ks(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-h,r)):(this._x=0,this._y=Math.atan2(o,d));break;case"XZY":this._z=Math.asin(-ks(i,-1,1)),Math.abs(i)<.9999999?(this._x=Math.atan2(u,l),this._y=Math.atan2(o,r)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return lD.makeRotationFromQuaternion(e),this.setFromRotationMatrix(lD,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return cD.setFromEuler(this),this.setFromQuaternion(cD,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}};gr.DefaultOrder="XYZ";gr.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];var dS=class{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!=0}isEnabled(e){return(this.mask&(1<<e|0))!=0}},R8=0,uD=new I,sd=new un,pl=new et,dy=new I,Pf=new I,L8=new I,F8=new un,hD=new I(1,0,0),dD=new I(0,1,0),pD=new I(0,0,1),$8={type:"added"},fD={type:"removed"},Ln=class extends Zr{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:R8++}),this.uuid=da(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Ln.DefaultUp.clone();let e=new I,t=new gr,n=new un,s=new I(1,1,1);function r(){n.setFromEuler(t,!1)}function i(){t.setFromQuaternion(n,void 0,!1)}t._onChange(r),n._onChange(i),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:s},modelViewMatrix:{value:new et},normalMatrix:{value:new Or}}),this.matrix=new et,this.matrixWorld=new et,this.matrixAutoUpdate=Ln.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new dS,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return sd.setFromAxisAngle(e,t),this.quaternion.multiply(sd),this}rotateOnWorldAxis(e,t){return sd.setFromAxisAngle(e,t),this.quaternion.premultiply(sd),this}rotateX(e){return this.rotateOnAxis(hD,e)}rotateY(e){return this.rotateOnAxis(dD,e)}rotateZ(e){return this.rotateOnAxis(pD,e)}translateOnAxis(e,t){return uD.copy(e).applyQuaternion(this.quaternion),this.position.add(uD.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(hD,e)}translateY(e){return this.translateOnAxis(dD,e)}translateZ(e){return this.translateOnAxis(pD,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(pl.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?dy.copy(e):dy.set(e,t,n);let s=this.parent;this.updateWorldMatrix(!0,!1),Pf.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?pl.lookAt(Pf,dy,this.up):pl.lookAt(dy,Pf,this.up),this.quaternion.setFromRotationMatrix(pl),s&&(pl.extractRotation(s.matrixWorld),sd.setFromRotationMatrix(pl),this.quaternion.premultiply(sd.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent($8)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}let t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(fD)),this}removeFromParent(){let e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){let t=this.children[e];t.parent=null,t.dispatchEvent(fD)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),pl.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),pl.multiply(e.parent.matrixWorld)),e.applyMatrix4(pl),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,s=this.children.length;n<s;n++){let r=this.children[n].getObjectByProperty(e,t);if(r!==void 0)return r}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Pf,e,L8),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Pf,F8,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);let t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);let t=this.children;for(let n=0,s=t.length;n<s;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);let t=this.children;for(let n=0,s=t.length;n<s;n++)t[n].traverseVisible(e)}traverseAncestors(e){let t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);let t=this.children;for(let n=0,s=t.length;n<s;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){let n=this.parent;if(e===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){let s=this.children;for(let r=0,i=s.length;r<i;r++)s[r].updateWorldMatrix(!1,!0)}}toJSON(e){let t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});let s={};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.castShadow===!0&&(s.castShadow=!0),this.receiveShadow===!0&&(s.receiveShadow=!0),this.visible===!1&&(s.visible=!1),this.frustumCulled===!1&&(s.frustumCulled=!1),this.renderOrder!==0&&(s.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(s.userData=this.userData),s.layers=this.layers.mask,s.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(s.matrixAutoUpdate=!1),this.isInstancedMesh&&(s.type="InstancedMesh",s.count=this.count,s.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(s.instanceColor=this.instanceColor.toJSON()));function r(o,a){return o[a.uuid]===void 0&&(o[a.uuid]=a.toJSON(e)),a.uuid}if(this.isScene)this.background&&(this.background.isColor?s.background=this.background.toJSON():this.background.isTexture&&(s.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(s.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){s.geometry=r(e.geometries,this.geometry);let o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){let a=o.shapes;if(Array.isArray(a))for(let l=0,c=a.length;l<c;l++){let h=a[l];r(e.shapes,h)}else r(e.shapes,a)}}if(this.isSkinnedMesh&&(s.bindMode=this.bindMode,s.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),s.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){let o=[];for(let a=0,l=this.material.length;a<l;a++)o.push(r(e.materials,this.material[a]));s.material=o}else s.material=r(e.materials,this.material);if(this.children.length>0){s.children=[];for(let o=0;o<this.children.length;o++)s.children.push(this.children[o].toJSON(e).object)}if(this.animations.length>0){s.animations=[];for(let o=0;o<this.animations.length;o++){let a=this.animations[o];s.animations.push(r(e.animations,a))}}if(t){let o=i(e.geometries),a=i(e.materials),l=i(e.textures),c=i(e.images),h=i(e.shapes),u=i(e.skeletons),d=i(e.animations),p=i(e.nodes);o.length>0&&(n.geometries=o),a.length>0&&(n.materials=a),l.length>0&&(n.textures=l),c.length>0&&(n.images=c),h.length>0&&(n.shapes=h),u.length>0&&(n.skeletons=u),d.length>0&&(n.animations=d),p.length>0&&(n.nodes=p)}return n.object=s,n;function i(o){let a=[];for(let l in o){let c=o[l];delete c.metadata,a.push(c)}return a}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){let s=e.children[n];this.add(s.clone())}return this}};Ln.DefaultUp=new I(0,1,0);Ln.DefaultMatrixAutoUpdate=!0;var Do=new I,fl=new I,pS=new I,ml=new I,rd=new I,id=new I,mD=new I,fS=new I,mS=new I,gS=new I,Jr=class{constructor(e=new I,t=new I,n=new I){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,s){s.subVectors(n,t),Do.subVectors(e,t),s.cross(Do);let r=s.lengthSq();return r>0?s.multiplyScalar(1/Math.sqrt(r)):s.set(0,0,0)}static getBarycoord(e,t,n,s,r){Do.subVectors(s,t),fl.subVectors(n,t),pS.subVectors(e,t);let i=Do.dot(Do),o=Do.dot(fl),a=Do.dot(pS),l=fl.dot(fl),c=fl.dot(pS),h=i*l-o*o;if(h===0)return r.set(-2,-1,-1);let u=1/h,d=(l*a-o*c)*u,p=(i*c-o*a)*u;return r.set(1-d-p,p,d)}static containsPoint(e,t,n,s){return this.getBarycoord(e,t,n,s,ml),ml.x>=0&&ml.y>=0&&ml.x+ml.y<=1}static getUV(e,t,n,s,r,i,o,a){return this.getBarycoord(e,t,n,s,ml),a.set(0,0),a.addScaledVector(r,ml.x),a.addScaledVector(i,ml.y),a.addScaledVector(o,ml.z),a}static isFrontFacing(e,t,n,s){return Do.subVectors(n,t),fl.subVectors(e,t),Do.cross(fl).dot(s)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,s){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[s]),this}setFromAttributeAndIndices(e,t,n,s){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,s),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Do.subVectors(this.c,this.b),fl.subVectors(this.a,this.b),Do.cross(fl).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Jr.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Jr.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,s,r){return Jr.getUV(e,this.a,this.b,this.c,t,n,s,r)}containsPoint(e){return Jr.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Jr.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){let n=this.a,s=this.b,r=this.c,i,o;rd.subVectors(s,n),id.subVectors(r,n),fS.subVectors(e,n);let a=rd.dot(fS),l=id.dot(fS);if(a<=0&&l<=0)return t.copy(n);mS.subVectors(e,s);let c=rd.dot(mS),h=id.dot(mS);if(c>=0&&h<=c)return t.copy(s);let u=a*h-c*l;if(u<=0&&a>=0&&c<=0)return i=a/(a-c),t.copy(n).addScaledVector(rd,i);gS.subVectors(e,r);let d=rd.dot(gS),p=id.dot(gS);if(p>=0&&d<=p)return t.copy(r);let f=d*l-a*p;if(f<=0&&l>=0&&p<=0)return o=l/(l-p),t.copy(n).addScaledVector(id,o);let g=c*p-d*h;if(g<=0&&h-c>=0&&d-p>=0)return mD.subVectors(r,s),o=(h-c)/(h-c+(d-p)),t.copy(s).addScaledVector(mD,o);let m=1/(g+f+u);return i=f*m,o=u*m,t.copy(n).addScaledVector(rd,i).addScaledVector(id,o)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}},B8=0,Of=class extends Zr{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:B8++}),this.uuid=da(),this.name="",this.type="Material",this.blending=Kh,this.side=jl,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=Ck,this.blendDst=Tk,this.blendEquation=Yh,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Gw,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=d8,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Qw,this.stencilZFail=Qw,this.stencilZPass=Qw,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(let t in e){let n=e[t];if(n===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===w6;continue}let s=this[t];if(s===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}s&&s.isColor?s.set(n):s&&s.isVector3&&n&&n.isVector3?s.copy(n):this[t]=n}}toJSON(e){let t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});let n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Kh&&(n.blending=this.blending),this.side!==jl&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function s(r){let i=[];for(let o in r){let a=r[o];delete a.metadata,i.push(a)}return i}if(t){let r=s(e.textures),i=s(e.images);r.length>0&&(n.textures=r),i.length>0&&(n.images=i)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;let t=e.clippingPlanes,n=null;if(t!==null){let s=t.length;n=new Array(s);for(let r=0;r!==s;++r)n[r]=t[r].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}},Rf=class extends Of{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new _t(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Ek,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}},_s=new I,py=new se,Lt=class{constructor(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n===!0,this.usage=Zw,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let s=0,r=this.itemSize;s<r;s++)this.array[e+s]=t.array[n+s];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){let t=this.array,n=0;for(let s=0,r=e.length;s<r;s++){let i=e[s];i===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",s),i=new _t),t[n++]=i.r,t[n++]=i.g,t[n++]=i.b}return this}copyVector2sArray(e){let t=this.array,n=0;for(let s=0,r=e.length;s<r;s++){let i=e[s];i===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",s),i=new se),t[n++]=i.x,t[n++]=i.y}return this}copyVector3sArray(e){let t=this.array,n=0;for(let s=0,r=e.length;s<r;s++){let i=e[s];i===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",s),i=new I),t[n++]=i.x,t[n++]=i.y,t[n++]=i.z}return this}copyVector4sArray(e){let t=this.array,n=0;for(let s=0,r=e.length;s<r;s++){let i=e[s];i===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",s),i=new Bt),t[n++]=i.x,t[n++]=i.y,t[n++]=i.z,t[n++]=i.w}return this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)py.fromBufferAttribute(this,t),py.applyMatrix3(e),this.setXY(t,py.x,py.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)_s.fromBufferAttribute(this,t),_s.applyMatrix3(e),this.setXYZ(t,_s.x,_s.y,_s.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)_s.fromBufferAttribute(this,t),_s.applyMatrix4(e),this.setXYZ(t,_s.x,_s.y,_s.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)_s.fromBufferAttribute(this,t),_s.applyNormalMatrix(e),this.setXYZ(t,_s.x,_s.y,_s.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)_s.fromBufferAttribute(this,t),_s.transformDirection(e),this.setXYZ(t,_s.x,_s.y,_s.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,s){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=s,this}setXYZW(e,t,n,s,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=s,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){let e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==Zw&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}},gD=class extends Lt{constructor(e,t,n){super(new Uint16Array(e),t,n)}},Lf=class extends Lt{constructor(e,t,n){super(new Uint32Array(e),t,n)}},z8=class extends Lt{constructor(e,t,n){super(new Uint16Array(e),t,n),this.isFloat16BufferAttribute=!0}},ot=class extends Lt{constructor(e,t,n){super(new Float32Array(e),t,n)}},U8=0,Hi=new et,yS=new Ln,od=new I,xi=new Ss,Ff=new Ss,qs=new I,It=class extends Zr{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:U8++}),this.uuid=da(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(tD(e)?Lf:gD)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){let t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);let n=this.attributes.normal;if(n!==void 0){let r=new Or().getNormalMatrix(e);n.applyNormalMatrix(r),n.needsUpdate=!0}let s=this.attributes.tangent;return s!==void 0&&(s.transformDirection(e),s.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Hi.makeRotationFromQuaternion(e),this.applyMatrix4(Hi),this}rotateX(e){return Hi.makeRotationX(e),this.applyMatrix4(Hi),this}rotateY(e){return Hi.makeRotationY(e),this.applyMatrix4(Hi),this}rotateZ(e){return Hi.makeRotationZ(e),this.applyMatrix4(Hi),this}translate(e,t,n){return Hi.makeTranslation(e,t,n),this.applyMatrix4(Hi),this}scale(e,t,n){return Hi.makeScale(e,t,n),this.applyMatrix4(Hi),this}lookAt(e){return yS.lookAt(e),yS.updateMatrix(),this.applyMatrix4(yS.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(od).negate(),this.translate(od.x,od.y,od.z),this}setFromPoints(e){let t=[];for(let n=0,s=e.length;n<s;n++){let r=e[n];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new ot(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ss);let e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new I(-1/0,-1/0,-1/0),new I(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,s=t.length;n<s;n++){let r=t[n];xi.setFromBufferAttribute(r),this.morphTargetsRelative?(qs.addVectors(this.boundingBox.min,xi.min),this.boundingBox.expandByPoint(qs),qs.addVectors(this.boundingBox.max,xi.max),this.boundingBox.expandByPoint(qs)):(this.boundingBox.expandByPoint(xi.min),this.boundingBox.expandByPoint(xi.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Wi);let e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new I,1/0);return}if(e){let n=this.boundingSphere.center;if(xi.setFromBufferAttribute(e),t)for(let r=0,i=t.length;r<i;r++){let o=t[r];Ff.setFromBufferAttribute(o),this.morphTargetsRelative?(qs.addVectors(xi.min,Ff.min),xi.expandByPoint(qs),qs.addVectors(xi.max,Ff.max),xi.expandByPoint(qs)):(xi.expandByPoint(Ff.min),xi.expandByPoint(Ff.max))}xi.getCenter(n);let s=0;for(let r=0,i=e.count;r<i;r++)qs.fromBufferAttribute(e,r),s=Math.max(s,n.distanceToSquared(qs));if(t)for(let r=0,i=t.length;r<i;r++){let o=t[r],a=this.morphTargetsRelative;for(let l=0,c=o.count;l<c;l++)qs.fromBufferAttribute(o,l),a&&(od.fromBufferAttribute(e,l),qs.add(od)),s=Math.max(s,n.distanceToSquared(qs))}this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){let e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}let n=e.array,s=t.position.array,r=t.normal.array,i=t.uv.array,o=s.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Lt(new Float32Array(4*o),4));let a=this.getAttribute("tangent").array,l=[],c=[];for(let T=0;T<o;T++)l[T]=new I,c[T]=new I;let h=new I,u=new I,d=new I,p=new se,f=new se,g=new se,m=new I,y=new I;function v(T,E,A){h.fromArray(s,T*3),u.fromArray(s,E*3),d.fromArray(s,A*3),p.fromArray(i,T*2),f.fromArray(i,E*2),g.fromArray(i,A*2),u.sub(h),d.sub(h),f.sub(p),g.sub(p);let D=1/(f.x*g.y-g.x*f.y);!isFinite(D)||(m.copy(u).multiplyScalar(g.y).addScaledVector(d,-f.y).multiplyScalar(D),y.copy(d).multiplyScalar(f.x).addScaledVector(u,-g.x).multiplyScalar(D),l[T].add(m),l[E].add(m),l[A].add(m),c[T].add(y),c[E].add(y),c[A].add(y))}let b=this.groups;b.length===0&&(b=[{start:0,count:n.length}]);for(let T=0,E=b.length;T<E;++T){let A=b[T],D=A.start,O=A.count;for(let P=D,L=D+O;P<L;P+=3)v(n[P+0],n[P+1],n[P+2])}let x=new I,w=new I,S=new I,C=new I;function _(T){S.fromArray(r,T*3),C.copy(S);let E=l[T];x.copy(E),x.sub(S.multiplyScalar(S.dot(E))).normalize(),w.crossVectors(C,E);let A=w.dot(c[T])<0?-1:1;a[T*4]=x.x,a[T*4+1]=x.y,a[T*4+2]=x.z,a[T*4+3]=A}for(let T=0,E=b.length;T<E;++T){let A=b[T],D=A.start,O=A.count;for(let P=D,L=D+O;P<L;P+=3)_(n[P+0]),_(n[P+1]),_(n[P+2])}}computeVertexNormals(){let e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new Lt(new Float32Array(t.count*3),3),this.setAttribute("normal",n);else for(let u=0,d=n.count;u<d;u++)n.setXYZ(u,0,0,0);let s=new I,r=new I,i=new I,o=new I,a=new I,l=new I,c=new I,h=new I;if(e)for(let u=0,d=e.count;u<d;u+=3){let p=e.getX(u+0),f=e.getX(u+1),g=e.getX(u+2);s.fromBufferAttribute(t,p),r.fromBufferAttribute(t,f),i.fromBufferAttribute(t,g),c.subVectors(i,r),h.subVectors(s,r),c.cross(h),o.fromBufferAttribute(n,p),a.fromBufferAttribute(n,f),l.fromBufferAttribute(n,g),o.add(c),a.add(c),l.add(c),n.setXYZ(p,o.x,o.y,o.z),n.setXYZ(f,a.x,a.y,a.z),n.setXYZ(g,l.x,l.y,l.z)}else for(let u=0,d=t.count;u<d;u+=3)s.fromBufferAttribute(t,u+0),r.fromBufferAttribute(t,u+1),i.fromBufferAttribute(t,u+2),c.subVectors(i,r),h.subVectors(s,r),c.cross(h),n.setXYZ(u+0,c.x,c.y,c.z),n.setXYZ(u+1,c.x,c.y,c.z),n.setXYZ(u+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(e,t){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));let n=this.attributes;for(let s in n){if(e.attributes[s]===void 0)continue;let r=n[s].array,i=e.attributes[s],o=i.array,a=i.itemSize*t,l=Math.min(o.length,r.length-a);for(let c=0,h=a;c<l;c++,h++)r[h]=o[c]}return this}normalizeNormals(){let e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)qs.fromBufferAttribute(e,t),qs.normalize(),e.setXYZ(t,qs.x,qs.y,qs.z)}toNonIndexed(){function e(o,a){let l=o.array,c=o.itemSize,h=o.normalized,u=new l.constructor(a.length*c),d=0,p=0;for(let f=0,g=a.length;f<g;f++){o.isInterleavedBufferAttribute?d=a[f]*o.data.stride+o.offset:d=a[f]*c;for(let m=0;m<c;m++)u[p++]=l[d++]}return new Lt(u,c,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;let t=new It,n=this.index.array,s=this.attributes;for(let o in s){let a=s[o],l=e(a,n);t.setAttribute(o,l)}let r=this.morphAttributes;for(let o in r){let a=[],l=r[o];for(let c=0,h=l.length;c<h;c++){let u=l[c],d=e(u,n);a.push(d)}t.morphAttributes[o]=a}t.morphTargetsRelative=this.morphTargetsRelative;let i=this.groups;for(let o=0,a=i.length;o<a;o++){let l=i[o];t.addGroup(l.start,l.count,l.materialIndex)}return t}toJSON(){let e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){let a=this.parameters;for(let l in a)a[l]!==void 0&&(e[l]=a[l]);return e}e.data={attributes:{}};let t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});let n=this.attributes;for(let a in n){let l=n[a];e.data.attributes[a]=l.toJSON(e.data)}let s={},r=!1;for(let a in this.morphAttributes){let l=this.morphAttributes[a],c=[];for(let h=0,u=l.length;h<u;h++){let d=l[h];c.push(d.toJSON(e.data))}c.length>0&&(s[a]=c,r=!0)}r&&(e.data.morphAttributes=s,e.data.morphTargetsRelative=this.morphTargetsRelative);let i=this.groups;i.length>0&&(e.data.groups=JSON.parse(JSON.stringify(i)));let o=this.boundingSphere;return o!==null&&(e.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;let t={};this.name=e.name;let n=e.index;n!==null&&this.setIndex(n.clone(t));let s=e.attributes;for(let l in s){let c=s[l];this.setAttribute(l,c.clone(t))}let r=e.morphAttributes;for(let l in r){let c=[],h=r[l];for(let u=0,d=h.length;u<d;u++)c.push(h[u].clone(t));this.morphAttributes[l]=c}this.morphTargetsRelative=e.morphTargetsRelative;let i=e.groups;for(let l=0,c=i.length;l<c;l++){let h=i[l];this.addGroup(h.start,h.count,h.materialIndex)}let o=e.boundingBox;o!==null&&(this.boundingBox=o.clone());let a=e.boundingSphere;return a!==null&&(this.boundingSphere=a.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,e.parameters!==void 0&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}},yD=new et,ad=new td,vS=new Wi,Jl=new I,ec=new I,tc=new I,xS=new I,bS=new I,wS=new I,fy=new I,my=new I,gy=new I,yy=new se,vy=new se,xy=new se,SS=new I,by=new I,bi=class extends Ln{constructor(e=new It,t=new Rf){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){let e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){let n=e[t[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,r=n.length;s<r;s++){let i=n[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=s}}}}raycast(e,t){let n=this.geometry,s=this.material,r=this.matrixWorld;if(s===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),vS.copy(n.boundingSphere),vS.applyMatrix4(r),e.ray.intersectsSphere(vS)===!1)||(yD.copy(r).invert(),ad.copy(e.ray).applyMatrix4(yD),n.boundingBox!==null&&ad.intersectsBox(n.boundingBox)===!1))return;let i,o=n.index,a=n.attributes.position,l=n.morphAttributes.position,c=n.morphTargetsRelative,h=n.attributes.uv,u=n.attributes.uv2,d=n.groups,p=n.drawRange;if(o!==null)if(Array.isArray(s))for(let f=0,g=d.length;f<g;f++){let m=d[f],y=s[m.materialIndex],v=Math.max(m.start,p.start),b=Math.min(o.count,Math.min(m.start+m.count,p.start+p.count));for(let x=v,w=b;x<w;x+=3){let S=o.getX(x),C=o.getX(x+1),_=o.getX(x+2);i=wy(this,y,e,ad,a,l,c,h,u,S,C,_),i&&(i.faceIndex=Math.floor(x/3),i.face.materialIndex=m.materialIndex,t.push(i))}}else{let f=Math.max(0,p.start),g=Math.min(o.count,p.start+p.count);for(let m=f,y=g;m<y;m+=3){let v=o.getX(m),b=o.getX(m+1),x=o.getX(m+2);i=wy(this,s,e,ad,a,l,c,h,u,v,b,x),i&&(i.faceIndex=Math.floor(m/3),t.push(i))}}else if(a!==void 0)if(Array.isArray(s))for(let f=0,g=d.length;f<g;f++){let m=d[f],y=s[m.materialIndex],v=Math.max(m.start,p.start),b=Math.min(a.count,Math.min(m.start+m.count,p.start+p.count));for(let x=v,w=b;x<w;x+=3){let S=x,C=x+1,_=x+2;i=wy(this,y,e,ad,a,l,c,h,u,S,C,_),i&&(i.faceIndex=Math.floor(x/3),i.face.materialIndex=m.materialIndex,t.push(i))}}else{let f=Math.max(0,p.start),g=Math.min(a.count,p.start+p.count);for(let m=f,y=g;m<y;m+=3){let v=m,b=m+1,x=m+2;i=wy(this,s,e,ad,a,l,c,h,u,v,b,x),i&&(i.faceIndex=Math.floor(m/3),t.push(i))}}}};function V8(e,t,n,s,r,i,o,a){let l;if(t.side===dr?l=s.intersectTriangle(o,i,r,!0,a):l=s.intersectTriangle(r,i,o,t.side!==Ao,a),l===null)return null;by.copy(a),by.applyMatrix4(e.matrixWorld);let c=n.ray.origin.distanceTo(by);return c<n.near||c>n.far?null:{distance:c,point:by.clone(),object:e}}function wy(e,t,n,s,r,i,o,a,l,c,h,u){Jl.fromBufferAttribute(r,c),ec.fromBufferAttribute(r,h),tc.fromBufferAttribute(r,u);let d=e.morphTargetInfluences;if(i&&d){fy.set(0,0,0),my.set(0,0,0),gy.set(0,0,0);for(let f=0,g=i.length;f<g;f++){let m=d[f],y=i[f];m!==0&&(xS.fromBufferAttribute(y,c),bS.fromBufferAttribute(y,h),wS.fromBufferAttribute(y,u),o?(fy.addScaledVector(xS,m),my.addScaledVector(bS,m),gy.addScaledVector(wS,m)):(fy.addScaledVector(xS.sub(Jl),m),my.addScaledVector(bS.sub(ec),m),gy.addScaledVector(wS.sub(tc),m)))}Jl.add(fy),ec.add(my),tc.add(gy)}e.isSkinnedMesh&&(e.boneTransform(c,Jl),e.boneTransform(h,ec),e.boneTransform(u,tc));let p=V8(e,t,n,s,Jl,ec,tc,SS);if(p){a&&(yy.fromBufferAttribute(a,c),vy.fromBufferAttribute(a,h),xy.fromBufferAttribute(a,u),p.uv=Jr.getUV(SS,Jl,ec,tc,yy,vy,xy,new se)),l&&(yy.fromBufferAttribute(l,c),vy.fromBufferAttribute(l,h),xy.fromBufferAttribute(l,u),p.uv2=Jr.getUV(SS,Jl,ec,tc,yy,vy,xy,new se));let f={a:c,b:h,c:u,normal:new I,materialIndex:0};Jr.getNormal(Jl,ec,tc,f.normal),p.face=f}return p}var pa=class extends It{constructor(e=1,t=1,n=1,s=1,r=1,i=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:s,heightSegments:r,depthSegments:i};let o=this;s=Math.floor(s),r=Math.floor(r),i=Math.floor(i);let a=[],l=[],c=[],h=[],u=0,d=0;p("z","y","x",-1,-1,n,t,e,i,r,0),p("z","y","x",1,-1,n,t,-e,i,r,1),p("x","z","y",1,1,e,n,t,s,i,2),p("x","z","y",1,-1,e,n,-t,s,i,3),p("x","y","z",1,-1,e,t,n,s,r,4),p("x","y","z",-1,-1,e,t,-n,s,r,5),this.setIndex(a),this.setAttribute("position",new ot(l,3)),this.setAttribute("normal",new ot(c,3)),this.setAttribute("uv",new ot(h,2));function p(f,g,m,y,v,b,x,w,S,C,_){let T=b/S,E=x/C,A=b/2,D=x/2,O=w/2,P=S+1,L=C+1,B=0,F=0,M=new I;for(let U=0;U<L;U++){let z=U*E-D;for(let $=0;$<P;$++){let R=$*T-A;M[f]=R*y,M[g]=z*v,M[m]=O,l.push(M.x,M.y,M.z),M[f]=0,M[g]=0,M[m]=w>0?1:-1,c.push(M.x,M.y,M.z),h.push($/S),h.push(1-U/C),B+=1}}for(let U=0;U<C;U++)for(let z=0;z<S;z++){let $=u+z+P*U,R=u+z+P*(U+1),H=u+(z+1)+P*(U+1),K=u+(z+1)+P*U;a.push($,R,K),a.push(R,H,K),F+=6}o.addGroup(d,F,_),d+=F,u+=B}}static fromJSON(e){return new pa(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}};function ld(e){let t={};for(let n in e){t[n]={};for(let s in e[n]){let r=e[n][s];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?t[n][s]=r.clone():Array.isArray(r)?t[n][s]=r.slice():t[n][s]=r}}return t}function yr(e){let t={};for(let n=0;n<e.length;n++){let s=ld(e[n]);for(let r in s)t[r]=s[r]}return t}var cd={clone:ld,merge:yr},G8=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,W8=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,Ms=class extends Of{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=G8,this.fragmentShader=W8,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=ld(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){let t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(let s in this.uniforms){let r=this.uniforms[s].value;r&&r.isTexture?t.uniforms[s]={type:"t",value:r.toJSON(e).uuid}:r&&r.isColor?t.uniforms[s]={type:"c",value:r.getHex()}:r&&r.isVector2?t.uniforms[s]={type:"v2",value:r.toArray()}:r&&r.isVector3?t.uniforms[s]={type:"v3",value:r.toArray()}:r&&r.isVector4?t.uniforms[s]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?t.uniforms[s]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?t.uniforms[s]={type:"m4",value:r.toArray()}:t.uniforms[s]={value:r}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;let n={};for(let s in this.extensions)this.extensions[s]===!0&&(n[s]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}},ud=class extends Ln{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new et,this.projectionMatrix=new et,this.projectionMatrixInverse=new et}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);let t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}},vr=class extends ud{constructor(e=50,t=1,n=.1,s=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=s,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){let t=.5*this.getFilmHeight()/e;this.fov=kf*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){let e=Math.tan(Nf*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return kf*2*Math.atan(Math.tan(Nf*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,s,r,i){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=s,this.view.width=r,this.view.height=i,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){let e=this.near,t=e*Math.tan(Nf*.5*this.fov)/this.zoom,n=2*t,s=this.aspect*n,r=-.5*s,i=this.view;if(this.view!==null&&this.view.enabled){let a=i.fullWidth,l=i.fullHeight;r+=i.offsetX*s/a,t-=i.offsetY*n/l,s*=i.width/a,n*=i.height/l}let o=this.filmOffset;o!==0&&(r+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+s,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){let t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}},hd=90,dd=1,H8=class extends Ln{constructor(e,t,n){if(super(),this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;let s=new vr(hd,dd,e,t);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new I(1,0,0)),this.add(s);let r=new vr(hd,dd,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new I(-1,0,0)),this.add(r);let i=new vr(hd,dd,e,t);i.layers=this.layers,i.up.set(0,0,1),i.lookAt(new I(0,1,0)),this.add(i);let o=new vr(hd,dd,e,t);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new I(0,-1,0)),this.add(o);let a=new vr(hd,dd,e,t);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new I(0,0,1)),this.add(a);let l=new vr(hd,dd,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new I(0,0,-1)),this.add(l)}update(e,t){this.parent===null&&this.updateMatrixWorld();let n=this.renderTarget,[s,r,i,o,a,l]=this.children,c=e.getRenderTarget(),h=e.toneMapping,u=e.xr.enabled;e.toneMapping=ll,e.xr.enabled=!1;let d=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,s),e.setRenderTarget(n,1),e.render(t,r),e.setRenderTarget(n,2),e.render(t,i),e.setRenderTarget(n,3),e.render(t,o),e.setRenderTarget(n,4),e.render(t,a),n.texture.generateMipmaps=d,e.setRenderTarget(n,5),e.render(t,l),e.setRenderTarget(c),e.toneMapping=h,e.xr.enabled=u,n.texture.needsPMREMUpdate=!0}},_S=class extends mr{constructor(e,t,n,s,r,i,o,a,l,c){e=e!==void 0?e:[],t=t!==void 0?t:hu,super(e,t,n,s,r,i,o,a,l,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}},j8=class extends hs{constructor(e,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;let n={width:e,height:e,depth:1},s=[n,n,n,n,n,n];this.texture=new _S(s,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:xn}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;let n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},s=new pa(5,5,5),r=new Ms({name:"CubemapFromEquirect",uniforms:ld(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:dr,blending:nr});r.uniforms.tEquirect.value=t;let i=new bi(s,r),o=t.minFilter;return t.minFilter===Af&&(t.minFilter=xn),new H8(1,10,this).update(e,i),t.minFilter=o,i.geometry.dispose(),i.material.dispose(),this}clear(e,t,n,s){let r=e.getRenderTarget();for(let i=0;i<6;i++)e.setRenderTarget(this,i),e.clear(t,n,s);e.setRenderTarget(r)}},CS=new I,q8=new I,X8=new Or,ji=class{constructor(e=new I(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,s){return this.normal.set(e,t,n),this.constant=s,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){let s=CS.subVectors(n,t).cross(q8.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(s,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){let e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){let n=e.delta(CS),s=this.normal.dot(n);if(s===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;let r=-(e.start.dot(this.normal)+this.constant)/s;return r<0||r>1?null:t.copy(n).multiplyScalar(r).add(e.start)}intersectsLine(e){let t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){let n=t||X8.getNormalMatrix(e),s=this.coplanarPoint(CS).applyMatrix4(e),r=this.normal.applyMatrix3(n).normalize();return this.constant=-s.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}},pd=new Wi,Sy=new I,TS=class{constructor(e=new ji,t=new ji,n=new ji,s=new ji,r=new ji,i=new ji){this.planes=[e,t,n,s,r,i]}set(e,t,n,s,r,i){let o=this.planes;return o[0].copy(e),o[1].copy(t),o[2].copy(n),o[3].copy(s),o[4].copy(r),o[5].copy(i),this}copy(e){let t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){let t=this.planes,n=e.elements,s=n[0],r=n[1],i=n[2],o=n[3],a=n[4],l=n[5],c=n[6],h=n[7],u=n[8],d=n[9],p=n[10],f=n[11],g=n[12],m=n[13],y=n[14],v=n[15];return t[0].setComponents(o-s,h-a,f-u,v-g).normalize(),t[1].setComponents(o+s,h+a,f+u,v+g).normalize(),t[2].setComponents(o+r,h+l,f+d,v+m).normalize(),t[3].setComponents(o-r,h-l,f-d,v-m).normalize(),t[4].setComponents(o-i,h-c,f-p,v-y).normalize(),t[5].setComponents(o+i,h+c,f+p,v+y).normalize(),this}intersectsObject(e){let t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),pd.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(pd)}intersectsSprite(e){return pd.center.set(0,0,0),pd.radius=.7071067811865476,pd.applyMatrix4(e.matrixWorld),this.intersectsSphere(pd)}intersectsSphere(e){let t=this.planes,n=e.center,s=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(n)<s)return!1;return!0}intersectsBox(e){let t=this.planes;for(let n=0;n<6;n++){let s=t[n];if(Sy.x=s.normal.x>0?e.max.x:e.min.x,Sy.y=s.normal.y>0?e.max.y:e.min.y,Sy.z=s.normal.z>0?e.max.z:e.min.z,s.distanceToPoint(Sy)<0)return!1}return!0}containsPoint(e){let t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}};function vD(){let e=null,t=!1,n=null,s=null;function r(i,o){n(i,o),s=e.requestAnimationFrame(r)}return{start:function(){t!==!0&&n!==null&&(s=e.requestAnimationFrame(r),t=!0)},stop:function(){e.cancelAnimationFrame(s),t=!1},setAnimationLoop:function(i){n=i},setContext:function(i){e=i}}}function K8(e,t){let n=t.isWebGL2,s=new WeakMap;function r(c,h){let u=c.array,d=c.usage,p=e.createBuffer();e.bindBuffer(h,p),e.bufferData(h,u,d),c.onUploadCallback();let f;if(u instanceof Float32Array)f=5126;else if(u instanceof Uint16Array)if(c.isFloat16BufferAttribute)if(n)f=5131;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else f=5123;else if(u instanceof Int16Array)f=5122;else if(u instanceof Uint32Array)f=5125;else if(u instanceof Int32Array)f=5124;else if(u instanceof Int8Array)f=5120;else if(u instanceof Uint8Array)f=5121;else if(u instanceof Uint8ClampedArray)f=5121;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+u);return{buffer:p,type:f,bytesPerElement:u.BYTES_PER_ELEMENT,version:c.version}}function i(c,h,u){let d=h.array,p=h.updateRange;e.bindBuffer(u,c),p.count===-1?e.bufferSubData(u,0,d):(n?e.bufferSubData(u,p.offset*d.BYTES_PER_ELEMENT,d,p.offset,p.count):e.bufferSubData(u,p.offset*d.BYTES_PER_ELEMENT,d.subarray(p.offset,p.offset+p.count)),p.count=-1)}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),s.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);let h=s.get(c);h&&(e.deleteBuffer(h.buffer),s.delete(c))}function l(c,h){if(c.isGLBufferAttribute){let d=s.get(c);(!d||d.version<c.version)&&s.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);let u=s.get(c);u===void 0?s.set(c,r(c,h)):u.version<c.version&&(i(u.buffer,c,h),u.version=c.version)}return{get:o,remove:a,update:l}}var _y=class extends It{constructor(e=1,t=1,n=1,s=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:s};let r=e/2,i=t/2,o=Math.floor(n),a=Math.floor(s),l=o+1,c=a+1,h=e/o,u=t/a,d=[],p=[],f=[],g=[];for(let m=0;m<c;m++){let y=m*u-i;for(let v=0;v<l;v++){let b=v*h-r;p.push(b,-y,0),f.push(0,0,1),g.push(v/o),g.push(1-m/a)}}for(let m=0;m<a;m++)for(let y=0;y<o;y++){let v=y+l*m,b=y+l*(m+1),x=y+1+l*(m+1),w=y+1+l*m;d.push(v,b,w),d.push(b,x,w)}this.setIndex(d),this.setAttribute("position",new ot(p,3)),this.setAttribute("normal",new ot(f,3)),this.setAttribute("uv",new ot(g,2))}static fromJSON(e){return new _y(e.width,e.height,e.widthSegments,e.heightSegments)}},Y8=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,Q8=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Z8=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,J8=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,eq=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,tq=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,nq="vec3 transformed = vec3( position );",sq=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,rq=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,iq=`#ifdef USE_IRIDESCENCE
const mat3 XYZ_TO_REC709 = mat3(
    3.2404542, -0.9692660,  0.0556434,
   -1.5371385,  1.8760108, -0.2040259,
   -0.4985314,  0.0415560,  1.0572252
);
vec3 Fresnel0ToIor( vec3 fresnel0 ) {
   vec3 sqrtF0 = sqrt( fresnel0 );
   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
}
vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
}
float IorToFresnel0( float transmittedIor, float incidentIor ) {
   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
}
vec3 evalSensitivity( float OPD, vec3 shift ) {
   float phase = 2.0 * PI * OPD * 1.0e-9;
   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );
   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );
   xyz /= 1.0685e-7;
   vec3 srgb = XYZ_TO_REC709 * xyz;
   return srgb;
}
vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
   vec3 I;
   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
   float cosTheta2Sq = 1.0 - sinTheta2Sq;
   if ( cosTheta2Sq < 0.0 ) {
       return vec3( 1.0 );
   }
   float cosTheta2 = sqrt( cosTheta2Sq );
   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
   float R12 = F_Schlick( R0, 1.0, cosTheta1 );
   float R21 = R12;
   float T121 = 1.0 - R12;
   float phi12 = 0.0;
   if ( iridescenceIOR < outsideIOR ) phi12 = PI;
   float phi21 = PI - phi12;
   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
   vec3 phi23 = vec3( 0.0 );
   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;
   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;
   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;
   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
   vec3 phi = vec3( phi21 ) + phi23;
   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
   vec3 r123 = sqrt( R123 );
   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
   vec3 C0 = R12 + Rs;
   I = C0;
   vec3 Cm = Rs - T121;
   for ( int m = 1; m <= 2; ++m ) {
       Cm *= r123;
       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
       I += Cm * Sm;
   }
   return max( I, vec3( 0.0 ) );
}
#endif`,oq=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,aq=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,lq=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,cq=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,uq=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,hq=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,dq=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,pq=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,fq=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,mq=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,gq=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,yq=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,vq=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,xq=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,bq=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,wq=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Sq="gl_FragColor = linearToOutputTexel( gl_FragColor );",_q=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,Cq=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Tq=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Eq=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Aq=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Iq=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Nq=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,kq=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Dq=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Mq=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Pq=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,Oq=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,Rq=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Lq=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,Fq=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,$q=`#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,Bq=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,zq=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,Uq=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,Vq=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,Gq=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,Wq=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,Hq=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
float dotNVi = saturate( dot( normal, geometry.viewDir ) );
if ( material.iridescenceThickness == 0.0 ) {
	material.iridescence = 0.0;
} else {
	material.iridescence = saturate( material.iridescence );
}
if ( material.iridescence > 0.0 ) {
	material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
	material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,jq=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,qq=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,Xq=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,Kq=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Yq=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,Qq=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,Zq=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,Jq=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,e7=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,t7=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,n7=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,s7=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,r7=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,i7=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,o7=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,a7=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,l7=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,c7=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,u7=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,h7=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,d7=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,p7=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,f7=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,m7=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,g7=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,y7=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,v7=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,x7=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,b7=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,w7=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,S7=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,_7=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,C7=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,T7=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,E7=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,A7=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,I7=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,N7=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,k7=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,D7=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,M7=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,P7=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,O7=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,R7=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,L7=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,F7=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,$7=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,B7=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,z7=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,U7=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,V7=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,G7=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,W7=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,H7=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,j7=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,q7=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,X7=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,K7=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Y7=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Q7=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,Z7=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,J7=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,e9=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,t9=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,n9=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,s9=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,r9=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,i9=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,o9=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,a9=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,l9=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,c9=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,u9=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,h9=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,d9=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,p9=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,f9=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,m9=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,g9=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,y9=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,v9=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,x9=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,b9=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,w9=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,S9=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,_9=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,C9=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,zt={alphamap_fragment:Y8,alphamap_pars_fragment:Q8,alphatest_fragment:Z8,alphatest_pars_fragment:J8,aomap_fragment:eq,aomap_pars_fragment:tq,begin_vertex:nq,beginnormal_vertex:sq,bsdfs:rq,iridescence_fragment:iq,bumpmap_pars_fragment:oq,clipping_planes_fragment:aq,clipping_planes_pars_fragment:lq,clipping_planes_pars_vertex:cq,clipping_planes_vertex:uq,color_fragment:hq,color_pars_fragment:dq,color_pars_vertex:pq,color_vertex:fq,common:mq,cube_uv_reflection_fragment:gq,defaultnormal_vertex:yq,displacementmap_pars_vertex:vq,displacementmap_vertex:xq,emissivemap_fragment:bq,emissivemap_pars_fragment:wq,encodings_fragment:Sq,encodings_pars_fragment:_q,envmap_fragment:Cq,envmap_common_pars_fragment:Tq,envmap_pars_fragment:Eq,envmap_pars_vertex:Aq,envmap_physical_pars_fragment:$q,envmap_vertex:Iq,fog_vertex:Nq,fog_pars_vertex:kq,fog_fragment:Dq,fog_pars_fragment:Mq,gradientmap_pars_fragment:Pq,lightmap_fragment:Oq,lightmap_pars_fragment:Rq,lights_lambert_vertex:Lq,lights_pars_begin:Fq,lights_toon_fragment:Bq,lights_toon_pars_fragment:zq,lights_phong_fragment:Uq,lights_phong_pars_fragment:Vq,lights_physical_fragment:Gq,lights_physical_pars_fragment:Wq,lights_fragment_begin:Hq,lights_fragment_maps:jq,lights_fragment_end:qq,logdepthbuf_fragment:Xq,logdepthbuf_pars_fragment:Kq,logdepthbuf_pars_vertex:Yq,logdepthbuf_vertex:Qq,map_fragment:Zq,map_pars_fragment:Jq,map_particle_fragment:e7,map_particle_pars_fragment:t7,metalnessmap_fragment:n7,metalnessmap_pars_fragment:s7,morphcolor_vertex:r7,morphnormal_vertex:i7,morphtarget_pars_vertex:o7,morphtarget_vertex:a7,normal_fragment_begin:l7,normal_fragment_maps:c7,normal_pars_fragment:u7,normal_pars_vertex:h7,normal_vertex:d7,normalmap_pars_fragment:p7,clearcoat_normal_fragment_begin:f7,clearcoat_normal_fragment_maps:m7,clearcoat_pars_fragment:g7,iridescence_pars_fragment:y7,output_fragment:v7,packing:x7,premultiplied_alpha_fragment:b7,project_vertex:w7,dithering_fragment:S7,dithering_pars_fragment:_7,roughnessmap_fragment:C7,roughnessmap_pars_fragment:T7,shadowmap_pars_fragment:E7,shadowmap_pars_vertex:A7,shadowmap_vertex:I7,shadowmask_pars_fragment:N7,skinbase_vertex:k7,skinning_pars_vertex:D7,skinning_vertex:M7,skinnormal_vertex:P7,specularmap_fragment:O7,specularmap_pars_fragment:R7,tonemapping_fragment:L7,tonemapping_pars_fragment:F7,transmission_fragment:$7,transmission_pars_fragment:B7,uv_pars_fragment:z7,uv_pars_vertex:U7,uv_vertex:V7,uv2_pars_fragment:G7,uv2_pars_vertex:W7,uv2_vertex:H7,worldpos_vertex:j7,background_vert:q7,background_frag:X7,cube_vert:K7,cube_frag:Y7,depth_vert:Q7,depth_frag:Z7,distanceRGBA_vert:J7,distanceRGBA_frag:e9,equirect_vert:t9,equirect_frag:n9,linedashed_vert:s9,linedashed_frag:r9,meshbasic_vert:i9,meshbasic_frag:o9,meshlambert_vert:a9,meshlambert_frag:l9,meshmatcap_vert:c9,meshmatcap_frag:u9,meshnormal_vert:h9,meshnormal_frag:d9,meshphong_vert:p9,meshphong_frag:f9,meshphysical_vert:m9,meshphysical_frag:g9,meshtoon_vert:y9,meshtoon_frag:v9,points_vert:x9,points_frag:b9,shadow_vert:w9,shadow_frag:S9,sprite_vert:_9,sprite_frag:C9},Ye={common:{diffuse:{value:new _t(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Or},uv2Transform:{value:new Or},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new se(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new _t(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new _t(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Or}},sprite:{diffuse:{value:new _t(16777215)},opacity:{value:1},center:{value:new se(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Or}}},fa={basic:{uniforms:yr([Ye.common,Ye.specularmap,Ye.envmap,Ye.aomap,Ye.lightmap,Ye.fog]),vertexShader:zt.meshbasic_vert,fragmentShader:zt.meshbasic_frag},lambert:{uniforms:yr([Ye.common,Ye.specularmap,Ye.envmap,Ye.aomap,Ye.lightmap,Ye.emissivemap,Ye.fog,Ye.lights,{emissive:{value:new _t(0)}}]),vertexShader:zt.meshlambert_vert,fragmentShader:zt.meshlambert_frag},phong:{uniforms:yr([Ye.common,Ye.specularmap,Ye.envmap,Ye.aomap,Ye.lightmap,Ye.emissivemap,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,Ye.fog,Ye.lights,{emissive:{value:new _t(0)},specular:{value:new _t(1118481)},shininess:{value:30}}]),vertexShader:zt.meshphong_vert,fragmentShader:zt.meshphong_frag},standard:{uniforms:yr([Ye.common,Ye.envmap,Ye.aomap,Ye.lightmap,Ye.emissivemap,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,Ye.roughnessmap,Ye.metalnessmap,Ye.fog,Ye.lights,{emissive:{value:new _t(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:zt.meshphysical_vert,fragmentShader:zt.meshphysical_frag},toon:{uniforms:yr([Ye.common,Ye.aomap,Ye.lightmap,Ye.emissivemap,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,Ye.gradientmap,Ye.fog,Ye.lights,{emissive:{value:new _t(0)}}]),vertexShader:zt.meshtoon_vert,fragmentShader:zt.meshtoon_frag},matcap:{uniforms:yr([Ye.common,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,Ye.fog,{matcap:{value:null}}]),vertexShader:zt.meshmatcap_vert,fragmentShader:zt.meshmatcap_frag},points:{uniforms:yr([Ye.points,Ye.fog]),vertexShader:zt.points_vert,fragmentShader:zt.points_frag},dashed:{uniforms:yr([Ye.common,Ye.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:zt.linedashed_vert,fragmentShader:zt.linedashed_frag},depth:{uniforms:yr([Ye.common,Ye.displacementmap]),vertexShader:zt.depth_vert,fragmentShader:zt.depth_frag},normal:{uniforms:yr([Ye.common,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,{opacity:{value:1}}]),vertexShader:zt.meshnormal_vert,fragmentShader:zt.meshnormal_frag},sprite:{uniforms:yr([Ye.sprite,Ye.fog]),vertexShader:zt.sprite_vert,fragmentShader:zt.sprite_frag},background:{uniforms:{uvTransform:{value:new Or},t2D:{value:null}},vertexShader:zt.background_vert,fragmentShader:zt.background_frag},cube:{uniforms:yr([Ye.envmap,{opacity:{value:1}}]),vertexShader:zt.cube_vert,fragmentShader:zt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:zt.equirect_vert,fragmentShader:zt.equirect_frag},distanceRGBA:{uniforms:yr([Ye.common,Ye.displacementmap,{referencePosition:{value:new I},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:zt.distanceRGBA_vert,fragmentShader:zt.distanceRGBA_frag},shadow:{uniforms:yr([Ye.lights,Ye.fog,{color:{value:new _t(0)},opacity:{value:1}}]),vertexShader:zt.shadow_vert,fragmentShader:zt.shadow_frag}};fa.physical={uniforms:yr([fa.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new se(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new _t(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new se},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new _t(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new _t(1,1,1)},specularColorMap:{value:null}}]),vertexShader:zt.meshphysical_vert,fragmentShader:zt.meshphysical_frag};function T9(e,t,n,s,r,i){let o=new _t(0),a=r===!0?0:1,l,c,h=null,u=0,d=null;function p(g,m){let y=!1,v=m.isScene===!0?m.background:null;v&&v.isTexture&&(v=t.get(v));let b=e.xr,x=b.getSession&&b.getSession();x&&x.environmentBlendMode==="additive"&&(v=null),v===null?f(o,a):v&&v.isColor&&(f(v,1),y=!0),(e.autoClear||y)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),v&&(v.isCubeTexture||v.mapping===Tf)?(c===void 0&&(c=new bi(new pa(1,1,1),new Ms({name:"BackgroundCubeMaterial",uniforms:ld(fa.cube.uniforms),vertexShader:fa.cube.vertexShader,fragmentShader:fa.cube.fragmentShader,side:dr,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(w,S,C){this.matrixWorld.copyPosition(C.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),s.update(c)),c.material.uniforms.envMap.value=v,c.material.uniforms.flipEnvMap.value=v.isCubeTexture&&v.isRenderTargetTexture===!1?-1:1,(h!==v||u!==v.version||d!==e.toneMapping)&&(c.material.needsUpdate=!0,h=v,u=v.version,d=e.toneMapping),c.layers.enableAll(),g.unshift(c,c.geometry,c.material,0,0,null)):v&&v.isTexture&&(l===void 0&&(l=new bi(new _y(2,2),new Ms({name:"BackgroundMaterial",uniforms:ld(fa.background.uniforms),vertexShader:fa.background.vertexShader,fragmentShader:fa.background.fragmentShader,side:jl,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),s.update(l)),l.material.uniforms.t2D.value=v,v.matrixAutoUpdate===!0&&v.updateMatrix(),l.material.uniforms.uvTransform.value.copy(v.matrix),(h!==v||u!==v.version||d!==e.toneMapping)&&(l.material.needsUpdate=!0,h=v,u=v.version,d=e.toneMapping),l.layers.enableAll(),g.unshift(l,l.geometry,l.material,0,0,null))}function f(g,m){n.buffers.color.setClear(g.r,g.g,g.b,m,i)}return{getClearColor:function(){return o},setClearColor:function(g,m=1){o.set(g),a=m,f(o,a)},getClearAlpha:function(){return a},setClearAlpha:function(g){a=g,f(o,a)},render:p}}function E9(e,t,n,s){let r=e.getParameter(34921),i=s.isWebGL2?null:t.get("OES_vertex_array_object"),o=s.isWebGL2||i!==null,a={},l=m(null),c=l,h=!1;function u(P,L,B,F,M){let U=!1;if(o){let z=g(F,B,L);c!==z&&(c=z,p(c.object)),U=y(P,F,B,M),U&&v(P,F,B,M)}else{let z=L.wireframe===!0;(c.geometry!==F.id||c.program!==B.id||c.wireframe!==z)&&(c.geometry=F.id,c.program=B.id,c.wireframe=z,U=!0)}M!==null&&n.update(M,34963),(U||h)&&(h=!1,_(P,L,B,F),M!==null&&e.bindBuffer(34963,n.get(M).buffer))}function d(){return s.isWebGL2?e.createVertexArray():i.createVertexArrayOES()}function p(P){return s.isWebGL2?e.bindVertexArray(P):i.bindVertexArrayOES(P)}function f(P){return s.isWebGL2?e.deleteVertexArray(P):i.deleteVertexArrayOES(P)}function g(P,L,B){let F=B.wireframe===!0,M=a[P.id];M===void 0&&(M={},a[P.id]=M);let U=M[L.id];U===void 0&&(U={},M[L.id]=U);let z=U[F];return z===void 0&&(z=m(d()),U[F]=z),z}function m(P){let L=[],B=[],F=[];for(let M=0;M<r;M++)L[M]=0,B[M]=0,F[M]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:L,enabledAttributes:B,attributeDivisors:F,object:P,attributes:{},index:null}}function y(P,L,B,F){let M=c.attributes,U=L.attributes,z=0,$=B.getAttributes();for(let R in $)if($[R].location>=0){let H=M[R],K=U[R];if(K===void 0&&(R==="instanceMatrix"&&P.instanceMatrix&&(K=P.instanceMatrix),R==="instanceColor"&&P.instanceColor&&(K=P.instanceColor)),H===void 0||H.attribute!==K||K&&H.data!==K.data)return!0;z++}return c.attributesNum!==z||c.index!==F}function v(P,L,B,F){let M={},U=L.attributes,z=0,$=B.getAttributes();for(let R in $)if($[R].location>=0){let H=U[R];H===void 0&&(R==="instanceMatrix"&&P.instanceMatrix&&(H=P.instanceMatrix),R==="instanceColor"&&P.instanceColor&&(H=P.instanceColor));let K={};K.attribute=H,H&&H.data&&(K.data=H.data),M[R]=K,z++}c.attributes=M,c.attributesNum=z,c.index=F}function b(){let P=c.newAttributes;for(let L=0,B=P.length;L<B;L++)P[L]=0}function x(P){w(P,0)}function w(P,L){let B=c.newAttributes,F=c.enabledAttributes,M=c.attributeDivisors;B[P]=1,F[P]===0&&(e.enableVertexAttribArray(P),F[P]=1),M[P]!==L&&((s.isWebGL2?e:t.get("ANGLE_instanced_arrays"))[s.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](P,L),M[P]=L)}function S(){let P=c.newAttributes,L=c.enabledAttributes;for(let B=0,F=L.length;B<F;B++)L[B]!==P[B]&&(e.disableVertexAttribArray(B),L[B]=0)}function C(P,L,B,F,M,U){s.isWebGL2===!0&&(B===5124||B===5125)?e.vertexAttribIPointer(P,L,B,M,U):e.vertexAttribPointer(P,L,B,F,M,U)}function _(P,L,B,F){if(s.isWebGL2===!1&&(P.isInstancedMesh||F.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;b();let M=F.attributes,U=B.getAttributes(),z=L.defaultAttributeValues;for(let $ in U){let R=U[$];if(R.location>=0){let H=M[$];if(H===void 0&&($==="instanceMatrix"&&P.instanceMatrix&&(H=P.instanceMatrix),$==="instanceColor"&&P.instanceColor&&(H=P.instanceColor)),H!==void 0){let K=H.normalized,Y=H.itemSize,X=n.get(H);if(X===void 0)continue;let oe=X.buffer,ie=X.type,Z=X.bytesPerElement;if(H.isInterleavedBufferAttribute){let ce=H.data,ge=ce.stride,_e=H.offset;if(ce.isInstancedInterleavedBuffer){for(let be=0;be<R.locationSize;be++)w(R.location+be,ce.meshPerAttribute);P.isInstancedMesh!==!0&&F._maxInstanceCount===void 0&&(F._maxInstanceCount=ce.meshPerAttribute*ce.count)}else for(let be=0;be<R.locationSize;be++)x(R.location+be);e.bindBuffer(34962,oe);for(let be=0;be<R.locationSize;be++)C(R.location+be,Y/R.locationSize,ie,K,ge*Z,(_e+Y/R.locationSize*be)*Z)}else{if(H.isInstancedBufferAttribute){for(let ce=0;ce<R.locationSize;ce++)w(R.location+ce,H.meshPerAttribute);P.isInstancedMesh!==!0&&F._maxInstanceCount===void 0&&(F._maxInstanceCount=H.meshPerAttribute*H.count)}else for(let ce=0;ce<R.locationSize;ce++)x(R.location+ce);e.bindBuffer(34962,oe);for(let ce=0;ce<R.locationSize;ce++)C(R.location+ce,Y/R.locationSize,ie,K,Y*Z,Y/R.locationSize*ce*Z)}}else if(z!==void 0){let K=z[$];if(K!==void 0)switch(K.length){case 2:e.vertexAttrib2fv(R.location,K);break;case 3:e.vertexAttrib3fv(R.location,K);break;case 4:e.vertexAttrib4fv(R.location,K);break;default:e.vertexAttrib1fv(R.location,K)}}}}S()}function T(){D();for(let P in a){let L=a[P];for(let B in L){let F=L[B];for(let M in F)f(F[M].object),delete F[M];delete L[B]}delete a[P]}}function E(P){if(a[P.id]===void 0)return;let L=a[P.id];for(let B in L){let F=L[B];for(let M in F)f(F[M].object),delete F[M];delete L[B]}delete a[P.id]}function A(P){for(let L in a){let B=a[L];if(B[P.id]===void 0)continue;let F=B[P.id];for(let M in F)f(F[M].object),delete F[M];delete B[P.id]}}function D(){O(),h=!0,c!==l&&(c=l,p(c.object))}function O(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:u,reset:D,resetDefaultState:O,dispose:T,releaseStatesOfGeometry:E,releaseStatesOfProgram:A,initAttributes:b,enableAttribute:x,disableUnusedAttributes:S}}function A9(e,t,n,s){let r=s.isWebGL2,i;function o(c){i=c}function a(c,h){e.drawArrays(i,c,h),n.update(h,i,1)}function l(c,h,u){if(u===0)return;let d,p;if(r)d=e,p="drawArraysInstanced";else if(d=t.get("ANGLE_instanced_arrays"),p="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[p](i,c,h,u),n.update(h,i,u)}this.setMode=o,this.render=a,this.renderInstances=l}function I9(e,t,n){let s;function r(){if(s!==void 0)return s;if(t.has("EXT_texture_filter_anisotropic")===!0){let C=t.get("EXT_texture_filter_anisotropic");s=e.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else s=0;return s}function i(C){if(C==="highp"){if(e.getShaderPrecisionFormat(35633,36338).precision>0&&e.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";C="mediump"}return C==="mediump"&&e.getShaderPrecisionFormat(35633,36337).precision>0&&e.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}let o=typeof WebGL2RenderingContext<"u"&&e instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&e instanceof WebGL2ComputeRenderingContext,a=n.precision!==void 0?n.precision:"highp",l=i(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);let c=o||t.has("WEBGL_draw_buffers"),h=n.logarithmicDepthBuffer===!0,u=e.getParameter(34930),d=e.getParameter(35660),p=e.getParameter(3379),f=e.getParameter(34076),g=e.getParameter(34921),m=e.getParameter(36347),y=e.getParameter(36348),v=e.getParameter(36349),b=d>0,x=o||t.has("OES_texture_float"),w=b&&x,S=o?e.getParameter(36183):0;return{isWebGL2:o,drawBuffers:c,getMaxAnisotropy:r,getMaxPrecision:i,precision:a,logarithmicDepthBuffer:h,maxTextures:u,maxVertexTextures:d,maxTextureSize:p,maxCubemapSize:f,maxAttributes:g,maxVertexUniforms:m,maxVaryings:y,maxFragmentUniforms:v,vertexTextures:b,floatFragmentTextures:x,floatVertexTextures:w,maxSamples:S}}function N9(e){let t=this,n=null,s=0,r=!1,i=!1,o=new ji,a=new Or,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(u,d,p){let f=u.length!==0||d||s!==0||r;return r=d,n=h(u,p,0),s=u.length,f},this.beginShadows=function(){i=!0,h(null)},this.endShadows=function(){i=!1,c()},this.setState=function(u,d,p){let f=u.clippingPlanes,g=u.clipIntersection,m=u.clipShadows,y=e.get(u);if(!r||f===null||f.length===0||i&&!m)i?h(null):c();else{let v=i?0:s,b=v*4,x=y.clippingState||null;l.value=x,x=h(f,d,b,p);for(let w=0;w!==b;++w)x[w]=n[w];y.clippingState=x,this.numIntersection=g?this.numPlanes:0,this.numPlanes+=v}};function c(){l.value!==n&&(l.value=n,l.needsUpdate=s>0),t.numPlanes=s,t.numIntersection=0}function h(u,d,p,f){let g=u!==null?u.length:0,m=null;if(g!==0){if(m=l.value,f!==!0||m===null){let y=p+g*4,v=d.matrixWorldInverse;a.getNormalMatrix(v),(m===null||m.length<y)&&(m=new Float32Array(y));for(let b=0,x=p;b!==g;++b,x+=4)o.copy(u[b]).applyMatrix4(v,a),o.normal.toArray(m,x),m[x+3]=o.constant}l.value=m,l.needsUpdate=!0}return t.numPlanes=g,t.numIntersection=0,m}}function k9(e){let t=new WeakMap;function n(o,a){return a===Ww?o.mapping=hu:a===Hw&&(o.mapping=du),o}function s(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){let a=o.mapping;if(a===Ww||a===Hw)if(t.has(o)){let l=t.get(o).texture;return n(l,o.mapping)}else{let l=o.image;if(l&&l.height>0){let c=new j8(l.height/2);return c.fromEquirectangularTexture(e,o),t.set(o,c),o.addEventListener("dispose",r),n(c.texture,o.mapping)}else return null}}return o}function r(o){let a=o.target;a.removeEventListener("dispose",r);let l=t.get(a);l!==void 0&&(t.delete(a),l.dispose())}function i(){t=new WeakMap}return{get:s,dispose:i}}var Cy=class extends ud{constructor(e=-1,t=1,n=1,s=-1,r=.1,i=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=s,this.near=r,this.far=i,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,s,r,i){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=s,this.view.width=r,this.view.height=i,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){let e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,s=(this.top+this.bottom)/2,r=n-e,i=n+e,o=s+t,a=s-t;if(this.view!==null&&this.view.enabled){let l=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=l*this.view.offsetX,i=r+l*this.view.width,o-=c*this.view.offsetY,a=o-c*this.view.height}this.projectionMatrix.makeOrthographic(r,i,o,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){let t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}},fd=4,xD=[.125,.215,.35,.446,.526,.582],wu=20,ES=new Cy,bD=new _t,AS=null,Su=(1+Math.sqrt(5))/2,md=1/Su,wD=[new I(1,1,1),new I(-1,1,1),new I(1,1,-1),new I(-1,1,-1),new I(0,Su,md),new I(0,Su,-md),new I(md,0,Su),new I(-md,0,Su),new I(Su,md,0),new I(-Su,md,0)],SD=class{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,s=100){AS=this._renderer.getRenderTarget(),this._setSize(256);let r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(e,n,s,r),t>0&&this._blur(r,0,0,t),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=TD(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=CD(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(AS),e.scissorTest=!1,Ty(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===hu||e.mapping===du?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),AS=this._renderer.getRenderTarget();let n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){let e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:xn,minFilter:xn,generateMipmaps:!1,type:If,format:ua,encoding:ha,depthBuffer:!1},s=_D(e,t,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=_D(e,t,n);let{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=D9(r)),this._blurMaterial=M9(r,e,t)}return s}_compileMaterial(e){let t=new bi(this._lodPlanes[0],e);this._renderer.compile(t,ES)}_sceneToCubeUV(e,t,n,s){let r=new vr(90,1,t,n),i=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],a=this._renderer,l=a.autoClear,c=a.toneMapping;a.getClearColor(bD),a.toneMapping=ll,a.autoClear=!1;let h=new Rf({name:"PMREM.Background",side:dr,depthWrite:!1,depthTest:!1}),u=new bi(new pa,h),d=!1,p=e.background;p?p.isColor&&(h.color.copy(p),e.background=null,d=!0):(h.color.copy(bD),d=!0);for(let f=0;f<6;f++){let g=f%3;g===0?(r.up.set(0,i[f],0),r.lookAt(o[f],0,0)):g===1?(r.up.set(0,0,i[f]),r.lookAt(0,o[f],0)):(r.up.set(0,i[f],0),r.lookAt(0,0,o[f]));let m=this._cubeSize;Ty(s,g*m,f>2?m:0,m,m),a.setRenderTarget(s),d&&a.render(u,r),a.render(e,r)}u.geometry.dispose(),u.material.dispose(),a.toneMapping=c,a.autoClear=l,e.background=p}_textureToCubeUV(e,t){let n=this._renderer,s=e.mapping===hu||e.mapping===du;s?(this._cubemapMaterial===null&&(this._cubemapMaterial=TD()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=CD());let r=s?this._cubemapMaterial:this._equirectMaterial,i=new bi(this._lodPlanes[0],r),o=r.uniforms;o.envMap.value=e;let a=this._cubeSize;Ty(t,0,0,3*a,2*a),n.setRenderTarget(t),n.render(i,ES)}_applyPMREM(e){let t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let s=1;s<this._lodPlanes.length;s++){let r=Math.sqrt(this._sigmas[s]*this._sigmas[s]-this._sigmas[s-1]*this._sigmas[s-1]),i=wD[(s-1)%wD.length];this._blur(e,s-1,s,r,i)}t.autoClear=n}_blur(e,t,n,s,r){let i=this._pingPongRenderTarget;this._halfBlur(e,i,t,n,s,"latitudinal",r),this._halfBlur(i,e,n,n,s,"longitudinal",r)}_halfBlur(e,t,n,s,r,i,o){let a=this._renderer,l=this._blurMaterial;i!=="latitudinal"&&i!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");let c=3,h=new bi(this._lodPlanes[s],l),u=l.uniforms,d=this._sizeLods[n]-1,p=isFinite(r)?Math.PI/(2*d):2*Math.PI/(2*wu-1),f=r/p,g=isFinite(r)?1+Math.floor(c*f):wu;g>wu&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${wu}`);let m=[],y=0;for(let S=0;S<wu;++S){let C=S/f,_=Math.exp(-C*C/2);m.push(_),S===0?y+=_:S<g&&(y+=2*_)}for(let S=0;S<m.length;S++)m[S]=m[S]/y;u.envMap.value=e.texture,u.samples.value=g,u.weights.value=m,u.latitudinal.value=i==="latitudinal",o&&(u.poleAxis.value=o);let{_lodMax:v}=this;u.dTheta.value=p,u.mipInt.value=v-n;let b=this._sizeLods[s],x=3*b*(s>v-fd?s-v+fd:0),w=4*(this._cubeSize-b);Ty(t,x,w,3*b,2*b),a.setRenderTarget(t),a.render(h,ES)}};function D9(e){let t=[],n=[],s=[],r=e,i=e-fd+1+xD.length;for(let o=0;o<i;o++){let a=Math.pow(2,r);n.push(a);let l=1/a;o>e-fd?l=xD[o-e+fd-1]:o===0&&(l=0),s.push(l);let c=1/(a-2),h=-c,u=1+c,d=[h,h,u,h,u,u,h,h,u,u,h,u],p=6,f=6,g=3,m=2,y=1,v=new Float32Array(g*f*p),b=new Float32Array(m*f*p),x=new Float32Array(y*f*p);for(let S=0;S<p;S++){let C=S%3*2/3-1,_=S>2?0:-1,T=[C,_,0,C+2/3,_,0,C+2/3,_+1,0,C,_,0,C+2/3,_+1,0,C,_+1,0];v.set(T,g*f*S),b.set(d,m*f*S);let E=[S,S,S,S,S,S];x.set(E,y*f*S)}let w=new It;w.setAttribute("position",new Lt(v,g)),w.setAttribute("uv",new Lt(b,m)),w.setAttribute("faceIndex",new Lt(x,y)),t.push(w),r>fd&&r--}return{lodPlanes:t,sizeLods:n,sigmas:s}}function _D(e,t,n){let s=new hs(e,t,n);return s.texture.mapping=Tf,s.texture.name="PMREM.cubeUv",s.scissorTest=!0,s}function Ty(e,t,n,s,r){e.viewport.set(t,n,s,r),e.scissor.set(t,n,s,r)}function M9(e,t,n){let s=new Float32Array(wu),r=new I(0,1,0);return new Ms({name:"SphericalGaussianBlur",defines:{n:wu,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${e}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:s},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r}},vertexShader:IS(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:nr,depthTest:!1,depthWrite:!1})}function CD(){return new Ms({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:IS(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:nr,depthTest:!1,depthWrite:!1})}function TD(){return new Ms({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:IS(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:nr,depthTest:!1,depthWrite:!1})}function IS(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function P9(e){let t=new WeakMap,n=null;function s(a){if(a&&a.isTexture){let l=a.mapping,c=l===Ww||l===Hw,h=l===hu||l===du;if(c||h)if(a.isRenderTargetTexture&&a.needsPMREMUpdate===!0){a.needsPMREMUpdate=!1;let u=t.get(a);return n===null&&(n=new SD(e)),u=c?n.fromEquirectangular(a,u):n.fromCubemap(a,u),t.set(a,u),u.texture}else{if(t.has(a))return t.get(a).texture;{let u=a.image;if(c&&u&&u.height>0||h&&u&&r(u)){n===null&&(n=new SD(e));let d=c?n.fromEquirectangular(a):n.fromCubemap(a);return t.set(a,d),a.addEventListener("dispose",i),d.texture}else return null}}}return a}function r(a){let l=0,c=6;for(let h=0;h<c;h++)a[h]!==void 0&&l++;return l===c}function i(a){let l=a.target;l.removeEventListener("dispose",i);let c=t.get(l);c!==void 0&&(t.delete(l),c.dispose())}function o(){t=new WeakMap,n!==null&&(n.dispose(),n=null)}return{get:s,dispose:o}}function O9(e){let t={};function n(s){if(t[s]!==void 0)return t[s];let r;switch(s){case"WEBGL_depth_texture":r=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=e.getExtension(s)}return t[s]=r,r}return{has:function(s){return n(s)!==null},init:function(s){s.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture")},get:function(s){let r=n(s);return r===null&&console.warn("THREE.WebGLRenderer: "+s+" extension not supported."),r}}}function R9(e,t,n,s){let r={},i=new WeakMap;function o(u){let d=u.target;d.index!==null&&t.remove(d.index);for(let f in d.attributes)t.remove(d.attributes[f]);d.removeEventListener("dispose",o),delete r[d.id];let p=i.get(d);p&&(t.remove(p),i.delete(d)),s.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,n.memory.geometries--}function a(u,d){return r[d.id]===!0||(d.addEventListener("dispose",o),r[d.id]=!0,n.memory.geometries++),d}function l(u){let d=u.attributes;for(let f in d)t.update(d[f],34962);let p=u.morphAttributes;for(let f in p){let g=p[f];for(let m=0,y=g.length;m<y;m++)t.update(g[m],34962)}}function c(u){let d=[],p=u.index,f=u.attributes.position,g=0;if(p!==null){let v=p.array;g=p.version;for(let b=0,x=v.length;b<x;b+=3){let w=v[b+0],S=v[b+1],C=v[b+2];d.push(w,S,S,C,C,w)}}else{let v=f.array;g=f.version;for(let b=0,x=v.length/3-1;b<x;b+=3){let w=b+0,S=b+1,C=b+2;d.push(w,S,S,C,C,w)}}let m=new(tD(d)?Lf:gD)(d,1);m.version=g;let y=i.get(u);y&&t.remove(y),i.set(u,m)}function h(u){let d=i.get(u);if(d){let p=u.index;p!==null&&d.version<p.version&&c(u)}else c(u);return i.get(u)}return{get:a,update:l,getWireframeAttribute:h}}function L9(e,t,n,s){let r=s.isWebGL2,i;function o(d){i=d}let a,l;function c(d){a=d.type,l=d.bytesPerElement}function h(d,p){e.drawElements(i,p,a,d*l),n.update(p,i,1)}function u(d,p,f){if(f===0)return;let g,m;if(r)g=e,m="drawElementsInstanced";else if(g=t.get("ANGLE_instanced_arrays"),m="drawElementsInstancedANGLE",g===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}g[m](i,p,a,d*l,f),n.update(p,i,f)}this.setMode=o,this.setIndex=c,this.render=h,this.renderInstances=u}function F9(e){let t={geometries:0,textures:0},n={frame:0,calls:0,triangles:0,points:0,lines:0};function s(i,o,a){switch(n.calls++,o){case 4:n.triangles+=a*(i/3);break;case 1:n.lines+=a*(i/2);break;case 3:n.lines+=a*(i-1);break;case 2:n.lines+=a*i;break;case 0:n.points+=a*i;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function r(){n.frame++,n.calls=0,n.triangles=0,n.points=0,n.lines=0}return{memory:t,render:n,programs:null,autoReset:!0,reset:r,update:s}}function $9(e,t){return e[0]-t[0]}function B9(e,t){return Math.abs(t[1])-Math.abs(e[1])}function NS(e,t){let n=1,s=t.isInterleavedBufferAttribute?t.data.array:t.array;s instanceof Int8Array?n=127:s instanceof Uint8Array?n=255:s instanceof Uint16Array?n=65535:s instanceof Int16Array?n=32767:s instanceof Int32Array?n=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",s),e.divideScalar(n)}function z9(e,t,n){let s={},r=new Float32Array(8),i=new WeakMap,o=new Bt,a=[];for(let c=0;c<8;c++)a[c]=[c,0];function l(c,h,u,d){let p=c.morphTargetInfluences;if(t.isWebGL2===!0){let f=h.morphAttributes.position||h.morphAttributes.normal||h.morphAttributes.color,g=f!==void 0?f.length:0,m=i.get(h);if(m===void 0||m.count!==g){let b=function(){P.dispose(),i.delete(h),h.removeEventListener("dispose",b)};m!==void 0&&m.texture.dispose();let x=h.morphAttributes.position!==void 0,w=h.morphAttributes.normal!==void 0,S=h.morphAttributes.color!==void 0,C=h.morphAttributes.position||[],_=h.morphAttributes.normal||[],T=h.morphAttributes.color||[],E=0;x===!0&&(E=1),w===!0&&(E=2),S===!0&&(E=3);let A=h.attributes.position.count*E,D=1;A>t.maxTextureSize&&(D=Math.ceil(A/t.maxTextureSize),A=t.maxTextureSize);let O=new Float32Array(A*D*4*g),P=new iD(O,A,D,g);P.type=Xl,P.needsUpdate=!0;let L=E*4;for(let B=0;B<g;B++){let F=C[B],M=_[B],U=T[B],z=A*D*4*B;for(let $=0;$<F.count;$++){let R=$*L;x===!0&&(o.fromBufferAttribute(F,$),F.normalized===!0&&NS(o,F),O[z+R+0]=o.x,O[z+R+1]=o.y,O[z+R+2]=o.z,O[z+R+3]=0),w===!0&&(o.fromBufferAttribute(M,$),M.normalized===!0&&NS(o,M),O[z+R+4]=o.x,O[z+R+5]=o.y,O[z+R+6]=o.z,O[z+R+7]=0),S===!0&&(o.fromBufferAttribute(U,$),U.normalized===!0&&NS(o,U),O[z+R+8]=o.x,O[z+R+9]=o.y,O[z+R+10]=o.z,O[z+R+11]=U.itemSize===4?o.w:1)}}m={count:g,texture:P,size:new se(A,D)},i.set(h,m),h.addEventListener("dispose",b)}let y=0;for(let b=0;b<p.length;b++)y+=p[b];let v=h.morphTargetsRelative?1:1-y;d.getUniforms().setValue(e,"morphTargetBaseInfluence",v),d.getUniforms().setValue(e,"morphTargetInfluences",p),d.getUniforms().setValue(e,"morphTargetsTexture",m.texture,n),d.getUniforms().setValue(e,"morphTargetsTextureSize",m.size)}else{let f=p===void 0?0:p.length,g=s[h.id];if(g===void 0||g.length!==f){g=[];for(let x=0;x<f;x++)g[x]=[x,0];s[h.id]=g}for(let x=0;x<f;x++){let w=g[x];w[0]=x,w[1]=p[x]}g.sort(B9);for(let x=0;x<8;x++)x<f&&g[x][1]?(a[x][0]=g[x][0],a[x][1]=g[x][1]):(a[x][0]=Number.MAX_SAFE_INTEGER,a[x][1]=0);a.sort($9);let m=h.morphAttributes.position,y=h.morphAttributes.normal,v=0;for(let x=0;x<8;x++){let w=a[x],S=w[0],C=w[1];S!==Number.MAX_SAFE_INTEGER&&C?(m&&h.getAttribute("morphTarget"+x)!==m[S]&&h.setAttribute("morphTarget"+x,m[S]),y&&h.getAttribute("morphNormal"+x)!==y[S]&&h.setAttribute("morphNormal"+x,y[S]),r[x]=C,v+=C):(m&&h.hasAttribute("morphTarget"+x)===!0&&h.deleteAttribute("morphTarget"+x),y&&h.hasAttribute("morphNormal"+x)===!0&&h.deleteAttribute("morphNormal"+x),r[x]=0)}let b=h.morphTargetsRelative?1:1-v;d.getUniforms().setValue(e,"morphTargetBaseInfluence",b),d.getUniforms().setValue(e,"morphTargetInfluences",r)}}return{update:l}}function U9(e,t,n,s){let r=new WeakMap;function i(l){let c=s.render.frame,h=l.geometry,u=t.get(l,h);return r.get(u)!==c&&(t.update(u),r.set(u,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),n.update(l.instanceMatrix,34962),l.instanceColor!==null&&n.update(l.instanceColor,34962)),u}function o(){r=new WeakMap}function a(l){let c=l.target;c.removeEventListener("dispose",a),n.remove(c.instanceMatrix),c.instanceColor!==null&&n.remove(c.instanceColor)}return{update:i,dispose:o}}var ED=new mr,AD=new iD,ID=new D8,ND=new _S,kD=[],DD=[],MD=new Float32Array(16),PD=new Float32Array(9),OD=new Float32Array(4);function gd(e,t,n){let s=e[0];if(s<=0||s>0)return e;let r=t*n,i=kD[r];if(i===void 0&&(i=new Float32Array(r),kD[r]=i),t!==0){s.toArray(i,0);for(let o=1,a=0;o!==t;++o)a+=n,e[o].toArray(i,a)}return i}function Rr(e,t){if(e.length!==t.length)return!1;for(let n=0,s=e.length;n<s;n++)if(e[n]!==t[n])return!1;return!0}function Lr(e,t){for(let n=0,s=t.length;n<s;n++)e[n]=t[n]}function Ey(e,t){let n=DD[t];n===void 0&&(n=new Int32Array(t),DD[t]=n);for(let s=0;s!==t;++s)n[s]=e.allocateTextureUnit();return n}function V9(e,t){let n=this.cache;n[0]!==t&&(e.uniform1f(this.addr,t),n[0]=t)}function G9(e,t){let n=this.cache;if(t.x!==void 0)(n[0]!==t.x||n[1]!==t.y)&&(e.uniform2f(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(Rr(n,t))return;e.uniform2fv(this.addr,t),Lr(n,t)}}function W9(e,t){let n=this.cache;if(t.x!==void 0)(n[0]!==t.x||n[1]!==t.y||n[2]!==t.z)&&(e.uniform3f(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else if(t.r!==void 0)(n[0]!==t.r||n[1]!==t.g||n[2]!==t.b)&&(e.uniform3f(this.addr,t.r,t.g,t.b),n[0]=t.r,n[1]=t.g,n[2]=t.b);else{if(Rr(n,t))return;e.uniform3fv(this.addr,t),Lr(n,t)}}function H9(e,t){let n=this.cache;if(t.x!==void 0)(n[0]!==t.x||n[1]!==t.y||n[2]!==t.z||n[3]!==t.w)&&(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(Rr(n,t))return;e.uniform4fv(this.addr,t),Lr(n,t)}}function j9(e,t){let n=this.cache,s=t.elements;if(s===void 0){if(Rr(n,t))return;e.uniformMatrix2fv(this.addr,!1,t),Lr(n,t)}else{if(Rr(n,s))return;OD.set(s),e.uniformMatrix2fv(this.addr,!1,OD),Lr(n,s)}}function q9(e,t){let n=this.cache,s=t.elements;if(s===void 0){if(Rr(n,t))return;e.uniformMatrix3fv(this.addr,!1,t),Lr(n,t)}else{if(Rr(n,s))return;PD.set(s),e.uniformMatrix3fv(this.addr,!1,PD),Lr(n,s)}}function X9(e,t){let n=this.cache,s=t.elements;if(s===void 0){if(Rr(n,t))return;e.uniformMatrix4fv(this.addr,!1,t),Lr(n,t)}else{if(Rr(n,s))return;MD.set(s),e.uniformMatrix4fv(this.addr,!1,MD),Lr(n,s)}}function K9(e,t){let n=this.cache;n[0]!==t&&(e.uniform1i(this.addr,t),n[0]=t)}function Y9(e,t){let n=this.cache;Rr(n,t)||(e.uniform2iv(this.addr,t),Lr(n,t))}function Q9(e,t){let n=this.cache;Rr(n,t)||(e.uniform3iv(this.addr,t),Lr(n,t))}function Z9(e,t){let n=this.cache;Rr(n,t)||(e.uniform4iv(this.addr,t),Lr(n,t))}function J9(e,t){let n=this.cache;n[0]!==t&&(e.uniform1ui(this.addr,t),n[0]=t)}function eX(e,t){let n=this.cache;Rr(n,t)||(e.uniform2uiv(this.addr,t),Lr(n,t))}function tX(e,t){let n=this.cache;Rr(n,t)||(e.uniform3uiv(this.addr,t),Lr(n,t))}function nX(e,t){let n=this.cache;Rr(n,t)||(e.uniform4uiv(this.addr,t),Lr(n,t))}function sX(e,t,n){let s=this.cache,r=n.allocateTextureUnit();s[0]!==r&&(e.uniform1i(this.addr,r),s[0]=r),n.setTexture2D(t||ED,r)}function rX(e,t,n){let s=this.cache,r=n.allocateTextureUnit();s[0]!==r&&(e.uniform1i(this.addr,r),s[0]=r),n.setTexture3D(t||ID,r)}function iX(e,t,n){let s=this.cache,r=n.allocateTextureUnit();s[0]!==r&&(e.uniform1i(this.addr,r),s[0]=r),n.setTextureCube(t||ND,r)}function oX(e,t,n){let s=this.cache,r=n.allocateTextureUnit();s[0]!==r&&(e.uniform1i(this.addr,r),s[0]=r),n.setTexture2DArray(t||AD,r)}function aX(e){switch(e){case 5126:return V9;case 35664:return G9;case 35665:return W9;case 35666:return H9;case 35674:return j9;case 35675:return q9;case 35676:return X9;case 5124:case 35670:return K9;case 35667:case 35671:return Y9;case 35668:case 35672:return Q9;case 35669:case 35673:return Z9;case 5125:return J9;case 36294:return eX;case 36295:return tX;case 36296:return nX;case 35678:case 36198:case 36298:case 36306:case 35682:return sX;case 35679:case 36299:case 36307:return rX;case 35680:case 36300:case 36308:case 36293:return iX;case 36289:case 36303:case 36311:case 36292:return oX}}function lX(e,t){e.uniform1fv(this.addr,t)}function cX(e,t){let n=gd(t,this.size,2);e.uniform2fv(this.addr,n)}function uX(e,t){let n=gd(t,this.size,3);e.uniform3fv(this.addr,n)}function hX(e,t){let n=gd(t,this.size,4);e.uniform4fv(this.addr,n)}function dX(e,t){let n=gd(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,n)}function pX(e,t){let n=gd(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,n)}function fX(e,t){let n=gd(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,n)}function mX(e,t){e.uniform1iv(this.addr,t)}function gX(e,t){e.uniform2iv(this.addr,t)}function yX(e,t){e.uniform3iv(this.addr,t)}function vX(e,t){e.uniform4iv(this.addr,t)}function xX(e,t){e.uniform1uiv(this.addr,t)}function bX(e,t){e.uniform2uiv(this.addr,t)}function wX(e,t){e.uniform3uiv(this.addr,t)}function SX(e,t){e.uniform4uiv(this.addr,t)}function _X(e,t,n){let s=t.length,r=Ey(n,s);e.uniform1iv(this.addr,r);for(let i=0;i!==s;++i)n.setTexture2D(t[i]||ED,r[i])}function CX(e,t,n){let s=t.length,r=Ey(n,s);e.uniform1iv(this.addr,r);for(let i=0;i!==s;++i)n.setTexture3D(t[i]||ID,r[i])}function TX(e,t,n){let s=t.length,r=Ey(n,s);e.uniform1iv(this.addr,r);for(let i=0;i!==s;++i)n.setTextureCube(t[i]||ND,r[i])}function EX(e,t,n){let s=t.length,r=Ey(n,s);e.uniform1iv(this.addr,r);for(let i=0;i!==s;++i)n.setTexture2DArray(t[i]||AD,r[i])}function AX(e){switch(e){case 5126:return lX;case 35664:return cX;case 35665:return uX;case 35666:return hX;case 35674:return dX;case 35675:return pX;case 35676:return fX;case 5124:case 35670:return mX;case 35667:case 35671:return gX;case 35668:case 35672:return yX;case 35669:case 35673:return vX;case 5125:return xX;case 36294:return bX;case 36295:return wX;case 36296:return SX;case 35678:case 36198:case 36298:case 36306:case 35682:return _X;case 35679:case 36299:case 36307:return CX;case 35680:case 36300:case 36308:case 36293:return TX;case 36289:case 36303:case 36311:case 36292:return EX}}var IX=class{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=aX(t.type)}},NX=class{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=AX(t.type)}},kX=class{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,n){let s=this.seq;for(let r=0,i=s.length;r!==i;++r){let o=s[r];o.setValue(e,t[o.id],n)}}},kS=/(\w+)(\])?(\[|\.)?/g;function RD(e,t){e.seq.push(t),e.map[t.id]=t}function DX(e,t,n){let s=e.name,r=s.length;for(kS.lastIndex=0;;){let i=kS.exec(s),o=kS.lastIndex,a=i[1],l=i[2]==="]",c=i[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===r){RD(n,c===void 0?new IX(a,e,t):new NX(a,e,t));break}else{let h=n.map[a];h===void 0&&(h=new kX(a),RD(n,h)),n=h}}}var Ay=class{constructor(e,t){this.seq=[],this.map={};let n=e.getProgramParameter(t,35718);for(let s=0;s<n;++s){let r=e.getActiveUniform(t,s),i=e.getUniformLocation(t,r.name);DX(r,i,this)}}setValue(e,t,n,s){let r=this.map[t];r!==void 0&&r.setValue(e,n,s)}setOptional(e,t,n){let s=t[n];s!==void 0&&this.setValue(e,n,s)}static upload(e,t,n,s){for(let r=0,i=t.length;r!==i;++r){let o=t[r],a=n[o.id];a.needsUpdate!==!1&&o.setValue(e,a.value,s)}}static seqWithValue(e,t){let n=[];for(let s=0,r=e.length;s!==r;++s){let i=e[s];i.id in t&&n.push(i)}return n}};function LD(e,t,n){let s=e.createShader(t);return e.shaderSource(s,n),e.compileShader(s),s}var MX=0;function PX(e,t){let n=e.split(`
`),s=[],r=Math.max(t-6,0),i=Math.min(t+6,n.length);for(let o=r;o<i;o++){let a=o+1;s.push(`${a===t?">":" "} ${a}: ${n[o]}`)}return s.join(`
`)}function OX(e){switch(e){case ha:return["Linear","( value )"];case Gt:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}function FD(e,t,n){let s=e.getShaderParameter(t,35713),r=e.getShaderInfoLog(t).trim();if(s&&r==="")return"";let i=/ERROR: 0:(\d+)/.exec(r);if(i){let o=parseInt(i[1]);return n.toUpperCase()+`

`+r+`

`+PX(e.getShaderSource(t),o)}else return r}function RX(e,t){let n=OX(t);return"vec4 "+e+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function LX(e,t){let n;switch(t){case G6:n="Linear";break;case W6:n="Reinhard";break;case H6:n="OptimizedCineon";break;case j6:n="ACESFilmic";break;case q6:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),n="Linear"}return"vec3 "+e+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function FX(e){return[e.extensionDerivatives||!!e.envMapCubeUVHeight||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||e.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap||e.transmission)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter($f).join(`
`)}function $X(e){let t=[];for(let n in e){let s=e[n];s!==!1&&t.push("#define "+n+" "+s)}return t.join(`
`)}function BX(e,t){let n={},s=e.getProgramParameter(t,35721);for(let r=0;r<s;r++){let i=e.getActiveAttrib(t,r),o=i.name,a=1;i.type===35674&&(a=2),i.type===35675&&(a=3),i.type===35676&&(a=4),n[o]={type:i.type,location:e.getAttribLocation(t,o),locationSize:a}}return n}function $f(e){return e!==""}function $D(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function BD(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}var zX=/^[ \t]*#include +<([\w\d./]+)>/gm;function DS(e){return e.replace(zX,UX)}function UX(e,t){let n=zt[t];if(n===void 0)throw new Error("Can not resolve #include <"+t+">");return DS(n)}var VX=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,GX=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function zD(e){return e.replace(GX,UD).replace(VX,WX)}function WX(e,t,n,s){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),UD(e,t,n,s)}function UD(e,t,n,s){let r="";for(let i=parseInt(t);i<parseInt(n);i++)r+=s.replace(/\[\s*i\s*\]/g,"[ "+i+" ]").replace(/UNROLLED_LOOP_INDEX/g,i);return r}function VD(e){let t="precision "+e.precision+` float;
precision `+e.precision+" int;";return e.precision==="highp"?t+=`
#define HIGH_PRECISION`:e.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:e.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function HX(e){let t="SHADOWMAP_TYPE_BASIC";return e.shadowMapType===Vw?t="SHADOWMAP_TYPE_PCF":e.shadowMapType===vk?t="SHADOWMAP_TYPE_PCF_SOFT":e.shadowMapType===Cf&&(t="SHADOWMAP_TYPE_VSM"),t}function jX(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case hu:case du:t="ENVMAP_TYPE_CUBE";break;case Tf:t="ENVMAP_TYPE_CUBE_UV";break}return t}function qX(e){let t="ENVMAP_MODE_REFLECTION";if(e.envMap)switch(e.envMapMode){case du:t="ENVMAP_MODE_REFRACTION";break}return t}function XX(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case Ek:t="ENVMAP_BLENDING_MULTIPLY";break;case U6:t="ENVMAP_BLENDING_MIX";break;case V6:t="ENVMAP_BLENDING_ADD";break}return t}function KX(e){let t=e.envMapCubeUVHeight;if(t===null)return null;let n=Math.log2(t)-2,s=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,n),7*16)),texelHeight:s,maxMip:n}}function YX(e,t,n,s){let r=e.getContext(),i=n.defines,o=n.vertexShader,a=n.fragmentShader,l=HX(n),c=jX(n),h=qX(n),u=XX(n),d=KX(n),p=n.isWebGL2?"":FX(n),f=$X(i),g=r.createProgram(),m,y,v=n.glslVersion?"#version "+n.glslVersion+`
`:"";n.isRawShaderMaterial?(m=[f].filter($f).join(`
`),m.length>0&&(m+=`
`),y=[p,f].filter($f).join(`
`),y.length>0&&(y+=`
`)):(m=[VD(n),"#define SHADER_NAME "+n.shaderName,f,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+h:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&n.flatShading===!1?"#define USE_MORPHNORMALS":"",n.morphColors&&n.isWebGL2?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter($f).join(`
`),y=[p,VD(n),"#define SHADER_NAME "+n.shaderName,f,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+h:"",n.envMap?"#define "+u:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==ll?"#define TONE_MAPPING":"",n.toneMapping!==ll?zt.tonemapping_pars_fragment:"",n.toneMapping!==ll?LX("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",zt.encodings_pars_fragment,RX("linearToOutputTexel",n.outputEncoding),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"",`
`].filter($f).join(`
`)),o=DS(o),o=$D(o,n),o=BD(o,n),a=DS(a),a=$D(a,n),a=BD(a,n),o=zD(o),a=zD(a),n.isWebGL2&&n.isRawShaderMaterial!==!0&&(v=`#version 300 es
`,m=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+m,y=["#define varying in",n.glslVersion===Jk?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===Jk?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+y);let b=v+m+o,x=v+y+a,w=LD(r,35633,b),S=LD(r,35632,x);if(r.attachShader(g,w),r.attachShader(g,S),n.index0AttributeName!==void 0?r.bindAttribLocation(g,0,n.index0AttributeName):n.morphTargets===!0&&r.bindAttribLocation(g,0,"position"),r.linkProgram(g),e.debug.checkShaderErrors){let T=r.getProgramInfoLog(g).trim(),E=r.getShaderInfoLog(w).trim(),A=r.getShaderInfoLog(S).trim(),D=!0,O=!0;if(r.getProgramParameter(g,35714)===!1){D=!1;let P=FD(r,w,"vertex"),L=FD(r,S,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(g,35715)+`

Program Info Log: `+T+`
`+P+`
`+L)}else T!==""?console.warn("THREE.WebGLProgram: Program Info Log:",T):(E===""||A==="")&&(O=!1);O&&(this.diagnostics={runnable:D,programLog:T,vertexShader:{log:E,prefix:m},fragmentShader:{log:A,prefix:y}})}r.deleteShader(w),r.deleteShader(S);let C;this.getUniforms=function(){return C===void 0&&(C=new Ay(r,g)),C};let _;return this.getAttributes=function(){return _===void 0&&(_=BX(r,g)),_},this.destroy=function(){s.releaseStatesOfProgram(this),r.deleteProgram(g),this.program=void 0},this.name=n.shaderName,this.id=MX++,this.cacheKey=t,this.usedTimes=1,this.program=g,this.vertexShader=w,this.fragmentShader=S,this}var QX=0,ZX=class{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){let t=e.vertexShader,n=e.fragmentShader,s=this._getShaderStage(t),r=this._getShaderStage(n),i=this._getShaderCacheForMaterial(e);return i.has(s)===!1&&(i.add(s),s.usedTimes++),i.has(r)===!1&&(i.add(r),r.usedTimes++),this}remove(e){let t=this.materialCache.get(e);for(let n of t)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){let t=this.materialCache;return t.has(e)===!1&&t.set(e,new Set),t.get(e)}_getShaderStage(e){let t=this.shaderCache;if(t.has(e)===!1){let n=new JX(e);t.set(e,n)}return t.get(e)}},JX=class{constructor(e){this.id=QX++,this.code=e,this.usedTimes=0}};function eK(e,t,n,s,r,i,o){let a=new dS,l=new ZX,c=[],h=r.isWebGL2,u=r.logarithmicDepthBuffer,d=r.vertexTextures,p=r.precision,f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function g(_,T,E,A,D){let O=A.fog,P=D.geometry,L=_.isMeshStandardMaterial?A.environment:null,B=(_.isMeshStandardMaterial?n:t).get(_.envMap||L),F=!!B&&B.mapping===Tf?B.image.height:null,M=f[_.type];_.precision!==null&&(p=r.getMaxPrecision(_.precision),p!==_.precision&&console.warn("THREE.WebGLProgram.getParameters:",_.precision,"not supported, using",p,"instead."));let U=P.morphAttributes.position||P.morphAttributes.normal||P.morphAttributes.color,z=U!==void 0?U.length:0,$=0;P.morphAttributes.position!==void 0&&($=1),P.morphAttributes.normal!==void 0&&($=2),P.morphAttributes.color!==void 0&&($=3);let R,H,K,Y;if(M){let ce=fa[M];R=ce.vertexShader,H=ce.fragmentShader}else R=_.vertexShader,H=_.fragmentShader,l.update(_),K=l.getVertexShaderID(_),Y=l.getFragmentShaderID(_);let X=e.getRenderTarget(),oe=_.alphaTest>0,ie=_.clearcoat>0,Z=_.iridescence>0;return{isWebGL2:h,shaderID:M,shaderName:_.type,vertexShader:R,fragmentShader:H,defines:_.defines,customVertexShaderID:K,customFragmentShaderID:Y,isRawShaderMaterial:_.isRawShaderMaterial===!0,glslVersion:_.glslVersion,precision:p,instancing:D.isInstancedMesh===!0,instancingColor:D.isInstancedMesh===!0&&D.instanceColor!==null,supportsVertexTextures:d,outputEncoding:X===null?e.outputEncoding:X.isXRRenderTarget===!0?X.texture.encoding:ha,map:!!_.map,matcap:!!_.matcap,envMap:!!B,envMapMode:B&&B.mapping,envMapCubeUVHeight:F,lightMap:!!_.lightMap,aoMap:!!_.aoMap,emissiveMap:!!_.emissiveMap,bumpMap:!!_.bumpMap,normalMap:!!_.normalMap,objectSpaceNormalMap:_.normalMapType===h8,tangentSpaceNormalMap:_.normalMapType===u8,decodeVideoTexture:!!_.map&&_.map.isVideoTexture===!0&&_.map.encoding===Gt,clearcoat:ie,clearcoatMap:ie&&!!_.clearcoatMap,clearcoatRoughnessMap:ie&&!!_.clearcoatRoughnessMap,clearcoatNormalMap:ie&&!!_.clearcoatNormalMap,iridescence:Z,iridescenceMap:Z&&!!_.iridescenceMap,iridescenceThicknessMap:Z&&!!_.iridescenceThicknessMap,displacementMap:!!_.displacementMap,roughnessMap:!!_.roughnessMap,metalnessMap:!!_.metalnessMap,specularMap:!!_.specularMap,specularIntensityMap:!!_.specularIntensityMap,specularColorMap:!!_.specularColorMap,opaque:_.transparent===!1&&_.blending===Kh,alphaMap:!!_.alphaMap,alphaTest:oe,gradientMap:!!_.gradientMap,sheen:_.sheen>0,sheenColorMap:!!_.sheenColorMap,sheenRoughnessMap:!!_.sheenRoughnessMap,transmission:_.transmission>0,transmissionMap:!!_.transmissionMap,thicknessMap:!!_.thicknessMap,combine:_.combine,vertexTangents:!!_.normalMap&&!!P.attributes.tangent,vertexColors:_.vertexColors,vertexAlphas:_.vertexColors===!0&&!!P.attributes.color&&P.attributes.color.itemSize===4,vertexUvs:!!_.map||!!_.bumpMap||!!_.normalMap||!!_.specularMap||!!_.alphaMap||!!_.emissiveMap||!!_.roughnessMap||!!_.metalnessMap||!!_.clearcoatMap||!!_.clearcoatRoughnessMap||!!_.clearcoatNormalMap||!!_.iridescenceMap||!!_.iridescenceThicknessMap||!!_.displacementMap||!!_.transmissionMap||!!_.thicknessMap||!!_.specularIntensityMap||!!_.specularColorMap||!!_.sheenColorMap||!!_.sheenRoughnessMap,uvsVertexOnly:!(!!_.map||!!_.bumpMap||!!_.normalMap||!!_.specularMap||!!_.alphaMap||!!_.emissiveMap||!!_.roughnessMap||!!_.metalnessMap||!!_.clearcoatNormalMap||!!_.iridescenceMap||!!_.iridescenceThicknessMap||_.transmission>0||!!_.transmissionMap||!!_.thicknessMap||!!_.specularIntensityMap||!!_.specularColorMap||_.sheen>0||!!_.sheenColorMap||!!_.sheenRoughnessMap)&&!!_.displacementMap,fog:!!O,useFog:_.fog===!0,fogExp2:O&&O.isFogExp2,flatShading:!!_.flatShading,sizeAttenuation:_.sizeAttenuation,logarithmicDepthBuffer:u,skinning:D.isSkinnedMesh===!0,morphTargets:P.morphAttributes.position!==void 0,morphNormals:P.morphAttributes.normal!==void 0,morphColors:P.morphAttributes.color!==void 0,morphTargetsCount:z,morphTextureStride:$,numDirLights:T.directional.length,numPointLights:T.point.length,numSpotLights:T.spot.length,numRectAreaLights:T.rectArea.length,numHemiLights:T.hemi.length,numDirLightShadows:T.directionalShadowMap.length,numPointLightShadows:T.pointShadowMap.length,numSpotLightShadows:T.spotShadowMap.length,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:_.dithering,shadowMapEnabled:e.shadowMap.enabled&&E.length>0,shadowMapType:e.shadowMap.type,toneMapping:_.toneMapped?e.toneMapping:ll,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:_.premultipliedAlpha,doubleSided:_.side===Ao,flipSided:_.side===dr,useDepthPacking:!!_.depthPacking,depthPacking:_.depthPacking||0,index0AttributeName:_.index0AttributeName,extensionDerivatives:_.extensions&&_.extensions.derivatives,extensionFragDepth:_.extensions&&_.extensions.fragDepth,extensionDrawBuffers:_.extensions&&_.extensions.drawBuffers,extensionShaderTextureLOD:_.extensions&&_.extensions.shaderTextureLOD,rendererExtensionFragDepth:h||s.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||s.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||s.has("EXT_shader_texture_lod"),customProgramCacheKey:_.customProgramCacheKey()}}function m(_){let T=[];if(_.shaderID?T.push(_.shaderID):(T.push(_.customVertexShaderID),T.push(_.customFragmentShaderID)),_.defines!==void 0)for(let E in _.defines)T.push(E),T.push(_.defines[E]);return _.isRawShaderMaterial===!1&&(y(T,_),v(T,_),T.push(e.outputEncoding)),T.push(_.customProgramCacheKey),T.join()}function y(_,T){_.push(T.precision),_.push(T.outputEncoding),_.push(T.envMapMode),_.push(T.envMapCubeUVHeight),_.push(T.combine),_.push(T.vertexUvs),_.push(T.fogExp2),_.push(T.sizeAttenuation),_.push(T.morphTargetsCount),_.push(T.morphAttributeCount),_.push(T.numDirLights),_.push(T.numPointLights),_.push(T.numSpotLights),_.push(T.numHemiLights),_.push(T.numRectAreaLights),_.push(T.numDirLightShadows),_.push(T.numPointLightShadows),_.push(T.numSpotLightShadows),_.push(T.shadowMapType),_.push(T.toneMapping),_.push(T.numClippingPlanes),_.push(T.numClipIntersection),_.push(T.depthPacking)}function v(_,T){a.disableAll(),T.isWebGL2&&a.enable(0),T.supportsVertexTextures&&a.enable(1),T.instancing&&a.enable(2),T.instancingColor&&a.enable(3),T.map&&a.enable(4),T.matcap&&a.enable(5),T.envMap&&a.enable(6),T.lightMap&&a.enable(7),T.aoMap&&a.enable(8),T.emissiveMap&&a.enable(9),T.bumpMap&&a.enable(10),T.normalMap&&a.enable(11),T.objectSpaceNormalMap&&a.enable(12),T.tangentSpaceNormalMap&&a.enable(13),T.clearcoat&&a.enable(14),T.clearcoatMap&&a.enable(15),T.clearcoatRoughnessMap&&a.enable(16),T.clearcoatNormalMap&&a.enable(17),T.iridescence&&a.enable(18),T.iridescenceMap&&a.enable(19),T.iridescenceThicknessMap&&a.enable(20),T.displacementMap&&a.enable(21),T.specularMap&&a.enable(22),T.roughnessMap&&a.enable(23),T.metalnessMap&&a.enable(24),T.gradientMap&&a.enable(25),T.alphaMap&&a.enable(26),T.alphaTest&&a.enable(27),T.vertexColors&&a.enable(28),T.vertexAlphas&&a.enable(29),T.vertexUvs&&a.enable(30),T.vertexTangents&&a.enable(31),T.uvsVertexOnly&&a.enable(32),T.fog&&a.enable(33),_.push(a.mask),a.disableAll(),T.useFog&&a.enable(0),T.flatShading&&a.enable(1),T.logarithmicDepthBuffer&&a.enable(2),T.skinning&&a.enable(3),T.morphTargets&&a.enable(4),T.morphNormals&&a.enable(5),T.morphColors&&a.enable(6),T.premultipliedAlpha&&a.enable(7),T.shadowMapEnabled&&a.enable(8),T.physicallyCorrectLights&&a.enable(9),T.doubleSided&&a.enable(10),T.flipSided&&a.enable(11),T.useDepthPacking&&a.enable(12),T.dithering&&a.enable(13),T.specularIntensityMap&&a.enable(14),T.specularColorMap&&a.enable(15),T.transmission&&a.enable(16),T.transmissionMap&&a.enable(17),T.thicknessMap&&a.enable(18),T.sheen&&a.enable(19),T.sheenColorMap&&a.enable(20),T.sheenRoughnessMap&&a.enable(21),T.decodeVideoTexture&&a.enable(22),T.opaque&&a.enable(23),_.push(a.mask)}function b(_){let T=f[_.type],E;if(T){let A=fa[T];E=cd.clone(A.uniforms)}else E=_.uniforms;return E}function x(_,T){let E;for(let A=0,D=c.length;A<D;A++){let O=c[A];if(O.cacheKey===T){E=O,++E.usedTimes;break}}return E===void 0&&(E=new YX(e,T,_,i),c.push(E)),E}function w(_){if(--_.usedTimes==0){let T=c.indexOf(_);c[T]=c[c.length-1],c.pop(),_.destroy()}}function S(_){l.remove(_)}function C(){l.dispose()}return{getParameters:g,getProgramCacheKey:m,getUniforms:b,acquireProgram:x,releaseProgram:w,releaseShaderCache:S,programs:c,dispose:C}}function tK(){let e=new WeakMap;function t(i){let o=e.get(i);return o===void 0&&(o={},e.set(i,o)),o}function n(i){e.delete(i)}function s(i,o,a){e.get(i)[o]=a}function r(){e=new WeakMap}return{get:t,remove:n,update:s,dispose:r}}function nK(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function GD(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function WD(){let e=[],t=0,n=[],s=[],r=[];function i(){t=0,n.length=0,s.length=0,r.length=0}function o(u,d,p,f,g,m){let y=e[t];return y===void 0?(y={id:u.id,object:u,geometry:d,material:p,groupOrder:f,renderOrder:u.renderOrder,z:g,group:m},e[t]=y):(y.id=u.id,y.object=u,y.geometry=d,y.material=p,y.groupOrder=f,y.renderOrder=u.renderOrder,y.z=g,y.group=m),t++,y}function a(u,d,p,f,g,m){let y=o(u,d,p,f,g,m);p.transmission>0?s.push(y):p.transparent===!0?r.push(y):n.push(y)}function l(u,d,p,f,g,m){let y=o(u,d,p,f,g,m);p.transmission>0?s.unshift(y):p.transparent===!0?r.unshift(y):n.unshift(y)}function c(u,d){n.length>1&&n.sort(u||nK),s.length>1&&s.sort(d||GD),r.length>1&&r.sort(d||GD)}function h(){for(let u=t,d=e.length;u<d;u++){let p=e[u];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.group=null}}return{opaque:n,transmissive:s,transparent:r,init:i,push:a,unshift:l,finish:h,sort:c}}function sK(){let e=new WeakMap;function t(s,r){let i;return e.has(s)===!1?(i=new WD,e.set(s,[i])):r>=e.get(s).length?(i=new WD,e.get(s).push(i)):i=e.get(s)[r],i}function n(){e=new WeakMap}return{get:t,dispose:n}}function rK(){let e={};return{get:function(t){if(e[t.id]!==void 0)return e[t.id];let n;switch(t.type){case"DirectionalLight":n={direction:new I,color:new _t};break;case"SpotLight":n={position:new I,direction:new I,color:new _t,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new I,color:new _t,distance:0,decay:0};break;case"HemisphereLight":n={direction:new I,skyColor:new _t,groundColor:new _t};break;case"RectAreaLight":n={color:new _t,position:new I,halfWidth:new I,halfHeight:new I};break}return e[t.id]=n,n}}}function iK(){let e={};return{get:function(t){if(e[t.id]!==void 0)return e[t.id];let n;switch(t.type){case"DirectionalLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new se};break;case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new se};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new se,shadowCameraNear:1,shadowCameraFar:1e3};break}return e[t.id]=n,n}}}var oK=0;function aK(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function lK(e,t){let n=new rK,s=iK(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let h=0;h<9;h++)r.probe.push(new I);let i=new I,o=new et,a=new et;function l(h,u){let d=0,p=0,f=0;for(let T=0;T<9;T++)r.probe[T].set(0,0,0);let g=0,m=0,y=0,v=0,b=0,x=0,w=0,S=0;h.sort(aK);let C=u!==!0?Math.PI:1;for(let T=0,E=h.length;T<E;T++){let A=h[T],D=A.color,O=A.intensity,P=A.distance,L=A.shadow&&A.shadow.map?A.shadow.map.texture:null;if(A.isAmbientLight)d+=D.r*O*C,p+=D.g*O*C,f+=D.b*O*C;else if(A.isLightProbe)for(let B=0;B<9;B++)r.probe[B].addScaledVector(A.sh.coefficients[B],O);else if(A.isDirectionalLight){let B=n.get(A);if(B.color.copy(A.color).multiplyScalar(A.intensity*C),A.castShadow){let F=A.shadow,M=s.get(A);M.shadowBias=F.bias,M.shadowNormalBias=F.normalBias,M.shadowRadius=F.radius,M.shadowMapSize=F.mapSize,r.directionalShadow[g]=M,r.directionalShadowMap[g]=L,r.directionalShadowMatrix[g]=A.shadow.matrix,x++}r.directional[g]=B,g++}else if(A.isSpotLight){let B=n.get(A);if(B.position.setFromMatrixPosition(A.matrixWorld),B.color.copy(D).multiplyScalar(O*C),B.distance=P,B.coneCos=Math.cos(A.angle),B.penumbraCos=Math.cos(A.angle*(1-A.penumbra)),B.decay=A.decay,A.castShadow){let F=A.shadow,M=s.get(A);M.shadowBias=F.bias,M.shadowNormalBias=F.normalBias,M.shadowRadius=F.radius,M.shadowMapSize=F.mapSize,r.spotShadow[y]=M,r.spotShadowMap[y]=L,r.spotShadowMatrix[y]=A.shadow.matrix,S++}r.spot[y]=B,y++}else if(A.isRectAreaLight){let B=n.get(A);B.color.copy(D).multiplyScalar(O),B.halfWidth.set(A.width*.5,0,0),B.halfHeight.set(0,A.height*.5,0),r.rectArea[v]=B,v++}else if(A.isPointLight){let B=n.get(A);if(B.color.copy(A.color).multiplyScalar(A.intensity*C),B.distance=A.distance,B.decay=A.decay,A.castShadow){let F=A.shadow,M=s.get(A);M.shadowBias=F.bias,M.shadowNormalBias=F.normalBias,M.shadowRadius=F.radius,M.shadowMapSize=F.mapSize,M.shadowCameraNear=F.camera.near,M.shadowCameraFar=F.camera.far,r.pointShadow[m]=M,r.pointShadowMap[m]=L,r.pointShadowMatrix[m]=A.shadow.matrix,w++}r.point[m]=B,m++}else if(A.isHemisphereLight){let B=n.get(A);B.skyColor.copy(A.color).multiplyScalar(O*C),B.groundColor.copy(A.groundColor).multiplyScalar(O*C),r.hemi[b]=B,b++}}v>0&&(t.isWebGL2||e.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=Ye.LTC_FLOAT_1,r.rectAreaLTC2=Ye.LTC_FLOAT_2):e.has("OES_texture_half_float_linear")===!0?(r.rectAreaLTC1=Ye.LTC_HALF_1,r.rectAreaLTC2=Ye.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=d,r.ambient[1]=p,r.ambient[2]=f;let _=r.hash;(_.directionalLength!==g||_.pointLength!==m||_.spotLength!==y||_.rectAreaLength!==v||_.hemiLength!==b||_.numDirectionalShadows!==x||_.numPointShadows!==w||_.numSpotShadows!==S)&&(r.directional.length=g,r.spot.length=y,r.rectArea.length=v,r.point.length=m,r.hemi.length=b,r.directionalShadow.length=x,r.directionalShadowMap.length=x,r.pointShadow.length=w,r.pointShadowMap.length=w,r.spotShadow.length=S,r.spotShadowMap.length=S,r.directionalShadowMatrix.length=x,r.pointShadowMatrix.length=w,r.spotShadowMatrix.length=S,_.directionalLength=g,_.pointLength=m,_.spotLength=y,_.rectAreaLength=v,_.hemiLength=b,_.numDirectionalShadows=x,_.numPointShadows=w,_.numSpotShadows=S,r.version=oK++)}function c(h,u){let d=0,p=0,f=0,g=0,m=0,y=u.matrixWorldInverse;for(let v=0,b=h.length;v<b;v++){let x=h[v];if(x.isDirectionalLight){let w=r.directional[d];w.direction.setFromMatrixPosition(x.matrixWorld),i.setFromMatrixPosition(x.target.matrixWorld),w.direction.sub(i),w.direction.transformDirection(y),d++}else if(x.isSpotLight){let w=r.spot[f];w.position.setFromMatrixPosition(x.matrixWorld),w.position.applyMatrix4(y),w.direction.setFromMatrixPosition(x.matrixWorld),i.setFromMatrixPosition(x.target.matrixWorld),w.direction.sub(i),w.direction.transformDirection(y),f++}else if(x.isRectAreaLight){let w=r.rectArea[g];w.position.setFromMatrixPosition(x.matrixWorld),w.position.applyMatrix4(y),a.identity(),o.copy(x.matrixWorld),o.premultiply(y),a.extractRotation(o),w.halfWidth.set(x.width*.5,0,0),w.halfHeight.set(0,x.height*.5,0),w.halfWidth.applyMatrix4(a),w.halfHeight.applyMatrix4(a),g++}else if(x.isPointLight){let w=r.point[p];w.position.setFromMatrixPosition(x.matrixWorld),w.position.applyMatrix4(y),p++}else if(x.isHemisphereLight){let w=r.hemi[m];w.direction.setFromMatrixPosition(x.matrixWorld),w.direction.transformDirection(y),m++}}}return{setup:l,setupView:c,state:r}}function HD(e,t){let n=new lK(e,t),s=[],r=[];function i(){s.length=0,r.length=0}function o(h){s.push(h)}function a(h){r.push(h)}function l(h){n.setup(s,h)}function c(h){n.setupView(s,h)}return{init:i,state:{lightsArray:s,shadowsArray:r,lights:n},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function cK(e,t){let n=new WeakMap;function s(i,o=0){let a;return n.has(i)===!1?(a=new HD(e,t),n.set(i,[a])):o>=n.get(i).length?(a=new HD(e,t),n.get(i).push(a)):a=n.get(i)[o],a}function r(){n=new WeakMap}return{get:s,dispose:r}}var jD=class extends Of{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=cl,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}},uK=class extends Of{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new I,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}},hK=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,dK=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function pK(e,t,n){let s=new TS,r=new se,i=new se,o=new Bt,a=new jD({depthPacking:Zk}),l=new uK,c={},h=n.maxTextureSize,u={0:dr,1:jl,2:Ao},d=new Ms({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new se},radius:{value:4}},vertexShader:hK,fragmentShader:dK}),p=d.clone();p.defines.HORIZONTAL_PASS=1;let f=new It;f.setAttribute("position",new Lt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));let g=new bi(f,d),m=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Vw,this.render=function(x,w,S){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||x.length===0)return;let C=e.getRenderTarget(),_=e.getActiveCubeFace(),T=e.getActiveMipmapLevel(),E=e.state;E.setBlending(nr),E.buffers.color.setClear(1,1,1,1),E.buffers.depth.setTest(!0),E.setScissorTest(!1);for(let A=0,D=x.length;A<D;A++){let O=x[A],P=O.shadow;if(P===void 0){console.warn("THREE.WebGLShadowMap:",O,"has no shadow.");continue}if(P.autoUpdate===!1&&P.needsUpdate===!1)continue;r.copy(P.mapSize);let L=P.getFrameExtents();if(r.multiply(L),i.copy(P.mapSize),(r.x>h||r.y>h)&&(r.x>h&&(i.x=Math.floor(h/L.x),r.x=i.x*L.x,P.mapSize.x=i.x),r.y>h&&(i.y=Math.floor(h/L.y),r.y=i.y*L.y,P.mapSize.y=i.y)),P.map===null){let F=this.type!==Cf?{minFilter:ns,magFilter:ns}:{};P.map=new hs(r.x,r.y,F),P.map.texture.name=O.name+".shadowMap",P.camera.updateProjectionMatrix()}e.setRenderTarget(P.map),e.clear();let B=P.getViewportCount();for(let F=0;F<B;F++){let M=P.getViewport(F);o.set(i.x*M.x,i.y*M.y,i.x*M.z,i.y*M.w),E.viewport(o),P.updateMatrices(O,F),s=P.getFrustum(),b(w,S,P.camera,O,this.type)}P.isPointLightShadow!==!0&&this.type===Cf&&y(P,S),P.needsUpdate=!1}m.needsUpdate=!1,e.setRenderTarget(C,_,T)};function y(x,w){let S=t.update(g);d.defines.VSM_SAMPLES!==x.blurSamples&&(d.defines.VSM_SAMPLES=x.blurSamples,p.defines.VSM_SAMPLES=x.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),x.mapPass===null&&(x.mapPass=new hs(r.x,r.y)),d.uniforms.shadow_pass.value=x.map.texture,d.uniforms.resolution.value=x.mapSize,d.uniforms.radius.value=x.radius,e.setRenderTarget(x.mapPass),e.clear(),e.renderBufferDirect(w,null,S,d,g,null),p.uniforms.shadow_pass.value=x.mapPass.texture,p.uniforms.resolution.value=x.mapSize,p.uniforms.radius.value=x.radius,e.setRenderTarget(x.map),e.clear(),e.renderBufferDirect(w,null,S,p,g,null)}function v(x,w,S,C,_,T){let E=null,A=S.isPointLight===!0?x.customDistanceMaterial:x.customDepthMaterial;if(A!==void 0?E=A:E=S.isPointLight===!0?l:a,e.localClippingEnabled&&w.clipShadows===!0&&Array.isArray(w.clippingPlanes)&&w.clippingPlanes.length!==0||w.displacementMap&&w.displacementScale!==0||w.alphaMap&&w.alphaTest>0){let D=E.uuid,O=w.uuid,P=c[D];P===void 0&&(P={},c[D]=P);let L=P[O];L===void 0&&(L=E.clone(),P[O]=L),E=L}return E.visible=w.visible,E.wireframe=w.wireframe,T===Cf?E.side=w.shadowSide!==null?w.shadowSide:w.side:E.side=w.shadowSide!==null?w.shadowSide:u[w.side],E.alphaMap=w.alphaMap,E.alphaTest=w.alphaTest,E.clipShadows=w.clipShadows,E.clippingPlanes=w.clippingPlanes,E.clipIntersection=w.clipIntersection,E.displacementMap=w.displacementMap,E.displacementScale=w.displacementScale,E.displacementBias=w.displacementBias,E.wireframeLinewidth=w.wireframeLinewidth,E.linewidth=w.linewidth,S.isPointLight===!0&&E.isMeshDistanceMaterial===!0&&(E.referencePosition.setFromMatrixPosition(S.matrixWorld),E.nearDistance=C,E.farDistance=_),E}function b(x,w,S,C,_){if(x.visible===!1)return;if(x.layers.test(w.layers)&&(x.isMesh||x.isLine||x.isPoints)&&(x.castShadow||x.receiveShadow&&_===Cf)&&(!x.frustumCulled||s.intersectsObject(x))){x.modelViewMatrix.multiplyMatrices(S.matrixWorldInverse,x.matrixWorld);let E=t.update(x),A=x.material;if(Array.isArray(A)){let D=E.groups;for(let O=0,P=D.length;O<P;O++){let L=D[O],B=A[L.materialIndex];if(B&&B.visible){let F=v(x,B,C,S.near,S.far,_);e.renderBufferDirect(S,null,E,F,x,L)}}}else if(A.visible){let D=v(x,A,C,S.near,S.far,_);e.renderBufferDirect(S,null,E,D,x,null)}}let T=x.children;for(let E=0,A=T.length;E<A;E++)b(T[E],w,S,C,_)}}function fK(e,t,n){let s=n.isWebGL2;function r(){let te=!1,Ke=new Bt,qe=null,Et=new Bt(0,0,0,0);return{setMask:function(it){qe!==it&&!te&&(e.colorMask(it,it,it,it),qe=it)},setLocked:function(it){te=it},setClear:function(it,At,Ge,yt,nt){nt===!0&&(it*=yt,At*=yt,Ge*=yt),Ke.set(it,At,Ge,yt),Et.equals(Ke)===!1&&(e.clearColor(it,At,Ge,yt),Et.copy(Ke))},reset:function(){te=!1,qe=null,Et.set(-1,0,0,0)}}}function i(){let te=!1,Ke=null,qe=null,Et=null;return{setTest:function(it){it?Y(2929):X(2929)},setMask:function(it){Ke!==it&&!te&&(e.depthMask(it),Ke=it)},setFunc:function(it){if(qe!==it){if(it)switch(it){case O6:e.depthFunc(512);break;case R6:e.depthFunc(519);break;case L6:e.depthFunc(513);break;case Gw:e.depthFunc(515);break;case F6:e.depthFunc(514);break;case $6:e.depthFunc(518);break;case B6:e.depthFunc(516);break;case z6:e.depthFunc(517);break;default:e.depthFunc(515)}else e.depthFunc(515);qe=it}},setLocked:function(it){te=it},setClear:function(it){Et!==it&&(e.clearDepth(it),Et=it)},reset:function(){te=!1,Ke=null,qe=null,Et=null}}}function o(){let te=!1,Ke=null,qe=null,Et=null,it=null,At=null,Ge=null,yt=null,nt=null;return{setTest:function(Je){te||(Je?Y(2960):X(2960))},setMask:function(Je){Ke!==Je&&!te&&(e.stencilMask(Je),Ke=Je)},setFunc:function(Je,mt,Dt){(qe!==Je||Et!==mt||it!==Dt)&&(e.stencilFunc(Je,mt,Dt),qe=Je,Et=mt,it=Dt)},setOp:function(Je,mt,Dt){(At!==Je||Ge!==mt||yt!==Dt)&&(e.stencilOp(Je,mt,Dt),At=Je,Ge=mt,yt=Dt)},setLocked:function(Je){te=Je},setClear:function(Je){nt!==Je&&(e.clearStencil(Je),nt=Je)},reset:function(){te=!1,Ke=null,qe=null,Et=null,it=null,At=null,Ge=null,yt=null,nt=null}}}let a=new r,l=new i,c=new o,h={},u={},d=new WeakMap,p=[],f=null,g=!1,m=null,y=null,v=null,b=null,x=null,w=null,S=null,C=!1,_=null,T=null,E=null,A=null,D=null,O=e.getParameter(35661),P=!1,L=0,B=e.getParameter(7938);B.indexOf("WebGL")!==-1?(L=parseFloat(/^WebGL (\d)/.exec(B)[1]),P=L>=1):B.indexOf("OpenGL ES")!==-1&&(L=parseFloat(/^OpenGL ES (\d)/.exec(B)[1]),P=L>=2);let F=null,M={},U=e.getParameter(3088),z=e.getParameter(2978),$=new Bt().fromArray(U),R=new Bt().fromArray(z);function H(te,Ke,qe){let Et=new Uint8Array(4),it=e.createTexture();e.bindTexture(te,it),e.texParameteri(te,10241,9728),e.texParameteri(te,10240,9728);for(let At=0;At<qe;At++)e.texImage2D(Ke+At,0,6408,1,1,0,6408,5121,Et);return it}let K={};K[3553]=H(3553,3553,1),K[34067]=H(34067,34069,6),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),Y(2929),l.setFunc(Gw),Me(!1),Ie(yk),Y(2884),_e(nr);function Y(te){h[te]!==!0&&(e.enable(te),h[te]=!0)}function X(te){h[te]!==!1&&(e.disable(te),h[te]=!1)}function oe(te,Ke){return u[te]!==Ke?(e.bindFramebuffer(te,Ke),u[te]=Ke,s&&(te===36009&&(u[36160]=Ke),te===36160&&(u[36009]=Ke)),!0):!1}function ie(te,Ke){let qe=p,Et=!1;if(te)if(qe=d.get(Ke),qe===void 0&&(qe=[],d.set(Ke,qe)),te.isWebGLMultipleRenderTargets){let it=te.texture;if(qe.length!==it.length||qe[0]!==36064){for(let At=0,Ge=it.length;At<Ge;At++)qe[At]=36064+At;qe.length=it.length,Et=!0}}else qe[0]!==36064&&(qe[0]=36064,Et=!0);else qe[0]!==1029&&(qe[0]=1029,Et=!0);Et&&(n.isWebGL2?e.drawBuffers(qe):t.get("WEBGL_draw_buffers").drawBuffersWEBGL(qe))}function Z(te){return f!==te?(e.useProgram(te),f=te,!0):!1}let ce={[Yh]:32774,[_6]:32778,[C6]:32779};if(s)ce[Sk]=32775,ce[_k]=32776;else{let te=t.get("EXT_blend_minmax");te!==null&&(ce[Sk]=te.MIN_EXT,ce[_k]=te.MAX_EXT)}let ge={[T6]:0,[E6]:1,[A6]:768,[Ck]:770,[P6]:776,[D6]:774,[N6]:772,[I6]:769,[Tk]:771,[M6]:775,[k6]:773};function _e(te,Ke,qe,Et,it,At,Ge,yt){if(te===nr){g===!0&&(X(3042),g=!1);return}if(g===!1&&(Y(3042),g=!0),te!==S6){if(te!==m||yt!==C){if((y!==Yh||x!==Yh)&&(e.blendEquation(32774),y=Yh,x=Yh),yt)switch(te){case Kh:e.blendFuncSeparate(1,771,1,771);break;case xk:e.blendFunc(1,1);break;case bk:e.blendFuncSeparate(0,769,0,1);break;case wk:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",te);break}else switch(te){case Kh:e.blendFuncSeparate(770,771,1,771);break;case xk:e.blendFunc(770,1);break;case bk:e.blendFuncSeparate(0,769,0,1);break;case wk:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",te);break}v=null,b=null,w=null,S=null,m=te,C=yt}return}it=it||Ke,At=At||qe,Ge=Ge||Et,(Ke!==y||it!==x)&&(e.blendEquationSeparate(ce[Ke],ce[it]),y=Ke,x=it),(qe!==v||Et!==b||At!==w||Ge!==S)&&(e.blendFuncSeparate(ge[qe],ge[Et],ge[At],ge[Ge]),v=qe,b=Et,w=At,S=Ge),m=te,C=null}function be(te,Ke){te.side===Ao?X(2884):Y(2884);let qe=te.side===dr;Ke&&(qe=!qe),Me(qe),te.blending===Kh&&te.transparent===!1?_e(nr):_e(te.blending,te.blendEquation,te.blendSrc,te.blendDst,te.blendEquationAlpha,te.blendSrcAlpha,te.blendDstAlpha,te.premultipliedAlpha),l.setFunc(te.depthFunc),l.setTest(te.depthTest),l.setMask(te.depthWrite),a.setMask(te.colorWrite);let Et=te.stencilWrite;c.setTest(Et),Et&&(c.setMask(te.stencilWriteMask),c.setFunc(te.stencilFunc,te.stencilRef,te.stencilFuncMask),c.setOp(te.stencilFail,te.stencilZFail,te.stencilZPass)),Ue(te.polygonOffset,te.polygonOffsetFactor,te.polygonOffsetUnits),te.alphaToCoverage===!0?Y(32926):X(32926)}function Me(te){_!==te&&(te?e.frontFace(2304):e.frontFace(2305),_=te)}function Ie(te){te!==x6?(Y(2884),te!==T&&(te===yk?e.cullFace(1029):te===b6?e.cullFace(1028):e.cullFace(1032))):X(2884),T=te}function Le(te){te!==E&&(P&&e.lineWidth(te),E=te)}function Ue(te,Ke,qe){te?(Y(32823),(A!==Ke||D!==qe)&&(e.polygonOffset(Ke,qe),A=Ke,D=qe)):X(32823)}function $e(te){te?Y(3089):X(3089)}function We(te){te===void 0&&(te=33984+O-1),F!==te&&(e.activeTexture(te),F=te)}function Rt(te,Ke){F===null&&We();let qe=M[F];qe===void 0&&(qe={type:void 0,texture:void 0},M[F]=qe),(qe.type!==te||qe.texture!==Ke)&&(e.bindTexture(te,Ke||K[te]),qe.type=te,qe.texture=Ke)}function ct(){let te=M[F];te!==void 0&&te.type!==void 0&&(e.bindTexture(te.type,null),te.type=void 0,te.texture=void 0)}function j(){try{e.compressedTexImage2D.apply(e,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function V(){try{e.texSubImage2D.apply(e,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function we(){try{e.texSubImage3D.apply(e,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function Pe(){try{e.compressedTexSubImage2D.apply(e,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function Be(){try{e.texStorage2D.apply(e,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function je(){try{e.texStorage3D.apply(e,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function pt(){try{e.texImage2D.apply(e,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function Te(){try{e.texImage3D.apply(e,arguments)}catch(te){console.error("THREE.WebGLState:",te)}}function ut(te){$.equals(te)===!1&&(e.scissor(te.x,te.y,te.z,te.w),$.copy(te))}function He(te){R.equals(te)===!1&&(e.viewport(te.x,te.y,te.z,te.w),R.copy(te))}function Xe(){e.disable(3042),e.disable(2884),e.disable(2929),e.disable(32823),e.disable(3089),e.disable(2960),e.disable(32926),e.blendEquation(32774),e.blendFunc(1,0),e.blendFuncSeparate(1,0,1,0),e.colorMask(!0,!0,!0,!0),e.clearColor(0,0,0,0),e.depthMask(!0),e.depthFunc(513),e.clearDepth(1),e.stencilMask(4294967295),e.stencilFunc(519,0,4294967295),e.stencilOp(7680,7680,7680),e.clearStencil(0),e.cullFace(1029),e.frontFace(2305),e.polygonOffset(0,0),e.activeTexture(33984),e.bindFramebuffer(36160,null),s===!0&&(e.bindFramebuffer(36009,null),e.bindFramebuffer(36008,null)),e.useProgram(null),e.lineWidth(1),e.scissor(0,0,e.canvas.width,e.canvas.height),e.viewport(0,0,e.canvas.width,e.canvas.height),h={},F=null,M={},u={},d=new WeakMap,p=[],f=null,g=!1,m=null,y=null,v=null,b=null,x=null,w=null,S=null,C=!1,_=null,T=null,E=null,A=null,D=null,$.set(0,0,e.canvas.width,e.canvas.height),R.set(0,0,e.canvas.width,e.canvas.height),a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:Y,disable:X,bindFramebuffer:oe,drawBuffers:ie,useProgram:Z,setBlending:_e,setMaterial:be,setFlipSided:Me,setCullFace:Ie,setLineWidth:Le,setPolygonOffset:Ue,setScissorTest:$e,activeTexture:We,bindTexture:Rt,unbindTexture:ct,compressedTexImage2D:j,texImage2D:pt,texImage3D:Te,texStorage2D:Be,texStorage3D:je,texSubImage2D:V,texSubImage3D:we,compressedTexSubImage2D:Pe,scissor:ut,viewport:He,reset:Xe}}function mK(e,t,n,s,r,i,o){let a=r.isWebGL2,l=r.maxTextures,c=r.maxCubemapSize,h=r.maxTextureSize,u=r.maxSamples,d=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,p=/OculusBrowser/g.test(navigator.userAgent),f=new WeakMap,g,m=new WeakMap,y=!1;try{y=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function v(j,V){return y?new OffscreenCanvas(j,V):ny("canvas")}function b(j,V,we,Pe){let Be=1;if((j.width>Pe||j.height>Pe)&&(Be=Pe/Math.max(j.width,j.height)),Be<1||V===!0)if(typeof HTMLImageElement<"u"&&j instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&j instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&j instanceof ImageBitmap){let je=V?ey:Math.floor,pt=je(Be*j.width),Te=je(Be*j.height);g===void 0&&(g=v(pt,Te));let ut=we?v(pt,Te):g;return ut.width=pt,ut.height=Te,ut.getContext("2d").drawImage(j,0,0,pt,Te),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+j.width+"x"+j.height+") to ("+pt+"x"+Te+")."),ut}else return"data"in j&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+j.width+"x"+j.height+")."),j;return j}function x(j){return tS(j.width)&&tS(j.height)}function w(j){return a?!1:j.wrapS!==yi||j.wrapT!==yi||j.minFilter!==ns&&j.minFilter!==xn}function S(j,V){return j.generateMipmaps&&V&&j.minFilter!==ns&&j.minFilter!==xn}function C(j){e.generateMipmap(j)}function _(j,V,we,Pe,Be=!1){if(a===!1)return V;if(j!==null){if(e[j]!==void 0)return e[j];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+j+"'")}let je=V;return V===6403&&(we===5126&&(je=33326),we===5131&&(je=33325),we===5121&&(je=33321)),V===33319&&(we===5126&&(je=33328),we===5131&&(je=33327),we===5121&&(je=33323)),V===6408&&(we===5126&&(je=34836),we===5131&&(je=34842),we===5121&&(je=Pe===Gt&&Be===!1?35907:32856),we===32819&&(je=32854),we===32820&&(je=32855)),(je===33325||je===33326||je===33327||je===33328||je===34842||je===34836)&&t.get("EXT_color_buffer_float"),je}function T(j,V,we){return S(j,we)===!0||j.isFramebufferTexture&&j.minFilter!==ns&&j.minFilter!==xn?Math.log2(Math.max(V.width,V.height))+1:j.mipmaps!==void 0&&j.mipmaps.length>0?j.mipmaps.length:j.isCompressedTexture&&Array.isArray(j.image)?V.mipmaps.length:1}function E(j){return j===ns||j===Ik||j===Nk?9728:9729}function A(j){let V=j.target;V.removeEventListener("dispose",A),O(V),V.isVideoTexture&&f.delete(V)}function D(j){let V=j.target;V.removeEventListener("dispose",D),L(V)}function O(j){let V=s.get(j);if(V.__webglInit===void 0)return;let we=j.source,Pe=m.get(we);if(Pe){let Be=Pe[V.__cacheKey];Be.usedTimes--,Be.usedTimes===0&&P(j),Object.keys(Pe).length===0&&m.delete(we)}s.remove(j)}function P(j){let V=s.get(j);e.deleteTexture(V.__webglTexture);let we=j.source,Pe=m.get(we);delete Pe[V.__cacheKey],o.memory.textures--}function L(j){let V=j.texture,we=s.get(j),Pe=s.get(V);if(Pe.__webglTexture!==void 0&&(e.deleteTexture(Pe.__webglTexture),o.memory.textures--),j.depthTexture&&j.depthTexture.dispose(),j.isWebGLCubeRenderTarget)for(let Be=0;Be<6;Be++)e.deleteFramebuffer(we.__webglFramebuffer[Be]),we.__webglDepthbuffer&&e.deleteRenderbuffer(we.__webglDepthbuffer[Be]);else{if(e.deleteFramebuffer(we.__webglFramebuffer),we.__webglDepthbuffer&&e.deleteRenderbuffer(we.__webglDepthbuffer),we.__webglMultisampledFramebuffer&&e.deleteFramebuffer(we.__webglMultisampledFramebuffer),we.__webglColorRenderbuffer)for(let Be=0;Be<we.__webglColorRenderbuffer.length;Be++)we.__webglColorRenderbuffer[Be]&&e.deleteRenderbuffer(we.__webglColorRenderbuffer[Be]);we.__webglDepthRenderbuffer&&e.deleteRenderbuffer(we.__webglDepthRenderbuffer)}if(j.isWebGLMultipleRenderTargets)for(let Be=0,je=V.length;Be<je;Be++){let pt=s.get(V[Be]);pt.__webglTexture&&(e.deleteTexture(pt.__webglTexture),o.memory.textures--),s.remove(V[Be])}s.remove(V),s.remove(j)}let B=0;function F(){B=0}function M(){let j=B;return j>=l&&console.warn("THREE.WebGLTextures: Trying to use "+j+" texture units while this GPU supports only "+l),B+=1,j}function U(j){let V=[];return V.push(j.wrapS),V.push(j.wrapT),V.push(j.magFilter),V.push(j.minFilter),V.push(j.anisotropy),V.push(j.internalFormat),V.push(j.format),V.push(j.type),V.push(j.generateMipmaps),V.push(j.premultiplyAlpha),V.push(j.flipY),V.push(j.unpackAlignment),V.push(j.encoding),V.join()}function z(j,V){let we=s.get(j);if(j.isVideoTexture&&Rt(j),j.isRenderTargetTexture===!1&&j.version>0&&we.__version!==j.version){let Pe=j.image;if(Pe===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Pe.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{ie(we,j,V);return}}n.activeTexture(33984+V),n.bindTexture(3553,we.__webglTexture)}function $(j,V){let we=s.get(j);if(j.version>0&&we.__version!==j.version){ie(we,j,V);return}n.activeTexture(33984+V),n.bindTexture(35866,we.__webglTexture)}function R(j,V){let we=s.get(j);if(j.version>0&&we.__version!==j.version){ie(we,j,V);return}n.activeTexture(33984+V),n.bindTexture(32879,we.__webglTexture)}function H(j,V){let we=s.get(j);if(j.version>0&&we.__version!==j.version){Z(we,j,V);return}n.activeTexture(33984+V),n.bindTexture(34067,we.__webglTexture)}let K={[Ef]:10497,[yi]:33071,[jw]:33648},Y={[ns]:9728,[Ik]:9984,[Nk]:9986,[xn]:9729,[X6]:9985,[Af]:9987};function X(j,V,we){if(we?(e.texParameteri(j,10242,K[V.wrapS]),e.texParameteri(j,10243,K[V.wrapT]),(j===32879||j===35866)&&e.texParameteri(j,32882,K[V.wrapR]),e.texParameteri(j,10240,Y[V.magFilter]),e.texParameteri(j,10241,Y[V.minFilter])):(e.texParameteri(j,10242,33071),e.texParameteri(j,10243,33071),(j===32879||j===35866)&&e.texParameteri(j,32882,33071),(V.wrapS!==yi||V.wrapT!==yi)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(j,10240,E(V.magFilter)),e.texParameteri(j,10241,E(V.minFilter)),V.minFilter!==ns&&V.minFilter!==xn&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){let Pe=t.get("EXT_texture_filter_anisotropic");if(V.type===Xl&&t.has("OES_texture_float_linear")===!1||a===!1&&V.type===If&&t.has("OES_texture_half_float_linear")===!1)return;(V.anisotropy>1||s.get(V).__currentAnisotropy)&&(e.texParameterf(j,Pe.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(V.anisotropy,r.getMaxAnisotropy())),s.get(V).__currentAnisotropy=V.anisotropy)}}function oe(j,V){let we=!1;j.__webglInit===void 0&&(j.__webglInit=!0,V.addEventListener("dispose",A));let Pe=V.source,Be=m.get(Pe);Be===void 0&&(Be={},m.set(Pe,Be));let je=U(V);if(je!==j.__cacheKey){Be[je]===void 0&&(Be[je]={texture:e.createTexture(),usedTimes:0},o.memory.textures++,we=!0),Be[je].usedTimes++;let pt=Be[j.__cacheKey];pt!==void 0&&(Be[j.__cacheKey].usedTimes--,pt.usedTimes===0&&P(V)),j.__cacheKey=je,j.__webglTexture=Be[je].texture}return we}function ie(j,V,we){let Pe=3553;V.isDataArrayTexture&&(Pe=35866),V.isData3DTexture&&(Pe=32879);let Be=oe(j,V),je=V.source;if(n.activeTexture(33984+we),n.bindTexture(Pe,j.__webglTexture),je.version!==je.__currentVersion||Be===!0){e.pixelStorei(37440,V.flipY),e.pixelStorei(37441,V.premultiplyAlpha),e.pixelStorei(3317,V.unpackAlignment),e.pixelStorei(37443,0);let pt=w(V)&&x(V.image)===!1,Te=b(V.image,pt,!1,h);Te=ct(V,Te);let ut=x(Te)||a,He=i.convert(V.format,V.encoding),Xe=i.convert(V.type),te=_(V.internalFormat,He,Xe,V.encoding,V.isVideoTexture);X(Pe,V,ut);let Ke,qe=V.mipmaps,Et=a&&V.isVideoTexture!==!0,it=je.__currentVersion===void 0||Be===!0,At=T(V,Te,ut);if(V.isDepthTexture)te=6402,a?V.type===Xl?te=36012:V.type===ql?te=33190:V.type===pu?te=35056:te=33189:V.type===Xl&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),V.format===fu&&te===6402&&V.type!==kk&&V.type!==ql&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),V.type=ql,Xe=i.convert(V.type)),V.format===mu&&te===6402&&(te=34041,V.type!==pu&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),V.type=pu,Xe=i.convert(V.type))),it&&(Et?n.texStorage2D(3553,1,te,Te.width,Te.height):n.texImage2D(3553,0,te,Te.width,Te.height,0,He,Xe,null));else if(V.isDataTexture)if(qe.length>0&&ut){Et&&it&&n.texStorage2D(3553,At,te,qe[0].width,qe[0].height);for(let Ge=0,yt=qe.length;Ge<yt;Ge++)Ke=qe[Ge],Et?n.texSubImage2D(3553,Ge,0,0,Ke.width,Ke.height,He,Xe,Ke.data):n.texImage2D(3553,Ge,te,Ke.width,Ke.height,0,He,Xe,Ke.data);V.generateMipmaps=!1}else Et?(it&&n.texStorage2D(3553,At,te,Te.width,Te.height),n.texSubImage2D(3553,0,0,0,Te.width,Te.height,He,Xe,Te.data)):n.texImage2D(3553,0,te,Te.width,Te.height,0,He,Xe,Te.data);else if(V.isCompressedTexture){Et&&it&&n.texStorage2D(3553,At,te,qe[0].width,qe[0].height);for(let Ge=0,yt=qe.length;Ge<yt;Ge++)Ke=qe[Ge],V.format!==ua?He!==null?Et?n.compressedTexSubImage2D(3553,Ge,0,0,Ke.width,Ke.height,He,Ke.data):n.compressedTexImage2D(3553,Ge,te,Ke.width,Ke.height,0,Ke.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Et?n.texSubImage2D(3553,Ge,0,0,Ke.width,Ke.height,He,Xe,Ke.data):n.texImage2D(3553,Ge,te,Ke.width,Ke.height,0,He,Xe,Ke.data)}else if(V.isDataArrayTexture)Et?(it&&n.texStorage3D(35866,At,te,Te.width,Te.height,Te.depth),n.texSubImage3D(35866,0,0,0,0,Te.width,Te.height,Te.depth,He,Xe,Te.data)):n.texImage3D(35866,0,te,Te.width,Te.height,Te.depth,0,He,Xe,Te.data);else if(V.isData3DTexture)Et?(it&&n.texStorage3D(32879,At,te,Te.width,Te.height,Te.depth),n.texSubImage3D(32879,0,0,0,0,Te.width,Te.height,Te.depth,He,Xe,Te.data)):n.texImage3D(32879,0,te,Te.width,Te.height,Te.depth,0,He,Xe,Te.data);else if(V.isFramebufferTexture){if(it)if(Et)n.texStorage2D(3553,At,te,Te.width,Te.height);else{let Ge=Te.width,yt=Te.height;for(let nt=0;nt<At;nt++)n.texImage2D(3553,nt,te,Ge,yt,0,He,Xe,null),Ge>>=1,yt>>=1}}else if(qe.length>0&&ut){Et&&it&&n.texStorage2D(3553,At,te,qe[0].width,qe[0].height);for(let Ge=0,yt=qe.length;Ge<yt;Ge++)Ke=qe[Ge],Et?n.texSubImage2D(3553,Ge,0,0,He,Xe,Ke):n.texImage2D(3553,Ge,te,He,Xe,Ke);V.generateMipmaps=!1}else Et?(it&&n.texStorage2D(3553,At,te,Te.width,Te.height),n.texSubImage2D(3553,0,0,0,He,Xe,Te)):n.texImage2D(3553,0,te,He,Xe,Te);S(V,ut)&&C(Pe),je.__currentVersion=je.version,V.onUpdate&&V.onUpdate(V)}j.__version=V.version}function Z(j,V,we){if(V.image.length!==6)return;let Pe=oe(j,V),Be=V.source;if(n.activeTexture(33984+we),n.bindTexture(34067,j.__webglTexture),Be.version!==Be.__currentVersion||Pe===!0){e.pixelStorei(37440,V.flipY),e.pixelStorei(37441,V.premultiplyAlpha),e.pixelStorei(3317,V.unpackAlignment),e.pixelStorei(37443,0);let je=V.isCompressedTexture||V.image[0].isCompressedTexture,pt=V.image[0]&&V.image[0].isDataTexture,Te=[];for(let Ge=0;Ge<6;Ge++)!je&&!pt?Te[Ge]=b(V.image[Ge],!1,!0,c):Te[Ge]=pt?V.image[Ge].image:V.image[Ge],Te[Ge]=ct(V,Te[Ge]);let ut=Te[0],He=x(ut)||a,Xe=i.convert(V.format,V.encoding),te=i.convert(V.type),Ke=_(V.internalFormat,Xe,te,V.encoding),qe=a&&V.isVideoTexture!==!0,Et=Be.__currentVersion===void 0||Pe===!0,it=T(V,ut,He);X(34067,V,He);let At;if(je){qe&&Et&&n.texStorage2D(34067,it,Ke,ut.width,ut.height);for(let Ge=0;Ge<6;Ge++){At=Te[Ge].mipmaps;for(let yt=0;yt<At.length;yt++){let nt=At[yt];V.format!==ua?Xe!==null?qe?n.compressedTexSubImage2D(34069+Ge,yt,0,0,nt.width,nt.height,Xe,nt.data):n.compressedTexImage2D(34069+Ge,yt,Ke,nt.width,nt.height,0,nt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):qe?n.texSubImage2D(34069+Ge,yt,0,0,nt.width,nt.height,Xe,te,nt.data):n.texImage2D(34069+Ge,yt,Ke,nt.width,nt.height,0,Xe,te,nt.data)}}}else{At=V.mipmaps,qe&&Et&&(At.length>0&&it++,n.texStorage2D(34067,it,Ke,Te[0].width,Te[0].height));for(let Ge=0;Ge<6;Ge++)if(pt){qe?n.texSubImage2D(34069+Ge,0,0,0,Te[Ge].width,Te[Ge].height,Xe,te,Te[Ge].data):n.texImage2D(34069+Ge,0,Ke,Te[Ge].width,Te[Ge].height,0,Xe,te,Te[Ge].data);for(let yt=0;yt<At.length;yt++){let nt=At[yt].image[Ge].image;qe?n.texSubImage2D(34069+Ge,yt+1,0,0,nt.width,nt.height,Xe,te,nt.data):n.texImage2D(34069+Ge,yt+1,Ke,nt.width,nt.height,0,Xe,te,nt.data)}}else{qe?n.texSubImage2D(34069+Ge,0,0,0,Xe,te,Te[Ge]):n.texImage2D(34069+Ge,0,Ke,Xe,te,Te[Ge]);for(let yt=0;yt<At.length;yt++){let nt=At[yt];qe?n.texSubImage2D(34069+Ge,yt+1,0,0,Xe,te,nt.image[Ge]):n.texImage2D(34069+Ge,yt+1,Ke,Xe,te,nt.image[Ge])}}}S(V,He)&&C(34067),Be.__currentVersion=Be.version,V.onUpdate&&V.onUpdate(V)}j.__version=V.version}function ce(j,V,we,Pe,Be){let je=i.convert(we.format,we.encoding),pt=i.convert(we.type),Te=_(we.internalFormat,je,pt,we.encoding);s.get(V).__hasExternalTextures||(Be===32879||Be===35866?n.texImage3D(Be,0,Te,V.width,V.height,V.depth,0,je,pt,null):n.texImage2D(Be,0,Te,V.width,V.height,0,je,pt,null)),n.bindFramebuffer(36160,j),We(V)?d.framebufferTexture2DMultisampleEXT(36160,Pe,Be,s.get(we).__webglTexture,0,$e(V)):e.framebufferTexture2D(36160,Pe,Be,s.get(we).__webglTexture,0),n.bindFramebuffer(36160,null)}function ge(j,V,we){if(e.bindRenderbuffer(36161,j),V.depthBuffer&&!V.stencilBuffer){let Pe=33189;if(we||We(V)){let Be=V.depthTexture;Be&&Be.isDepthTexture&&(Be.type===Xl?Pe=36012:Be.type===ql&&(Pe=33190));let je=$e(V);We(V)?d.renderbufferStorageMultisampleEXT(36161,je,Pe,V.width,V.height):e.renderbufferStorageMultisample(36161,je,Pe,V.width,V.height)}else e.renderbufferStorage(36161,Pe,V.width,V.height);e.framebufferRenderbuffer(36160,36096,36161,j)}else if(V.depthBuffer&&V.stencilBuffer){let Pe=$e(V);we&&We(V)===!1?e.renderbufferStorageMultisample(36161,Pe,35056,V.width,V.height):We(V)?d.renderbufferStorageMultisampleEXT(36161,Pe,35056,V.width,V.height):e.renderbufferStorage(36161,34041,V.width,V.height),e.framebufferRenderbuffer(36160,33306,36161,j)}else{let Pe=V.isWebGLMultipleRenderTargets===!0?V.texture:[V.texture];for(let Be=0;Be<Pe.length;Be++){let je=Pe[Be],pt=i.convert(je.format,je.encoding),Te=i.convert(je.type),ut=_(je.internalFormat,pt,Te,je.encoding),He=$e(V);we&&We(V)===!1?e.renderbufferStorageMultisample(36161,He,ut,V.width,V.height):We(V)?d.renderbufferStorageMultisampleEXT(36161,He,ut,V.width,V.height):e.renderbufferStorage(36161,ut,V.width,V.height)}}e.bindRenderbuffer(36161,null)}function _e(j,V){if(V&&V.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,j),!(V.depthTexture&&V.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!s.get(V.depthTexture).__webglTexture||V.depthTexture.image.width!==V.width||V.depthTexture.image.height!==V.height)&&(V.depthTexture.image.width=V.width,V.depthTexture.image.height=V.height,V.depthTexture.needsUpdate=!0),z(V.depthTexture,0);let we=s.get(V.depthTexture).__webglTexture,Pe=$e(V);if(V.depthTexture.format===fu)We(V)?d.framebufferTexture2DMultisampleEXT(36160,36096,3553,we,0,Pe):e.framebufferTexture2D(36160,36096,3553,we,0);else if(V.depthTexture.format===mu)We(V)?d.framebufferTexture2DMultisampleEXT(36160,33306,3553,we,0,Pe):e.framebufferTexture2D(36160,33306,3553,we,0);else throw new Error("Unknown depthTexture format")}function be(j){let V=s.get(j),we=j.isWebGLCubeRenderTarget===!0;if(j.depthTexture&&!V.__autoAllocateDepthBuffer){if(we)throw new Error("target.depthTexture not supported in Cube render targets");_e(V.__webglFramebuffer,j)}else if(we){V.__webglDepthbuffer=[];for(let Pe=0;Pe<6;Pe++)n.bindFramebuffer(36160,V.__webglFramebuffer[Pe]),V.__webglDepthbuffer[Pe]=e.createRenderbuffer(),ge(V.__webglDepthbuffer[Pe],j,!1)}else n.bindFramebuffer(36160,V.__webglFramebuffer),V.__webglDepthbuffer=e.createRenderbuffer(),ge(V.__webglDepthbuffer,j,!1);n.bindFramebuffer(36160,null)}function Me(j,V,we){let Pe=s.get(j);V!==void 0&&ce(Pe.__webglFramebuffer,j,j.texture,36064,3553),we!==void 0&&be(j)}function Ie(j){let V=j.texture,we=s.get(j),Pe=s.get(V);j.addEventListener("dispose",D),j.isWebGLMultipleRenderTargets!==!0&&(Pe.__webglTexture===void 0&&(Pe.__webglTexture=e.createTexture()),Pe.__version=V.version,o.memory.textures++);let Be=j.isWebGLCubeRenderTarget===!0,je=j.isWebGLMultipleRenderTargets===!0,pt=x(j)||a;if(Be){we.__webglFramebuffer=[];for(let Te=0;Te<6;Te++)we.__webglFramebuffer[Te]=e.createFramebuffer()}else{if(we.__webglFramebuffer=e.createFramebuffer(),je)if(r.drawBuffers){let Te=j.texture;for(let ut=0,He=Te.length;ut<He;ut++){let Xe=s.get(Te[ut]);Xe.__webglTexture===void 0&&(Xe.__webglTexture=e.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(a&&j.samples>0&&We(j)===!1){let Te=je?V:[V];we.__webglMultisampledFramebuffer=e.createFramebuffer(),we.__webglColorRenderbuffer=[],n.bindFramebuffer(36160,we.__webglMultisampledFramebuffer);for(let ut=0;ut<Te.length;ut++){let He=Te[ut];we.__webglColorRenderbuffer[ut]=e.createRenderbuffer(),e.bindRenderbuffer(36161,we.__webglColorRenderbuffer[ut]);let Xe=i.convert(He.format,He.encoding),te=i.convert(He.type),Ke=_(He.internalFormat,Xe,te,He.encoding),qe=$e(j);e.renderbufferStorageMultisample(36161,qe,Ke,j.width,j.height),e.framebufferRenderbuffer(36160,36064+ut,36161,we.__webglColorRenderbuffer[ut])}e.bindRenderbuffer(36161,null),j.depthBuffer&&(we.__webglDepthRenderbuffer=e.createRenderbuffer(),ge(we.__webglDepthRenderbuffer,j,!0)),n.bindFramebuffer(36160,null)}}if(Be){n.bindTexture(34067,Pe.__webglTexture),X(34067,V,pt);for(let Te=0;Te<6;Te++)ce(we.__webglFramebuffer[Te],j,V,36064,34069+Te);S(V,pt)&&C(34067),n.unbindTexture()}else if(je){let Te=j.texture;for(let ut=0,He=Te.length;ut<He;ut++){let Xe=Te[ut],te=s.get(Xe);n.bindTexture(3553,te.__webglTexture),X(3553,Xe,pt),ce(we.__webglFramebuffer,j,Xe,36064+ut,3553),S(Xe,pt)&&C(3553)}n.unbindTexture()}else{let Te=3553;(j.isWebGL3DRenderTarget||j.isWebGLArrayRenderTarget)&&(a?Te=j.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),n.bindTexture(Te,Pe.__webglTexture),X(Te,V,pt),ce(we.__webglFramebuffer,j,V,36064,Te),S(V,pt)&&C(Te),n.unbindTexture()}j.depthBuffer&&be(j)}function Le(j){let V=x(j)||a,we=j.isWebGLMultipleRenderTargets===!0?j.texture:[j.texture];for(let Pe=0,Be=we.length;Pe<Be;Pe++){let je=we[Pe];if(S(je,V)){let pt=j.isWebGLCubeRenderTarget?34067:3553,Te=s.get(je).__webglTexture;n.bindTexture(pt,Te),C(pt),n.unbindTexture()}}}function Ue(j){if(a&&j.samples>0&&We(j)===!1){let V=j.isWebGLMultipleRenderTargets?j.texture:[j.texture],we=j.width,Pe=j.height,Be=16384,je=[],pt=j.stencilBuffer?33306:36096,Te=s.get(j),ut=j.isWebGLMultipleRenderTargets===!0;if(ut)for(let He=0;He<V.length;He++)n.bindFramebuffer(36160,Te.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064+He,36161,null),n.bindFramebuffer(36160,Te.__webglFramebuffer),e.framebufferTexture2D(36009,36064+He,3553,null,0);n.bindFramebuffer(36008,Te.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,Te.__webglFramebuffer);for(let He=0;He<V.length;He++){je.push(36064+He),j.depthBuffer&&je.push(pt);let Xe=Te.__ignoreDepthValues!==void 0?Te.__ignoreDepthValues:!1;if(Xe===!1&&(j.depthBuffer&&(Be|=256),j.stencilBuffer&&(Be|=1024)),ut&&e.framebufferRenderbuffer(36008,36064,36161,Te.__webglColorRenderbuffer[He]),Xe===!0&&(e.invalidateFramebuffer(36008,[pt]),e.invalidateFramebuffer(36009,[pt])),ut){let te=s.get(V[He]).__webglTexture;e.framebufferTexture2D(36009,36064,3553,te,0)}e.blitFramebuffer(0,0,we,Pe,0,0,we,Pe,Be,9728),p&&e.invalidateFramebuffer(36008,je)}if(n.bindFramebuffer(36008,null),n.bindFramebuffer(36009,null),ut)for(let He=0;He<V.length;He++){n.bindFramebuffer(36160,Te.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064+He,36161,Te.__webglColorRenderbuffer[He]);let Xe=s.get(V[He]).__webglTexture;n.bindFramebuffer(36160,Te.__webglFramebuffer),e.framebufferTexture2D(36009,36064+He,3553,Xe,0)}n.bindFramebuffer(36009,Te.__webglMultisampledFramebuffer)}}function $e(j){return Math.min(u,j.samples)}function We(j){let V=s.get(j);return a&&j.samples>0&&t.has("WEBGL_multisampled_render_to_texture")===!0&&V.__useRenderToTexture!==!1}function Rt(j){let V=o.render.frame;f.get(j)!==V&&(f.set(j,V),j.update())}function ct(j,V){let we=j.encoding,Pe=j.format,Be=j.type;return j.isCompressedTexture===!0||j.isVideoTexture===!0||j.format===Jw||we!==ha&&(we===Gt?a===!1?t.has("EXT_sRGB")===!0&&Pe===ua?(j.format=Jw,j.minFilter=xn,j.generateMipmaps=!1):V=sD.sRGBToLinear(V):(Pe!==ua||Be!==pr)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",we)),V}this.allocateTextureUnit=M,this.resetTextureUnits=F,this.setTexture2D=z,this.setTexture2DArray=$,this.setTexture3D=R,this.setTextureCube=H,this.rebindTextures=Me,this.setupRenderTarget=Ie,this.updateRenderTargetMipmap=Le,this.updateMultisampleRenderTarget=Ue,this.setupDepthRenderbuffer=be,this.setupFrameBufferTexture=ce,this.useMultisampledRTT=We}function gK(e,t,n){let s=n.isWebGL2;function r(i,o=null){let a;if(i===pr)return 5121;if(i===Z6)return 32819;if(i===J6)return 32820;if(i===K6)return 5120;if(i===Y6)return 5122;if(i===kk)return 5123;if(i===Q6)return 5124;if(i===ql)return 5125;if(i===Xl)return 5126;if(i===If)return s?5131:(a=t.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(i===e8)return 6406;if(i===ua)return 6408;if(i===n8)return 6409;if(i===s8)return 6410;if(i===fu)return 6402;if(i===mu)return 34041;if(i===r8)return 6403;if(i===t8)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(i===Jw)return a=t.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(i===i8)return 36244;if(i===o8)return 33319;if(i===a8)return 33320;if(i===l8)return 36249;if(i===qw||i===Xw||i===Kw||i===Yw)if(o===Gt)if(a=t.get("WEBGL_compressed_texture_s3tc_srgb"),a!==null){if(i===qw)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(i===Xw)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(i===Kw)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(i===Yw)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(a=t.get("WEBGL_compressed_texture_s3tc"),a!==null){if(i===qw)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===Xw)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===Kw)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===Yw)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(i===Dk||i===Mk||i===Pk||i===Ok)if(a=t.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(i===Dk)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===Mk)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===Pk)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===Ok)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(i===c8)return a=t.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(i===Rk||i===Lk)if(a=t.get("WEBGL_compressed_texture_etc"),a!==null){if(i===Rk)return o===Gt?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(i===Lk)return o===Gt?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(i===Fk||i===$k||i===Bk||i===zk||i===Uk||i===Vk||i===Gk||i===Wk||i===Hk||i===jk||i===qk||i===Xk||i===Kk||i===Yk)if(a=t.get("WEBGL_compressed_texture_astc"),a!==null){if(i===Fk)return o===Gt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(i===$k)return o===Gt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(i===Bk)return o===Gt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(i===zk)return o===Gt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(i===Uk)return o===Gt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(i===Vk)return o===Gt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(i===Gk)return o===Gt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(i===Wk)return o===Gt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(i===Hk)return o===Gt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(i===jk)return o===Gt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(i===qk)return o===Gt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(i===Xk)return o===Gt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(i===Kk)return o===Gt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(i===Yk)return o===Gt?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(i===Qk)if(a=t.get("EXT_texture_compression_bptc"),a!==null){if(i===Qk)return o===Gt?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;return i===pu?s?34042:(a=t.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):e[i]!==void 0?e[i]:null}return{convert:r}}var yK=class extends vr{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}},yd=class extends Ln{constructor(){super(),this.isGroup=!0,this.type="Group"}},vK={type:"move"},MS=class{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new yd,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new yd,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new I,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new I),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new yd,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new I,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new I),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let s=null,r=null,i=null,o=this._targetRay,a=this._grip,l=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(l&&e.hand){i=!0;for(let f of e.hand.values()){let g=t.getJointPose(f,n);if(l.joints[f.jointName]===void 0){let y=new yd;y.matrixAutoUpdate=!1,y.visible=!1,l.joints[f.jointName]=y,l.add(y)}let m=l.joints[f.jointName];g!==null&&(m.matrix.fromArray(g.transform.matrix),m.matrix.decompose(m.position,m.rotation,m.scale),m.jointRadius=g.radius),m.visible=g!==null}let c=l.joints["index-finger-tip"],h=l.joints["thumb-tip"],u=c.position.distanceTo(h.position),d=.02,p=.005;l.inputState.pinching&&u>d+p?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&u<=d-p&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else a!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,n),r!==null&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1));o!==null&&(s=t.getPose(e.targetRaySpace,n),s===null&&r!==null&&(s=r),s!==null&&(o.matrix.fromArray(s.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),s.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(s.linearVelocity)):o.hasLinearVelocity=!1,s.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(s.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(vK)))}return o!==null&&(o.visible=s!==null),a!==null&&(a.visible=r!==null),l!==null&&(l.visible=i!==null),this}},PS=class extends mr{constructor(e,t,n,s,r,i,o,a,l,c){if(c=c!==void 0?c:fu,c!==fu&&c!==mu)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&c===fu&&(n=ql),n===void 0&&c===mu&&(n=pu),super(null,s,r,i,o,a,c,n,l),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=o!==void 0?o:ns,this.minFilter=a!==void 0?a:ns,this.flipY=!1,this.generateMipmaps=!1}},xK=class extends Zr{constructor(e,t){super();let n=this,s=null,r=1,i=null,o="local-floor",a=null,l=null,c=null,h=null,u=null,d=null,p=t.getContextAttributes(),f=null,g=null,m=[],y=[],v=new vr;v.layers.enable(1),v.viewport=new Bt;let b=new vr;b.layers.enable(2),b.viewport=new Bt;let x=[v,b],w=new yK;w.layers.enable(1),w.layers.enable(2);let S=null,C=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(M){let U=m[M];return U===void 0&&(U=new MS,m[M]=U),U.getTargetRaySpace()},this.getControllerGrip=function(M){let U=m[M];return U===void 0&&(U=new MS,m[M]=U),U.getGripSpace()},this.getHand=function(M){let U=m[M];return U===void 0&&(U=new MS,m[M]=U),U.getHandSpace()};function _(M){let U=y.indexOf(M.inputSource);if(U===-1)return;let z=m[U];z!==void 0&&z.dispatchEvent({type:M.type,data:M.inputSource})}function T(){s.removeEventListener("select",_),s.removeEventListener("selectstart",_),s.removeEventListener("selectend",_),s.removeEventListener("squeeze",_),s.removeEventListener("squeezestart",_),s.removeEventListener("squeezeend",_),s.removeEventListener("end",T),s.removeEventListener("inputsourceschange",E);for(let M=0;M<m.length;M++){let U=y[M];U!==null&&(y[M]=null,m[M].disconnect(U))}S=null,C=null,e.setRenderTarget(f),u=null,h=null,c=null,s=null,g=null,F.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(M){r=M,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(M){o=M,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return a||i},this.setReferenceSpace=function(M){a=M},this.getBaseLayer=function(){return h!==null?h:u},this.getBinding=function(){return c},this.getFrame=function(){return d},this.getSession=function(){return s},this.setSession=async function(M){if(s=M,s!==null){if(f=e.getRenderTarget(),s.addEventListener("select",_),s.addEventListener("selectstart",_),s.addEventListener("selectend",_),s.addEventListener("squeeze",_),s.addEventListener("squeezestart",_),s.addEventListener("squeezeend",_),s.addEventListener("end",T),s.addEventListener("inputsourceschange",E),p.xrCompatible!==!0&&await t.makeXRCompatible(),s.renderState.layers===void 0||e.capabilities.isWebGL2===!1){let U={antialias:s.renderState.layers===void 0?p.antialias:!0,alpha:p.alpha,depth:p.depth,stencil:p.stencil,framebufferScaleFactor:r};u=new XRWebGLLayer(s,t,U),s.updateRenderState({baseLayer:u}),g=new hs(u.framebufferWidth,u.framebufferHeight,{format:ua,type:pr,encoding:e.outputEncoding})}else{let U=null,z=null,$=null;p.depth&&($=p.stencil?35056:33190,U=p.stencil?mu:fu,z=p.stencil?pu:ql);let R={colorFormat:32856,depthFormat:$,scaleFactor:r};c=new XRWebGLBinding(s,t),h=c.createProjectionLayer(R),s.updateRenderState({layers:[h]}),g=new hs(h.textureWidth,h.textureHeight,{format:ua,type:pr,depthTexture:new PS(h.textureWidth,h.textureHeight,z,void 0,void 0,void 0,void 0,void 0,void 0,U),stencilBuffer:p.stencil,encoding:e.outputEncoding,samples:p.antialias?4:0});let H=e.properties.get(g);H.__ignoreDepthValues=h.ignoreDepthValues}g.isXRRenderTarget=!0,this.setFoveation(1),a=null,i=await s.requestReferenceSpace(o),F.setContext(s),F.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function E(M){for(let U=0;U<M.removed.length;U++){let z=M.removed[U],$=y.indexOf(z);$>=0&&(y[$]=null,m[$].dispatchEvent({type:"disconnected",data:z}))}for(let U=0;U<M.added.length;U++){let z=M.added[U],$=y.indexOf(z);if($===-1){for(let H=0;H<m.length;H++)if(H>=y.length){y.push(z),$=H;break}else if(y[H]===null){y[H]=z,$=H;break}if($===-1)break}let R=m[$];R&&R.dispatchEvent({type:"connected",data:z})}}let A=new I,D=new I;function O(M,U,z){A.setFromMatrixPosition(U.matrixWorld),D.setFromMatrixPosition(z.matrixWorld);let $=A.distanceTo(D),R=U.projectionMatrix.elements,H=z.projectionMatrix.elements,K=R[14]/(R[10]-1),Y=R[14]/(R[10]+1),X=(R[9]+1)/R[5],oe=(R[9]-1)/R[5],ie=(R[8]-1)/R[0],Z=(H[8]+1)/H[0],ce=K*ie,ge=K*Z,_e=$/(-ie+Z),be=_e*-ie;U.matrixWorld.decompose(M.position,M.quaternion,M.scale),M.translateX(be),M.translateZ(_e),M.matrixWorld.compose(M.position,M.quaternion,M.scale),M.matrixWorldInverse.copy(M.matrixWorld).invert();let Me=K+_e,Ie=Y+_e,Le=ce-be,Ue=ge+($-be),$e=X*Y/Ie*Me,We=oe*Y/Ie*Me;M.projectionMatrix.makePerspective(Le,Ue,$e,We,Me,Ie)}function P(M,U){U===null?M.matrixWorld.copy(M.matrix):M.matrixWorld.multiplyMatrices(U.matrixWorld,M.matrix),M.matrixWorldInverse.copy(M.matrixWorld).invert()}this.updateCamera=function(M){if(s===null)return;w.near=b.near=v.near=M.near,w.far=b.far=v.far=M.far,(S!==w.near||C!==w.far)&&(s.updateRenderState({depthNear:w.near,depthFar:w.far}),S=w.near,C=w.far);let U=M.parent,z=w.cameras;P(w,U);for(let R=0;R<z.length;R++)P(z[R],U);w.matrixWorld.decompose(w.position,w.quaternion,w.scale),M.position.copy(w.position),M.quaternion.copy(w.quaternion),M.scale.copy(w.scale),M.matrix.copy(w.matrix),M.matrixWorld.copy(w.matrixWorld);let $=M.children;for(let R=0,H=$.length;R<H;R++)$[R].updateMatrixWorld(!0);z.length===2?O(w,v,b):w.projectionMatrix.copy(v.projectionMatrix)},this.getCamera=function(){return w},this.getFoveation=function(){if(h!==null)return h.fixedFoveation;if(u!==null)return u.fixedFoveation},this.setFoveation=function(M){h!==null&&(h.fixedFoveation=M),u!==null&&u.fixedFoveation!==void 0&&(u.fixedFoveation=M)};let L=null;function B(M,U){if(l=U.getViewerPose(a||i),d=U,l!==null){let z=l.views;u!==null&&(e.setRenderTargetFramebuffer(g,u.framebuffer),e.setRenderTarget(g));let $=!1;z.length!==w.cameras.length&&(w.cameras.length=0,$=!0);for(let R=0;R<z.length;R++){let H=z[R],K=null;if(u!==null)K=u.getViewport(H);else{let X=c.getViewSubImage(h,H);K=X.viewport,R===0&&(e.setRenderTargetTextures(g,X.colorTexture,h.ignoreDepthValues?void 0:X.depthStencilTexture),e.setRenderTarget(g))}let Y=x[R];Y===void 0&&(Y=new vr,Y.layers.enable(R),Y.viewport=new Bt,x[R]=Y),Y.matrix.fromArray(H.transform.matrix),Y.projectionMatrix.fromArray(H.projectionMatrix),Y.viewport.set(K.x,K.y,K.width,K.height),R===0&&w.matrix.copy(Y.matrix),$===!0&&w.cameras.push(Y)}}for(let z=0;z<m.length;z++){let $=y[z],R=m[z];$!==null&&R!==void 0&&R.update($,U,a||i)}L&&L(M,U),d=null}let F=new vD;F.setAnimationLoop(B),this.setAnimationLoop=function(M){L=M},this.dispose=function(){}}};function bK(e,t){function n(g,m){g.fogColor.value.copy(m.color),m.isFog?(g.fogNear.value=m.near,g.fogFar.value=m.far):m.isFogExp2&&(g.fogDensity.value=m.density)}function s(g,m,y,v,b){m.isMeshBasicMaterial||m.isMeshLambertMaterial?r(g,m):m.isMeshToonMaterial?(r(g,m),h(g,m)):m.isMeshPhongMaterial?(r(g,m),c(g,m)):m.isMeshStandardMaterial?(r(g,m),u(g,m),m.isMeshPhysicalMaterial&&d(g,m,b)):m.isMeshMatcapMaterial?(r(g,m),p(g,m)):m.isMeshDepthMaterial?r(g,m):m.isMeshDistanceMaterial?(r(g,m),f(g,m)):m.isMeshNormalMaterial?r(g,m):m.isLineBasicMaterial?(i(g,m),m.isLineDashedMaterial&&o(g,m)):m.isPointsMaterial?a(g,m,y,v):m.isSpriteMaterial?l(g,m):m.isShadowMaterial?(g.color.value.copy(m.color),g.opacity.value=m.opacity):m.isShaderMaterial&&(m.uniformsNeedUpdate=!1)}function r(g,m){g.opacity.value=m.opacity,m.color&&g.diffuse.value.copy(m.color),m.emissive&&g.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap),m.bumpMap&&(g.bumpMap.value=m.bumpMap,g.bumpScale.value=m.bumpScale,m.side===dr&&(g.bumpScale.value*=-1)),m.displacementMap&&(g.displacementMap.value=m.displacementMap,g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias),m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap),m.normalMap&&(g.normalMap.value=m.normalMap,g.normalScale.value.copy(m.normalScale),m.side===dr&&g.normalScale.value.negate()),m.specularMap&&(g.specularMap.value=m.specularMap),m.alphaTest>0&&(g.alphaTest.value=m.alphaTest);let y=t.get(m).envMap;if(y&&(g.envMap.value=y,g.flipEnvMap.value=y.isCubeTexture&&y.isRenderTargetTexture===!1?-1:1,g.reflectivity.value=m.reflectivity,g.ior.value=m.ior,g.refractionRatio.value=m.refractionRatio),m.lightMap){g.lightMap.value=m.lightMap;let x=e.physicallyCorrectLights!==!0?Math.PI:1;g.lightMapIntensity.value=m.lightMapIntensity*x}m.aoMap&&(g.aoMap.value=m.aoMap,g.aoMapIntensity.value=m.aoMapIntensity);let v;m.map?v=m.map:m.specularMap?v=m.specularMap:m.displacementMap?v=m.displacementMap:m.normalMap?v=m.normalMap:m.bumpMap?v=m.bumpMap:m.roughnessMap?v=m.roughnessMap:m.metalnessMap?v=m.metalnessMap:m.alphaMap?v=m.alphaMap:m.emissiveMap?v=m.emissiveMap:m.clearcoatMap?v=m.clearcoatMap:m.clearcoatNormalMap?v=m.clearcoatNormalMap:m.clearcoatRoughnessMap?v=m.clearcoatRoughnessMap:m.iridescenceMap?v=m.iridescenceMap:m.iridescenceThicknessMap?v=m.iridescenceThicknessMap:m.specularIntensityMap?v=m.specularIntensityMap:m.specularColorMap?v=m.specularColorMap:m.transmissionMap?v=m.transmissionMap:m.thicknessMap?v=m.thicknessMap:m.sheenColorMap?v=m.sheenColorMap:m.sheenRoughnessMap&&(v=m.sheenRoughnessMap),v!==void 0&&(v.isWebGLRenderTarget&&(v=v.texture),v.matrixAutoUpdate===!0&&v.updateMatrix(),g.uvTransform.value.copy(v.matrix));let b;m.aoMap?b=m.aoMap:m.lightMap&&(b=m.lightMap),b!==void 0&&(b.isWebGLRenderTarget&&(b=b.texture),b.matrixAutoUpdate===!0&&b.updateMatrix(),g.uv2Transform.value.copy(b.matrix))}function i(g,m){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity}function o(g,m){g.dashSize.value=m.dashSize,g.totalSize.value=m.dashSize+m.gapSize,g.scale.value=m.scale}function a(g,m,y,v){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity,g.size.value=m.size*y,g.scale.value=v*.5,m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap),m.alphaTest>0&&(g.alphaTest.value=m.alphaTest);let b;m.map?b=m.map:m.alphaMap&&(b=m.alphaMap),b!==void 0&&(b.matrixAutoUpdate===!0&&b.updateMatrix(),g.uvTransform.value.copy(b.matrix))}function l(g,m){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity,g.rotation.value=m.rotation,m.map&&(g.map.value=m.map),m.alphaMap&&(g.alphaMap.value=m.alphaMap),m.alphaTest>0&&(g.alphaTest.value=m.alphaTest);let y;m.map?y=m.map:m.alphaMap&&(y=m.alphaMap),y!==void 0&&(y.matrixAutoUpdate===!0&&y.updateMatrix(),g.uvTransform.value.copy(y.matrix))}function c(g,m){g.specular.value.copy(m.specular),g.shininess.value=Math.max(m.shininess,1e-4)}function h(g,m){m.gradientMap&&(g.gradientMap.value=m.gradientMap)}function u(g,m){g.roughness.value=m.roughness,g.metalness.value=m.metalness,m.roughnessMap&&(g.roughnessMap.value=m.roughnessMap),m.metalnessMap&&(g.metalnessMap.value=m.metalnessMap),t.get(m).envMap&&(g.envMapIntensity.value=m.envMapIntensity)}function d(g,m,y){g.ior.value=m.ior,m.sheen>0&&(g.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen),g.sheenRoughness.value=m.sheenRoughness,m.sheenColorMap&&(g.sheenColorMap.value=m.sheenColorMap),m.sheenRoughnessMap&&(g.sheenRoughnessMap.value=m.sheenRoughnessMap)),m.clearcoat>0&&(g.clearcoat.value=m.clearcoat,g.clearcoatRoughness.value=m.clearcoatRoughness,m.clearcoatMap&&(g.clearcoatMap.value=m.clearcoatMap),m.clearcoatRoughnessMap&&(g.clearcoatRoughnessMap.value=m.clearcoatRoughnessMap),m.clearcoatNormalMap&&(g.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),g.clearcoatNormalMap.value=m.clearcoatNormalMap,m.side===dr&&g.clearcoatNormalScale.value.negate())),m.iridescence>0&&(g.iridescence.value=m.iridescence,g.iridescenceIOR.value=m.iridescenceIOR,g.iridescenceThicknessMinimum.value=m.iridescenceThicknessRange[0],g.iridescenceThicknessMaximum.value=m.iridescenceThicknessRange[1],m.iridescenceMap&&(g.iridescenceMap.value=m.iridescenceMap),m.iridescenceThicknessMap&&(g.iridescenceThicknessMap.value=m.iridescenceThicknessMap)),m.transmission>0&&(g.transmission.value=m.transmission,g.transmissionSamplerMap.value=y.texture,g.transmissionSamplerSize.value.set(y.width,y.height),m.transmissionMap&&(g.transmissionMap.value=m.transmissionMap),g.thickness.value=m.thickness,m.thicknessMap&&(g.thicknessMap.value=m.thicknessMap),g.attenuationDistance.value=m.attenuationDistance,g.attenuationColor.value.copy(m.attenuationColor)),g.specularIntensity.value=m.specularIntensity,g.specularColor.value.copy(m.specularColor),m.specularIntensityMap&&(g.specularIntensityMap.value=m.specularIntensityMap),m.specularColorMap&&(g.specularColorMap.value=m.specularColorMap)}function p(g,m){m.matcap&&(g.matcap.value=m.matcap)}function f(g,m){g.referencePosition.value.copy(m.referencePosition),g.nearDistance.value=m.nearDistance,g.farDistance.value=m.farDistance}return{refreshFogUniforms:n,refreshMaterialUniforms:s}}function wK(){let e=ny("canvas");return e.style.display="block",e}function qD(e={}){this.isWebGLRenderer=!0;let t=e.canvas!==void 0?e.canvas:wK(),n=e.context!==void 0?e.context:null,s=e.depth!==void 0?e.depth:!0,r=e.stencil!==void 0?e.stencil:!0,i=e.antialias!==void 0?e.antialias:!1,o=e.premultipliedAlpha!==void 0?e.premultipliedAlpha:!0,a=e.preserveDrawingBuffer!==void 0?e.preserveDrawingBuffer:!1,l=e.powerPreference!==void 0?e.powerPreference:"default",c=e.failIfMajorPerformanceCaveat!==void 0?e.failIfMajorPerformanceCaveat:!1,h;n!==null?h=n.getContextAttributes().alpha:h=e.alpha!==void 0?e.alpha:!1;let u=null,d=null,p=[],f=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=ha,this.physicallyCorrectLights=!1,this.toneMapping=ll,this.toneMappingExposure=1,Object.defineProperties(this,{gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});let g=this,m=!1,y=0,v=0,b=null,x=-1,w=null,S=new Bt,C=new Bt,_=null,T=t.width,E=t.height,A=1,D=null,O=null,P=new Bt(0,0,T,E),L=new Bt(0,0,T,E),B=!1,F=new TS,M=!1,U=!1,z=null,$=new et,R=new se,H=new I,K={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Y(){return b===null?A:1}let X=n;function oe(q,ve){for(let Ne=0;Ne<q.length;Ne++){let Ce=q[Ne],Re=t.getContext(Ce,ve);if(Re!==null)return Re}return null}try{let q={alpha:!0,depth:s,stencil:r,antialias:i,premultipliedAlpha:o,preserveDrawingBuffer:a,powerPreference:l,failIfMajorPerformanceCaveat:c};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${_f}`),t.addEventListener("webglcontextlost",te,!1),t.addEventListener("webglcontextrestored",Ke,!1),t.addEventListener("webglcontextcreationerror",qe,!1),X===null){let ve=["webgl2","webgl","experimental-webgl"];if(g.isWebGL1Renderer===!0&&ve.shift(),X=oe(ve,q),X===null)throw oe(ve)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}X.getShaderPrecisionFormat===void 0&&(X.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(q){throw console.error("THREE.WebGLRenderer: "+q.message),q}let ie,Z,ce,ge,_e,be,Me,Ie,Le,Ue,$e,We,Rt,ct,j,V,we,Pe,Be,je,pt,Te,ut;function He(){ie=new O9(X),Z=new I9(X,ie,e),ie.init(Z),Te=new gK(X,ie,Z),ce=new fK(X,ie,Z),ge=new F9,_e=new tK,be=new mK(X,ie,ce,_e,Z,Te,ge),Me=new k9(g),Ie=new P9(g),Le=new K8(X,Z),ut=new E9(X,ie,Le,Z),Ue=new R9(X,Le,ge,ut),$e=new U9(X,Ue,Le,ge),Be=new z9(X,Z,be),V=new N9(_e),We=new eK(g,Me,Ie,ie,Z,ut,V),Rt=new bK(g,_e),ct=new sK,j=new cK(ie,Z),Pe=new T9(g,Me,ce,$e,h,o),we=new pK(g,$e,Z),je=new A9(X,ie,ge,Z),pt=new L9(X,ie,ge,Z),ge.programs=We.programs,g.capabilities=Z,g.extensions=ie,g.properties=_e,g.renderLists=ct,g.shadowMap=we,g.state=ce,g.info=ge}He();let Xe=new xK(g,X);this.xr=Xe,this.getContext=function(){return X},this.getContextAttributes=function(){return X.getContextAttributes()},this.forceContextLoss=function(){let q=ie.get("WEBGL_lose_context");q&&q.loseContext()},this.forceContextRestore=function(){let q=ie.get("WEBGL_lose_context");q&&q.restoreContext()},this.getPixelRatio=function(){return A},this.setPixelRatio=function(q){q!==void 0&&(A=q,this.setSize(T,E,!1))},this.getSize=function(q){return q.set(T,E)},this.setSize=function(q,ve,Ne){if(Xe.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}T=q,E=ve,t.width=Math.floor(q*A),t.height=Math.floor(ve*A),Ne!==!1&&(t.style.width=q+"px",t.style.height=ve+"px"),this.setViewport(0,0,q,ve)},this.getDrawingBufferSize=function(q){return q.set(T*A,E*A).floor()},this.setDrawingBufferSize=function(q,ve,Ne){T=q,E=ve,A=Ne,t.width=Math.floor(q*Ne),t.height=Math.floor(ve*Ne),this.setViewport(0,0,q,ve)},this.getCurrentViewport=function(q){return q.copy(S)},this.getViewport=function(q){return q.copy(P)},this.setViewport=function(q,ve,Ne,Ce){q.isVector4?P.set(q.x,q.y,q.z,q.w):P.set(q,ve,Ne,Ce),ce.viewport(S.copy(P).multiplyScalar(A).floor())},this.getScissor=function(q){return q.copy(L)},this.setScissor=function(q,ve,Ne,Ce){q.isVector4?L.set(q.x,q.y,q.z,q.w):L.set(q,ve,Ne,Ce),ce.scissor(C.copy(L).multiplyScalar(A).floor())},this.getScissorTest=function(){return B},this.setScissorTest=function(q){ce.setScissorTest(B=q)},this.setOpaqueSort=function(q){D=q},this.setTransparentSort=function(q){O=q},this.getClearColor=function(q){return q.copy(Pe.getClearColor())},this.setClearColor=function(){Pe.setClearColor.apply(Pe,arguments)},this.getClearAlpha=function(){return Pe.getClearAlpha()},this.setClearAlpha=function(){Pe.setClearAlpha.apply(Pe,arguments)},this.clear=function(q=!0,ve=!0,Ne=!0){let Ce=0;q&&(Ce|=16384),ve&&(Ce|=256),Ne&&(Ce|=1024),X.clear(Ce)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",te,!1),t.removeEventListener("webglcontextrestored",Ke,!1),t.removeEventListener("webglcontextcreationerror",qe,!1),ct.dispose(),j.dispose(),_e.dispose(),Me.dispose(),Ie.dispose(),$e.dispose(),ut.dispose(),We.dispose(),Xe.dispose(),Xe.removeEventListener("sessionstart",nt),Xe.removeEventListener("sessionend",Je),z&&(z.dispose(),z=null),mt.stop()};function te(q){q.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),m=!0}function Ke(){console.log("THREE.WebGLRenderer: Context Restored."),m=!1;let q=ge.autoReset,ve=we.enabled,Ne=we.autoUpdate,Ce=we.needsUpdate,Re=we.type;He(),ge.autoReset=q,we.enabled=ve,we.autoUpdate=Ne,we.needsUpdate=Ce,we.type=Re}function qe(q){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",q.statusMessage)}function Et(q){let ve=q.target;ve.removeEventListener("dispose",Et),it(ve)}function it(q){At(q),_e.remove(q)}function At(q){let ve=_e.get(q).programs;ve!==void 0&&(ve.forEach(function(Ne){We.releaseProgram(Ne)}),q.isShaderMaterial&&We.releaseShaderCache(q))}this.renderBufferDirect=function(q,ve,Ne,Ce,Re,bt){ve===null&&(ve=K);let Ut=Re.isMesh&&Re.matrixWorld.determinant()<0,Vt=Hs(q,ve,Ne,Ce,Re);ce.setMaterial(Ce,Ut);let tn=Ne.index,ts=Ne.attributes.position;if(tn===null){if(ts===void 0||ts.count===0)return}else if(tn.count===0)return;let nn=1;Ce.wireframe===!0&&(tn=Ue.getWireframeAttribute(Ne),nn=2),ut.setup(Re,Ce,Vt,Ne,tn);let on,js=je;tn!==null&&(on=Le.get(tn),js=pt,js.setIndex(on));let cu=tn!==null?tn.count:ts.count,Wh=Ne.drawRange.start*nn,Hh=Ne.drawRange.count*nn,oa=bt!==null?bt.start*nn:0,yn=bt!==null?bt.count*nn:1/0,jh=Math.max(Wh,oa),bf=Math.min(cu,Wh+Hh,oa+yn)-1,aa=Math.max(0,bf-jh+1);if(aa!==0){if(Re.isMesh)Ce.wireframe===!0?(ce.setLineWidth(Ce.wireframeLinewidth*Y()),js.setMode(1)):js.setMode(4);else if(Re.isLine){let Hl=Ce.linewidth;Hl===void 0&&(Hl=1),ce.setLineWidth(Hl*Y()),Re.isLineSegments?js.setMode(1):Re.isLineLoop?js.setMode(2):js.setMode(3)}else Re.isPoints?js.setMode(0):Re.isSprite&&js.setMode(4);if(Re.isInstancedMesh)js.renderInstances(jh,aa,Re.count);else if(Ne.isInstancedBufferGeometry){let Hl=Math.min(Ne.instanceCount,Ne._maxInstanceCount);js.renderInstances(jh,aa,Hl)}else js.render(jh,aa)}},this.compile=function(q,ve){d=j.get(q),d.init(),f.push(d),q.traverseVisible(function(Ne){Ne.isLight&&Ne.layers.test(ve.layers)&&(d.pushLight(Ne),Ne.castShadow&&d.pushShadow(Ne))}),d.setupLights(g.physicallyCorrectLights),q.traverse(function(Ne){let Ce=Ne.material;if(Ce)if(Array.isArray(Ce))for(let Re=0;Re<Ce.length;Re++){let bt=Ce[Re];Tn(bt,q,Ne)}else Tn(Ce,q,Ne)}),f.pop(),d=null};let Ge=null;function yt(q){Ge&&Ge(q)}function nt(){mt.stop()}function Je(){mt.start()}let mt=new vD;mt.setAnimationLoop(yt),typeof self<"u"&&mt.setContext(self),this.setAnimationLoop=function(q){Ge=q,Xe.setAnimationLoop(q),q===null?mt.stop():mt.start()},Xe.addEventListener("sessionstart",nt),Xe.addEventListener("sessionend",Je),this.render=function(q,ve){if(ve!==void 0&&ve.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(m===!0)return;q.autoUpdate===!0&&q.updateMatrixWorld(),ve.parent===null&&ve.updateMatrixWorld(),Xe.enabled===!0&&Xe.isPresenting===!0&&(Xe.cameraAutoUpdate===!0&&Xe.updateCamera(ve),ve=Xe.getCamera()),q.isScene===!0&&q.onBeforeRender(g,q,ve,b),d=j.get(q,f.length),d.init(),f.push(d),$.multiplyMatrices(ve.projectionMatrix,ve.matrixWorldInverse),F.setFromProjectionMatrix($),U=this.localClippingEnabled,M=V.init(this.clippingPlanes,U,ve),u=ct.get(q,p.length),u.init(),p.push(u),Dt(q,ve,0,g.sortObjects),u.finish(),g.sortObjects===!0&&u.sort(D,O),M===!0&&V.beginShadows();let Ne=d.state.shadowsArray;if(we.render(Ne,q,ve),M===!0&&V.endShadows(),this.info.autoReset===!0&&this.info.reset(),Pe.render(u,q),d.setupLights(g.physicallyCorrectLights),ve.isArrayCamera){let Ce=ve.cameras;for(let Re=0,bt=Ce.length;Re<bt;Re++){let Ut=Ce[Re];rn(u,q,Ut,Ut.viewport)}}else rn(u,q,ve);b!==null&&(be.updateMultisampleRenderTarget(b),be.updateRenderTargetMipmap(b)),q.isScene===!0&&q.onAfterRender(g,q,ve),ut.resetDefaultState(),x=-1,w=null,f.pop(),f.length>0?d=f[f.length-1]:d=null,p.pop(),p.length>0?u=p[p.length-1]:u=null};function Dt(q,ve,Ne,Ce){if(q.visible===!1)return;if(q.layers.test(ve.layers)){if(q.isGroup)Ne=q.renderOrder;else if(q.isLOD)q.autoUpdate===!0&&q.update(ve);else if(q.isLight)d.pushLight(q),q.castShadow&&d.pushShadow(q);else if(q.isSprite){if(!q.frustumCulled||F.intersectsSprite(q)){Ce&&H.setFromMatrixPosition(q.matrixWorld).applyMatrix4($);let bt=$e.update(q),Ut=q.material;Ut.visible&&u.push(q,bt,Ut,Ne,H.z,null)}}else if((q.isMesh||q.isLine||q.isPoints)&&(q.isSkinnedMesh&&q.skeleton.frame!==ge.render.frame&&(q.skeleton.update(),q.skeleton.frame=ge.render.frame),!q.frustumCulled||F.intersectsObject(q))){Ce&&H.setFromMatrixPosition(q.matrixWorld).applyMatrix4($);let bt=$e.update(q),Ut=q.material;if(Array.isArray(Ut)){let Vt=bt.groups;for(let tn=0,ts=Vt.length;tn<ts;tn++){let nn=Vt[tn],on=Ut[nn.materialIndex];on&&on.visible&&u.push(q,bt,on,Ne,H.z,nn)}}else Ut.visible&&u.push(q,bt,Ut,Ne,H.z,null)}}let Re=q.children;for(let bt=0,Ut=Re.length;bt<Ut;bt++)Dt(Re[bt],ve,Ne,Ce)}function rn(q,ve,Ne,Ce){let Re=q.opaque,bt=q.transmissive,Ut=q.transparent;d.setupLightsView(Ne),bt.length>0&&Xn(Re,ve,Ne),Ce&&ce.viewport(S.copy(Ce)),Re.length>0&&gn(Re,ve,Ne),bt.length>0&&gn(bt,ve,Ne),Ut.length>0&&gn(Ut,ve,Ne),ce.buffers.depth.setTest(!0),ce.buffers.depth.setMask(!0),ce.buffers.color.setMask(!0),ce.setPolygonOffset(!1)}function Xn(q,ve,Ne){let Ce=Z.isWebGL2;z===null&&(z=new hs(1,1,{generateMipmaps:!0,type:ie.has("EXT_color_buffer_half_float")?If:pr,minFilter:Af,samples:Ce&&i===!0?4:0})),g.getDrawingBufferSize(R),Ce?z.setSize(R.x,R.y):z.setSize(ey(R.x),ey(R.y));let Re=g.getRenderTarget();g.setRenderTarget(z),g.clear();let bt=g.toneMapping;g.toneMapping=ll,gn(q,ve,Ne),g.toneMapping=bt,be.updateMultisampleRenderTarget(z),be.updateRenderTargetMipmap(z),g.setRenderTarget(Re)}function gn(q,ve,Ne){let Ce=ve.isScene===!0?ve.overrideMaterial:null;for(let Re=0,bt=q.length;Re<bt;Re++){let Ut=q[Re],Vt=Ut.object,tn=Ut.geometry,ts=Ce===null?Ut.material:Ce,nn=Ut.group;Vt.layers.test(Ne.layers)&&On(Vt,ve,Ne,tn,ts,nn)}}function On(q,ve,Ne,Ce,Re,bt){q.onBeforeRender(g,ve,Ne,Ce,Re,bt),q.modelViewMatrix.multiplyMatrices(Ne.matrixWorldInverse,q.matrixWorld),q.normalMatrix.getNormalMatrix(q.modelViewMatrix),Re.onBeforeRender(g,ve,Ne,Ce,q,bt),Re.transparent===!0&&Re.side===Ao?(Re.side=dr,Re.needsUpdate=!0,g.renderBufferDirect(Ne,ve,Ce,Re,q,bt),Re.side=jl,Re.needsUpdate=!0,g.renderBufferDirect(Ne,ve,Ce,Re,q,bt),Re.side=Ao):g.renderBufferDirect(Ne,ve,Ce,Re,q,bt),q.onAfterRender(g,ve,Ne,Ce,Re,bt)}function Tn(q,ve,Ne){ve.isScene!==!0&&(ve=K);let Ce=_e.get(q),Re=d.state.lights,bt=d.state.shadowsArray,Ut=Re.state.version,Vt=We.getParameters(q,Re.state,bt,ve,Ne),tn=We.getProgramCacheKey(Vt),ts=Ce.programs;Ce.environment=q.isMeshStandardMaterial?ve.environment:null,Ce.fog=ve.fog,Ce.envMap=(q.isMeshStandardMaterial?Ie:Me).get(q.envMap||Ce.environment),ts===void 0&&(q.addEventListener("dispose",Et),ts=new Map,Ce.programs=ts);let nn=ts.get(tn);if(nn!==void 0){if(Ce.currentProgram===nn&&Ce.lightsStateVersion===Ut)return Rn(q,Vt),nn}else Vt.uniforms=We.getUniforms(q),q.onBuild(Ne,Vt,g),q.onBeforeCompile(Vt,g),nn=We.acquireProgram(Vt,tn),ts.set(tn,nn),Ce.uniforms=Vt.uniforms;let on=Ce.uniforms;(!q.isShaderMaterial&&!q.isRawShaderMaterial||q.clipping===!0)&&(on.clippingPlanes=V.uniform),Rn(q,Vt),Ce.needsLights=Mr(q),Ce.lightsStateVersion=Ut,Ce.needsLights&&(on.ambientLightColor.value=Re.state.ambient,on.lightProbe.value=Re.state.probe,on.directionalLights.value=Re.state.directional,on.directionalLightShadows.value=Re.state.directionalShadow,on.spotLights.value=Re.state.spot,on.spotLightShadows.value=Re.state.spotShadow,on.rectAreaLights.value=Re.state.rectArea,on.ltc_1.value=Re.state.rectAreaLTC1,on.ltc_2.value=Re.state.rectAreaLTC2,on.pointLights.value=Re.state.point,on.pointLightShadows.value=Re.state.pointShadow,on.hemisphereLights.value=Re.state.hemi,on.directionalShadowMap.value=Re.state.directionalShadowMap,on.directionalShadowMatrix.value=Re.state.directionalShadowMatrix,on.spotShadowMap.value=Re.state.spotShadowMap,on.spotShadowMatrix.value=Re.state.spotShadowMatrix,on.pointShadowMap.value=Re.state.pointShadowMap,on.pointShadowMatrix.value=Re.state.pointShadowMatrix);let js=nn.getUniforms(),cu=Ay.seqWithValue(js.seq,on);return Ce.currentProgram=nn,Ce.uniformsList=cu,nn}function Rn(q,ve){let Ne=_e.get(q);Ne.outputEncoding=ve.outputEncoding,Ne.instancing=ve.instancing,Ne.skinning=ve.skinning,Ne.morphTargets=ve.morphTargets,Ne.morphNormals=ve.morphNormals,Ne.morphColors=ve.morphColors,Ne.morphTargetsCount=ve.morphTargetsCount,Ne.numClippingPlanes=ve.numClippingPlanes,Ne.numIntersection=ve.numClipIntersection,Ne.vertexAlphas=ve.vertexAlphas,Ne.vertexTangents=ve.vertexTangents,Ne.toneMapping=ve.toneMapping}function Hs(q,ve,Ne,Ce,Re){ve.isScene!==!0&&(ve=K),be.resetTextureUnits();let bt=ve.fog,Ut=Ce.isMeshStandardMaterial?ve.environment:null,Vt=b===null?g.outputEncoding:b.isXRRenderTarget===!0?b.texture.encoding:ha,tn=(Ce.isMeshStandardMaterial?Ie:Me).get(Ce.envMap||Ut),ts=Ce.vertexColors===!0&&!!Ne.attributes.color&&Ne.attributes.color.itemSize===4,nn=!!Ce.normalMap&&!!Ne.attributes.tangent,on=!!Ne.morphAttributes.position,js=!!Ne.morphAttributes.normal,cu=!!Ne.morphAttributes.color,Wh=Ce.toneMapped?g.toneMapping:ll,Hh=Ne.morphAttributes.position||Ne.morphAttributes.normal||Ne.morphAttributes.color,oa=Hh!==void 0?Hh.length:0,yn=_e.get(Ce),jh=d.state.lights;if(M===!0&&(U===!0||q!==w)){let la=q===w&&Ce.id===x;V.setState(Ce,q,la)}let bf=!1;Ce.version===yn.__version?(yn.needsLights&&yn.lightsStateVersion!==jh.state.version||yn.outputEncoding!==Vt||Re.isInstancedMesh&&yn.instancing===!1||!Re.isInstancedMesh&&yn.instancing===!0||Re.isSkinnedMesh&&yn.skinning===!1||!Re.isSkinnedMesh&&yn.skinning===!0||yn.envMap!==tn||Ce.fog===!0&&yn.fog!==bt||yn.numClippingPlanes!==void 0&&(yn.numClippingPlanes!==V.numPlanes||yn.numIntersection!==V.numIntersection)||yn.vertexAlphas!==ts||yn.vertexTangents!==nn||yn.morphTargets!==on||yn.morphNormals!==js||yn.morphColors!==cu||yn.toneMapping!==Wh||Z.isWebGL2===!0&&yn.morphTargetsCount!==oa)&&(bf=!0):(bf=!0,yn.__version=Ce.version);let aa=yn.currentProgram;bf===!0&&(aa=Tn(Ce,ve,Re));let Hl=!1,wf=!1,Fw=!1,Pr=aa.getUniforms(),Sf=yn.uniforms;if(ce.useProgram(aa.program)&&(Hl=!0,wf=!0,Fw=!0),Ce.id!==x&&(x=Ce.id,wf=!0),Hl||w!==q){if(Pr.setValue(X,"projectionMatrix",q.projectionMatrix),Z.logarithmicDepthBuffer&&Pr.setValue(X,"logDepthBufFC",2/(Math.log(q.far+1)/Math.LN2)),w!==q&&(w=q,wf=!0,Fw=!0),Ce.isShaderMaterial||Ce.isMeshPhongMaterial||Ce.isMeshToonMaterial||Ce.isMeshStandardMaterial||Ce.envMap){let la=Pr.map.cameraPosition;la!==void 0&&la.setValue(X,H.setFromMatrixPosition(q.matrixWorld))}(Ce.isMeshPhongMaterial||Ce.isMeshToonMaterial||Ce.isMeshLambertMaterial||Ce.isMeshBasicMaterial||Ce.isMeshStandardMaterial||Ce.isShaderMaterial)&&Pr.setValue(X,"isOrthographic",q.isOrthographicCamera===!0),(Ce.isMeshPhongMaterial||Ce.isMeshToonMaterial||Ce.isMeshLambertMaterial||Ce.isMeshBasicMaterial||Ce.isMeshStandardMaterial||Ce.isShaderMaterial||Ce.isShadowMaterial||Re.isSkinnedMesh)&&Pr.setValue(X,"viewMatrix",q.matrixWorldInverse)}if(Re.isSkinnedMesh){Pr.setOptional(X,Re,"bindMatrix"),Pr.setOptional(X,Re,"bindMatrixInverse");let la=Re.skeleton;la&&(Z.floatVertexTextures?(la.boneTexture===null&&la.computeBoneTexture(),Pr.setValue(X,"boneTexture",la.boneTexture,be),Pr.setValue(X,"boneTextureSize",la.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}let $w=Ne.morphAttributes;return($w.position!==void 0||$w.normal!==void 0||$w.color!==void 0&&Z.isWebGL2===!0)&&Be.update(Re,Ne,Ce,aa),(wf||yn.receiveShadow!==Re.receiveShadow)&&(yn.receiveShadow=Re.receiveShadow,Pr.setValue(X,"receiveShadow",Re.receiveShadow)),wf&&(Pr.setValue(X,"toneMappingExposure",g.toneMappingExposure),yn.needsLights&&gi(Sf,Fw),bt&&Ce.fog===!0&&Rt.refreshFogUniforms(Sf,bt),Rt.refreshMaterialUniforms(Sf,Ce,A,E,z),Ay.upload(X,yn.uniformsList,Sf,be)),Ce.isShaderMaterial&&Ce.uniformsNeedUpdate===!0&&(Ay.upload(X,yn.uniformsList,Sf,be),Ce.uniformsNeedUpdate=!1),Ce.isSpriteMaterial&&Pr.setValue(X,"center",Re.center),Pr.setValue(X,"modelViewMatrix",Re.modelViewMatrix),Pr.setValue(X,"normalMatrix",Re.normalMatrix),Pr.setValue(X,"modelMatrix",Re.matrixWorld),aa}function gi(q,ve){q.ambientLightColor.needsUpdate=ve,q.lightProbe.needsUpdate=ve,q.directionalLights.needsUpdate=ve,q.directionalLightShadows.needsUpdate=ve,q.pointLights.needsUpdate=ve,q.pointLightShadows.needsUpdate=ve,q.spotLights.needsUpdate=ve,q.spotLightShadows.needsUpdate=ve,q.rectAreaLights.needsUpdate=ve,q.hemisphereLights.needsUpdate=ve}function Mr(q){return q.isMeshLambertMaterial||q.isMeshToonMaterial||q.isMeshPhongMaterial||q.isMeshStandardMaterial||q.isShadowMaterial||q.isShaderMaterial&&q.lights===!0}this.getActiveCubeFace=function(){return y},this.getActiveMipmapLevel=function(){return v},this.getRenderTarget=function(){return b},this.setRenderTargetTextures=function(q,ve,Ne){_e.get(q.texture).__webglTexture=ve,_e.get(q.depthTexture).__webglTexture=Ne;let Ce=_e.get(q);Ce.__hasExternalTextures=!0,Ce.__hasExternalTextures&&(Ce.__autoAllocateDepthBuffer=Ne===void 0,Ce.__autoAllocateDepthBuffer||ie.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),Ce.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(q,ve){let Ne=_e.get(q);Ne.__webglFramebuffer=ve,Ne.__useDefaultFramebuffer=ve===void 0},this.setRenderTarget=function(q,ve=0,Ne=0){b=q,y=ve,v=Ne;let Ce=!0;if(q){let Vt=_e.get(q);Vt.__useDefaultFramebuffer!==void 0?(ce.bindFramebuffer(36160,null),Ce=!1):Vt.__webglFramebuffer===void 0?be.setupRenderTarget(q):Vt.__hasExternalTextures&&be.rebindTextures(q,_e.get(q.texture).__webglTexture,_e.get(q.depthTexture).__webglTexture)}let Re=null,bt=!1,Ut=!1;if(q){let Vt=q.texture;(Vt.isData3DTexture||Vt.isDataArrayTexture)&&(Ut=!0);let tn=_e.get(q).__webglFramebuffer;q.isWebGLCubeRenderTarget?(Re=tn[ve],bt=!0):Z.isWebGL2&&q.samples>0&&be.useMultisampledRTT(q)===!1?Re=_e.get(q).__webglMultisampledFramebuffer:Re=tn,S.copy(q.viewport),C.copy(q.scissor),_=q.scissorTest}else S.copy(P).multiplyScalar(A).floor(),C.copy(L).multiplyScalar(A).floor(),_=B;if(ce.bindFramebuffer(36160,Re)&&Z.drawBuffers&&Ce&&ce.drawBuffers(q,Re),ce.viewport(S),ce.scissor(C),ce.setScissorTest(_),bt){let Vt=_e.get(q.texture);X.framebufferTexture2D(36160,36064,34069+ve,Vt.__webglTexture,Ne)}else if(Ut){let Vt=_e.get(q.texture),tn=ve||0;X.framebufferTextureLayer(36160,36064,Vt.__webglTexture,Ne||0,tn)}x=-1},this.readRenderTargetPixels=function(q,ve,Ne,Ce,Re,bt,Ut){if(!(q&&q.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Vt=_e.get(q).__webglFramebuffer;if(q.isWebGLCubeRenderTarget&&Ut!==void 0&&(Vt=Vt[Ut]),Vt){ce.bindFramebuffer(36160,Vt);try{let tn=q.texture,ts=tn.format,nn=tn.type;if(ts!==ua&&Te.convert(ts)!==X.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}let on=nn===If&&(ie.has("EXT_color_buffer_half_float")||Z.isWebGL2&&ie.has("EXT_color_buffer_float"));if(nn!==pr&&Te.convert(nn)!==X.getParameter(35738)&&!(nn===Xl&&(Z.isWebGL2||ie.has("OES_texture_float")||ie.has("WEBGL_color_buffer_float")))&&!on){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}ve>=0&&ve<=q.width-Ce&&Ne>=0&&Ne<=q.height-Re&&X.readPixels(ve,Ne,Ce,Re,Te.convert(ts),Te.convert(nn),bt)}finally{let tn=b!==null?_e.get(b).__webglFramebuffer:null;ce.bindFramebuffer(36160,tn)}}},this.copyFramebufferToTexture=function(q,ve,Ne=0){let Ce=Math.pow(2,-Ne),Re=Math.floor(ve.image.width*Ce),bt=Math.floor(ve.image.height*Ce);be.setTexture2D(ve,0),X.copyTexSubImage2D(3553,Ne,0,0,q.x,q.y,Re,bt),ce.unbindTexture()},this.copyTextureToTexture=function(q,ve,Ne,Ce=0){let Re=ve.image.width,bt=ve.image.height,Ut=Te.convert(Ne.format),Vt=Te.convert(Ne.type);be.setTexture2D(Ne,0),X.pixelStorei(37440,Ne.flipY),X.pixelStorei(37441,Ne.premultiplyAlpha),X.pixelStorei(3317,Ne.unpackAlignment),ve.isDataTexture?X.texSubImage2D(3553,Ce,q.x,q.y,Re,bt,Ut,Vt,ve.image.data):ve.isCompressedTexture?X.compressedTexSubImage2D(3553,Ce,q.x,q.y,ve.mipmaps[0].width,ve.mipmaps[0].height,Ut,ve.mipmaps[0].data):X.texSubImage2D(3553,Ce,q.x,q.y,Ut,Vt,ve.image),Ce===0&&Ne.generateMipmaps&&X.generateMipmap(3553),ce.unbindTexture()},this.copyTextureToTexture3D=function(q,ve,Ne,Ce,Re=0){if(g.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}let bt=q.max.x-q.min.x+1,Ut=q.max.y-q.min.y+1,Vt=q.max.z-q.min.z+1,tn=Te.convert(Ce.format),ts=Te.convert(Ce.type),nn;if(Ce.isData3DTexture)be.setTexture3D(Ce,0),nn=32879;else if(Ce.isDataArrayTexture)be.setTexture2DArray(Ce,0),nn=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}X.pixelStorei(37440,Ce.flipY),X.pixelStorei(37441,Ce.premultiplyAlpha),X.pixelStorei(3317,Ce.unpackAlignment);let on=X.getParameter(3314),js=X.getParameter(32878),cu=X.getParameter(3316),Wh=X.getParameter(3315),Hh=X.getParameter(32877),oa=Ne.isCompressedTexture?Ne.mipmaps[0]:Ne.image;X.pixelStorei(3314,oa.width),X.pixelStorei(32878,oa.height),X.pixelStorei(3316,q.min.x),X.pixelStorei(3315,q.min.y),X.pixelStorei(32877,q.min.z),Ne.isDataTexture||Ne.isData3DTexture?X.texSubImage3D(nn,Re,ve.x,ve.y,ve.z,bt,Ut,Vt,tn,ts,oa.data):Ne.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),X.compressedTexSubImage3D(nn,Re,ve.x,ve.y,ve.z,bt,Ut,Vt,tn,oa.data)):X.texSubImage3D(nn,Re,ve.x,ve.y,ve.z,bt,Ut,Vt,tn,ts,oa),X.pixelStorei(3314,on),X.pixelStorei(32878,js),X.pixelStorei(3316,cu),X.pixelStorei(3315,Wh),X.pixelStorei(32877,Hh),Re===0&&Ce.generateMipmaps&&X.generateMipmap(nn),ce.unbindTexture()},this.initTexture=function(q){q.isCubeTexture?be.setTextureCube(q,0):q.isData3DTexture?be.setTexture3D(q,0):q.isDataArrayTexture?be.setTexture2DArray(q,0):be.setTexture2D(q,0),ce.unbindTexture()},this.resetState=function(){y=0,v=0,b=null,ce.reset(),ut.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}var SK=class extends qD{};SK.prototype.isWebGL1Renderer=!0;var XD=class{constructor(e,t=1,n=1e3){this.isFog=!0,this.name="",this.color=new _t(e),this.near=t,this.far=n}clone(){return new XD(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}},_u=class extends Ln{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){let t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}},_K=class{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=Zw,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=da()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let s=0,r=this.stride;s<r;s++)this.array[e+s]=t.array[n+s];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=da()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);let t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=da()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}},Fr=new I,OS=class{constructor(e,t,n,s=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=s===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)Fr.fromBufferAttribute(this,t),Fr.applyMatrix4(e),this.setXYZ(t,Fr.x,Fr.y,Fr.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Fr.fromBufferAttribute(this,t),Fr.applyNormalMatrix(e),this.setXYZ(t,Fr.x,Fr.y,Fr.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Fr.fromBufferAttribute(this,t),Fr.transformDirection(e),this.setXYZ(t,Fr.x,Fr.y,Fr.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,s){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=s,this}setXYZW(e,t,n,s,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=s,this.data.array[e+3]=r,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");let t=[];for(let n=0;n<this.count;n++){let s=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[s+r])}return new Lt(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new OS(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");let t=[];for(let n=0;n<this.count;n++){let s=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[s+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}},CK=class extends Lt{constructor(e,t,n,s=1){typeof n=="number"&&(s=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(e,t,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=s}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){let e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}},nc=class extends Of{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new _t(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}},KD=new I,YD=new I,QD=new et,RS=new td,Iy=new Wi,Ny=class extends Ln{constructor(e=new It,t=new nc){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){let e=this.geometry;if(e.index===null){let t=e.attributes.position,n=[0];for(let s=1,r=t.count;s<r;s++)KD.fromBufferAttribute(t,s-1),YD.fromBufferAttribute(t,s),n[s]=n[s-1],n[s]+=KD.distanceTo(YD);e.setAttribute("lineDistance",new ot(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){let n=this.geometry,s=this.matrixWorld,r=e.params.Line.threshold,i=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Iy.copy(n.boundingSphere),Iy.applyMatrix4(s),Iy.radius+=r,e.ray.intersectsSphere(Iy)===!1)return;QD.copy(s).invert(),RS.copy(e.ray).applyMatrix4(QD);let o=r/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o,l=new I,c=new I,h=new I,u=new I,d=this.isLineSegments?2:1,p=n.index,f=n.attributes.position;if(p!==null){let g=Math.max(0,i.start),m=Math.min(p.count,i.start+i.count);for(let y=g,v=m-1;y<v;y+=d){let b=p.getX(y),x=p.getX(y+1);if(l.fromBufferAttribute(f,b),c.fromBufferAttribute(f,x),RS.distanceSqToSegment(l,c,u,h)>a)continue;u.applyMatrix4(this.matrixWorld);let w=e.ray.origin.distanceTo(u);w<e.near||w>e.far||t.push({distance:w,point:h.clone().applyMatrix4(this.matrixWorld),index:y,face:null,faceIndex:null,object:this})}}else{let g=Math.max(0,i.start),m=Math.min(f.count,i.start+i.count);for(let y=g,v=m-1;y<v;y+=d){if(l.fromBufferAttribute(f,y),c.fromBufferAttribute(f,y+1),RS.distanceSqToSegment(l,c,u,h)>a)continue;u.applyMatrix4(this.matrixWorld);let b=e.ray.origin.distanceTo(u);b<e.near||b>e.far||t.push({distance:b,point:h.clone().applyMatrix4(this.matrixWorld),index:y,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){let e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){let n=e[t[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,r=n.length;s<r;s++){let i=n[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=s}}}}},ZD=new I,JD=new I,Bf=class extends Ny{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){let e=this.geometry;if(e.index===null){let t=e.attributes.position,n=[];for(let s=0,r=t.count;s<r;s+=2)ZD.fromBufferAttribute(t,s),JD.fromBufferAttribute(t,s+1),n[s]=s===0?0:n[s-1],n[s+1]=n[s]+ZD.distanceTo(JD);e.setAttribute("lineDistance",new ot(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}},TK=class extends mr{constructor(e,t,n,s,r,i,o,a,l){super(e,t,n,s,r,i,o,a,l),this.isVideoTexture=!0,this.minFilter=i!==void 0?i:xn,this.magFilter=r!==void 0?r:xn,this.generateMipmaps=!1;let c=this;function h(){c.needsUpdate=!0,e.requestVideoFrameCallback(h)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(h)}clone(){return new this.constructor(this.image).copy(this)}update(){let e=this.image;!("requestVideoFrameCallback"in e)&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}},ma=class{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){let n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){let t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){let t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){let e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;let t=[],n,s=this.getPoint(0),r=0;t.push(0);for(let i=1;i<=e;i++)n=this.getPoint(i/e),r+=n.distanceTo(s),t.push(r),s=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){let n=this.getLengths(),s=0,r=n.length,i;t?i=t:i=e*n[r-1];let o=0,a=r-1,l;for(;o<=a;)if(s=Math.floor(o+(a-o)/2),l=n[s]-i,l<0)o=s+1;else if(l>0)a=s-1;else{a=s;break}if(s=a,n[s]===i)return s/(r-1);let c=n[s],h=n[s+1]-c,u=(i-c)/h;return(s+u)/(r-1)}getTangent(e,t){let n=e-1e-4,s=e+1e-4;n<0&&(n=0),s>1&&(s=1);let r=this.getPoint(n),i=this.getPoint(s),o=t||(r.isVector2?new se:new I);return o.copy(i).sub(r).normalize(),o}getTangentAt(e,t){let n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){let n=new I,s=[],r=[],i=[],o=new I,a=new et;for(let d=0;d<=e;d++){let p=d/e;s[d]=this.getTangentAt(p,new I)}r[0]=new I,i[0]=new I;let l=Number.MAX_VALUE,c=Math.abs(s[0].x),h=Math.abs(s[0].y),u=Math.abs(s[0].z);c<=l&&(l=c,n.set(1,0,0)),h<=l&&(l=h,n.set(0,1,0)),u<=l&&n.set(0,0,1),o.crossVectors(s[0],n).normalize(),r[0].crossVectors(s[0],o),i[0].crossVectors(s[0],r[0]);for(let d=1;d<=e;d++){if(r[d]=r[d-1].clone(),i[d]=i[d-1].clone(),o.crossVectors(s[d-1],s[d]),o.length()>Number.EPSILON){o.normalize();let p=Math.acos(ks(s[d-1].dot(s[d]),-1,1));r[d].applyMatrix4(a.makeRotationAxis(o,p))}i[d].crossVectors(s[d],r[d])}if(t===!0){let d=Math.acos(ks(r[0].dot(r[e]),-1,1));d/=e,s[0].dot(o.crossVectors(r[0],r[e]))>0&&(d=-d);for(let p=1;p<=e;p++)r[p].applyMatrix4(a.makeRotationAxis(s[p],d*p)),i[p].crossVectors(s[p],r[p])}return{tangents:s,normals:r,binormals:i}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){let e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}},ky=class extends ma{constructor(e=0,t=0,n=1,s=1,r=0,i=Math.PI*2,o=!1,a=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=s,this.aStartAngle=r,this.aEndAngle=i,this.aClockwise=o,this.aRotation=a}getPoint(e,t){let n=t||new se,s=Math.PI*2,r=this.aEndAngle-this.aStartAngle,i=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=s;for(;r>s;)r-=s;r<Number.EPSILON&&(i?r=0:r=s),this.aClockwise===!0&&!i&&(r===s?r=-s:r=r-s);let o=this.aStartAngle+e*r,a=this.aX+this.xRadius*Math.cos(o),l=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){let c=Math.cos(this.aRotation),h=Math.sin(this.aRotation),u=a-this.aX,d=l-this.aY;a=u*c-d*h+this.aX,l=u*h+d*c+this.aY}return n.set(a,l)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){let e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}},EK=class extends ky{constructor(e,t,n,s,r,i){super(e,t,n,n,s,r,i),this.isArcCurve=!0,this.type="ArcCurve"}};function LS(){let e=0,t=0,n=0,s=0;function r(i,o,a,l){e=i,t=a,n=-3*i+3*o-2*a-l,s=2*i-2*o+a+l}return{initCatmullRom:function(i,o,a,l,c){r(o,a,c*(a-i),c*(l-o))},initNonuniformCatmullRom:function(i,o,a,l,c,h,u){let d=(o-i)/c-(a-i)/(c+h)+(a-o)/h,p=(a-o)/h-(l-o)/(h+u)+(l-a)/u;d*=h,p*=h,r(o,a,d,p)},calc:function(i){let o=i*i,a=o*i;return e+t*i+n*o+s*a}}}var Dy=new I,FS=new LS,$S=new LS,BS=new LS,AK=class extends ma{constructor(e=[],t=!1,n="centripetal",s=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=s}getPoint(e,t=new I){let n=t,s=this.points,r=s.length,i=(r-(this.closed?0:1))*e,o=Math.floor(i),a=i-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/r)+1)*r:a===0&&o===r-1&&(o=r-2,a=1);let l,c;this.closed||o>0?l=s[(o-1)%r]:(Dy.subVectors(s[0],s[1]).add(s[0]),l=Dy);let h=s[o%r],u=s[(o+1)%r];if(this.closed||o+2<r?c=s[(o+2)%r]:(Dy.subVectors(s[r-1],s[r-2]).add(s[r-1]),c=Dy),this.curveType==="centripetal"||this.curveType==="chordal"){let d=this.curveType==="chordal"?.5:.25,p=Math.pow(l.distanceToSquared(h),d),f=Math.pow(h.distanceToSquared(u),d),g=Math.pow(u.distanceToSquared(c),d);f<1e-4&&(f=1),p<1e-4&&(p=f),g<1e-4&&(g=f),FS.initNonuniformCatmullRom(l.x,h.x,u.x,c.x,p,f,g),$S.initNonuniformCatmullRom(l.y,h.y,u.y,c.y,p,f,g),BS.initNonuniformCatmullRom(l.z,h.z,u.z,c.z,p,f,g)}else this.curveType==="catmullrom"&&(FS.initCatmullRom(l.x,h.x,u.x,c.x,this.tension),$S.initCatmullRom(l.y,h.y,u.y,c.y,this.tension),BS.initCatmullRom(l.z,h.z,u.z,c.z,this.tension));return n.set(FS.calc(a),$S.calc(a),BS.calc(a)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){let s=e.points[t];this.points.push(s.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){let e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){let s=this.points[t];e.points.push(s.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){let s=e.points[t];this.points.push(new I().fromArray(s))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}};function eM(e,t,n,s,r){let i=(s-t)*.5,o=(r-n)*.5,a=e*e,l=e*a;return(2*n-2*s+i+o)*l+(-3*n+3*s-2*i-o)*a+i*e+n}function IK(e,t){let n=1-e;return n*n*t}function NK(e,t){return 2*(1-e)*e*t}function kK(e,t){return e*e*t}function zf(e,t,n,s){return IK(e,t)+NK(e,n)+kK(e,s)}function DK(e,t){let n=1-e;return n*n*n*t}function MK(e,t){let n=1-e;return 3*n*n*e*t}function PK(e,t){return 3*(1-e)*e*e*t}function OK(e,t){return e*e*e*t}function Uf(e,t,n,s,r){return DK(e,t)+MK(e,n)+PK(e,s)+OK(e,r)}var Mo=class extends ma{constructor(e=new se,t=new se,n=new se,s=new se){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=s}getPoint(e,t=new se){let n=t,s=this.v0,r=this.v1,i=this.v2,o=this.v3;return n.set(Uf(e,s.x,r.x,i.x,o.x),Uf(e,s.y,r.y,i.y,o.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){let e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}},RK=class extends ma{constructor(e=new I,t=new I,n=new I,s=new I){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=s}getPoint(e,t=new I){let n=t,s=this.v0,r=this.v1,i=this.v2,o=this.v3;return n.set(Uf(e,s.x,r.x,i.x,o.x),Uf(e,s.y,r.y,i.y,o.y),Uf(e,s.z,r.z,i.z,o.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){let e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}},Po=class extends ma{constructor(e=new se,t=new se){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new se){let n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){let n=t||new se;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){let e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}},tM=class extends ma{constructor(e=new I,t=new I){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new I){let n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){let e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}},sc=class extends ma{constructor(e=new se,t=new se,n=new se){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new se){let n=t,s=this.v0,r=this.v1,i=this.v2;return n.set(zf(e,s.x,r.x,i.x),zf(e,s.y,r.y,i.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){let e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}},LK=class extends ma{constructor(e=new I,t=new I,n=new I){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new I){let n=t,s=this.v0,r=this.v1,i=this.v2;return n.set(zf(e,s.x,r.x,i.x),zf(e,s.y,r.y,i.y),zf(e,s.z,r.z,i.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){let e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}},zS=class extends ma{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new se){let n=t,s=this.points,r=(s.length-1)*e,i=Math.floor(r),o=r-i,a=s[i===0?i:i-1],l=s[i],c=s[i>s.length-2?s.length-1:i+1],h=s[i>s.length-3?s.length-1:i+2];return n.set(eM(o,a.x,l.x,c.x,h.x),eM(o,a.y,l.y,c.y,h.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){let s=e.points[t];this.points.push(s.clone())}return this}toJSON(){let e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){let s=this.points[t];e.points.push(s.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){let s=e.points[t];this.points.push(new se().fromArray(s))}return this}},FK=Object.freeze({__proto__:null,ArcCurve:EK,CatmullRomCurve3:AK,CubicBezierCurve:Mo,CubicBezierCurve3:RK,EllipseCurve:ky,LineCurve:Po,LineCurve3:tM,QuadraticBezierCurve:sc,QuadraticBezierCurve3:LK,SplineCurve:zS}),$K=class extends ma{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){let e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new Po(t,e))}getPoint(e,t){let n=e*this.getLength(),s=this.getCurveLengths(),r=0;for(;r<s.length;){if(s[r]>=n){let i=s[r]-n,o=this.curves[r],a=o.getLength(),l=a===0?0:1-i/a;return o.getPointAt(l,t)}r++}return null}getLength(){let e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;let e=[],t=0;for(let n=0,s=this.curves.length;n<s;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){let t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){let t=[],n;for(let s=0,r=this.curves;s<r.length;s++){let i=r[s],o=i.isEllipseCurve?e*2:i.isLineCurve||i.isLineCurve3?1:i.isSplineCurve?e*i.points.length:e,a=i.getPoints(o);for(let l=0;l<a.length;l++){let c=a[l];n&&n.equals(c)||(t.push(c),n=c)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){let s=e.curves[t];this.curves.push(s.clone())}return this.autoClose=e.autoClose,this}toJSON(){let e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){let s=this.curves[t];e.curves.push(s.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){let s=e.curves[t];this.curves.push(new FK[s.type]().fromJSON(s))}return this}},My=class extends $K{constructor(e){super(),this.type="Path",this.currentPoint=new se,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){let n=new Po(this.currentPoint.clone(),new se(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,s){let r=new sc(this.currentPoint.clone(),new se(e,t),new se(n,s));return this.curves.push(r),this.currentPoint.set(n,s),this}bezierCurveTo(e,t,n,s,r,i){let o=new Mo(this.currentPoint.clone(),new se(e,t),new se(n,s),new se(r,i));return this.curves.push(o),this.currentPoint.set(r,i),this}splineThru(e){let t=[this.currentPoint.clone()].concat(e),n=new zS(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,s,r,i){let o=this.currentPoint.x,a=this.currentPoint.y;return this.absarc(e+o,t+a,n,s,r,i),this}absarc(e,t,n,s,r,i){return this.absellipse(e,t,n,n,s,r,i),this}ellipse(e,t,n,s,r,i,o,a){let l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(e+l,t+c,n,s,r,i,o,a),this}absellipse(e,t,n,s,r,i,o,a){let l=new ky(e,t,n,s,r,i,o,a);if(this.curves.length>0){let h=l.getPoint(0);h.equals(this.currentPoint)||this.lineTo(h.x,h.y)}this.curves.push(l);let c=l.getPoint(1);return this.currentPoint.copy(c),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){let e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}},nM=class extends It{constructor(e=[new se(0,.5),new se(.5,0),new se(0,-.5)],t=12,n=0,s=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:s},t=Math.floor(t),s=ks(s,0,Math.PI*2);let r=[],i=[],o=[],a=[],l=[],c=1/t,h=new I,u=new se,d=new I,p=new I,f=new I,g=0,m=0;for(let y=0;y<=e.length-1;y++)switch(y){case 0:g=e[y+1].x-e[y].x,m=e[y+1].y-e[y].y,d.x=m*1,d.y=-g,d.z=m*0,f.copy(d),d.normalize(),a.push(d.x,d.y,d.z);break;case e.length-1:a.push(f.x,f.y,f.z);break;default:g=e[y+1].x-e[y].x,m=e[y+1].y-e[y].y,d.x=m*1,d.y=-g,d.z=m*0,p.copy(d),d.x+=f.x,d.y+=f.y,d.z+=f.z,d.normalize(),a.push(d.x,d.y,d.z),f.copy(p)}for(let y=0;y<=t;y++){let v=n+y*c*s,b=Math.sin(v),x=Math.cos(v);for(let w=0;w<=e.length-1;w++){h.x=e[w].x*b,h.y=e[w].y,h.z=e[w].x*x,i.push(h.x,h.y,h.z),u.x=y/t,u.y=w/(e.length-1),o.push(u.x,u.y);let S=a[3*w+0]*b,C=a[3*w+1],_=a[3*w+0]*x;l.push(S,C,_)}}for(let y=0;y<t;y++)for(let v=0;v<e.length-1;v++){let b=v+y*e.length,x=b,w=b+e.length,S=b+e.length+1,C=b+1;r.push(x,w,C),r.push(S,C,w)}this.setIndex(r),this.setAttribute("position",new ot(i,3)),this.setAttribute("uv",new ot(o,2)),this.setAttribute("normal",new ot(l,3))}static fromJSON(e){return new nM(e.points,e.segments,e.phiStart,e.phiLength)}},US=class extends It{constructor(e=1,t=1,n=1,s=8,r=1,i=!1,o=0,a=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:s,heightSegments:r,openEnded:i,thetaStart:o,thetaLength:a};let l=this;s=Math.floor(s),r=Math.floor(r);let c=[],h=[],u=[],d=[],p=0,f=[],g=n/2,m=0;y(),i===!1&&(e>0&&v(!0),t>0&&v(!1)),this.setIndex(c),this.setAttribute("position",new ot(h,3)),this.setAttribute("normal",new ot(u,3)),this.setAttribute("uv",new ot(d,2));function y(){let b=new I,x=new I,w=0,S=(t-e)/n;for(let C=0;C<=r;C++){let _=[],T=C/r,E=T*(t-e)+e;for(let A=0;A<=s;A++){let D=A/s,O=D*a+o,P=Math.sin(O),L=Math.cos(O);x.x=E*P,x.y=-T*n+g,x.z=E*L,h.push(x.x,x.y,x.z),b.set(P,S,L).normalize(),u.push(b.x,b.y,b.z),d.push(D,1-T),_.push(p++)}f.push(_)}for(let C=0;C<s;C++)for(let _=0;_<r;_++){let T=f[_][C],E=f[_+1][C],A=f[_+1][C+1],D=f[_][C+1];c.push(T,E,D),c.push(E,A,D),w+=6}l.addGroup(m,w,0),m+=w}function v(b){let x=p,w=new se,S=new I,C=0,_=b===!0?e:t,T=b===!0?1:-1;for(let A=1;A<=s;A++)h.push(0,g*T,0),u.push(0,T,0),d.push(.5,.5),p++;let E=p;for(let A=0;A<=s;A++){let D=A/s*a+o,O=Math.cos(D),P=Math.sin(D);S.x=_*P,S.y=g*T,S.z=_*O,h.push(S.x,S.y,S.z),u.push(0,T,0),w.x=O*.5+.5,w.y=P*.5*T+.5,d.push(w.x,w.y),p++}for(let A=0;A<s;A++){let D=x+A,O=E+A;b===!0?c.push(O,O+1,D):c.push(O+1,O,D),C+=3}l.addGroup(m,C,b===!0?1:2),m+=C}}static fromJSON(e){return new US(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}},sM=class extends US{constructor(e=1,t=1,n=8,s=1,r=!1,i=0,o=Math.PI*2){super(0,e,t,n,s,r,i,o),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:s,openEnded:r,thetaStart:i,thetaLength:o}}static fromJSON(e){return new sM(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}},VS=class extends It{constructor(e=[],t=[],n=1,s=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:s};let r=[],i=[];o(s),l(n),c(),this.setAttribute("position",new ot(r,3)),this.setAttribute("normal",new ot(r.slice(),3)),this.setAttribute("uv",new ot(i,2)),s===0?this.computeVertexNormals():this.normalizeNormals();function o(y){let v=new I,b=new I,x=new I;for(let w=0;w<t.length;w+=3)d(t[w+0],v),d(t[w+1],b),d(t[w+2],x),a(v,b,x,y)}function a(y,v,b,x){let w=x+1,S=[];for(let C=0;C<=w;C++){S[C]=[];let _=y.clone().lerp(b,C/w),T=v.clone().lerp(b,C/w),E=w-C;for(let A=0;A<=E;A++)A===0&&C===w?S[C][A]=_:S[C][A]=_.clone().lerp(T,A/E)}for(let C=0;C<w;C++)for(let _=0;_<2*(w-C)-1;_++){let T=Math.floor(_/2);_%2==0?(u(S[C][T+1]),u(S[C+1][T]),u(S[C][T])):(u(S[C][T+1]),u(S[C+1][T+1]),u(S[C+1][T]))}}function l(y){let v=new I;for(let b=0;b<r.length;b+=3)v.x=r[b+0],v.y=r[b+1],v.z=r[b+2],v.normalize().multiplyScalar(y),r[b+0]=v.x,r[b+1]=v.y,r[b+2]=v.z}function c(){let y=new I;for(let v=0;v<r.length;v+=3){y.x=r[v+0],y.y=r[v+1],y.z=r[v+2];let b=g(y)/2/Math.PI+.5,x=m(y)/Math.PI+.5;i.push(b,1-x)}p(),h()}function h(){for(let y=0;y<i.length;y+=6){let v=i[y+0],b=i[y+2],x=i[y+4],w=Math.max(v,b,x),S=Math.min(v,b,x);w>.9&&S<.1&&(v<.2&&(i[y+0]+=1),b<.2&&(i[y+2]+=1),x<.2&&(i[y+4]+=1))}}function u(y){r.push(y.x,y.y,y.z)}function d(y,v){let b=y*3;v.x=e[b+0],v.y=e[b+1],v.z=e[b+2]}function p(){let y=new I,v=new I,b=new I,x=new I,w=new se,S=new se,C=new se;for(let _=0,T=0;_<r.length;_+=9,T+=6){y.set(r[_+0],r[_+1],r[_+2]),v.set(r[_+3],r[_+4],r[_+5]),b.set(r[_+6],r[_+7],r[_+8]),w.set(i[T+0],i[T+1]),S.set(i[T+2],i[T+3]),C.set(i[T+4],i[T+5]),x.copy(y).add(v).add(b).divideScalar(3);let E=g(x);f(w,T+0,y,E),f(S,T+2,v,E),f(C,T+4,b,E)}}function f(y,v,b,x){x<0&&y.x===1&&(i[v]=y.x-1),b.x===0&&b.z===0&&(i[v]=x/2/Math.PI+.5)}function g(y){return Math.atan2(y.z,-y.x)}function m(y){return Math.atan2(-y.y,Math.sqrt(y.x*y.x+y.z*y.z))}}static fromJSON(e){return new VS(e.vertices,e.indices,e.radius,e.details)}},rM=class extends VS{constructor(e=1,t=0){let n=(1+Math.sqrt(5))/2,s=1/n,r=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-s,-n,0,-s,n,0,s,-n,0,s,n,-s,-n,0,-s,n,0,s,-n,0,s,n,0,-n,0,-s,n,0,-s,-n,0,s,n,0,s],i=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(r,i,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new rM(e.radius,e.detail)}},Py=class extends My{constructor(e){super(e),this.uuid=da(),this.type="Shape",this.holes=[]}getPointsHoles(e){let t=[];for(let n=0,s=this.holes.length;n<s;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){let s=e.holes[t];this.holes.push(s.clone())}return this}toJSON(){let e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){let s=this.holes[t];e.holes.push(s.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){let s=e.holes[t];this.holes.push(new My().fromJSON(s))}return this}},BK={triangulate:function(e,t,n=2){let s=t&&t.length,r=s?t[0]*n:e.length,i=iM(e,0,r,n,!0),o=[];if(!i||i.next===i.prev)return o;let a,l,c,h,u,d,p;if(s&&(i=WK(e,t,i,n)),e.length>80*n){a=c=e[0],l=h=e[1];for(let f=n;f<r;f+=n)u=e[f],d=e[f+1],u<a&&(a=u),d<l&&(l=d),u>c&&(c=u),d>h&&(h=d);p=Math.max(c-a,h-l),p=p!==0?1/p:0}return Vf(i,o,n,a,l,p),o}};function iM(e,t,n,s,r){let i,o;if(r===tY(e,t,n,s)>0)for(i=t;i<n;i+=s)o=lM(i,e[i],e[i+1],o);else for(i=n-s;i>=t;i-=s)o=lM(i,e[i],e[i+1],o);return o&&Oy(o,o.next)&&(Wf(o),o=o.next),o}function rc(e,t){if(!e)return e;t||(t=e);let n=e,s;do if(s=!1,!n.steiner&&(Oy(n,n.next)||Jn(n.prev,n,n.next)===0)){if(Wf(n),n=t=n.prev,n===n.next)break;s=!0}else n=n.next;while(s||n!==t);return t}function Vf(e,t,n,s,r,i,o){if(!e)return;!o&&i&&KK(e,s,r,i);let a=e,l,c;for(;e.prev!==e.next;){if(l=e.prev,c=e.next,i?UK(e,s,r,i):zK(e)){t.push(l.i/n),t.push(e.i/n),t.push(c.i/n),Wf(e),e=c.next,a=c.next;continue}if(e=c,e===a){o?o===1?(e=VK(rc(e),t,n),Vf(e,t,n,s,r,i,2)):o===2&&GK(e,t,n,s,r,i):Vf(rc(e),t,n,s,r,i,1);break}}}function zK(e){let t=e.prev,n=e,s=e.next;if(Jn(t,n,s)>=0)return!1;let r=e.next.next;for(;r!==e.prev;){if(vd(t.x,t.y,n.x,n.y,s.x,s.y,r.x,r.y)&&Jn(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function UK(e,t,n,s){let r=e.prev,i=e,o=e.next;if(Jn(r,i,o)>=0)return!1;let a=r.x<i.x?r.x<o.x?r.x:o.x:i.x<o.x?i.x:o.x,l=r.y<i.y?r.y<o.y?r.y:o.y:i.y<o.y?i.y:o.y,c=r.x>i.x?r.x>o.x?r.x:o.x:i.x>o.x?i.x:o.x,h=r.y>i.y?r.y>o.y?r.y:o.y:i.y>o.y?i.y:o.y,u=GS(a,l,t,n,s),d=GS(c,h,t,n,s),p=e.prevZ,f=e.nextZ;for(;p&&p.z>=u&&f&&f.z<=d;){if(p!==e.prev&&p!==e.next&&vd(r.x,r.y,i.x,i.y,o.x,o.y,p.x,p.y)&&Jn(p.prev,p,p.next)>=0||(p=p.prevZ,f!==e.prev&&f!==e.next&&vd(r.x,r.y,i.x,i.y,o.x,o.y,f.x,f.y)&&Jn(f.prev,f,f.next)>=0))return!1;f=f.nextZ}for(;p&&p.z>=u;){if(p!==e.prev&&p!==e.next&&vd(r.x,r.y,i.x,i.y,o.x,o.y,p.x,p.y)&&Jn(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;f&&f.z<=d;){if(f!==e.prev&&f!==e.next&&vd(r.x,r.y,i.x,i.y,o.x,o.y,f.x,f.y)&&Jn(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function VK(e,t,n){let s=e;do{let r=s.prev,i=s.next.next;!Oy(r,i)&&oM(r,s,s.next,i)&&Gf(r,i)&&Gf(i,r)&&(t.push(r.i/n),t.push(s.i/n),t.push(i.i/n),Wf(s),Wf(s.next),s=e=i),s=s.next}while(s!==e);return rc(s)}function GK(e,t,n,s,r,i){let o=e;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&ZK(o,a)){let l=aM(o,a);o=rc(o,o.next),l=rc(l,l.next),Vf(o,t,n,s,r,i),Vf(l,t,n,s,r,i);return}a=a.next}o=o.next}while(o!==e)}function WK(e,t,n,s){let r=[],i,o,a,l,c;for(i=0,o=t.length;i<o;i++)a=t[i]*s,l=i<o-1?t[i+1]*s:e.length,c=iM(e,a,l,s,!1),c===c.next&&(c.steiner=!0),r.push(QK(c));for(r.sort(HK),i=0;i<r.length;i++)jK(r[i],n),n=rc(n,n.next);return n}function HK(e,t){return e.x-t.x}function jK(e,t){if(t=qK(e,t),t){let n=aM(t,e);rc(t,t.next),rc(n,n.next)}}function qK(e,t){let n=t,s=e.x,r=e.y,i=-1/0,o;do{if(r<=n.y&&r>=n.next.y&&n.next.y!==n.y){let d=n.x+(r-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(d<=s&&d>i){if(i=d,d===s){if(r===n.y)return n;if(r===n.next.y)return n.next}o=n.x<n.next.x?n:n.next}}n=n.next}while(n!==t);if(!o)return null;if(s===i)return o;let a=o,l=o.x,c=o.y,h=1/0,u;n=o;do s>=n.x&&n.x>=l&&s!==n.x&&vd(r<c?s:i,r,l,c,r<c?i:s,r,n.x,n.y)&&(u=Math.abs(r-n.y)/(s-n.x),Gf(n,e)&&(u<h||u===h&&(n.x>o.x||n.x===o.x&&XK(o,n)))&&(o=n,h=u)),n=n.next;while(n!==a);return o}function XK(e,t){return Jn(e.prev,e,t.prev)<0&&Jn(t.next,e,e.next)<0}function KK(e,t,n,s){let r=e;do r.z===null&&(r.z=GS(r.x,r.y,t,n,s)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==e);r.prevZ.nextZ=null,r.prevZ=null,YK(r)}function YK(e){let t,n,s,r,i,o,a,l,c=1;do{for(n=e,e=null,i=null,o=0;n;){for(o++,s=n,a=0,t=0;t<c&&(a++,s=s.nextZ,!!s);t++);for(l=c;a>0||l>0&&s;)a!==0&&(l===0||!s||n.z<=s.z)?(r=n,n=n.nextZ,a--):(r=s,s=s.nextZ,l--),i?i.nextZ=r:e=r,r.prevZ=i,i=r;n=s}i.nextZ=null,c*=2}while(o>1);return e}function GS(e,t,n,s,r){return e=32767*(e-n)*r,t=32767*(t-s)*r,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,e|t<<1}function QK(e){let t=e,n=e;do(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next;while(t!==e);return n}function vd(e,t,n,s,r,i,o,a){return(r-o)*(t-a)-(e-o)*(i-a)>=0&&(e-o)*(s-a)-(n-o)*(t-a)>=0&&(n-o)*(i-a)-(r-o)*(s-a)>=0}function ZK(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!JK(e,t)&&(Gf(e,t)&&Gf(t,e)&&eY(e,t)&&(Jn(e.prev,e,t.prev)||Jn(e,t.prev,t))||Oy(e,t)&&Jn(e.prev,e,e.next)>0&&Jn(t.prev,t,t.next)>0)}function Jn(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function Oy(e,t){return e.x===t.x&&e.y===t.y}function oM(e,t,n,s){let r=Ly(Jn(e,t,n)),i=Ly(Jn(e,t,s)),o=Ly(Jn(n,s,e)),a=Ly(Jn(n,s,t));return!!(r!==i&&o!==a||r===0&&Ry(e,n,t)||i===0&&Ry(e,s,t)||o===0&&Ry(n,e,s)||a===0&&Ry(n,t,s))}function Ry(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function Ly(e){return e>0?1:e<0?-1:0}function JK(e,t){let n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&oM(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}function Gf(e,t){return Jn(e.prev,e,e.next)<0?Jn(e,t,e.next)>=0&&Jn(e,e.prev,t)>=0:Jn(e,t,e.prev)<0||Jn(e,e.next,t)<0}function eY(e,t){let n=e,s=!1,r=(e.x+t.x)/2,i=(e.y+t.y)/2;do n.y>i!=n.next.y>i&&n.next.y!==n.y&&r<(n.next.x-n.x)*(i-n.y)/(n.next.y-n.y)+n.x&&(s=!s),n=n.next;while(n!==e);return s}function aM(e,t){let n=new WS(e.i,e.x,e.y),s=new WS(t.i,t.x,t.y),r=e.next,i=t.prev;return e.next=t,t.prev=e,n.next=r,r.prev=n,s.next=n,n.prev=s,i.next=s,s.prev=i,s}function lM(e,t,n,s){let r=new WS(e,t,n);return s?(r.next=s.next,r.prev=s,s.next.prev=r,s.next=r):(r.prev=r,r.next=r),r}function Wf(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function WS(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function tY(e,t,n,s){let r=0;for(let i=t,o=n-s;i<n;i+=s)r+=(e[o]-e[i])*(e[i+1]+e[o+1]),o=i;return r}var cM=class{static area(e){let t=e.length,n=0;for(let s=t-1,r=0;r<t;s=r++)n+=e[s].x*e[r].y-e[r].x*e[s].y;return n*.5}static isClockWise(e){return cM.area(e)<0}static triangulateShape(e,t){let n=[],s=[],r=[];uM(e),hM(n,e);let i=e.length;t.forEach(uM);for(let a=0;a<t.length;a++)s.push(i),i+=t[a].length,hM(n,t[a]);let o=BK.triangulate(n,s);for(let a=0;a<o.length;a+=3)r.push(o.slice(a,a+3));return r}};function uM(e){let t=e.length;t>2&&e[t-1].equals(e[0])&&e.pop()}function hM(e,t){for(let n=0;n<t.length;n++)e.push(t[n].x),e.push(t[n].y)}var dM=class extends VS{constructor(e=1,t=0){let n=(1+Math.sqrt(5))/2,s=[-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],r=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(s,r,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new dM(e.radius,e.detail)}},HS=class extends It{constructor(e=1,t=32,n=16,s=0,r=Math.PI*2,i=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:s,phiLength:r,thetaStart:i,thetaLength:o},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));let a=Math.min(i+o,Math.PI),l=0,c=[],h=new I,u=new I,d=[],p=[],f=[],g=[];for(let m=0;m<=n;m++){let y=[],v=m/n,b=0;m==0&&i==0?b=.5/t:m==n&&a==Math.PI&&(b=-.5/t);for(let x=0;x<=t;x++){let w=x/t;h.x=-e*Math.cos(s+w*r)*Math.sin(i+v*o),h.y=e*Math.cos(i+v*o),h.z=e*Math.sin(s+w*r)*Math.sin(i+v*o),p.push(h.x,h.y,h.z),u.copy(h).normalize(),f.push(u.x,u.y,u.z),g.push(w+b,1-v),y.push(l++)}c.push(y)}for(let m=0;m<n;m++)for(let y=0;y<t;y++){let v=c[m][y+1],b=c[m][y],x=c[m+1][y],w=c[m+1][y+1];(m!==0||i>0)&&d.push(v,b,w),(m!==n-1||a<Math.PI)&&d.push(b,x,w)}this.setIndex(d),this.setAttribute("position",new ot(p,3)),this.setAttribute("normal",new ot(f,3)),this.setAttribute("uv",new ot(g,2))}static fromJSON(e){return new HS(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}},pM=class extends It{constructor(e=1,t=.4,n=64,s=8,r=2,i=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:s,p:r,q:i},n=Math.floor(n),s=Math.floor(s);let o=[],a=[],l=[],c=[],h=new I,u=new I,d=new I,p=new I,f=new I,g=new I,m=new I;for(let v=0;v<=n;++v){let b=v/n*r*Math.PI*2;y(b,r,i,e,d),y(b+.01,r,i,e,p),g.subVectors(p,d),m.addVectors(p,d),f.crossVectors(g,m),m.crossVectors(f,g),f.normalize(),m.normalize();for(let x=0;x<=s;++x){let w=x/s*Math.PI*2,S=-t*Math.cos(w),C=t*Math.sin(w);h.x=d.x+(S*m.x+C*f.x),h.y=d.y+(S*m.y+C*f.y),h.z=d.z+(S*m.z+C*f.z),a.push(h.x,h.y,h.z),u.subVectors(h,d).normalize(),l.push(u.x,u.y,u.z),c.push(v/n),c.push(x/s)}}for(let v=1;v<=n;v++)for(let b=1;b<=s;b++){let x=(s+1)*(v-1)+(b-1),w=(s+1)*v+(b-1),S=(s+1)*v+b,C=(s+1)*(v-1)+b;o.push(x,w,C),o.push(w,S,C)}this.setIndex(o),this.setAttribute("position",new ot(a,3)),this.setAttribute("normal",new ot(l,3)),this.setAttribute("uv",new ot(c,2));function y(v,b,x,w,S){let C=Math.cos(v),_=Math.sin(v),T=x/b*v,E=Math.cos(T);S.x=w*(2+E)*.5*C,S.y=w*(2+E)*_*.5,S.z=w*Math.sin(T)*.5}}static fromJSON(e){return new pM(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}},fM={enabled:!1,files:{},add:function(e,t){this.enabled!==!1&&(this.files[e]=t)},get:function(e){if(this.enabled!==!1)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}},mM=class{constructor(e,t,n){let s=this,r=!1,i=0,o=0,a,l=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(c){o++,r===!1&&s.onStart!==void 0&&s.onStart(c,i,o),r=!0},this.itemEnd=function(c){i++,s.onProgress!==void 0&&s.onProgress(c,i,o),i===o&&(r=!1,s.onLoad!==void 0&&s.onLoad())},this.itemError=function(c){s.onError!==void 0&&s.onError(c)},this.resolveURL=function(c){return a?a(c):c},this.setURLModifier=function(c){return a=c,this},this.addHandler=function(c,h){return l.push(c,h),this},this.removeHandler=function(c){let h=l.indexOf(c);return h!==-1&&l.splice(h,2),this},this.getHandler=function(c){for(let h=0,u=l.length;h<u;h+=2){let d=l[h],p=l[h+1];if(d.global&&(d.lastIndex=0),d.test(c))return p}return null}}},nY=new mM,jS=class{constructor(e){this.manager=e!==void 0?e:nY,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){let n=this;return new Promise(function(s,r){n.load(e,s,t,r)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}},gl={},qS=class extends jS{constructor(e){super(e)}load(e,t,n,s){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);let r=fM.get(e);if(r!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(r),this.manager.itemEnd(e)},0),r;if(gl[e]!==void 0){gl[e].push({onLoad:t,onProgress:n,onError:s});return}gl[e]=[],gl[e].push({onLoad:t,onProgress:n,onError:s});let i=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,a=this.responseType;fetch(i).then(l=>{if(l.status===200||l.status===0){if(l.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||l.body===void 0||l.body.getReader===void 0)return l;let c=gl[e],h=l.body.getReader(),u=l.headers.get("Content-Length"),d=u?parseInt(u):0,p=d!==0,f=0,g=new ReadableStream({start(m){y();function y(){h.read().then(({done:v,value:b})=>{if(v)m.close();else{f+=b.byteLength;let x=new ProgressEvent("progress",{lengthComputable:p,loaded:f,total:d});for(let w=0,S=c.length;w<S;w++){let C=c[w];C.onProgress&&C.onProgress(x)}m.enqueue(b),y()}})}}});return new Response(g)}else throw Error(`fetch for "${l.url}" responded with ${l.status}: ${l.statusText}`)}).then(l=>{switch(a){case"arraybuffer":return l.arrayBuffer();case"blob":return l.blob();case"document":return l.text().then(c=>new DOMParser().parseFromString(c,o));case"json":return l.json();default:if(o===void 0)return l.text();{let c=/charset="?([^;"\s]*)"?/i.exec(o),h=c&&c[1]?c[1].toLowerCase():void 0,u=new TextDecoder(h);return l.arrayBuffer().then(d=>u.decode(d))}}}).then(l=>{fM.add(e,l);let c=gl[e];delete gl[e];for(let h=0,u=c.length;h<u;h++){let d=c[h];d.onLoad&&d.onLoad(l)}}).catch(l=>{let c=gl[e];if(c===void 0)throw this.manager.itemError(e),l;delete gl[e];for(let h=0,u=c.length;h<u;h++){let d=c[h];d.onError&&d.onError(l)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}},Hf=class extends Ln{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new _t(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){let t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}},sY=class extends Hf{constructor(e,t,n){super(e,n),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Ln.DefaultUp),this.updateMatrix(),this.groundColor=new _t(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}},gM=new et,yM=new I,vM=new I,XS=class{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new se(512,512),this.map=null,this.mapPass=null,this.matrix=new et,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new TS,this._frameExtents=new se(1,1),this._viewportCount=1,this._viewports=[new Bt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){let t=this.camera,n=this.matrix;yM.setFromMatrixPosition(e.matrixWorld),t.position.copy(yM),vM.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(vM),t.updateMatrixWorld(),gM.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(gM),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){let e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}},rY=class extends XS{constructor(){super(new vr(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){let t=this.camera,n=kf*2*e.angle*this.focus,s=this.mapSize.width/this.mapSize.height,r=e.distance||t.far;(n!==t.fov||s!==t.aspect||r!==t.far)&&(t.fov=n,t.aspect=s,t.far=r,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}},iY=class extends Hf{constructor(e,t,n=0,s=Math.PI/3,r=0,i=1){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Ln.DefaultUp),this.updateMatrix(),this.target=new Ln,this.distance=n,this.angle=s,this.penumbra=r,this.decay=i,this.shadow=new rY}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}},xM=new et,jf=new I,KS=new I,oY=class extends XS{constructor(){super(new vr(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new se(4,2),this._viewportCount=6,this._viewports=[new Bt(2,1,1,1),new Bt(0,1,1,1),new Bt(3,1,1,1),new Bt(1,1,1,1),new Bt(3,0,1,1),new Bt(1,0,1,1)],this._cubeDirections=[new I(1,0,0),new I(-1,0,0),new I(0,0,1),new I(0,0,-1),new I(0,1,0),new I(0,-1,0)],this._cubeUps=[new I(0,1,0),new I(0,1,0),new I(0,1,0),new I(0,1,0),new I(0,0,1),new I(0,0,-1)]}updateMatrices(e,t=0){let n=this.camera,s=this.matrix,r=e.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),jf.setFromMatrixPosition(e.matrixWorld),n.position.copy(jf),KS.copy(n.position),KS.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(KS),n.updateMatrixWorld(),s.makeTranslation(-jf.x,-jf.y,-jf.z),xM.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(xM)}},aY=class extends Hf{constructor(e,t,n=0,s=1){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=s,this.shadow=new oY}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}},lY=class extends XS{constructor(){super(new Cy(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}},cY=class extends Hf{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Ln.DefaultUp),this.updateMatrix(),this.target=new Ln,this.shadow=new lY}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}},uY=class extends It{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){let e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}},bM=class extends jS{constructor(e){super(e)}load(e,t,n,s){let r=this,i=new qS(r.manager);i.setPath(r.path),i.setRequestHeader(r.requestHeader),i.setWithCredentials(r.withCredentials),i.load(e,function(o){try{t(r.parse(JSON.parse(o)))}catch(a){s?s(a):console.error(a),r.manager.itemError(e)}},n,s)}parse(e){let t={},n={};function s(u,d){if(t[d]!==void 0)return t[d];let p=u.interleavedBuffers[d],f=r(u,p.buffer),g=ty(p.type,f),m=new _K(g,p.stride);return m.uuid=p.uuid,t[d]=m,m}function r(u,d){if(n[d]!==void 0)return n[d];let p=u.arrayBuffers[d],f=new Uint32Array(p).buffer;return n[d]=f,f}let i=e.isInstancedBufferGeometry?new uY:new It,o=e.data.index;if(o!==void 0){let u=ty(o.type,o.array);i.setIndex(new Lt(u,1))}let a=e.data.attributes;for(let u in a){let d=a[u],p;if(d.isInterleavedBufferAttribute){let f=s(e.data,d.data);p=new OS(f,d.itemSize,d.offset,d.normalized)}else{let f=ty(d.type,d.array),g=d.isInstancedBufferAttribute?CK:Lt;p=new g(f,d.itemSize,d.normalized)}d.name!==void 0&&(p.name=d.name),d.usage!==void 0&&p.setUsage(d.usage),d.updateRange!==void 0&&(p.updateRange.offset=d.updateRange.offset,p.updateRange.count=d.updateRange.count),i.setAttribute(u,p)}let l=e.data.morphAttributes;if(l)for(let u in l){let d=l[u],p=[];for(let f=0,g=d.length;f<g;f++){let m=d[f],y;if(m.isInterleavedBufferAttribute){let v=s(e.data,m.data);y=new OS(v,m.itemSize,m.offset,m.normalized)}else{let v=ty(m.type,m.array);y=new Lt(v,m.itemSize,m.normalized)}m.name!==void 0&&(y.name=m.name),p.push(y)}i.morphAttributes[u]=p}e.data.morphTargetsRelative&&(i.morphTargetsRelative=!0);let c=e.data.groups||e.data.drawcalls||e.data.offsets;if(c!==void 0)for(let u=0,d=c.length;u!==d;++u){let p=c[u];i.addGroup(p.start,p.count,p.materialIndex)}let h=e.data.boundingSphere;if(h!==void 0){let u=new I;h.center!==void 0&&u.fromArray(h.center),i.boundingSphere=new Wi(u,h.radius)}return e.name&&(i.name=e.name),e.userData&&(i.userData=e.userData),i}},hY=class{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=wM(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){let t=wM();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}};function wM(){return(typeof performance>"u"?Date:performance).now()}var SM="\\[\\]\\.:\\/",YS="[^"+SM+"]",dY="[^"+SM.replace("\\.","")+"]";/((?:WC+[\/:])*)/.source.replace("WC",YS);/(WCOD+)?/.source.replace("WCOD",dY);/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",YS);/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",YS);var dt=class{constructor(e){typeof e=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new dt(this.value.clone===void 0?this.value:this.value.clone())}},_M=class{constructor(e,t,n=0,s=1/0){this.ray=new td(e,t),this.near=n,this.far=s,this.camera=null,this.layers=new dS,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!0,n=[]){return QS(e,this,n,t),n.sort(CM),n}intersectObjects(e,t=!0,n=[]){for(let s=0,r=e.length;s<r;s++)QS(e[s],this,n,t);return n.sort(CM),n}};function CM(e,t){return e.distance-t.distance}function QS(e,t,n,s){if(e.layers.test(t.layers)&&e.raycast(t,n),s===!0){let r=e.children;for(let i=0,o=r.length;i<o;i++)QS(r[i],t,n,!0)}}var TM=class{constructor(e=1,t=0,n=0){return this.radius=e,this.phi=t,this.theta=n,this}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(ks(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}},EM=new se,pY=class{constructor(e=new se(1/0,1/0),t=new se(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){let n=EM.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return EM.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}},AM=new I,Fy=new I,qi=class{constructor(e=new I,t=new I){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){AM.subVectors(e,this.start),Fy.subVectors(this.end,this.start);let n=Fy.dot(Fy),s=Fy.dot(AM)/n;return t&&(s=ks(s,0,1)),s}closestPointToPoint(e,t,n){let s=this.closestPointToPointParameter(e,t);return this.delta(n).multiplyScalar(s).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}},IM=new I,fY=class extends Ln{constructor(e,t){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;let n=new It,s=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let i=0,o=1,a=32;i<a;i++,o++){let l=i/a*Math.PI*2,c=o/a*Math.PI*2;s.push(Math.cos(l),Math.sin(l),1,Math.cos(c),Math.sin(c),1)}n.setAttribute("position",new ot(s,3));let r=new nc({fog:!1,toneMapped:!1});this.cone=new Bf(n,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();let e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),IM.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(IM),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}},mY=class extends bi{constructor(e,t,n){let s=new HS(t,4,2),r=new Rf({wireframe:!0,fog:!1,toneMapped:!1});super(s,r),this.light=e,this.light.updateMatrixWorld(),this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}},NM=new I,$y=new I,kM=new I,gY=class extends Ln{constructor(e,t,n){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,t===void 0&&(t=1);let s=new It;s.setAttribute("position",new ot([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));let r=new nc({fog:!1,toneMapped:!1});this.lightPlane=new Ny(s,r),this.add(this.lightPlane),s=new It,s.setAttribute("position",new ot([0,0,0,0,0,1],3)),this.targetLine=new Ny(s,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){NM.setFromMatrixPosition(this.light.matrixWorld),$y.setFromMatrixPosition(this.light.target.matrixWorld),kM.subVectors($y,NM),this.lightPlane.lookAt($y),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt($y),this.targetLine.scale.z=kM.length()}},By=new I,ss=new ud,zy=class extends Bf{constructor(e){let t=new It,n=new nc({color:16777215,vertexColors:!0,toneMapped:!1}),s=[],r=[],i={};o("n1","n2"),o("n2","n4"),o("n4","n3"),o("n3","n1"),o("f1","f2"),o("f2","f4"),o("f4","f3"),o("f3","f1"),o("n1","f1"),o("n2","f2"),o("n3","f3"),o("n4","f4"),o("p","n1"),o("p","n2"),o("p","n3"),o("p","n4"),o("u1","u2"),o("u2","u3"),o("u3","u1"),o("c","t"),o("p","c"),o("cn1","cn2"),o("cn3","cn4"),o("cf1","cf2"),o("cf3","cf4");function o(p,f){a(p),a(f)}function a(p){s.push(0,0,0),r.push(0,0,0),i[p]===void 0&&(i[p]=[]),i[p].push(s.length/3-1)}t.setAttribute("position",new ot(s,3)),t.setAttribute("color",new ot(r,3)),super(t,n),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=i,this.update();let l=new _t(16755200),c=new _t(16711680),h=new _t(43775),u=new _t(16777215),d=new _t(3355443);this.setColors(l,c,h,u,d)}setColors(e,t,n,s,r){let i=this.geometry.getAttribute("color");i.setXYZ(0,e.r,e.g,e.b),i.setXYZ(1,e.r,e.g,e.b),i.setXYZ(2,e.r,e.g,e.b),i.setXYZ(3,e.r,e.g,e.b),i.setXYZ(4,e.r,e.g,e.b),i.setXYZ(5,e.r,e.g,e.b),i.setXYZ(6,e.r,e.g,e.b),i.setXYZ(7,e.r,e.g,e.b),i.setXYZ(8,e.r,e.g,e.b),i.setXYZ(9,e.r,e.g,e.b),i.setXYZ(10,e.r,e.g,e.b),i.setXYZ(11,e.r,e.g,e.b),i.setXYZ(12,e.r,e.g,e.b),i.setXYZ(13,e.r,e.g,e.b),i.setXYZ(14,e.r,e.g,e.b),i.setXYZ(15,e.r,e.g,e.b),i.setXYZ(16,e.r,e.g,e.b),i.setXYZ(17,e.r,e.g,e.b),i.setXYZ(18,e.r,e.g,e.b),i.setXYZ(19,e.r,e.g,e.b),i.setXYZ(20,e.r,e.g,e.b),i.setXYZ(21,e.r,e.g,e.b),i.setXYZ(22,e.r,e.g,e.b),i.setXYZ(23,e.r,e.g,e.b),i.setXYZ(24,t.r,t.g,t.b),i.setXYZ(25,t.r,t.g,t.b),i.setXYZ(26,t.r,t.g,t.b),i.setXYZ(27,t.r,t.g,t.b),i.setXYZ(28,t.r,t.g,t.b),i.setXYZ(29,t.r,t.g,t.b),i.setXYZ(30,t.r,t.g,t.b),i.setXYZ(31,t.r,t.g,t.b),i.setXYZ(32,n.r,n.g,n.b),i.setXYZ(33,n.r,n.g,n.b),i.setXYZ(34,n.r,n.g,n.b),i.setXYZ(35,n.r,n.g,n.b),i.setXYZ(36,n.r,n.g,n.b),i.setXYZ(37,n.r,n.g,n.b),i.setXYZ(38,s.r,s.g,s.b),i.setXYZ(39,s.r,s.g,s.b),i.setXYZ(40,r.r,r.g,r.b),i.setXYZ(41,r.r,r.g,r.b),i.setXYZ(42,r.r,r.g,r.b),i.setXYZ(43,r.r,r.g,r.b),i.setXYZ(44,r.r,r.g,r.b),i.setXYZ(45,r.r,r.g,r.b),i.setXYZ(46,r.r,r.g,r.b),i.setXYZ(47,r.r,r.g,r.b),i.setXYZ(48,r.r,r.g,r.b),i.setXYZ(49,r.r,r.g,r.b),i.needsUpdate=!0}update(){let e=this.geometry,t=this.pointMap,n=1,s=1;ss.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),ds("c",t,e,ss,0,0,-1),ds("t",t,e,ss,0,0,1),ds("n1",t,e,ss,-n,-s,-1),ds("n2",t,e,ss,n,-s,-1),ds("n3",t,e,ss,-n,s,-1),ds("n4",t,e,ss,n,s,-1),ds("f1",t,e,ss,-n,-s,1),ds("f2",t,e,ss,n,-s,1),ds("f3",t,e,ss,-n,s,1),ds("f4",t,e,ss,n,s,1),ds("u1",t,e,ss,n*.7,s*1.1,-1),ds("u2",t,e,ss,-n*.7,s*1.1,-1),ds("u3",t,e,ss,0,s*2,-1),ds("cf1",t,e,ss,-n,0,1),ds("cf2",t,e,ss,n,0,1),ds("cf3",t,e,ss,0,-s,1),ds("cf4",t,e,ss,0,s,1),ds("cn1",t,e,ss,-n,0,-1),ds("cn2",t,e,ss,n,0,-1),ds("cn3",t,e,ss,0,-s,-1),ds("cn4",t,e,ss,0,s,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}};function ds(e,t,n,s,r,i,o){By.set(r,i,o).unproject(s);let a=t[e];if(a!==void 0){let l=n.getAttribute("position");for(let c=0,h=a.length;c<h;c++)l.setXYZ(a[c],By.x,By.y,By.z)}}var Uy=class extends Bf{constructor(e,t=16776960){let n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],r=new It;r.setIndex(new Lt(n,1)),r.setAttribute("position",new ot(s,3)),super(r,new nc({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){let t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}},yY=class extends Bf{constructor(e=1){let t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],s=new It;s.setAttribute("position",new ot(t,3)),s.setAttribute("color",new ot(n,3));let r=new nc({vertexColors:!0,toneMapped:!1});super(s,r),this.type="AxesHelper"}setColors(e,t,n){let s=new _t,r=this.geometry.attributes.color.array;return s.set(e),s.toArray(r,0),s.toArray(r,3),s.set(t),s.toArray(r,6),s.toArray(r,9),s.set(n),s.toArray(r,12),s.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}};vY();function vY(){let e=new ArrayBuffer(4),t=new Float32Array(e),n=new Uint32Array(e),s=new Uint32Array(512),r=new Uint32Array(512);for(let l=0;l<256;++l){let c=l-127;c<-27?(s[l]=0,s[l|256]=32768,r[l]=24,r[l|256]=24):c<-14?(s[l]=1024>>-c-14,s[l|256]=1024>>-c-14|32768,r[l]=-c-1,r[l|256]=-c-1):c<=15?(s[l]=c+15<<10,s[l|256]=c+15<<10|32768,r[l]=13,r[l|256]=13):c<128?(s[l]=31744,s[l|256]=64512,r[l]=24,r[l|256]=24):(s[l]=31744,s[l|256]=64512,r[l]=13,r[l|256]=13)}let i=new Uint32Array(2048),o=new Uint32Array(64),a=new Uint32Array(64);for(let l=1;l<1024;++l){let c=l<<13,h=0;for(;(c&8388608)==0;)c<<=1,h-=8388608;c&=-8388609,h+=947912704,i[l]=c|h}for(let l=1024;l<2048;++l)i[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)o[l]=l<<23;o[31]=1199570944,o[32]=2147483648;for(let l=33;l<63;++l)o[l]=2147483648+(l-32<<23);o[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(a[l]=1024);return{floatView:t,uint32View:n,baseTable:s,shiftTable:r,mantissaTable:i,exponentTable:o,offsetTable:a}}var xY=class extends hs{constructor(e,t,n){console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),super(e,t,n),this.samples=4}};typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:_f}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=_f);var qf=".",ZS=Symbol("target"),DM=Symbol("unsubscribe");function JS(e){return e instanceof Date||e instanceof Set||e instanceof Map||e instanceof WeakSet||e instanceof WeakMap||ArrayBuffer.isView(e)}function bY(e){return(typeof e=="object"?e===null:typeof e!="function")||e instanceof RegExp}var ga=Array.isArray;function e_(e){return typeof e=="symbol"}var wY={after:(e,t)=>ga(e)?e.slice(t.length):t===""?e:e.slice(t.length+1),concat:(e,t)=>ga(e)?(e=[...e],t&&e.push(t),e):t&&t.toString!==void 0?(e!==""&&(e+=qf),e_(t)?e+t.toString():e+t):e,initial:e=>{if(ga(e))return e.slice(0,-1);if(e==="")return e;let t=e.lastIndexOf(qf);return t===-1?"":e.slice(0,t)},last:e=>{if(ga(e))return e[e.length-1]||"";if(e==="")return e;let t=e.lastIndexOf(qf);return t===-1?e:e.slice(t+1)},walk:(e,t)=>{if(ga(e))for(let n of e)t(n);else if(e!==""){let n=0,s=e.indexOf(qf);if(s===-1)t(e);else for(;n<e.length;)s===-1&&(s=e.length),t(e.slice(n,s)),n=s+1,s=e.indexOf(qf,n)}},get(e,t){return this.walk(t,n=>{e&&(e=e[n])}),e}},Xi=wY;function SY(e){return typeof e=="object"&&typeof e.next=="function"}function _Y(e,t,n,s,r){let i=e.next;if(t.name==="entries")e.next=function(){let o=i.call(this);return o.done===!1&&(o.value[0]=r(o.value[0],t,o.value[0],s),o.value[1]=r(o.value[1],t,o.value[0],s)),o};else if(t.name==="values"){let o=n[ZS].keys();e.next=function(){let a=i.call(this);return a.done===!1&&(a.value=r(a.value,t,o.next().value,s)),a}}else e.next=function(){let o=i.call(this);return o.done===!1&&(o.value=r(o.value,t,o.value,s)),o};return e}function MM(e,t,n){return e.isUnsubscribed||t.ignoreSymbols&&e_(n)||t.ignoreUnderscores&&n.charAt(0)==="_"||"ignoreKeys"in t&&t.ignoreKeys.includes(n)}var CY=class{constructor(e){this._equals=e,this._proxyCache=new WeakMap,this._pathCache=new WeakMap,this.isUnsubscribed=!1}_getDescriptorCache(){return this._descriptorCache===void 0&&(this._descriptorCache=new WeakMap),this._descriptorCache}_getProperties(e){let t=this._getDescriptorCache(),n=t.get(e);return n===void 0&&(n={},t.set(e,n)),n}_getOwnPropertyDescriptor(e,t){if(this.isUnsubscribed)return Reflect.getOwnPropertyDescriptor(e,t);let n=this._getProperties(e),s=n[t];return s===void 0&&(s=Reflect.getOwnPropertyDescriptor(e,t),n[t]=s),s}getProxy(e,t,n,s){if(this.isUnsubscribed)return e;let r=e[s],i=r||e;this._pathCache.set(i,t);let o=this._proxyCache.get(i);return o===void 0&&(o=r===void 0?new Proxy(e,n):e,this._proxyCache.set(i,o)),o}getPath(e){return this.isUnsubscribed?void 0:this._pathCache.get(e)}isDetached(e,t){return!Object.is(e,Xi.get(t,this.getPath(e)))}defineProperty(e,t,n){return Reflect.defineProperty(e,t,n)?(this.isUnsubscribed||(this._getProperties(e)[t]=n),!0):!1}setProperty(e,t,n,s,r){if(!this._equals(r,n)||!(t in e)){let i=this._getOwnPropertyDescriptor(e,t);return i!==void 0&&"set"in i?Reflect.set(e,t,n,s):Reflect.set(e,t,n)}return!0}deleteProperty(e,t,n){if(Reflect.deleteProperty(e,t)){if(!this.isUnsubscribed){let s=this._getDescriptorCache().get(e);s&&(delete s[t],this._pathCache.delete(n))}return!0}return!1}isSameDescriptor(e,t,n){let s=this._getOwnPropertyDescriptor(t,n);return e!==void 0&&s!==void 0&&Object.is(e.value,s.value)&&(e.writable||!1)===(s.writable||!1)&&(e.enumerable||!1)===(s.enumerable||!1)&&(e.configurable||!1)===(s.configurable||!1)&&e.get===s.get&&e.set===s.set}isGetInvariant(e,t){let n=this._getOwnPropertyDescriptor(e,t);return n!==void 0&&n.configurable!==!0&&n.writable!==!0}unsubscribe(){this._descriptorCache=null,this._pathCache=null,this._proxyCache=null,this.isUnsubscribed=!0}};function t_(e){return toString.call(e)==="[object Object]"}function Vy(){return!0}function xd(e,t){return e.length!==t.length||e.some((n,s)=>t[s]!==n)}var PM=new Set(["hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]),TY=new Set(["concat","includes","indexOf","join","keys","lastIndexOf"]),OM={push:Vy,pop:Vy,shift:Vy,unshift:Vy,copyWithin:xd,reverse:xd,sort:xd,splice:xd,flat:xd,fill:xd},EY=new Set([...PM,...TY,...Object.keys(OM)]);function Gy(e,t){if(e.size!==t.size)return!0;for(let n of e)if(!t.has(n))return!0;return!1}var RM=["keys","values","entries"],LM=new Set(["has","toString"]),FM={add:Gy,clear:Gy,delete:Gy,forEach:Gy},AY=new Set([...LM,...Object.keys(FM),...RM]);function Wy(e,t){if(e.size!==t.size)return!0;let n;for(let[s,r]of e)if(n=t.get(s),n!==r||n===void 0&&!t.has(s))return!0;return!1}var IY=new Set([...LM,"get"]),$M={set:Wy,clear:Wy,delete:Wy,forEach:Wy},NY=new Set([...IY,...Object.keys($M),...RM]),ic=class{constructor(e,t,n,s){this._path=t,this._isChanged=!1,this._clonedCache=new Set,this._hasOnValidate=s,this._changes=s?[]:null,this.clone=t===void 0?e:this._shallowClone(e)}static isHandledMethod(e){return PM.has(e)}_shallowClone(e){let t=e;if(t_(e))t=ue({},e);else if(ga(e))t=[...e];else if(e instanceof Date)t=new Date(e);else if(e instanceof Set)t=new Set([...e].map(n=>this._shallowClone(n)));else if(e instanceof Map){t=new Map;for(let[n,s]of e.entries())t.set(n,this._shallowClone(s))}return this._clonedCache.add(t),t}preferredThisArg(e,t,n,s){return e?(ga(s)?this._onIsChanged=OM[t]:s instanceof Set?this._onIsChanged=FM[t]:s instanceof Map&&(this._onIsChanged=$M[t]),s):n}update(e,t,n){let s=Xi.after(e,this._path);if(t!=="length"){let r=this.clone;Xi.walk(s,i=>{r&&r[i]&&(this._clonedCache.has(r[i])||(r[i]=this._shallowClone(r[i])),r=r[i])}),this._hasOnValidate&&this._changes.push({path:s,property:t,previous:n}),r&&r[t]&&(r[t]=n)}this._isChanged=!0}undo(e){let t;for(let n=this._changes.length-1;n!==-1;n--)t=this._changes[n],Xi.get(e,t.path)[t.property]=t.previous}isChanged(e){return this._onIsChanged===void 0?this._isChanged:this._onIsChanged(this.clone,e)}},BM=class extends ic{static isHandledMethod(e){return EY.has(e)}},kY=class extends ic{undo(e){e.setTime(this.clone.getTime())}isChanged(e,t){return!t(this.clone.valueOf(),e.valueOf())}},zM=class extends ic{static isHandledMethod(e){return AY.has(e)}undo(e){for(let t of this.clone)e.add(t);for(let t of e)this.clone.has(t)||e.delete(t)}},UM=class extends ic{static isHandledMethod(e){return NY.has(e)}undo(e){for(let[t,n]of this.clone.entries())e.set(t,n);for(let t of e.keys())this.clone.has(t)||e.delete(t)}},DY=class extends ic{constructor(e,t,n,s){super(void 0,t,n,s),this._arg1=n[0],this._weakValue=e.has(this._arg1)}isChanged(e){return this._weakValue!==e.has(this._arg1)}undo(e){this._weakValue&&!e.has(this._arg1)?e.add(this._arg1):e.delete(this._arg1)}},MY=class extends ic{constructor(e,t,n,s){super(void 0,t,n,s),this._weakKey=n[0],this._weakHas=e.has(this._weakKey),this._weakValue=e.get(this._weakKey)}isChanged(e){return this._weakValue!==e.get(this._weakKey)}undo(e){let t=e.has(this._weakKey);this._weakHas&&!t?e.set(this._weakKey,this._weakValue):!this._weakHas&&t?e.delete(this._weakKey):this._weakValue!==e.get(this._weakKey)&&e.set(this._weakKey,this._weakValue)}},bd=class{constructor(e){this._stack=[],this._hasOnValidate=e}static isHandledType(e){return t_(e)||ga(e)||JS(e)}static isHandledMethod(e,t){return t_(e)?ic.isHandledMethod(t):ga(e)?BM.isHandledMethod(t):e instanceof Set?zM.isHandledMethod(t):e instanceof Map?UM.isHandledMethod(t):JS(e)}get isCloning(){return this._stack.length>0}start(e,t,n){let s=ic;ga(e)?s=BM:e instanceof Date?s=kY:e instanceof Set?s=zM:e instanceof Map?s=UM:e instanceof WeakSet?s=DY:e instanceof WeakMap&&(s=MY),this._stack.push(new s(e,t,n,this._hasOnValidate))}update(e,t,n){this._stack[this._stack.length-1].update(e,t,n)}preferredThisArg(e,t,n){let{name:s}=e,r=bd.isHandledMethod(n,s);return this._stack[this._stack.length-1].preferredThisArg(r,s,t,n)}isChanged(e,t,n){return this._stack[this._stack.length-1].isChanged(e,t,n)}undo(e){this._previousClone!==void 0&&this._previousClone.undo(e)}stop(){return this._previousClone=this._stack.pop(),this._previousClone.clone}},PY={equals:Object.is,isShallow:!1,pathAsArray:!1,ignoreSymbols:!1,ignoreUnderscores:!1,ignoreDetached:!1,details:!1},n_=(e,t,n={})=>{n=ue(ue({},PY),n);let s=Symbol("ProxyTarget"),{equals:r,isShallow:i,ignoreDetached:o,details:a}=n,l=new CY(r),c=typeof n.onValidate=="function",h=new bd(c),u=(v,b,x,w,S)=>!c||h.isCloning||n.onValidate(Xi.concat(l.getPath(v),b),x,w,S)===!0,d=(v,b,x,w)=>{!MM(l,n,b)&&!(o&&l.isDetached(v,e))&&p(l.getPath(v),b,x,w)},p=(v,b,x,w,S)=>{h.isCloning?h.update(v,b,w):t(Xi.concat(v,b),x,w,S)},f=v=>v&&(v[s]||v),g=(v,b,x,w)=>bY(v)||x==="constructor"||i&&!bd.isHandledMethod(b,x)||MM(l,n,x)||l.isGetInvariant(b,x)||o&&l.isDetached(b,e)?v:(w===void 0&&(w=l.getPath(b)),l.getProxy(v,Xi.concat(w,x),m,s)),m={get(v,b,x){if(e_(b)){if(b===s||b===ZS)return v;if(b===DM&&!l.isUnsubscribed&&l.getPath(v).length===0)return l.unsubscribe(),v}let w=JS(v)?Reflect.get(v,b):Reflect.get(v,b,x);return g(w,v,b)},set(v,b,x,w){x=f(x);let S=v[s]||v,C=S[b];if(r(C,x)&&b in v)return!0;let _=u(v,b,x,C);return _&&l.setProperty(S,b,x,w,C)?(d(v,b,v[b],C),!0):!_},defineProperty(v,b,x){if(!l.isSameDescriptor(x,v,b)){let w=v[b];u(v,b,x.value,w)&&l.defineProperty(v,b,x,w)&&d(v,b,x.value,w)}return!0},deleteProperty(v,b){if(!Reflect.has(v,b))return!0;let x=Reflect.get(v,b),w=u(v,b,void 0,x);return w&&l.deleteProperty(v,b,x)?(d(v,b,void 0,x),!0):!w},apply(v,b,x){let w=b[s]||b;if(l.isUnsubscribed)return Reflect.apply(v,w,x);if((a===!1||a!==!0&&!a.includes(v.name))&&bd.isHandledType(w)){let S=Xi.initial(l.getPath(v)),C=bd.isHandledMethod(w,v.name);h.start(w,S,x);let _=Reflect.apply(v,h.preferredThisArg(v,b,w),C?x.map(A=>f(A)):x),T=h.isChanged(w,r),E=h.stop();if(bd.isHandledType(_)&&C&&(b instanceof Map&&v.name==="get"&&(S=Xi.concat(S,x[0])),_=l.getProxy(_,S,m)),T){let A={name:v.name,args:x,result:_},D=h.isCloning?Xi.initial(S):S,O=h.isCloning?Xi.last(S):"";u(Xi.get(e,D),O,w,E,A)?p(D,O,w,E,A):h.undo(w)}return(b instanceof Map||b instanceof Set)&&SY(_)?_Y(_,v,b,S,g):_}return Reflect.apply(v,b,x)}},y=l.getProxy(e,n.pathAsArray?[]:"",m);return t=t.bind(y),c&&(n.onValidate=n.onValidate.bind(y)),y};n_.target=e=>e&&e[ZS]||e;n_.unsubscribe=e=>e[DM]||e;var VM=n_,OY=typeof global=="object"&&global&&global.Object===Object&&global,GM=OY,RY=typeof self=="object"&&self&&self.Object===Object&&self,LY=GM||RY||Function("return this")(),Oo=LY,FY=Oo.Symbol,Ki=FY,WM=Object.prototype,$Y=WM.hasOwnProperty,BY=WM.toString,Xf=Ki?Ki.toStringTag:void 0;function zY(e){var t=$Y.call(e,Xf),n=e[Xf];try{e[Xf]=void 0;var s=!0}catch{}var r=BY.call(e);return s&&(t?e[Xf]=n:delete e[Xf]),r}var UY=zY,VY=Object.prototype,GY=VY.toString;function WY(e){return GY.call(e)}var HY=WY,jY="[object Null]",qY="[object Undefined]",HM=Ki?Ki.toStringTag:void 0;function XY(e){return e==null?e===void 0?qY:jY:HM&&HM in Object(e)?UY(e):HY(e)}var Cu=XY;function KY(e){return e!=null&&typeof e=="object"}var yl=KY,YY="[object Symbol]";function QY(e){return typeof e=="symbol"||yl(e)&&Cu(e)==YY}var Hy=QY;function ZY(e,t){for(var n=-1,s=e==null?0:e.length,r=Array(s);++n<s;)r[n]=t(e[n],n,e);return r}var jM=ZY,JY=Array.isArray,ya=JY,eQ=1/0,qM=Ki?Ki.prototype:void 0,XM=qM?qM.toString:void 0;function KM(e){if(typeof e=="string")return e;if(ya(e))return jM(e,KM)+"";if(Hy(e))return XM?XM.call(e):"";var t=e+"";return t=="0"&&1/e==-eQ?"-0":t}var tQ=KM,nQ=/\s/;function sQ(e){for(var t=e.length;t--&&nQ.test(e.charAt(t)););return t}var rQ=sQ,iQ=/^\s+/;function oQ(e){return e&&e.slice(0,rQ(e)+1).replace(iQ,"")}var aQ=oQ;function lQ(e){var t=typeof e;return e!=null&&(t=="object"||t=="function")}var va=lQ,YM=0/0,cQ=/^[-+]0x[0-9a-f]+$/i,uQ=/^0b[01]+$/i,hQ=/^0o[0-7]+$/i,dQ=parseInt;function pQ(e){if(typeof e=="number")return e;if(Hy(e))return YM;if(va(e)){var t=typeof e.valueOf=="function"?e.valueOf():e;e=va(t)?t+"":t}if(typeof e!="string")return e===0?e:+e;e=aQ(e);var n=uQ.test(e);return n||hQ.test(e)?dQ(e.slice(2),n?2:8):cQ.test(e)?YM:+e}var QM=pQ;function fQ(e){return e}var mQ=fQ,gQ="[object AsyncFunction]",yQ="[object Function]",vQ="[object GeneratorFunction]",xQ="[object Proxy]";function bQ(e){if(!va(e))return!1;var t=Cu(e);return t==yQ||t==vQ||t==gQ||t==xQ}var ZM=bQ,wQ=Oo["__core-js_shared__"],s_=wQ,JM=function(){var e=/[^.]+$/.exec(s_&&s_.keys&&s_.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}();function SQ(e){return!!JM&&JM in e}var _Q=SQ,CQ=Function.prototype,TQ=CQ.toString;function EQ(e){if(e!=null){try{return TQ.call(e)}catch{}try{return e+""}catch{}}return""}var Tu=EQ,AQ=/[\\^$.*+?()[\]{}|]/g,IQ=/^\[object .+?Constructor\]$/,NQ=Function.prototype,kQ=Object.prototype,DQ=NQ.toString,MQ=kQ.hasOwnProperty,PQ=RegExp("^"+DQ.call(MQ).replace(AQ,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");function OQ(e){if(!va(e)||_Q(e))return!1;var t=ZM(e)?PQ:IQ;return t.test(Tu(e))}var RQ=OQ;function LQ(e,t){return e==null?void 0:e[t]}var FQ=LQ;function $Q(e,t){var n=FQ(e,t);return RQ(n)?n:void 0}var Eu=$Q,BQ=Eu(Oo,"WeakMap"),r_=BQ,e3=Object.create,zQ=function(){function e(){}return function(t){if(!va(t))return{};if(e3)return e3(t);e.prototype=t;var n=new e;return e.prototype=void 0,n}}(),UQ=zQ;function VQ(e,t,n){switch(n.length){case 0:return e.call(t);case 1:return e.call(t,n[0]);case 2:return e.call(t,n[0],n[1]);case 3:return e.call(t,n[0],n[1],n[2])}return e.apply(t,n)}var GQ=VQ;function WQ(e,t){var n=-1,s=e.length;for(t||(t=Array(s));++n<s;)t[n]=e[n];return t}var HQ=WQ,jQ=800,qQ=16,XQ=Date.now;function KQ(e){var t=0,n=0;return function(){var s=XQ(),r=qQ-(s-n);if(n=s,r>0){if(++t>=jQ)return arguments[0]}else t=0;return e.apply(void 0,arguments)}}var YQ=KQ;function QQ(e){return function(){return e}}var ZQ=QQ,JQ=function(){try{var e=Eu(Object,"defineProperty");return e({},"",{}),e}catch{}}(),jy=JQ,eZ=jy?function(e,t){return jy(e,"toString",{configurable:!0,enumerable:!1,value:ZQ(t),writable:!0})}:mQ,tZ=eZ,nZ=YQ(tZ),sZ=nZ;function rZ(e,t){for(var n=-1,s=e==null?0:e.length;++n<s&&t(e[n],n,e)!==!1;);return e}var iZ=rZ,oZ=9007199254740991,aZ=/^(?:0|[1-9]\d*)$/;function lZ(e,t){var n=typeof e;return t=t!=null?t:oZ,!!t&&(n=="number"||n!="symbol"&&aZ.test(e))&&e>-1&&e%1==0&&e<t}var i_=lZ;function cZ(e,t,n){t=="__proto__"&&jy?jy(e,t,{configurable:!0,enumerable:!0,value:n,writable:!0}):e[t]=n}var t3=cZ;function uZ(e,t){return e===t||e!==e&&t!==t}var o_=uZ,hZ=Object.prototype,dZ=hZ.hasOwnProperty;function pZ(e,t,n){var s=e[t];(!(dZ.call(e,t)&&o_(s,n))||n===void 0&&!(t in e))&&t3(e,t,n)}var a_=pZ;function fZ(e,t,n,s){var r=!n;n||(n={});for(var i=-1,o=t.length;++i<o;){var a=t[i],l=s?s(n[a],e[a],a,n,e):void 0;l===void 0&&(l=e[a]),r?t3(n,a,l):a_(n,a,l)}return n}var Kf=fZ,n3=Math.max;function mZ(e,t,n){return t=n3(t===void 0?e.length-1:t,0),function(){for(var s=arguments,r=-1,i=n3(s.length-t,0),o=Array(i);++r<i;)o[r]=s[t+r];r=-1;for(var a=Array(t+1);++r<t;)a[r]=s[r];return a[t]=n(o),GQ(e,this,a)}}var gZ=mZ,yZ=9007199254740991;function vZ(e){return typeof e=="number"&&e>-1&&e%1==0&&e<=yZ}var l_=vZ;function xZ(e){return e!=null&&l_(e.length)&&!ZM(e)}var s3=xZ,bZ=Object.prototype;function wZ(e){var t=e&&e.constructor,n=typeof t=="function"&&t.prototype||bZ;return e===n}var c_=wZ;function SZ(e,t){for(var n=-1,s=Array(e);++n<e;)s[n]=t(n);return s}var _Z=SZ,CZ="[object Arguments]";function TZ(e){return yl(e)&&Cu(e)==CZ}var r3=TZ,i3=Object.prototype,EZ=i3.hasOwnProperty,AZ=i3.propertyIsEnumerable,IZ=r3(function(){return arguments}())?r3:function(e){return yl(e)&&EZ.call(e,"callee")&&!AZ.call(e,"callee")},u_=IZ;function NZ(){return!1}var kZ=NZ,o3=typeof Ui=="object"&&Ui&&!Ui.nodeType&&Ui,a3=o3&&typeof Vi=="object"&&Vi&&!Vi.nodeType&&Vi,DZ=a3&&a3.exports===o3,l3=DZ?Oo.Buffer:void 0,MZ=l3?l3.isBuffer:void 0,PZ=MZ||kZ,qy=PZ,OZ="[object Arguments]",RZ="[object Array]",LZ="[object Boolean]",FZ="[object Date]",$Z="[object Error]",BZ="[object Function]",zZ="[object Map]",UZ="[object Number]",VZ="[object Object]",GZ="[object RegExp]",WZ="[object Set]",HZ="[object String]",jZ="[object WeakMap]",qZ="[object ArrayBuffer]",XZ="[object DataView]",KZ="[object Float32Array]",YZ="[object Float64Array]",QZ="[object Int8Array]",ZZ="[object Int16Array]",JZ="[object Int32Array]",eJ="[object Uint8Array]",tJ="[object Uint8ClampedArray]",nJ="[object Uint16Array]",sJ="[object Uint32Array]",Gn={};Gn[KZ]=Gn[YZ]=Gn[QZ]=Gn[ZZ]=Gn[JZ]=Gn[eJ]=Gn[tJ]=Gn[nJ]=Gn[sJ]=!0;Gn[OZ]=Gn[RZ]=Gn[qZ]=Gn[LZ]=Gn[XZ]=Gn[FZ]=Gn[$Z]=Gn[BZ]=Gn[zZ]=Gn[UZ]=Gn[VZ]=Gn[GZ]=Gn[WZ]=Gn[HZ]=Gn[jZ]=!1;function rJ(e){return yl(e)&&l_(e.length)&&!!Gn[Cu(e)]}var iJ=rJ;function oJ(e){return function(t){return e(t)}}var h_=oJ,c3=typeof Ui=="object"&&Ui&&!Ui.nodeType&&Ui,Yf=c3&&typeof Vi=="object"&&Vi&&!Vi.nodeType&&Vi,aJ=Yf&&Yf.exports===c3,d_=aJ&&GM.process,lJ=function(){try{var e=Yf&&Yf.require&&Yf.require("util").types;return e||d_&&d_.binding&&d_.binding("util")}catch{}}(),wd=lJ,u3=wd&&wd.isTypedArray,cJ=u3?h_(u3):iJ,h3=cJ,uJ=Object.prototype,hJ=uJ.hasOwnProperty;function dJ(e,t){var n=ya(e),s=!n&&u_(e),r=!n&&!s&&qy(e),i=!n&&!s&&!r&&h3(e),o=n||s||r||i,a=o?_Z(e.length,String):[],l=a.length;for(var c in e)(t||hJ.call(e,c))&&!(o&&(c=="length"||r&&(c=="offset"||c=="parent")||i&&(c=="buffer"||c=="byteLength"||c=="byteOffset")||i_(c,l)))&&a.push(c);return a}var d3=dJ;function pJ(e,t){return function(n){return e(t(n))}}var p3=pJ,fJ=p3(Object.keys,Object),mJ=fJ,gJ=Object.prototype,yJ=gJ.hasOwnProperty;function vJ(e){if(!c_(e))return mJ(e);var t=[];for(var n in Object(e))yJ.call(e,n)&&n!="constructor"&&t.push(n);return t}var xJ=vJ;function bJ(e){return s3(e)?d3(e):xJ(e)}var p_=bJ;function wJ(e){var t=[];if(e!=null)for(var n in Object(e))t.push(n);return t}var SJ=wJ,_J=Object.prototype,CJ=_J.hasOwnProperty;function TJ(e){if(!va(e))return SJ(e);var t=c_(e),n=[];for(var s in e)s=="constructor"&&(t||!CJ.call(e,s))||n.push(s);return n}var EJ=TJ;function AJ(e){return s3(e)?d3(e,!0):EJ(e)}var f_=AJ,IJ=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,NJ=/^\w*$/;function kJ(e,t){if(ya(e))return!1;var n=typeof e;return n=="number"||n=="symbol"||n=="boolean"||e==null||Hy(e)?!0:NJ.test(e)||!IJ.test(e)||t!=null&&e in Object(t)}var DJ=kJ,MJ=Eu(Object,"create"),Qf=MJ;function PJ(){this.__data__=Qf?Qf(null):{},this.size=0}var OJ=PJ;function RJ(e){var t=this.has(e)&&delete this.__data__[e];return this.size-=t?1:0,t}var LJ=RJ,FJ="__lodash_hash_undefined__",$J=Object.prototype,BJ=$J.hasOwnProperty;function zJ(e){var t=this.__data__;if(Qf){var n=t[e];return n===FJ?void 0:n}return BJ.call(t,e)?t[e]:void 0}var UJ=zJ,VJ=Object.prototype,GJ=VJ.hasOwnProperty;function WJ(e){var t=this.__data__;return Qf?t[e]!==void 0:GJ.call(t,e)}var HJ=WJ,jJ="__lodash_hash_undefined__";function qJ(e,t){var n=this.__data__;return this.size+=this.has(e)?0:1,n[e]=Qf&&t===void 0?jJ:t,this}var XJ=qJ;function Sd(e){var t=-1,n=e==null?0:e.length;for(this.clear();++t<n;){var s=e[t];this.set(s[0],s[1])}}Sd.prototype.clear=OJ;Sd.prototype.delete=LJ;Sd.prototype.get=UJ;Sd.prototype.has=HJ;Sd.prototype.set=XJ;var f3=Sd;function KJ(){this.__data__=[],this.size=0}var YJ=KJ;function QJ(e,t){for(var n=e.length;n--;)if(o_(e[n][0],t))return n;return-1}var Xy=QJ,ZJ=Array.prototype,JJ=ZJ.splice;function eee(e){var t=this.__data__,n=Xy(t,e);if(n<0)return!1;var s=t.length-1;return n==s?t.pop():JJ.call(t,n,1),--this.size,!0}var tee=eee;function nee(e){var t=this.__data__,n=Xy(t,e);return n<0?void 0:t[n][1]}var see=nee;function ree(e){return Xy(this.__data__,e)>-1}var iee=ree;function oee(e,t){var n=this.__data__,s=Xy(n,e);return s<0?(++this.size,n.push([e,t])):n[s][1]=t,this}var aee=oee;function _d(e){var t=-1,n=e==null?0:e.length;for(this.clear();++t<n;){var s=e[t];this.set(s[0],s[1])}}_d.prototype.clear=YJ;_d.prototype.delete=tee;_d.prototype.get=see;_d.prototype.has=iee;_d.prototype.set=aee;var Ky=_d,lee=Eu(Oo,"Map"),Zf=lee;function cee(){this.size=0,this.__data__={hash:new f3,map:new(Zf||Ky),string:new f3}}var uee=cee;function hee(e){var t=typeof e;return t=="string"||t=="number"||t=="symbol"||t=="boolean"?e!=="__proto__":e===null}var dee=hee;function pee(e,t){var n=e.__data__;return dee(t)?n[typeof t=="string"?"string":"hash"]:n.map}var Yy=pee;function fee(e){var t=Yy(this,e).delete(e);return this.size-=t?1:0,t}var mee=fee;function gee(e){return Yy(this,e).get(e)}var yee=gee;function vee(e){return Yy(this,e).has(e)}var xee=vee;function bee(e,t){var n=Yy(this,e),s=n.size;return n.set(e,t),this.size+=n.size==s?0:1,this}var wee=bee;function Cd(e){var t=-1,n=e==null?0:e.length;for(this.clear();++t<n;){var s=e[t];this.set(s[0],s[1])}}Cd.prototype.clear=uee;Cd.prototype.delete=mee;Cd.prototype.get=yee;Cd.prototype.has=xee;Cd.prototype.set=wee;var Qy=Cd,See="Expected a function";function m_(e,t){if(typeof e!="function"||t!=null&&typeof t!="function")throw new TypeError(See);var n=function(){var s=arguments,r=t?t.apply(this,s):s[0],i=n.cache;if(i.has(r))return i.get(r);var o=e.apply(this,s);return n.cache=i.set(r,o)||i,o};return n.cache=new(m_.Cache||Qy),n}m_.Cache=Qy;var _ee=m_,Cee=500;function Tee(e){var t=_ee(e,function(s){return n.size===Cee&&n.clear(),s}),n=t.cache;return t}var Eee=Tee,Aee=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,Iee=/\\(\\)?/g,Nee=Eee(function(e){var t=[];return e.charCodeAt(0)===46&&t.push(""),e.replace(Aee,function(n,s,r,i){t.push(r?i.replace(Iee,"$1"):s||n)}),t}),kee=Nee;function Dee(e){return e==null?"":tQ(e)}var Mee=Dee;function Pee(e,t){return ya(e)?e:DJ(e,t)?[e]:kee(Mee(e))}var Td=Pee,Oee=1/0;function Ree(e){if(typeof e=="string"||Hy(e))return e;var t=e+"";return t=="0"&&1/e==-Oee?"-0":t}var Zy=Ree;function Lee(e,t){t=Td(t,e);for(var n=0,s=t.length;e!=null&&n<s;)e=e[Zy(t[n++])];return n&&n==s?e:void 0}var m3=Lee;function Fee(e,t){for(var n=-1,s=t.length,r=e.length;++n<s;)e[r+n]=t[n];return e}var g_=Fee,g3=Ki?Ki.isConcatSpreadable:void 0;function $ee(e){return ya(e)||u_(e)||!!(g3&&e&&e[g3])}var Bee=$ee;function y3(e,t,n,s,r){var i=-1,o=e.length;for(n||(n=Bee),r||(r=[]);++i<o;){var a=e[i];t>0&&n(a)?t>1?y3(a,t-1,n,s,r):g_(r,a):s||(r[r.length]=a)}return r}var zee=y3;function Uee(e){var t=e==null?0:e.length;return t?zee(e,1):[]}var Vee=Uee;function Gee(e){return sZ(gZ(e,void 0,Vee),e+"")}var v3=Gee,Wee=p3(Object.getPrototypeOf,Object),y_=Wee,Hee="[object Object]",jee=Function.prototype,qee=Object.prototype,x3=jee.toString,Xee=qee.hasOwnProperty,Kee=x3.call(Object);function Yee(e){if(!yl(e)||Cu(e)!=Hee)return!1;var t=y_(e);if(t===null)return!0;var n=Xee.call(t,"constructor")&&t.constructor;return typeof n=="function"&&n instanceof n&&x3.call(n)==Kee}var Qee=Yee;function Zee(e,t,n){var s=-1,r=e.length;t<0&&(t=-t>r?0:r+t),n=n>r?r:n,n<0&&(n+=r),r=t>n?0:n-t>>>0,t>>>=0;for(var i=Array(r);++s<r;)i[s]=e[s+t];return i}var Jee=Zee;function ete(){this.__data__=new Ky,this.size=0}var tte=ete;function nte(e){var t=this.__data__,n=t.delete(e);return this.size=t.size,n}var ste=nte;function rte(e){return this.__data__.get(e)}var ite=rte;function ote(e){return this.__data__.has(e)}var ate=ote,lte=200;function cte(e,t){var n=this.__data__;if(n instanceof Ky){var s=n.__data__;if(!Zf||s.length<lte-1)return s.push([e,t]),this.size=++n.size,this;n=this.__data__=new Qy(s)}return n.set(e,t),this.size=n.size,this}var ute=cte;function Ed(e){var t=this.__data__=new Ky(e);this.size=t.size}Ed.prototype.clear=tte;Ed.prototype.delete=ste;Ed.prototype.get=ite;Ed.prototype.has=ate;Ed.prototype.set=ute;var Jy=Ed;function hte(e,t){return e&&Kf(t,p_(t),e)}var dte=hte;function pte(e,t){return e&&Kf(t,f_(t),e)}var fte=pte,b3=typeof Ui=="object"&&Ui&&!Ui.nodeType&&Ui,w3=b3&&typeof Vi=="object"&&Vi&&!Vi.nodeType&&Vi,mte=w3&&w3.exports===b3,S3=mte?Oo.Buffer:void 0,_3=S3?S3.allocUnsafe:void 0;function gte(e,t){if(t)return e.slice();var n=e.length,s=_3?_3(n):new e.constructor(n);return e.copy(s),s}var yte=gte;function vte(e,t){for(var n=-1,s=e==null?0:e.length,r=0,i=[];++n<s;){var o=e[n];t(o,n,e)&&(i[r++]=o)}return i}var xte=vte;function bte(){return[]}var C3=bte,wte=Object.prototype,Ste=wte.propertyIsEnumerable,T3=Object.getOwnPropertySymbols,_te=T3?function(e){return e==null?[]:(e=Object(e),xte(T3(e),function(t){return Ste.call(e,t)}))}:C3,v_=_te;function Cte(e,t){return Kf(e,v_(e),t)}var Tte=Cte,Ete=Object.getOwnPropertySymbols,Ate=Ete?function(e){for(var t=[];e;)g_(t,v_(e)),e=y_(e);return t}:C3,E3=Ate;function Ite(e,t){return Kf(e,E3(e),t)}var Nte=Ite;function kte(e,t,n){var s=t(e);return ya(e)?s:g_(s,n(e))}var A3=kte;function Dte(e){return A3(e,p_,v_)}var x_=Dte;function Mte(e){return A3(e,f_,E3)}var I3=Mte,Pte=Eu(Oo,"DataView"),b_=Pte,Ote=Eu(Oo,"Promise"),w_=Ote,Rte=Eu(Oo,"Set"),S_=Rte,N3="[object Map]",Lte="[object Object]",k3="[object Promise]",D3="[object Set]",M3="[object WeakMap]",P3="[object DataView]",Fte=Tu(b_),$te=Tu(Zf),Bte=Tu(w_),zte=Tu(S_),Ute=Tu(r_),Au=Cu;(b_&&Au(new b_(new ArrayBuffer(1)))!=P3||Zf&&Au(new Zf)!=N3||w_&&Au(w_.resolve())!=k3||S_&&Au(new S_)!=D3||r_&&Au(new r_)!=M3)&&(Au=function(e){var t=Cu(e),n=t==Lte?e.constructor:void 0,s=n?Tu(n):"";if(s)switch(s){case Fte:return P3;case $te:return N3;case Bte:return k3;case zte:return D3;case Ute:return M3}return t});var Jf=Au,Vte=Object.prototype,Gte=Vte.hasOwnProperty;function Wte(e){var t=e.length,n=new e.constructor(t);return t&&typeof e[0]=="string"&&Gte.call(e,"index")&&(n.index=e.index,n.input=e.input),n}var Hte=Wte,jte=Oo.Uint8Array,ev=jte;function qte(e){var t=new e.constructor(e.byteLength);return new ev(t).set(new ev(e)),t}var __=qte;function Xte(e,t){var n=t?__(e.buffer):e.buffer;return new e.constructor(n,e.byteOffset,e.byteLength)}var Kte=Xte,Yte=/\w*$/;function Qte(e){var t=new e.constructor(e.source,Yte.exec(e));return t.lastIndex=e.lastIndex,t}var Zte=Qte,O3=Ki?Ki.prototype:void 0,R3=O3?O3.valueOf:void 0;function Jte(e){return R3?Object(R3.call(e)):{}}var ene=Jte;function tne(e,t){var n=t?__(e.buffer):e.buffer;return new e.constructor(n,e.byteOffset,e.length)}var nne=tne,sne="[object Boolean]",rne="[object Date]",ine="[object Map]",one="[object Number]",ane="[object RegExp]",lne="[object Set]",cne="[object String]",une="[object Symbol]",hne="[object ArrayBuffer]",dne="[object DataView]",pne="[object Float32Array]",fne="[object Float64Array]",mne="[object Int8Array]",gne="[object Int16Array]",yne="[object Int32Array]",vne="[object Uint8Array]",xne="[object Uint8ClampedArray]",bne="[object Uint16Array]",wne="[object Uint32Array]";function Sne(e,t,n){var s=e.constructor;switch(t){case hne:return __(e);case sne:case rne:return new s(+e);case dne:return Kte(e,n);case pne:case fne:case mne:case gne:case yne:case vne:case xne:case bne:case wne:return nne(e,n);case ine:return new s;case one:case cne:return new s(e);case ane:return Zte(e);case lne:return new s;case une:return ene(e)}}var _ne=Sne;function Cne(e){return typeof e.constructor=="function"&&!c_(e)?UQ(y_(e)):{}}var Tne=Cne,Ene="[object Map]";function Ane(e){return yl(e)&&Jf(e)==Ene}var Ine=Ane,L3=wd&&wd.isMap,Nne=L3?h_(L3):Ine,kne=Nne,Dne="[object Set]";function Mne(e){return yl(e)&&Jf(e)==Dne}var Pne=Mne,F3=wd&&wd.isSet,One=F3?h_(F3):Pne,Rne=One,Lne=1,Fne=2,$ne=4,$3="[object Arguments]",Bne="[object Array]",zne="[object Boolean]",Une="[object Date]",Vne="[object Error]",B3="[object Function]",Gne="[object GeneratorFunction]",Wne="[object Map]",Hne="[object Number]",z3="[object Object]",jne="[object RegExp]",qne="[object Set]",Xne="[object String]",Kne="[object Symbol]",Yne="[object WeakMap]",Qne="[object ArrayBuffer]",Zne="[object DataView]",Jne="[object Float32Array]",ese="[object Float64Array]",tse="[object Int8Array]",nse="[object Int16Array]",sse="[object Int32Array]",rse="[object Uint8Array]",ise="[object Uint8ClampedArray]",ose="[object Uint16Array]",ase="[object Uint32Array]",Fn={};Fn[$3]=Fn[Bne]=Fn[Qne]=Fn[Zne]=Fn[zne]=Fn[Une]=Fn[Jne]=Fn[ese]=Fn[tse]=Fn[nse]=Fn[sse]=Fn[Wne]=Fn[Hne]=Fn[z3]=Fn[jne]=Fn[qne]=Fn[Xne]=Fn[Kne]=Fn[rse]=Fn[ise]=Fn[ose]=Fn[ase]=!0;Fn[Vne]=Fn[B3]=Fn[Yne]=!1;function tv(e,t,n,s,r,i){var o,a=t&Lne,l=t&Fne,c=t&$ne;if(n&&(o=r?n(e,s,r,i):n(e)),o!==void 0)return o;if(!va(e))return e;var h=ya(e);if(h){if(o=Hte(e),!a)return HQ(e,o)}else{var u=Jf(e),d=u==B3||u==Gne;if(qy(e))return yte(e,a);if(u==z3||u==$3||d&&!r){if(o=l||d?{}:Tne(e),!a)return l?Nte(e,fte(o,e)):Tte(e,dte(o,e))}else{if(!Fn[u])return r?e:{};o=_ne(e,u,a)}}i||(i=new Jy);var p=i.get(e);if(p)return p;i.set(e,o),Rne(e)?e.forEach(function(m){o.add(tv(m,t,n,m,e,i))}):kne(e)&&e.forEach(function(m,y){o.set(y,tv(m,t,n,y,e,i))});var f=c?l?I3:x_:l?f_:p_,g=h?void 0:f(e);return iZ(g||e,function(m,y){g&&(y=m,m=e[y]),a_(o,y,tv(m,t,n,y,e,i))}),o}var U3=tv,lse=1,cse=4;function use(e){return U3(e,lse|cse)}var C_=use,hse="__lodash_hash_undefined__";function dse(e){return this.__data__.set(e,hse),this}var pse=dse;function fse(e){return this.__data__.has(e)}var mse=fse;function nv(e){var t=-1,n=e==null?0:e.length;for(this.__data__=new Qy;++t<n;)this.add(e[t])}nv.prototype.add=nv.prototype.push=pse;nv.prototype.has=mse;var gse=nv;function yse(e,t){for(var n=-1,s=e==null?0:e.length;++n<s;)if(t(e[n],n,e))return!0;return!1}var vse=yse;function xse(e,t){return e.has(t)}var bse=xse,wse=1,Sse=2;function _se(e,t,n,s,r,i){var o=n&wse,a=e.length,l=t.length;if(a!=l&&!(o&&l>a))return!1;var c=i.get(e),h=i.get(t);if(c&&h)return c==t&&h==e;var u=-1,d=!0,p=n&Sse?new gse:void 0;for(i.set(e,t),i.set(t,e);++u<a;){var f=e[u],g=t[u];if(s)var m=o?s(g,f,u,t,e,i):s(f,g,u,e,t,i);if(m!==void 0){if(m)continue;d=!1;break}if(p){if(!vse(t,function(y,v){if(!bse(p,v)&&(f===y||r(f,y,n,s,i)))return p.push(v)})){d=!1;break}}else if(!(f===g||r(f,g,n,s,i))){d=!1;break}}return i.delete(e),i.delete(t),d}var V3=_se;function Cse(e){var t=-1,n=Array(e.size);return e.forEach(function(s,r){n[++t]=[r,s]}),n}var Tse=Cse;function Ese(e){var t=-1,n=Array(e.size);return e.forEach(function(s){n[++t]=s}),n}var Ase=Ese,Ise=1,Nse=2,kse="[object Boolean]",Dse="[object Date]",Mse="[object Error]",Pse="[object Map]",Ose="[object Number]",Rse="[object RegExp]",Lse="[object Set]",Fse="[object String]",$se="[object Symbol]",Bse="[object ArrayBuffer]",zse="[object DataView]",G3=Ki?Ki.prototype:void 0,T_=G3?G3.valueOf:void 0;function Use(e,t,n,s,r,i,o){switch(n){case zse:if(e.byteLength!=t.byteLength||e.byteOffset!=t.byteOffset)return!1;e=e.buffer,t=t.buffer;case Bse:return!(e.byteLength!=t.byteLength||!i(new ev(e),new ev(t)));case kse:case Dse:case Ose:return o_(+e,+t);case Mse:return e.name==t.name&&e.message==t.message;case Rse:case Fse:return e==t+"";case Pse:var a=Tse;case Lse:var l=s&Ise;if(a||(a=Ase),e.size!=t.size&&!l)return!1;var c=o.get(e);if(c)return c==t;s|=Nse,o.set(e,t);var h=V3(a(e),a(t),s,r,i,o);return o.delete(e),h;case $se:if(T_)return T_.call(e)==T_.call(t)}return!1}var Vse=Use,Gse=1,Wse=Object.prototype,Hse=Wse.hasOwnProperty;function jse(e,t,n,s,r,i){var o=n&Gse,a=x_(e),l=a.length,c=x_(t),h=c.length;if(l!=h&&!o)return!1;for(var u=l;u--;){var d=a[u];if(!(o?d in t:Hse.call(t,d)))return!1}var p=i.get(e),f=i.get(t);if(p&&f)return p==t&&f==e;var g=!0;i.set(e,t),i.set(t,e);for(var m=o;++u<l;){d=a[u];var y=e[d],v=t[d];if(s)var b=o?s(v,y,d,t,e,i):s(y,v,d,e,t,i);if(!(b===void 0?y===v||r(y,v,n,s,i):b)){g=!1;break}m||(m=d=="constructor")}if(g&&!m){var x=e.constructor,w=t.constructor;x!=w&&"constructor"in e&&"constructor"in t&&!(typeof x=="function"&&x instanceof x&&typeof w=="function"&&w instanceof w)&&(g=!1)}return i.delete(e),i.delete(t),g}var qse=jse,Xse=1,W3="[object Arguments]",H3="[object Array]",sv="[object Object]",Kse=Object.prototype,j3=Kse.hasOwnProperty;function Yse(e,t,n,s,r,i){var o=ya(e),a=ya(t),l=o?H3:Jf(e),c=a?H3:Jf(t);l=l==W3?sv:l,c=c==W3?sv:c;var h=l==sv,u=c==sv,d=l==c;if(d&&qy(e)){if(!qy(t))return!1;o=!0,h=!1}if(d&&!h)return i||(i=new Jy),o||h3(e)?V3(e,t,n,s,r,i):Vse(e,t,l,n,s,r,i);if(!(n&Xse)){var p=h&&j3.call(e,"__wrapped__"),f=u&&j3.call(t,"__wrapped__");if(p||f){var g=p?e.value():e,m=f?t.value():t;return i||(i=new Jy),r(g,m,n,s,i)}}return d?(i||(i=new Jy),qse(e,t,n,s,r,i)):!1}var Qse=Yse;function q3(e,t,n,s,r){return e===t?!0:e==null||t==null||!yl(e)&&!yl(t)?e!==e&&t!==t:Qse(e,t,n,s,q3,r)}var Zse=q3;function Jse(e,t){return e!=null&&t in Object(e)}var ere=Jse;function tre(e,t,n){t=Td(t,e);for(var s=-1,r=t.length,i=!1;++s<r;){var o=Zy(t[s]);if(!(i=e!=null&&n(e,o)))break;e=e[o]}return i||++s!=r?i:(r=e==null?0:e.length,!!r&&l_(r)&&i_(o,r)&&(ya(e)||u_(e)))}var nre=tre;function sre(e,t){return e!=null&&nre(e,t,ere)}var rre=sre,ire=function(){return Oo.Date.now()},E_=ire,ore="Expected a function",are=Math.max,lre=Math.min;function cre(e,t,n){var s,r,i,o,a,l,c=0,h=!1,u=!1,d=!0;if(typeof e!="function")throw new TypeError(ore);t=QM(t)||0,va(n)&&(h=!!n.leading,u="maxWait"in n,i=u?are(QM(n.maxWait)||0,t):i,d="trailing"in n?!!n.trailing:d);function p(S){var C=s,_=r;return s=r=void 0,c=S,o=e.apply(_,C),o}function f(S){return c=S,a=setTimeout(y,t),h?p(S):o}function g(S){var C=S-l,_=S-c,T=t-C;return u?lre(T,i-_):T}function m(S){var C=S-l,_=S-c;return l===void 0||C>=t||C<0||u&&_>=i}function y(){var S=E_();if(m(S))return v(S);a=setTimeout(y,g(S))}function v(S){return a=void 0,d&&s?p(S):(s=r=void 0,o)}function b(){a!==void 0&&clearTimeout(a),c=0,s=l=r=a=void 0}function x(){return a===void 0?o:v(E_())}function w(){var S=E_(),C=m(S);if(s=arguments,r=this,l=S,C){if(a===void 0)return f(l);if(u)return clearTimeout(a),a=setTimeout(y,t),p(l)}return a===void 0&&(a=setTimeout(y,t)),o}return w.cancel=b,w.flush=x,w}var X3=cre;function ure(e){var t=e==null?0:e.length;return t?e[t-1]:void 0}var hre=ure;function dre(e,t){return t.length<2?e:m3(e,Jee(t,0,-1))}var pre=dre;function fre(e,t){return Zse(e,t)}var A_=fre;function mre(e,t){return t=Td(t,e),e=pre(e,t),e==null||delete e[Zy(hre(t))]}var gre=mre;function yre(e){return Qee(e)?void 0:e}var vre=yre,xre=1,bre=2,wre=4,Sre=v3(function(e,t){var n={};if(e==null)return n;var s=!1;t=jM(t,function(i){return i=Td(i,e),s||(s=i.length>1),i}),Kf(e,I3(e),n),s&&(n=U3(n,xre|bre|wre,vre));for(var r=t.length;r--;)gre(n,t[r]);return n}),I_=Sre;function _re(e,t,n,s){if(!va(e))return e;t=Td(t,e);for(var r=-1,i=t.length,o=i-1,a=e;a!=null&&++r<i;){var l=Zy(t[r]),c=n;if(l==="__proto__"||l==="constructor"||l==="prototype")return e;if(r!=o){var h=a[l];c=s?s(h,l,a):void 0,c===void 0&&(c=va(h)?h:i_(t[r+1])?[]:{})}a_(a,l,c),a=a[l]}return e}var Cre=_re;function Tre(e,t,n){for(var s=-1,r=t.length,i={};++s<r;){var o=t[s],a=m3(e,o);n(a,o)&&Cre(i,Td(o,e),a)}return i}var Ere=Tre;function Are(e,t){return Ere(e,t,function(n,s){return rre(e,s)})}var Ire=Are,Nre=v3(function(e,t){return e==null?{}:Ire(e,t)}),rv=Nre,K3,kre=new Promise(e=>{K3=e}),Y3=!1;async function Dre(){if(Y3)return;let e=await import("./physics.6df9af68.js");await e.init(),K3(e),Y3=!0}var Ps=class{modifyById(e,t){let n=this;if(n[e]===void 0)throw new Error("not expected");{let s=De(ue({},n),{[e]:t});return Object.setPrototypeOf(s,Ps.prototype),s}}add(e,t){var n,s;return(s=(n=this.runOp({type:1,id:e,data:t}))==null?void 0:n.data)!=null?s:this}runOp(e){let t=this;if(e.type===1){let n=t[e.id],s;n===void 0?s={type:2,id:e.id}:s={type:1,id:e.id,data:n};let{id:r,data:i}=e,o=De(ue({},t),{[r]:i});return Object.setPrototypeOf(o,Ps.prototype),{data:o,actual:e,reverse:s}}else if(e.type===2){let{id:n}=e,s=t[n];if(s===void 0)return null;{let r=ue({},t);return Object.setPrototypeOf(r,Ps.prototype),delete r[n],{data:r,actual:e,reverse:{type:1,id:n,data:s}}}}return null}};function N_(e){if(e.deepFreeze!==void 0){e.deepFreeze(e);return}let t=Object.getOwnPropertyNames(e);for(let n of t){let s=e[n];s&&typeof s=="object"&&N_(s)}return Object.freeze(e)}function Mre(e,t){let n=0;for(;n<e.length&&n<t.length;){if(e[n]<t[n])return-1;if(e[n]>t[n])return 1;n+=1}return n!==t.length?-1:n!==e.length?1:0}var Q3=class extends Error{};function k_(e){let t=ue({},e);return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}function oc(e,t,n){if(e===void 0?t===void 0?(e=0,t=10):e=t-10:t===void 0&&(t=e+10),e>t){let i=e;e=t,t=i}let s=[],r=1/(n+1);for(let i=0;i<n;i++){let o=e+(t-e)*(i+.75+Math.random()*.5)*r;s.push(o)}return s}function D_(e){return e instanceof Uint8Array||e instanceof Uint16Array||e instanceof Uint32Array||e instanceof Int8Array||e instanceof Int16Array||e instanceof Int32Array||e instanceof Float32Array||e instanceof Float64Array}function Pre(){return typeof process<"u"}function Z3(e,t){for(let n of e)t(n.id,n.data)!==!0&&Z3(n.children,t)}function J3(e,t){if(t(e.id,e.data)!==!0)for(let n of e.children)J3(n,t)}var ei=class extends Array{constructor(...e){super(...e);Object.setPrototypeOf(this,ei.prototype)}deepFreeze(){let e=0;for(;e<this.length;)N_(this[e]),e++}fillCaches0(e,t){this.objCaches.set(e.id,e),this.parentCaches.set(e.id,t);for(let n of e.children)this.fillCaches0(n,e.id)}fillCaches(){if(this.objCaches===void 0){this.objCaches=new Map,this.parentCaches=new Map;for(let e of this)this.fillCaches0(e,null)}}randomId(){this.fillCaches();let e=Array.from(this.objCaches.keys());if(e.length!==0)return e[Math.max(0,Math.floor(Math.random()*e.length)-1)]}nonExistOrDescendantOf(e,t){if(!this.has(e))return!0;for(;e;){let n=this.parent(e);if(n===t)return!0;e=n}return!1}isDescendantOf(e,t){for(;e;){let n=this.parent(e);if(n===t)return!0;e=n}return!1}data(e){var t;return(t=this.get(e))==null?void 0:t.data}has(e){return this.childrenOf(e)!==void 0}get(e){return this.fillCaches(),this.objCaches.get(e)}childrenOf(e){var t;return e===null?this:(t=this.get(e))==null?void 0:t.children}traverseFrom(e,t){if(e===null)this.traverse(t);else{let n=this.get(e);n&&J3(n,t)}}traverse(e){Z3(this,e)}totalSize(){return this.fillCaches(),this.objCaches.size}parent(e){return this.fillCaches(),this.parentCaches.get(e)}childrenArray(e){return e===null?this:this.get(e).children}modifyById(e,t){if(this.get(e)===void 0)throw new Error("not expected");{let n=this.parent(e),s=this.childrenArray(n),r=s.findIndex(o=>o.id===e);if(r<0)throw new Error("not expected");let i=s[r];return s=[...s],s[r]=De(ue({},i),{data:t}),this.modifyArrayBy(n,s)}}modifyArrayBy(e,t){let n=e,s=t;for(;n!==null;){let i=s,o=n;if(n=this.parent(n),n===void 0)throw new Error;s=this.childrenArray(n);let a=s.findIndex(l=>l.id===o);if(a<0)throw new Error;s=[...s],s[a]=De(ue({},s[a]),{children:i})}Object.setPrototypeOf(s,ei.prototype);let r=s;return r.fillCaches(),r}runOp(e){switch(e.type){case 7:return this.addOp(e);case 8:return this.deleteOp(e);case 9:return this.moveOp(e)}return null}checkDuplicatedIdRec({id:e,children:t}){if(this.get(e)!==void 0)return!0;for(let n of t)if(this.checkDuplicatedIdRec(n))return!0;return!1}addOp(e){let{parent:t,fi:n,id:s,data:r,children:i}=e;if(t!==null&&this.get(t)===void 0||this.checkDuplicatedIdRec(e))return null;{let o=t,a=this.childrenArray(o),l={fi:n,id:s,data:r,children:i};return a=[...a,l],a.sort((c,h)=>c.fi-h.fi),e.localIndex=a.indexOf(l),{data:this.modifyArrayBy(o,a),actual:e,reverse:{type:8,id:s}}}}deleteOp(e){let{id:t}=e;if(this.get(t)===null)return null;{let n=this.parent(t);if(n===void 0)return null;let s=this.childrenArray(n),r=s.findIndex(o=>o.id===t);e.localIndex=r,s=[...s];let i=s.splice(r,1)[0];return{data:this.modifyArrayBy(n,s),actual:e,reverse:De(ue({type:7},i),{parent:n})}}}moveOp(e){let{parent:t,fi:n,id:s}=e;if(t!==null&&this.get(t)===void 0)return this.deleteOp({type:8,id:s});if(t!==null){let u=t;for(;u!==null;){if(u===void 0)throw new Error;if(u===s)throw new Q3("cyclic tree");u=this.parent(u)}}let r=this.parent(s);if(r===void 0)return null;let i=r,o=this.childrenArray(r),a=o.findIndex(u=>u.id===s);o=[...o];let l=o.splice(a,1)[0],c=this.modifyArrayBy(r,o);r=t,o=c.childrenArray(r);let h=l.fi;return l=De(ue({},l),{fi:n}),o=[...o,l],o.sort((u,d)=>u.fi-d.fi),e.localIndex=o.indexOf(l),c=c.modifyArrayBy(r,o),{data:c,actual:e,reverse:{type:9,parent:i,fi:h,id:s}}}previous(e,t){if(t===null){let s=this.childrenArray(e);return s.length===0?null:s[s.length-1].id}let n=null;for(let s of this.childrenArray(e)){if(s.id===t)return n;n=s.id}return null}traverseSortNext(e){let t=this.parent(e);if(t!==void 0){let n=this.childrenArray(t),s=n.findIndex(r=>r.id===e)+1;if(s<n.length)return n[s].id;if(t)return this.traverseSortNext(t)}}sortNext(e){let t=this.childrenArray(e);return t.length>0?t[0].id:this.traverseSortNext(e)}traverseSortPrevious(e){let t=this.childrenArray(e);return t.length>0?this.traverseSortPrevious(t[t.length-1].id):e}sortPrevious(e){let t=this.parent(e);if(t!==void 0){let n=this.childrenArray(t),s=n.findIndex(r=>r.id===e)-1;return s>=0?this.traverseSortPrevious(n[s].id):t}}getAllSorted(e){let t=[];for(let n of e){let s=this.getWithSortKey(n.id);s!==void 0&&t.push(ue(ue({},n),s))}t.sort((n,s)=>Mre(n.sortKey,s.sortKey));for(let n of t)delete n.sortKey;return t}getWithSortKey(e){var t=e;let n=[],s=this.get(t),r=s;if(s!==void 0){for(;t;)n.splice(0,0,s.fi),t=this.parent(t),t!==null&&(s=this.get(t));return De(ue({},r),{sortKey:n})}}insertBeforeHelper(e,t,n){return this.insertAfterHelper(e,this.previous(e,t),n)}insertAfterHelper(e,t,n){let s=this.childrenArray(e);if(t===null){if(s.length===0)return oc(0,n,n);{let r=s[0].fi;return oc(r-n,r,n)}}else{let r=this.get(t);if(r===void 0||this.parent(t)!==e)throw new Error("illegal args");let i=s.find(o=>o.fi>r.fi);if(i===void 0){let o=s[s.length-1].fi;return oc(o,o+n,n)}else return oc(r.fi,i.fi,n)}}},iv;(e=>{function t(n,s){if(s.type!==0)return null;if(Array.isArray(n)){let r=s.props,i={},o=[...n],a=!1;if(r)for(let l of Object.keys(r)){let c=parseInt(l);if(isNaN(c))throw new Error("wrong index");i[l]=o[c],o[c]=r[l],a=!0}return a?{data:o,actual:s,reverse:{type:0,props:i}}:null}else{let r=s.props,i={},o=ue({},n),a=!1;if(r)for(let l of Object.keys(r)){i[l]=o[l];let c=r[l];c===void 0?delete o[l]:o[l]=c,a=!0}return a?{data:o,actual:s,reverse:{type:0,props:i}}:null}}e.runOp=t})(iv||(iv={}));var Qt=class extends Array{constructor(...e){super(...e);Object.setPrototypeOf(this,Qt.prototype)}deepFreeze(){let e=0;for(;e<this.length;)N_(this[e]),e++}fillCaches0(e){this.objCaches.set(e.id,e)}fillCaches(){if(this.objCaches===void 0){this.objCaches=new Map,Object.getOwnPropertyDescriptor(this,"objCaches").enumerable=!1;for(let e of this)this.fillCaches0(e)}}randomId(){this.fillCaches();let e=Array.from(this.objCaches.keys());if(e.length!==0)return e[Math.max(0,Math.floor(Math.random()*e.length)-1)]}data(e){var t;return(t=this.get(e))==null?void 0:t.data}get(e){return this.fillCaches(),this.objCaches.get(e)}modifyById(e,t){if(this.get(e)===void 0)throw new Error("not expected");{let n=this,s=n.findIndex(i=>i.id===e);if(s<0)throw new Error("not expected");let r=n[s];return n=[...n],n[s]=De(ue({},r),{data:t}),this.modifyArrayBy(n)}}modifyArrayBy(e){Object.setPrototypeOf(e,Qt.prototype);let t=e;return Pre()||t.fillCaches(),t}runOp(e){switch(e.type){case 4:return this.addOp(e);case 5:return this.deleteOp(e);case 6:return this.moveOp(e)}return null}addOp(e){let{fi:t,id:n,data:s}=e,r=this,i={fi:t,id:n,data:s};return r=[...r,i],r.sort((o,a)=>o.fi-a.fi),e.localIndex=r.indexOf(i),{data:this.modifyArrayBy(r),actual:e,reverse:{type:5,id:n}}}deleteOp(e){let{id:t}=e,n=this,s=n.findIndex(i=>i.id===t);if(s===-1)return null;e.localIndex=s,n=[...n];let r=n.splice(s,1)[0];return{data:this.modifyArrayBy(n),actual:e,reverse:ue({type:4},r)}}moveOp(e){let{fi:t,id:n}=e,s=this;s=[...s];let r=s.findIndex(a=>a.id===n);if(r===-1)return null;let i=s[r].fi,o=De(ue({},s[r]),{fi:t});return s[r]=o,s.sort((a,l)=>a.fi-l.fi),e.localIndex=s.indexOf(o),{data:this.modifyArrayBy(s),actual:e,reverse:{type:6,fi:i,id:n}}}previous(e){if(e===null)return this.length===0?null:this[this.length-1].id;let t=null;for(let n of this){if(n.id===e)return t;t=n.id}return null}insertBeforeHelper(e,t){return this.insertAfterHelper(this.previous(e),t)}insertAfterHelper(e,t){let n=this;if(e===null){if(n.length===0)return oc(0,t,t);{let s=n[0].fi;return oc(s-t,s,t)}}else{let s=this.get(e);if(s===void 0)throw new Error("illegal args");let r=n.find(i=>i.fi>s.fi);if(r===void 0){let i=n[n.length-1].fi;return oc(i,i+t,t)}else return oc(s.fi,r.fi,t)}}};function Ad(e){return e&&typeof e=="object"&&e instanceof sr}var sr=class{unusedFunOverridesTable(e){}runOp(e){let t=[],n=this,s=0,r={};for(;s<e.path.length;){if(t.push(n),n=n===void 0?void 0:n[e.path[s]],n!==void 0&&!Ad(n))return null;s+=1}n=n?k_(n):new sr;for(let[a,l]of Object.entries(e.props)){let c=n[a];r[a]=c,l===void 0?delete n[a]:n[a]=l}for(;s>0;){if(Object.keys(n).length===0){let a=t[s-1];a&&(n=k_(a),delete n[e.path[s-1]])}else{let a=t[s-1];if(a){let l=k_(a);l[e.path[s-1]]=n,n=l}else{let l=new sr;l[e.path[s-1]]=n,n=l}}s-=1}let i=Object.setPrototypeOf(n,sr.prototype),o=De(ue({},e),{props:r});return{data:i,actual:e,reverse:o}}},Iu;(e=>{function t(r,i){var o;return(o=em(r,i))!=null?o:r}e.apply=t;function n(r,i){return P_(r,i)}e.merge=n;function s(r,i){let o=0,a=i.path,l=r;for(;o<a.length&&l!==void 0;){if(l=xa.zoomOnce(l,a[o]),l===void 0)return i;if(!Ad(l))return;o+=1}if(l===void 0)return i;if(Ad(l))if(i.type===0){let c=ue({},i.props);for(let h of Object.keys(l))delete c[h];return De(ue({},i),{props:c})}else if(i.type===1||i.type===4||i.type===7){let c=M_([i],l);return c?(console.log(c),c):i}else return i}e.filterOp=s})(Iu||(Iu={}));function M_(e,t){if(t===void 0)return;let n=!1,s=e.map(r=>{let i=r.id,o=em(r.data,t[i]);if(n=n||o!==void 0,o===void 0&&(o=r.data),r.children){let a=M_(r.children,t);return a!==void 0?n=!0:a=r.children,De(ue({},r),{id:i,data:o,children:a})}else return De(ue({},r),{id:i,data:o})});if(n)return s}function Ore(e,t){if(t===void 0)return;let n=!1,s=e.map(r=>{let i=r.id,o=em(r.data,t[i]);return n=n||o!==void 0,o===void 0&&(o=r.data),De(ue({},r),{id:i,data:o})});if(n)return Object.setPrototypeOf(s,Object.getPrototypeOf(e)),s}function em(e,t){if(!Ad(t))return t;if(e instanceof ei){let n=M_(e,t);return n!==void 0&&Object.setPrototypeOf(n,Object.getPrototypeOf(e)),n}else{if(e instanceof Qt)return Ore(e,t);if(Array.isArray(e)){let n=!1,s=e.map((r,i)=>{let o=em(r,t[i]);return n=n||o!==void 0,o===void 0&&(o=r),o});return n?(Object.setPrototypeOf(s,Object.getPrototypeOf(e)),s):void 0}else{if(e instanceof sr)return P_(e,t);if(e&&typeof e=="object"){let n={},s=!1;for(let[r,i]of Object.entries(e)){let o=em(i,t[r]);s=s||o!==void 0,o===void 0&&(o=i),n[r]=o}return s?(Object.setPrototypeOf(n,Object.getPrototypeOf(e)),n):void 0}}}}function P_(e,t){if(e===void 0)return t;if(t===void 0)return e;if(!Ad(t))return t;if(!Ad(e))return Iu.apply(e,t);let n=new Set;for(let r of Object.keys(e))n.add(r);for(let r of Object.keys(t))n.add(r);let s=new sr;for(let r of n){let i=P_(e===void 0?void 0:e[r],t===void 0?void 0:t[r]);s[r]=i}return s}function Rre(e,t){var s;let n={cur:[],result:[],len:0};return e=(s=tm(e,t,n))!=null?s:e,[e,n.result]}function ov(e,t){return e===null?null:(e.cur[e.len]=t,e.len+=1,e)}function av(e){e&&(e.len-=1)}function Lre(e){if(e===null)return null;e.result.push(e.cur.slice(0,e.len))}function eP(e,t,n){let s=!1,r=e.map(i=>{let o=i.id,a=t[o];if(a!==void 0&&typeof a=="string"&&(s=!0,o=a,n!==null))throw new Error("not supported");let l=tm(i.data,t,ov(n,o));av(n),s=s||l!==void 0,l===void 0&&(l=i.data);let c=eP(i.children,t,n);return c!==void 0?s=!0:c=i.children,De(ue({},i),{id:o,data:l,children:c})});if(s)return r}function Fre(e,t,n){let s=!1,r=e.map(i=>{let o=i.id,a=t[o];if(a!==void 0&&typeof a=="string"&&(s=!0,o=a,n!==null))throw new Error("not supported");let l=tm(i.data,t,ov(n,o));return av(n),s=s||l!==void 0,l===void 0&&(l=i.data),De(ue({},i),{id:o,data:l})});if(s)return Object.setPrototypeOf(r,Object.getPrototypeOf(e)),r}function tm(e,t,n){if(e instanceof ei){let s=eP(e,t,n);return s!==void 0&&Object.setPrototypeOf(s,Object.getPrototypeOf(e)),s}else{if(e instanceof Qt)return Fre(e,t,n);if(Array.isArray(e)){let s=!1,r=e.map((i,o)=>{let a=tm(i,t,ov(n,o));return av(n),s=s||a!==void 0,a===void 0&&(a=i),a});return s?(Object.setPrototypeOf(r,Object.getPrototypeOf(e)),r):void 0}else if(e&&typeof e=="object"&&!D_(e)){let s={},r=!1;for(let[i,o]of Object.entries(e))if(i!=="name"&&i!=="text"){let a=t[i];if(typeof a=="string"){if(n!==null)throw new Error("not supported");r=!0,i=a}let l=tm(o,t,ov(n,i));av(n),r=r||l!==void 0,l===void 0&&(l=o),s[i]=l}else s[i]=o;return r?(Object.setPrototypeOf(s,Object.getPrototypeOf(e)),s):void 0}else if(typeof e=="string"){let s=t[e];if(s!==void 0){if(e.length!==36)throw new Error("for now you should only call this method when the key is a uuid");Lre(n)}return s}else return}}var O_;(e=>{function t(n,s){let r=xa.zoom(s,n.path);if(typeof r=="object"){let i={};for(let o of Object.keys(n.props))i[o]=r[o];return De(ue({},n),{props:i})}else return De(ue({},n),{props:{}})}e.replaceProps=t})(O_||(O_={}));var wi;(e=>{function t(l,c){return De(ue({},l),{path:l.path.slice(c)})}e.drop=t;function n(l,c){var h,u;return(u=(h=s(l,c))==null?void 0:h.data)!=null?u:l}e.applySimple=n;function s(l,c){var d,p;let h=c.path;for(var u=[];;){let f;if(l instanceof sr&&c.type===0&&(f=l.runOp(De(ue({},c),{path:h.slice(u.length)})),f===null&&(f=void 0)),u.length===h.length&&(l instanceof ei||l instanceof Qt||l instanceof Ps?f=l.runOp(c):f=iv.runOp(l,c)),f!==void 0)if(f!==null){let y=f.data;for(let v=u.length-1;v>=0;v--){let b=h[v],x=u[v];if(x instanceof ei){if(typeof b=="number")throw new Error("illegal arg");y=x.modifyById(b,y)}else if(x instanceof Qt){if(typeof b=="number")throw new Error("illegal arg");y=x.modifyById(b,y)}else if(x instanceof Ps){if(typeof b=="number")throw new Error("illegal arg");y=x.modifyById(b,y)}else if(x instanceof sr){let w=De(ue({},x),{[b]:y});y=Object.setPrototypeOf(w,sr.prototype)}else if(typeof x=="object")if(Array.isArray(x)){if(typeof b=="string"&&(b=parseInt(b),isNaN(b)))throw new Error("Invalid path");let w=y;y=[...x],y[b]=w}else y=De(ue({},x),{[b]:y});else return null}return{data:y,actual:De(ue({},f.actual),{path:h}),reverse:De(ue({},f.reverse),{path:h})}}else return null;let g=h[u.length],m;if(l instanceof ei){if(typeof g=="number")throw new Error("");m=(d=l.get(g))==null?void 0:d.data}else if(l instanceof Qt){if(typeof g=="number")throw new Error("");m=(p=l.get(g))==null?void 0:p.data}else l!==null&&(m=l[g]);if(m!==void 0)u.push(l),l=m;else return null}}e.apply=s;function r(l,c){for(let h=0;h<l.length&&h<c.length;h++)if(l[h]!==c[h])return!0;return!1}e.pathDisjoint=r;function i(l,c){if(l.length!==c.length)return!1;for(let h=0;h<l.length;h++)if(l[h]!==c[h])return!1;return!0}e.pathEq=i;function o(l,c){return r(l.path,c.path)}e.commutative=o;function a(l,c){return l.type===0&&c.type===0&&i(l.path,c.path)?Object.keys(l.props).every(h=>c.props[h]!==void 0):!1}e.subsumed=a})(wi||(wi={}));var tP;(e=>{function t(){return[]}e.empty=t;function n(c,h){let u=[];for(let d of c){let[p,...f]=d.path;p===h&&u.push(De(ue({},d),{path:f}))}return u}e.removePrefix=n;function s(c,h){return c.map(u=>De(ue({},u),{path:[h,...u.path]}))}e.addPrefix=s;function r(c,h){return[...c,...h]}e.concat=r;function i(c,h){return[...c.filter(u=>!h.some(d=>wi.subsumed(u,d))),...h]}e.compress=i;function o(c,h){return c.every(u=>h.every(d=>wi.commutative(u,d)))}e.commutative=o;function a(c,h){for(let u of h){let d=l(c,u);d!==null&&(c=d.data)}return c}e.applyAll=a;function l(c,h){var u=c;let d=[],p=[];for(let f of h)try{if(f.type===3){let g=xa.zoom(u,[...f.path,f.id]),m=wi.apply(u,De(ue({},f),{type:2}));if(m!==null){u=m.data;let[y,v]=Rre(u,{[f.id]:g});u=y;for(let b of v){let x=b[b.length-1];b.splice(b.length-1,1),d.push({type:0,path:b,props:{[x]:g}}),p.push({type:0,path:b,props:{[x]:f.id}})}p.push(m.reverse),d.push(m.actual)}}else{let g=wi.apply(u,f);g!==null&&(d.push(g.actual),u=g.data,p.push(g.reverse))}}catch(g){if(g instanceof Q3)return null;throw g}return{data:u,actual:d,reverse:p.reverse()}}e.apply=l})(tP||(tP={}));var nP=Symbol(),$re=Symbol(),lv=Symbol(),nm=class{reportOp(e,t,n=[]){let s=this;if(t===null)return;s._current=t.data;let r=n;for(;!(s instanceof rP);){let i=s._path,o=s._current;if(i!==""&&r.splice(0,0,i),s=s._parent,s===null)return;s.update(i,o)}s.push(r,e,t.actual,t.reverse)}deleteChildren(e){if(this._children){let t=this._children[e];if(t){let n=t[lv];n&&n(),delete this._children[e]}}}},Bre=class extends nm{constructor(e,t,n){super(),this._parent=e,this._path=t,this._current=n}update(e,t){if(Array.isArray(this._current)){if(typeof e=="string"&&(e=parseInt(e),isNaN(e)))throw new Error("Invalid path");this._current=[...this._current],this._current[e]=t}else this._current=De(ue({},this._current),{[e]:t})}runOp(e){this.reportOp(e,iv.runOp(this._current,e),e.path)}},zre=class extends nm{constructor(e,t,n){super(),this._parent=e,this._path=t,this._current=n}update(e,t){this._current=De(ue({},this._current),{[e]:t}),Object.setPrototypeOf(this._current,Ps.prototype)}runOp(e){this.reportOp(e,this._current.runOp(e))}},sP={get(e,t){if(t===lv)return()=>{e._parent=null};if(t===nP)return e._current;if(t===$re)return e;let{_current:n,_children:s}=e;if(t==="push"&&Array.isArray(n))throw new Error("not supported to expand array");let r=s===void 0?void 0:s[t];if(r!==void 0)return r;let i=n[t],o=cv(e,t,i);return o!==i?(s===void 0&&(s={},e._children=s),s[t]=o,o):i},has(e,t){return t in e._current},ownKeys(e){return Reflect.ownKeys(e._current)},defineProperty(){throw Error("not supported")},getPrototypeOf(e){return Object.getPrototypeOf(e._current)},setPrototypeOf(){throw Error("not supported")},getOwnPropertyDescriptor(e,t){let n=e._current,s=Reflect.getOwnPropertyDescriptor(n,t);return s&&{writable:!0,configurable:!0,enumerable:s.enumerable,value:n[t]}}},Ure=De(ue({},sP),{set(e,t,n){var r;let s={type:0,props:{[t]:(r=xr(n))!=null?r:n}};return e.deleteChildren(t),e.runOp(s),!0},deleteProperty(e,t){let n={type:0,props:{[t]:void 0}};return e.deleteChildren(t),e.runOp(n),!0}}),Vre=De(ue({},sP),{set(e,t,n){return n===void 0?this.deleteProperty(e,t):(e.deleteChildren(t),e.runOp({type:1,id:t,data:n})),!0},deleteProperty(e,t){return e.runOp({type:2,id:t}),!0}}),R_=class extends nm{constructor(e,t,n){super(),this._children={},this._parent=e,this._path=t,this._current=n,this[lv]=()=>{this._parent=null}}unproxy(){return this._current}update(e,t){this._current=this._current.modifyById(e,t)}runOp(e){this.reportOp(e,this._current.runOp(e))}randomId(){return this._current.randomId()}isDescendantOf(e,t){return this._current.isDescendantOf(e,t)}childrenOf(e){return this._current.childrenOf(e)}traverse(e){return this._current.traverse(e)}get(e){return this._current.get(e)}parent(e){return this._current.parent(e)}traverse(e){this._current.traverse((t,n)=>{e(t,this.data(t))})}data(e){var o;let{_current:t,_children:n}=this,s=n===void 0?void 0:n[e];if(s!==void 0)return s;let r=(o=t.get(e))==null?void 0:o.data,i=cv(this,e,r);return i!==r?(n===void 0&&(n={},this._children=n),n[e]=i,i):r}add(e,t,n,s,r){this.runOp({type:7,parent:e,fi:t,id:n,data:s,children:r})}move(e,t,n){this.runOp({type:9,parent:e,fi:t,id:n})}insertAfter(e,t,n){let s=this._current.insertAfterHelper(e,t,n.length);for(let r=0;r<n.length;r++){let i=n[r];this.add(e,s[r],i.id,i.data,i.children)}}insertBefore(e,t,n){let s=this._current.insertBeforeHelper(e,t,n.length);for(let r=0;r<n.length;r++){let i=n[r];this.add(e,s[r],i.id,i.data,i.children)}}moveAfter(e,t,n){let s=this._current.insertAfterHelper(e,t,n.length);for(let r=0;r<n.length;r++){let i=n[r];this.move(e,s[r],i)}}moveBefore(e,t,n){let s=this._current.insertBeforeHelper(e,t,n.length);for(let r=0;r<n.length;r++){let i=n[r];this.move(e,s[r],i)}}delete(e){this.deleteChildren(e),this.runOp({type:8,id:e})}sortNext(e){return this._current.sortNext(e)}sortPrevious(e){return this._current.sortPrevious(e)}getAllSorted(e){return this._current.getAllSorted(e)}},L_=class extends nm{constructor(e,t,n){super(),this._children={},this._parent=e,this._path=t,this._current=n,this[lv]=()=>{this._parent=null}}unproxy(){return this._current}get length(){return this._current.length}forEach(e){let t=this.length;for(let n=0;n<t;n++){let s=this._current[n].id,r=this._current[n].fi;e(this.data(this._current[n].id),s,r)}}find(e){let t=this.length;for(let n=0;n<t;n++){let s=this._current[n].id;if(e(this.data(s),s))return this.get(s)}}update(e,t){this._current=this._current.modifyById(e,t)}randomId(){return this._current.randomId()}get(e){return De(ue({},this._current.get(e)),{data:this.data(e)})}data(e){var o;let{_current:t,_children:n}=this,s=n===void 0?void 0:n[e];if(s!==void 0)return s;let r=(o=t.get(e))==null?void 0:o.data,i=cv(this,e,r);return i!==r?(n===void 0&&(n={},this._children=n),n[e]=i,i):r}runOp(e){this.reportOp(e,this._current.runOp(e))}add(e,t,n){this.runOp({type:4,fi:e,id:t,data:n})}move(e,t){this.runOp({type:6,fi:e,id:t})}insertAfter(e,t){let n=this._current.insertAfterHelper(e,t.length);for(let s=0;s<t.length;s++){let r=t[s];this.add(n[s],r.id,r.data)}}insertBefore(e,t){let n=this._current.insertBeforeHelper(e,t.length);for(let s=0;s<t.length;s++){let r=t[s];this.add(n[s],r.id,r.data)}}moveAfter(e,t){let n=this._current.insertAfterHelper(e,t.length);for(let s=0;s<t.length;s++){let r=t[s];this.move(n[s],r)}}moveBefore(e,t){let n=this._current.insertBeforeHelper(e,t.length);for(let s=0;s<t.length;s++){let r=t[s];this.move(n[s],r)}}delete(e){this.deleteChildren(e),this.runOp({type:5,id:e})}};function F_(e,t,n){if(e.length>0){let s=e[e.length-1];if(s.type===0&&t.type===0&&xa.equal(s.path,n)){Object.assign(s.props,t.props);return}}e.push(De(ue({},t),{path:n}))}var rP=class extends nm{constructor(e){super(),this.ts=[],this.actual=[],this.reverse=[],this._current=e}update(e,t){if(e!=="")throw new Error("");this._current=t}push(e,t,n,s){F_(this.ts,t,e),F_(this.actual,n,e),F_(this.reverse,s,e)}result(){return{data:this._current,ts:this.ts,actual:this.actual,reverse:this.reverse.reverse()}}};function cv(e,t,n){return n instanceof ei?new R_(e,t,n):n instanceof Qt?new L_(e,t,n):n instanceof Ps?new Proxy(new zre(e,t,n),Vre):n!==null&&typeof n=="object"?D_(n)?n:new Proxy(new Bre(e,t,n),Ure):n}function iP(e){let t=new rP(e);return[cv(t,"",e),t]}function uv(e,t){let[n,s]=iP(e);return t(n),s.result()}function xr(e){return e instanceof R_||e instanceof L_?e._current:e!==null&&typeof e=="object"?e[nP]:e}var xa;(e=>{function t(i,o){if(o.length===i.length)for(var a=0;a<i.length;){if(i[a]!==o[a])return!1;a+=1}else return!1;return!0}e.equal=t;function n(i,o,a){let l=r(a,i);if(l!==void 0&&typeof l=="object"&&l!==null){let c=ue({},o);return Object.keys(l).forEach(h=>{delete c[h]}),c}else return o}e.removeOverridden=n;function s(i,o){if((i instanceof ei||i instanceof R_)&&typeof o=="string"||(i instanceof Qt||i instanceof L_)&&typeof o=="string")return i.data(o);if(typeof o=="number"&&Array.isArray(i)||typeof o=="string"&&typeof i=="object"&&i!==null)return i[o]}e.zoomOnce=s;function r(i,o,a=0){for(;a<o.length&&i!==void 0;)i=s(i,o[a]),a+=1;return i}e.zoom=r})(xa||(xa={}));function Gre(e,t){let n=[];if(t.length===e.length)for(var s=0;s<e.length;){if(t[s]==="*")n.push(e[s]);else if(e[s]!==t[s])return null;s+=1}else return null;return n}function Nu(e,t){let n=[];if(t.length<=e.length)for(var s=0;s<t.length;){if(t[s]==="*")n.push(e[s]);else if(e[s]!==t[s])return null;s+=1}else return null;return n}var oP=class{},aP=class extends oP{constructor(e){super();this.id=e}},lP=class extends oP{constructor(e){super();this.data=e}},$_;try{$_=new TextDecoder}catch{}var st,ac,me=0,cP=[],B_=cP,z_=0,ti={},hn,lc,Yi=0,ba=0,Si,vl,$r=[],bn,uP={useRecords:!1,mapsAsObjects:!0},hP=class{},dP=new hP;dP.name="MessagePack 0xC1";var Id=!1,hv=class{constructor(e){e&&(e.useRecords===!1&&e.mapsAsObjects===void 0&&(e.mapsAsObjects=!0),e.structures?e.structures.sharedLength=e.structures.length:e.getStructures&&((e.structures=[]).uninitialized=!0,e.structures.sharedLength=0)),Object.assign(this,e)}unpack(e,t){if(st)return CP(()=>(H_(),this?this.unpack(e,t):hv.prototype.unpack.call(uP,e,t)));ac=t>-1?t:e.length,me=0,z_=0,ba=0,lc=null,B_=cP,Si=null,st=e;try{bn=e.dataView||(e.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength))}catch(n){throw st=null,e instanceof Uint8Array?n:new Error("Source must be a Uint8Array or Buffer but was a "+(e&&typeof e=="object"?e.constructor.name:typeof e))}if(this instanceof hv){if(ti=this,this.structures)return hn=this.structures,dv();(!hn||hn.length>0)&&(hn=[])}else ti=uP,(!hn||hn.length>0)&&(hn=[]);return dv()}unpackMultiple(e,t){let n,s=0;try{Id=!0;let r=e.length,i=this?this.unpack(e,r):fv.unpack(e,r);if(t){for(t(i);me<r;)if(s=me,t(dv())===!1)return}else{for(n=[i];me<r;)s=me,n.push(dv());return n}}catch(r){throw r.lastPosition=s,r.values=n,r}finally{Id=!1,H_()}}_mergeStructures(e,t){e=e||[];for(let n=0,s=e.length;n<s;n++){let r=e[n];r&&(r.isShared=!0,n>=32&&(r.highByte=n-32>>5))}e.sharedLength=e.length;for(let n in t||[])if(n>=0){let s=e[n],r=t[n];r&&(s&&((e.restoreStructures||(e.restoreStructures=[]))[n]=s),e[n]=r)}return this.structures=e}decode(e,t){return this.unpack(e,t)}};function dv(){try{if(!ti.trusted&&!Id){let t=hn.sharedLength||0;t<hn.length&&(hn.length=t)}let e=rs();if(me==ac)hn.restoreStructures&&pP(),hn=null,st=null,vl&&(vl=null);else if(me>ac){let t=new Error("Unexpected end of MessagePack data");throw t.incomplete=!0,t}else if(!Id)throw new Error("Data read, but end of buffer not reached");return e}catch(e){throw hn.restoreStructures&&pP(),H_(),(e instanceof RangeError||e.message.startsWith("Unexpected end of buffer"))&&(e.incomplete=!0),e}}function pP(){for(let e in hn.restoreStructures)hn[e]=hn.restoreStructures[e];hn.restoreStructures=null}function rs(){let e=st[me++];if(e<160)if(e<128){if(e<64)return e;{let t=hn[e&63]||ti.getStructures&&mP()[e&63];return t?(t.read||(t.read=U_(t,e&63)),t.read()):e}}else if(e<144)if(e-=128,ti.mapsAsObjects){let t={};for(let n=0;n<e;n++)t[bP()]=rs();return t}else{let t=new Map;for(let n=0;n<e;n++)t.set(rs(),rs());return t}else{e-=144;let t=new Array(e);for(let n=0;n<e;n++)t[n]=rs();return t}else if(e<192){let t=e-160;if(ba>=me)return lc.slice(me-Yi,(me+=t)-Yi);if(ba==0&&ac<140){let n=t<16?G_(t):vP(t);if(n!=null)return n}return V_(t)}else{let t;switch(e){case 192:return null;case 193:return Si?(t=rs(),t>0?Si[1].slice(Si.position1,Si.position1+=t):Si[0].slice(Si.position0,Si.position0-=t)):dP;case 194:return!1;case 195:return!0;case 196:return W_(st[me++]);case 197:return t=bn.getUint16(me),me+=2,W_(t);case 198:return t=bn.getUint32(me),me+=4,W_(t);case 199:return ku(st[me++]);case 200:return t=bn.getUint16(me),me+=2,ku(t);case 201:return t=bn.getUint32(me),me+=4,ku(t);case 202:if(t=bn.getFloat32(me),ti.useFloat32>2){let n=j_[(st[me]&127)<<1|st[me+1]>>7];return me+=4,(n*t+(t>0?.5:-.5)>>0)/n}return me+=4,t;case 203:return t=bn.getFloat64(me),me+=8,t;case 204:return st[me++];case 205:return t=bn.getUint16(me),me+=2,t;case 206:return t=bn.getUint32(me),me+=4,t;case 207:return ti.int64AsNumber?(t=bn.getUint32(me)*4294967296,t+=bn.getUint32(me+4)):t=bn.getBigUint64(me),me+=8,t;case 208:return bn.getInt8(me++);case 209:return t=bn.getInt16(me),me+=2,t;case 210:return t=bn.getInt32(me),me+=4,t;case 211:return ti.int64AsNumber?(t=bn.getInt32(me)*4294967296,t+=bn.getUint32(me+4)):t=bn.getBigInt64(me),me+=8,t;case 212:if(t=st[me++],t==114)return wP(st[me++]&63);{let n=$r[t];if(n)return n.read?(me++,n.read(rs())):n.noBuffer?(me++,n()):n(st.subarray(me,++me));throw new Error("Unknown extension "+t)}case 213:return t=st[me],t==114?(me++,wP(st[me++]&63,st[me++])):ku(2);case 214:return ku(4);case 215:return ku(8);case 216:return ku(16);case 217:return t=st[me++],ba>=me?lc.slice(me-Yi,(me+=t)-Yi):Hre(t);case 218:return t=bn.getUint16(me),me+=2,ba>=me?lc.slice(me-Yi,(me+=t)-Yi):jre(t);case 219:return t=bn.getUint32(me),me+=4,ba>=me?lc.slice(me-Yi,(me+=t)-Yi):qre(t);case 220:return t=bn.getUint16(me),me+=2,gP(t);case 221:return t=bn.getUint32(me),me+=4,gP(t);case 222:return t=bn.getUint16(me),me+=2,yP(t);case 223:return t=bn.getUint32(me),me+=4,yP(t);default:if(e>=224)return e-256;if(e===void 0){let n=new Error("Unexpected end of MessagePack data");throw n.incomplete=!0,n}throw new Error("Unknown MessagePack token "+e)}}}var Wre=/^[a-zA-Z_$][a-zA-Z\d_$]*$/;function U_(e,t){function n(){if(n.count++>2){let r=e.read=new Function("r","return function(){return {"+e.map(i=>Wre.test(i)?i+":r()":"["+JSON.stringify(i)+"]:r()").join(",")+"}}")(rs);return e.highByte===0&&(e.read=fP(t,e.read)),r()}let s={};for(let r=0,i=e.length;r<i;r++){let o=e[r];s[o]=rs()}return s}return n.count=0,e.highByte===0?fP(t,n):n}var fP=(e,t)=>function(){let n=st[me++];if(n===0)return t();let s=e<32?-(e+(n<<5)):e+(n<<5),r=hn[s]||mP()[s];if(!r)throw new Error("Record id is not defined for "+s);return r.read||(r.read=U_(r,e)),r.read()};function mP(){let e=CP(()=>(st=null,ti.getStructures()));return hn=ti._mergeStructures(e,hn)}var V_=pv,Hre=pv,jre=pv,qre=pv;function pv(e){let t;if(e<16&&(t=G_(e)))return t;if(e>64&&$_)return $_.decode(st.subarray(me,me+=e));let n=me+e,s=[];for(t="";me<n;){let r=st[me++];if((r&128)==0)s.push(r);else if((r&224)==192){let i=st[me++]&63;s.push((r&31)<<6|i)}else if((r&240)==224){let i=st[me++]&63,o=st[me++]&63;s.push((r&31)<<12|i<<6|o)}else if((r&248)==240){let i=st[me++]&63,o=st[me++]&63,a=st[me++]&63,l=(r&7)<<18|i<<12|o<<6|a;l>65535&&(l-=65536,s.push(l>>>10&1023|55296),l=56320|l&1023),s.push(l)}else s.push(r);s.length>=4096&&(t+=Xs.apply(String,s),s.length=0)}return s.length>0&&(t+=Xs.apply(String,s)),t}function gP(e){let t=new Array(e);for(let n=0;n<e;n++)t[n]=rs();return t}function yP(e){if(ti.mapsAsObjects){let t={};for(let n=0;n<e;n++)t[bP()]=rs();return t}else{let t=new Map;for(let n=0;n<e;n++)t.set(rs(),rs());return t}}var Xs=String.fromCharCode;function vP(e){let t=me,n=new Array(e);for(let s=0;s<e;s++){let r=st[me++];if((r&128)>0){me=t;return}n[s]=r}return Xs.apply(String,n)}function G_(e){if(e<4)if(e<2){if(e===0)return"";{let t=st[me++];if((t&128)>1){me-=1;return}return Xs(t)}}else{let t=st[me++],n=st[me++];if((t&128)>0||(n&128)>0){me-=2;return}if(e<3)return Xs(t,n);let s=st[me++];if((s&128)>0){me-=3;return}return Xs(t,n,s)}else{let t=st[me++],n=st[me++],s=st[me++],r=st[me++];if((t&128)>0||(n&128)>0||(s&128)>0||(r&128)>0){me-=4;return}if(e<6){if(e===4)return Xs(t,n,s,r);{let i=st[me++];if((i&128)>0){me-=5;return}return Xs(t,n,s,r,i)}}else if(e<8){let i=st[me++],o=st[me++];if((i&128)>0||(o&128)>0){me-=6;return}if(e<7)return Xs(t,n,s,r,i,o);let a=st[me++];if((a&128)>0){me-=7;return}return Xs(t,n,s,r,i,o,a)}else{let i=st[me++],o=st[me++],a=st[me++],l=st[me++];if((i&128)>0||(o&128)>0||(a&128)>0||(l&128)>0){me-=8;return}if(e<10){if(e===8)return Xs(t,n,s,r,i,o,a,l);{let c=st[me++];if((c&128)>0){me-=9;return}return Xs(t,n,s,r,i,o,a,l,c)}}else if(e<12){let c=st[me++],h=st[me++];if((c&128)>0||(h&128)>0){me-=10;return}if(e<11)return Xs(t,n,s,r,i,o,a,l,c,h);let u=st[me++];if((u&128)>0){me-=11;return}return Xs(t,n,s,r,i,o,a,l,c,h,u)}else{let c=st[me++],h=st[me++],u=st[me++],d=st[me++];if((c&128)>0||(h&128)>0||(u&128)>0||(d&128)>0){me-=12;return}if(e<14){if(e===12)return Xs(t,n,s,r,i,o,a,l,c,h,u,d);{let p=st[me++];if((p&128)>0){me-=13;return}return Xs(t,n,s,r,i,o,a,l,c,h,u,d,p)}}else{let p=st[me++],f=st[me++];if((p&128)>0||(f&128)>0){me-=14;return}if(e<15)return Xs(t,n,s,r,i,o,a,l,c,h,u,d,p,f);let g=st[me++];if((g&128)>0){me-=15;return}return Xs(t,n,s,r,i,o,a,l,c,h,u,d,p,f,g)}}}}}function W_(e){return ti.copyBuffers?Uint8Array.prototype.slice.call(st,me,me+=e):st.subarray(me,me+=e)}function ku(e){let t=st[me++];if($r[t])return $r[t](st.subarray(me,me+=e));throw new Error("Unknown extension type "+t)}var xP=new Array(4096);function bP(){let e=st[me++];if(e>=160&&e<192){if(e=e-160,ba>=me)return lc.slice(me-Yi,(me+=e)-Yi);if(!(ba==0&&ac<180))return V_(e)}else return me--,rs();let t=(e<<5^(e>1?bn.getUint16(me):e>0?st[me]:0))&4095,n=xP[t],s=me,r=me+e-3,i,o=0;if(n&&n.bytes==e){for(;s<r;){if(i=bn.getUint32(s),i!=n[o++]){s=1879048192;break}s+=4}for(r+=3;s<r;)if(i=st[s++],i!=n[o++]){s=1879048192;break}if(s===r)return me=s,n.string;r-=3,s=me}for(n=[],xP[t]=n,n.bytes=e;s<r;)i=bn.getUint32(s),n.push(i),s+=4;for(r+=3;s<r;)i=st[s++],n.push(i);let a=e<16?G_(e):vP(e);return a!=null?n.string=a:n.string=V_(e)}var wP=(e,t)=>{var n=rs();let s=e;t!==void 0&&(e=e<32?-((t<<5)+e):(t<<5)+e,n.highByte=t);let r=hn[e];return r&&r.isShared&&((hn.restoreStructures||(hn.restoreStructures=[]))[e]=r),hn[e]=n,n.read=U_(n,s),n.read()},SP=typeof self=="object"?self:global;$r[0]=()=>{};$r[0].noBuffer=!0;$r[101]=()=>{let e=rs();return(SP[e[0]]||Error)(e[1])};$r[105]=e=>{let t=bn.getUint32(me-4);vl||(vl=new Map);let n=st[me],s;n>=144&&n<160||n==220||n==221?s=[]:s={};let r={target:s};vl.set(t,r);let i=rs();return r.used?Object.assign(s,i):(r.target=i,i)};$r[112]=e=>{let t=bn.getUint32(me-4),n=vl.get(t);return n.used=!0,n.target};$r[115]=()=>new Set(rs());var _P=["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64"].map(e=>e+"Array");$r[116]=e=>{let t=e[0],n=_P[t];if(!n)throw new Error("Could not find typed array for code "+t);return new SP[n](Uint8Array.prototype.slice.call(e,1).buffer)};$r[120]=()=>{let e=rs();return new RegExp(e[0],e[1])};$r[98]=e=>{let t=(e[0]<<24)+(e[1]<<16)+(e[2]<<8)+e[3],n=me;me+=t-4,Si=[rs(),rs()],Si.position0=0,Si.position1=0;let s=me;me=n;try{return rs()}finally{me=s}};$r[255]=e=>e.length==4?new Date((e[0]*16777216+(e[1]<<16)+(e[2]<<8)+e[3])*1e3):e.length==8?new Date(((e[0]<<22)+(e[1]<<14)+(e[2]<<6)+(e[3]>>2))/1e6+((e[3]&3)*4294967296+e[4]*16777216+(e[5]<<16)+(e[6]<<8)+e[7])*1e3):e.length==12?new Date(((e[0]<<24)+(e[1]<<16)+(e[2]<<8)+e[3])/1e6+((e[4]&128?-281474976710656:0)+e[6]*1099511627776+e[7]*4294967296+e[8]*16777216+(e[9]<<16)+(e[10]<<8)+e[11])*1e3):new Date("invalid");function CP(e){let t=ac,n=me,s=z_,r=Yi,i=ba,o=lc,a=B_,l=vl,c=Si,h=new Uint8Array(st.slice(0,ac)),u=hn,d=hn.slice(0,hn.length),p=ti,f=Id,g=e();return ac=t,me=n,z_=s,Yi=r,ba=i,lc=o,B_=a,vl=l,Si=c,st=h,Id=f,hn=u,hn.splice(0,hn.length,...d),ti=p,bn=new DataView(st.buffer,st.byteOffset,st.byteLength),g}function H_(){st=null,vl=null,hn=null}function Xre(e){e.unpack?$r[e.type]=e.unpack:$r[e.type]=e}var j_=new Array(147);for(let e=0;e<256;e++)j_[e]=+("1e"+Math.floor(45.15-e*.30103));var fv=new hv({useRecords:!1});fv.unpack;fv.unpackMultiple;fv.unpack;var Kre=new Float32Array(1);new Uint8Array(Kre.buffer,0,4);var mv;try{mv=new TextEncoder}catch{}var gv,q_,yv=typeof Buffer<"u",X_=yv?Buffer.allocUnsafeSlow:Uint8Array,TP=yv?Buffer:Uint8Array,EP=yv?4294967296:2144337920,ke,ps,Se=0,wa,Sa=null,Yre=/[\u0080-\uFFFF]/,sm=Symbol("record-id"),AP=class extends hv{constructor(e){super(e),this.offset=0;let t,n,s,r,i,o=0,a=TP.prototype.utf8Write?function(S,C,_){return ke.utf8Write(S,C,_)}:mv&&mv.encodeInto?function(S,C){return mv.encodeInto(S,ke.subarray(C)).written}:!1,l=this;e||(e={});let c=e&&e.sequential,h=e.structures||e.saveStructures,u=e.maxSharedStructures;if(u==null&&(u=h?32:0),u>8160)throw new Error("Maximum maxSharedStructure is 8160");let d=e.maxOwnStructures;d==null&&(d=h?32:64),c&&!e.saveStructures&&(this.structures=[]);let p=u>32||d+u>64,f=u+64,g=u+d+64;if(g>8256)throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");let m=[],y=0,v=0;this.pack=this.encode=function(S,C){if(ke||(ke=new X_(8192),ps=new DataView(ke.buffer,0,8192),Se=0),wa=ke.length-10,wa-Se<2048?(ke=new X_(ke.length),ps=new DataView(ke.buffer,0,ke.length),wa=ke.length-10,Se=0):Se=Se+7&2147483640,t=Se,i=l.structuredClone?new Map:null,l.bundleStrings?(Sa=["",""],ke[Se++]=214,ke[Se++]=98,Sa.position=Se-t,Se+=4):Sa=null,n=l.structures,n){n.uninitialized&&(n=l._mergeStructures(l.getStructures()));let _=n.sharedLength||0;if(_>u)throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to "+n.sharedLength);if(!n.transitions){n.transitions=Object.create(null);for(let T=0;T<_;T++){let E=n[T];if(!E)continue;let A,D=n.transitions;for(let O=0,P=E.length;O<P;O++){let L=E[O];A=D[L],A||(A=D[L]=Object.create(null)),D=A}D[sm]=T+64}o=_}c||(n.nextId=_+64)}s&&(s=!1),r=n||[];try{if(b(S),Sa){ps.setUint32(Sa.position+t,Se-Sa.position-t);let _=Sa;Sa=null,b(_[0]),b(_[1])}if(l.offset=Se,i&&i.idsToInsert){Se+=i.idsToInsert.length*6,Se>wa&&w(Se),l.offset=Se;let _=Zre(ke.subarray(t,Se),i.idsToInsert);return i=null,_}return C&Jre?(ke.start=t,ke.end=Se,ke):ke.subarray(t,Se)}finally{if(n){if(v<10&&v++,y>1e4)n.transitions=null,v=0,y=0,m.length>0&&(m=[]);else if(m.length>0&&!c){for(let _=0,T=m.length;_<T;_++)m[_][sm]=0;m=[]}if(s&&l.saveStructures){let _=n.sharedLength||u;n.length>_&&(n=n.slice(0,_));let T=ke.subarray(t,Se);return l.saveStructures(n,o)===!1?(l._mergeStructures(l.getStructures()),l.pack(S)):(o=_,T)}}C&eie&&(Se=t)}};let b=S=>{Se>wa&&(ke=w(Se));var C=typeof S,_;if(C==="string"){let T=S.length;if(Sa&&T>=8&&T<4096){let D=Yre.test(S);Sa[D?0:1]+=S,ke[Se++]=193,b(D?-T:T);return}let E;T<32?E=1:T<256?E=2:T<65536?E=3:E=5;let A=T*3;if(Se+A>wa&&(ke=w(Se+A)),T<64||!a){let D,O,P,L=Se+E;for(D=0;D<T;D++)O=S.charCodeAt(D),O<128?ke[L++]=O:O<2048?(ke[L++]=O>>6|192,ke[L++]=O&63|128):(O&64512)==55296&&((P=S.charCodeAt(D+1))&64512)==56320?(O=65536+((O&1023)<<10)+(P&1023),D++,ke[L++]=O>>18|240,ke[L++]=O>>12&63|128,ke[L++]=O>>6&63|128,ke[L++]=O&63|128):(ke[L++]=O>>12|224,ke[L++]=O>>6&63|128,ke[L++]=O&63|128);_=L-Se-E}else _=a(S,Se+E,A);_<32?ke[Se++]=160|_:_<256?(E<2&&ke.copyWithin(Se+2,Se+1,Se+1+_),ke[Se++]=217,ke[Se++]=_):_<65536?(E<3&&ke.copyWithin(Se+3,Se+2,Se+2+_),ke[Se++]=218,ke[Se++]=_>>8,ke[Se++]=_&255):(E<5&&ke.copyWithin(Se+5,Se+3,Se+3+_),ke[Se++]=219,ps.setUint32(Se,_),Se+=4),Se+=_}else if(C==="number")if(S>>>0===S)S<64?ke[Se++]=S:S<256?(ke[Se++]=204,ke[Se++]=S):S<65536?(ke[Se++]=205,ke[Se++]=S>>8,ke[Se++]=S&255):(ke[Se++]=206,ps.setUint32(Se,S),Se+=4);else if(S>>0===S)S>=-32?ke[Se++]=256+S:S>=-128?(ke[Se++]=208,ke[Se++]=S+256):S>=-32768?(ke[Se++]=209,ps.setInt16(Se,S),Se+=2):(ke[Se++]=210,ps.setInt32(Se,S),Se+=4);else{let T;if((T=this.useFloat32)>0&&S<4294967296&&S>=-2147483648){ke[Se++]=202,ps.setFloat32(Se,S);let E;if(T<4||(E=S*j_[(ke[Se]&127)<<1|ke[Se+1]>>7])>>0===E){Se+=4;return}else Se--}ke[Se++]=203,ps.setFloat64(Se,S),Se+=8}else if(C==="object")if(!S)ke[Se++]=192;else{if(i){let E=i.get(S);if(E){if(!E.id){let A=i.idsToInsert||(i.idsToInsert=[]);E.id=A.push(E)}ke[Se++]=214,ke[Se++]=112,ps.setUint32(Se,E.id),Se+=4;return}else i.set(S,{offset:Se-t})}let T=S.constructor;if(T===Object)x(S,!0);else if(T===Array){_=S.length,_<16?ke[Se++]=144|_:_<65536?(ke[Se++]=220,ke[Se++]=_>>8,ke[Se++]=_&255):(ke[Se++]=221,ps.setUint32(Se,_),Se+=4);for(let E=0;E<_;E++)b(S[E])}else if(T===Map){_=S.size,_<16?ke[Se++]=128|_:_<65536?(ke[Se++]=222,ke[Se++]=_>>8,ke[Se++]=_&255):(ke[Se++]=223,ps.setUint32(Se,_),Se+=4);for(let[E,A]of S)b(E),b(A)}else{for(let E=0,A=gv.length;E<A;E++){let D=q_[E];if(S instanceof D){let O=gv[E];if(O.write){O.type&&(ke[Se++]=212,ke[Se++]=O.type,ke[Se++]=0),b(O.write.call(this,S));return}let P=ke,L=ps,B=Se;ke=null;let F;try{F=O.pack.call(this,S,M=>(ke=P,P=null,Se+=M,Se>wa&&w(Se),{target:ke,targetView:ps,position:Se-M}),b)}finally{P&&(ke=P,ps=L,Se=B,wa=ke.length-10)}F&&(F.length+Se>wa&&w(F.length+Se),Se=Qre(F,ke,Se,O.type));return}}x(S,!S.hasOwnProperty)}}else if(C==="boolean")ke[Se++]=S?195:194;else if(C==="bigint"){if(S<BigInt(1)<<BigInt(63)&&S>=-(BigInt(1)<<BigInt(63)))ke[Se++]=211,ps.setBigInt64(Se,S);else if(S<BigInt(1)<<BigInt(64)&&S>0)ke[Se++]=207,ps.setBigUint64(Se,S);else if(this.largeBigIntToFloat)ke[Se++]=203,ps.setFloat64(Se,Number(S));else throw new RangeError(S+" was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");Se+=8}else if(C==="undefined")this.encodeUndefinedAsNil?ke[Se++]=192:(ke[Se++]=212,ke[Se++]=0,ke[Se++]=0);else if(C==="function")b(this.writeFunction&&this.writeFunction());else throw new Error("Unknown type: "+C)},x=this.useRecords===!1?this.variableMapSize?S=>{let C=Object.keys(S),_=C.length;_<16?ke[Se++]=128|_:_<65536?(ke[Se++]=222,ke[Se++]=_>>8,ke[Se++]=_&255):(ke[Se++]=223,ps.setUint32(Se,_),Se+=4);let T;for(let E=0;E<_;E++)b(T=C[E]),b(S[T])}:(S,C)=>{ke[Se++]=222;let _=Se-t;Se+=2;let T=0;for(let E in S)(C||S.hasOwnProperty(E))&&(b(E),b(S[E]),T++);ke[_+++t]=T>>8,ke[_+t]=T&255}:S=>{let C=Object.keys(S),_,T=r.transitions||(r.transitions=Object.create(null)),E=0;for(let D=0,O=C.length;D<O;D++){let P=C[D];_=T[P],_||(_=T[P]=Object.create(null),E++),T=_}let A=T[sm];if(A)A>=96&&p?(ke[Se++]=((A-=96)&31)+96,ke[Se++]=A>>5):ke[Se++]=A;else{A=r.nextId,A||(A=64),A<f&&this.shouldShareStructure&&!this.shouldShareStructure(C)?(A=r.nextOwnId,A<g||(A=f),r.nextOwnId=A+1):(A>=g&&(A=f),r.nextId=A+1);let D=C.highByte=A>=96&&p?A-96>>5:-1;T[sm]=A,r[A-64]=C,A<f?(C.isShared=!0,r.sharedLength=A-63,s=!0,D>=0?(ke[Se++]=(A&31)+96,ke[Se++]=D):ke[Se++]=A):(D>=0?(ke[Se++]=213,ke[Se++]=114,ke[Se++]=(A&31)+96,ke[Se++]=D):(ke[Se++]=212,ke[Se++]=114,ke[Se++]=A),E&&(y+=v*E),m.length>=d&&(m.shift()[sm]=0),m.push(T),b(C))}for(let D=0,O=C.length;D<O;D++)b(S[C[D]])},w=S=>{let C;if(S>16777216){if(S-t>EP)throw new Error("Packed buffer would be larger than maximum buffer size");C=Math.min(EP,Math.round(Math.max((S-t)*(S>67108864?1.25:2),4194304)/4096)*4096)}else C=(Math.max(S-t<<2,ke.length-1)>>12)+1<<12;let _=new X_(C);return ps=new DataView(_.buffer,0,C),ke.copy?ke.copy(_,0,t,S):_.set(ke.slice(t,S)),Se-=t,t=0,wa=_.length-10,ke=_}}useBuffer(e){ke=e,ps=new DataView(ke.buffer,ke.byteOffset,ke.byteLength),Se=0}};q_=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor,hP];gv=[{pack(e,t,n){let s=e.getTime()/1e3;if((this.useTimestamp32||e.getMilliseconds()===0)&&s>=0&&s<4294967296){let{target:r,targetView:i,position:o}=t(6);r[o++]=214,r[o++]=255,i.setUint32(o,s)}else if(s>0&&s<17179869184){let{target:r,targetView:i,position:o}=t(10);r[o++]=215,r[o++]=255,i.setUint32(o,e.getMilliseconds()*4e6+(s/1e3/4294967296>>0)),i.setUint32(o+4,s)}else if(isNaN(s)){if(this.onInvalidDate)return t(0),n(this.onInvalidDate());let{target:r,targetView:i,position:o}=t(3);r[o++]=212,r[o++]=255,r[o++]=255}else{let{target:r,targetView:i,position:o}=t(15);r[o++]=199,r[o++]=12,r[o++]=255,i.setUint32(o,e.getMilliseconds()*1e6),i.setBigInt64(o+4,BigInt(Math.floor(s)))}}},{pack(e,t,n){let s=Array.from(e),{target:r,position:i}=t(this.structuredClone?3:0);this.structuredClone&&(r[i++]=212,r[i++]=115,r[i++]=0),n(s)}},{pack(e,t,n){let{target:s,position:r}=t(this.structuredClone?3:0);this.structuredClone&&(s[r++]=212,s[r++]=101,s[r++]=0),n([e.name,e.message])}},{pack(e,t,n){let{target:s,position:r}=t(this.structuredClone?3:0);this.structuredClone&&(s[r++]=212,s[r++]=120,s[r++]=0),n([e.source,e.flags])}},{pack(e,t){this.structuredClone?IP(e,16,t):NP(yv?Buffer.from(e):new Uint8Array(e),t)}},{pack(e,t){let n=e.constructor;n!==TP&&this.structuredClone?IP(e,_P.indexOf(n.name),t):NP(e,t)}},{pack(e,t){let{target:n,position:s}=t(1);n[s]=193}}];function IP(e,t,n,s){let r=e.byteLength;if(r+1<256){var{target:i,position:o}=n(4+r);i[o++]=199,i[o++]=r+1}else if(r+1<65536){var{target:i,position:o}=n(5+r);i[o++]=200,i[o++]=r+1>>8,i[o++]=r+1&255}else{var{target:i,position:o,targetView:a}=n(7+r);i[o++]=201,a.setUint32(o,r+1),o+=4}i[o++]=116,i[o++]=t,i.set(new Uint8Array(e.buffer,e.byteOffset,e.byteLength),o)}function NP(e,t){let n=e.byteLength;var s,r;if(n<256){var{target:s,position:r}=t(n+2);s[r++]=196,s[r++]=n}else if(n<65536){var{target:s,position:r}=t(n+3);s[r++]=197,s[r++]=n>>8,s[r++]=n&255}else{var{target:s,position:r,targetView:i}=t(n+5);s[r++]=198,i.setUint32(r,n),r+=4}s.set(e,r)}function Qre(e,t,n,s){let r=e.length;switch(r){case 1:t[n++]=212;break;case 2:t[n++]=213;break;case 4:t[n++]=214;break;case 8:t[n++]=215;break;case 16:t[n++]=216;break;default:r<256?(t[n++]=199,t[n++]=r):r<65536?(t[n++]=200,t[n++]=r>>8,t[n++]=r&255):(t[n++]=201,t[n++]=r>>24,t[n++]=r>>16&255,t[n++]=r>>8&255,t[n++]=r&255)}return t[n++]=s,t.set(e,n),n+=r,n}function Zre(e,t){let n,s=t.length*6,r=e.length-s;for(t.sort((i,o)=>i.offset>o.offset?1:-1);n=t.pop();){let i=n.offset,o=n.id;e.copyWithin(i+s,i,r),s-=6;let a=i+s;e[a++]=214,e[a++]=105,e[a++]=o>>24,e[a++]=o>>16&255,e[a++]=o>>8&255,e[a++]=o&255,r=i}return e}function Nd(e){if(e.Class){if(!e.pack&&!e.write)throw new Error("Extension has no pack or write function");if(e.pack&&!e.type)throw new Error("Extension has no type (numeric code to identify the extension)");q_.unshift(e.Class),gv.unshift(e)}Xre(e)}var kP=new AP({useRecords:!1});kP.pack;kP.pack;var Jre=512,eie=1024,DP=new AP({structuredClone:!0});Nd({Class:Ps.prototype.constructor,type:1,write(e){return ue({},e)},read(e){return Object.setPrototypeOf(e,Ps.prototype),e}});Nd({Class:Qt.prototype.constructor,type:2,write(e){return[...e]},read(e){return Object.setPrototypeOf(e,Qt.prototype),e}});Nd({Class:ei.prototype.constructor,type:3,write(e){return[...e]},read(e){return Object.setPrototypeOf(e,ei.prototype),e}});Nd({Class:aP.prototype.constructor,type:4,write(e){return e.id},read(e){return new aP(e)}});Nd({Class:lP.prototype.constructor,type:5,write(e){return e.data},read(e){return new lP(e)}});Nd({Class:sr.prototype.constructor,type:6,write(e){return ue({},e)},read(e){return Object.setPrototypeOf(e,sr.prototype),e}});function tie(e){var t=0;if(e.length===0)return t;for(let n=0;n<e.length;n++){let s=e[n];t=(t<<5)-t+s,t=t&t}return t}function K_(e){if(D_(e))return e;if(Array.isArray(e))return e.map(K_);if(typeof e=="object"&&e!==null){let t={};for(let n of Object.keys(e).sort())t[n]=K_(e[n]);return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}else return e}var Y_;(e=>{function t(r){return DP.pack(r)}e.serialize=t;function n(r){return DP.unpack(r)}e.deserialize=n;function s(r){return tie(t(K_(r))).toString()}e.checksum=s})(Y_||(Y_={}));var rm={LookAt:[],Follow:[],MouseHover:["Transition"],Scroll:["Transition"],Start:["Transition","Audio","Video"],Conditional:["Transition","Audio","Video"],MouseDown:["Transition","Audio","Video","Link","Reset"],MouseUp:["Transition","Audio","Video","Link","Reset"],MousePress:["Transition","Audio","Video","Link","Reset"],KeyDown:["Transition","Audio","Video","Link","Reset"],KeyUp:["Transition","Audio","Video","Link","Reset"],KeyPress:["Transition","Audio","Video","Link","Reset"],GameControl:["Transition","Audio"],Collision:["Transition","Audio"]},MP;(e=>{function t(s){return s.type==="MouseDown"||s.type==="MouseUp"||s.type==="MousePress"||s.type==="KeyDown"||s.type==="KeyUp"||s.type==="KeyPress"}e.is=t;function n(s){return s==="MouseDown"||s==="MouseUp"||s==="MousePress"?{type:s,disabled:!1,toggle:!1,actions:new Qt}:{type:s,disabled:!1,key:void 0,toggle:!1,actions:new Qt}}e.defaultData=n})(MP||(MP={}));var vv;(e=>{function t(n){return{type:"Property",value:[n!=null?n:null,"position","x"]}}e.propertyDefaultData=t,e.valueDefaultData={type:"Literal",value:0}})(vv||(vv={}));var Q_;(e=>{function t(r){return{type:"Comparison",operator:"==",lOperand:vv.propertyDefaultData(r),rOperand:ue({},vv.valueDefaultData)}}e.comparisonDefaultData=t;function n(r){return{type:"Distance",toObject:r!=null?r:null,fromObject:r!=null?r:null,distance:200}}e.distanceDefaultData=n;function s(r,i){return{type:"State",object:r!=null?r:null,state:i!=null?i:null}}e.stateDefaultData=s})(Q_||(Q_={}));var PP;(e=>{function t(s){return s.type==="Conditional"}e.is=t;function n(s){return{type:"Conditional",disabled:!1,inActions:new Qt,outActions:new Qt,condition:Q_.distanceDefaultData(s)}}e.defaultData=n})(PP||(PP={}));var OP;(e=>e.defaultData={type:"Follow",disabled:!1,maxDelta:0,dampingFactor:1,plane:"custom",resetOnPointerLeave:!0})(OP||(OP={}));var RP;(e=>e.defaultData={type:"LookAt",disabled:!1,distance:1e3,dampingFactor:1,tilt:"up",axis:"z",plane:"custom",resetOnPointerLeave:!0})(RP||(RP={}));var LP;(e=>{function t(s){return s.type==="MouseHover"}e.is=t;function n(){return{type:"MouseHover",disabled:!1,actions:new Qt}}e.defaultData=n})(LP||(LP={}));var FP;(e=>{function t(s){return s.type==="Scroll"}e.is=t;function n(){return{type:"Scroll",disabled:!1,steps:100,actions:new Qt}}e.defaultData=n})(FP||(FP={}));var $P;(e=>{function t(s){return s.type==="Start"}e.is=t;function n(){return{type:"Start",disabled:!1,actions:new Qt}}e.defaultData=n})($P||($P={}));var BP;(e=>{function t(s){return s.type==="Collision"}e.is=t;function n(){return{type:"Collision",disabled:!1,toggle:!1,target:"character",actions:new Qt}}e.defaultData=n})(BP||(BP={}));var kd;(e=>{function t(s,r){return s[0]===r[0]&&s[1]===r[1]}e.isEqual=t;function n(s,r,i){return[s[0]+(r[0]-s[0])*i,s[1]+(r[1]-s[1])*i]}e.lerp=n})(kd||(kd={}));var Du;(e=>{function t(a,l){return a[0]===l[0]&&a[1]===l[1]&&a[2]===l[2]}e.isEqual=t;function n(a,l){return[a[0]+l[0],a[1]+l[1],a[2]+l[2]]}e.add=n;function s(a,l){return[a[0]-l[0],a[1]-l[1],a[2]-l[2]]}e.sub=s;function r(a,l){return[a[0]/l[0],a[1]/l[1],a[2]/l[2]]}e.div=r;function i(a,l){return[a[0]*l[0],a[1]*l[1],a[2]*l[2]]}e.mul=i;function o(a,l,c){return[a[0]+(l[0]-a[0])*c,a[1]+(l[1]-a[1])*c,a[2]+(l[2]-a[2])*c]}e.lerp=o})(Du||(Du={}));var xv;(e=>{function t(s,r){return s[0]===r[0]&&s[1]===r[1]&&s[2]===r[2]&&s[3]===r[3]}e.isEqual=t;function n(s,r,i){return[s[0]+(r[0]-s[0])*i,s[1]+(r[1]-s[1])*i,s[2]+(r[2]-s[2])*i,s[3]+(r[3]-s[3])*i]}e.lerp=n})(xv||(xv={}));var Dd;(e=>{e.identity=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];function t(r,i){for(let o=0;o<16;o++)if(r[o]!==i[o])return!1;return!0}e.isEqual=t;function n(r){return r!=null?r:e.identity}e.simplify=n;function s(r,i){let o=i.slice(0);for(var a=0,l=i.length;a<l;a+=3){let c=r[3]*i[a]+r[7]*i[a+1]+r[11]*i[a+2]+r[15];o[a]=(r[0]*i[a]+r[4]*i[a+1]+r[8]*i[a+2]+r[12])/c,o[a+1]=(r[1]*i[a]+r[5]*i[a+1]+r[9]*i[a+2]+r[13])/c,o[a+2]=(r[2]*i[a]+r[6]*i[a+1]+r[10]*i[a+2]+r[14])/c}return o}e.applyMatrix4=s})(Dd||(Dd={}));var _i;(e=>{function t(a){return typeof a=="object"&&typeof a.r=="number"&&typeof a.g=="number"&&typeof a.b=="number"}e.isRGB=t,e.white={r:1,g:1,b:1},e.red={r:1,g:0,b:0},e.black={r:0,g:0,b:0};function n(a){return{r:Math.round(a.r*255),g:Math.round(a.g*255),b:Math.round(a.b*255),a:1}}e.toRgb255a1=n;function s(a){return{r:a.r,g:a.g,b:a.b}}e.clone=s;function r(a){return a=Math.floor(a),{r:(a>>16&255)/255,g:(a>>8&255)/255,b:(a&255)/255}}e.fromHex=r;function i(a,l){return a.r===l.r&&a.g===l.g&&a.b===l.b}e.equals=i;function o(a,l,c){return{r:a.r+(l.r-a.r)*c,g:a.g+(l.g-a.g)*c,b:a.b+(l.b-a.b)*c}}e.lerp=o})(_i||(_i={}));var Ro;(e=>{e.white=De(ue({},_i.white),{a:1}),e.transparent=De(ue({},_i.white),{a:0});function t(o){return{r:o[0],g:o[1],b:o[2],a:o[3]}}e.from0to1=t;function n(o,a){return De(ue({},_i.fromHex(o)),{a})}e.fromHexAndA=n;function s(o){return{r:Math.round(o.r*255),g:Math.round(o.g*255),b:Math.round(o.b*255),a:o.a}}e.toRgb255a1=s;function r(o,a){return _i.equals(o,a)&&o.a===a.a}e.equals=r;function i(o,a,l){return{r:o.r+(a.r-o.r)*l,g:o.g+(a.g-o.g)*l,b:o.b+(a.b-o.b)*l,a:o.a+(a.a-o.a)*l}}e.lerp=i})(Ro||(Ro={}));var Z_;(e=>e.identity={position:[0,0,0],rotation:[0,0,0],scale:[1,1,1]})(Z_||(Z_={}));var zP;(e=>e.defaultData={mass:1,stiffness:80,damping:10,velocity:0})(zP||(zP={}));var UP;(e=>e.defaultData={control1:[.5,.05],control2:[.1,.3]})(UP||(UP={}));var Mu;(e=>{e.all=["PerspectiveCamera","OrthographicCamera"];function t(n){return e.all.includes(n)}e.is=t})(Mu||(Mu={}));var im;(e=>{e.DefaultUp=[0,1,0],e.DefaultTargetOffset=1e3,e.defaultData={far:1e5,type:"OrthographicCamera",perspective:{near:70,fov:45,zoom:1},orthographic:{near:-1e5,zoom:1,autoZoom:!1,autoZoomFrustumSize:790},up:e.DefaultUp,isUpVectorFlipped:!1,targetOffset:e.DefaultTargetOffset};function t(n){return n.type==="PerspectiveCamera"?n.perspective.zoom:n.orthographic.zoom}e.getZoom=t})(im||(im={}));var cc;(e=>{function t(s,r=.1){return{disabled:!1,type:"linear",hideBase:!1,count:3,radial:{radius:Math.max(s[0],s[1])*2,start:0,end:360,alignment:!1,axis:"y",scale:[1,1,1],rotation:[0,0,0],position:[0,0,0]},toObject:{object:"",spreadType:"random",scale:[0,0,0],rotation:[0,0,0],position:[0,0,0],axis:"x",seed:0,count:99,align:"normal"},linear:{scale:[1,1,1],rotation:[0,0,0],position:[s[0]+s[0]*r,0,0]},grid:{count:[2,2,2],size:s.map(i=>i*(1+r)),useCenter:!0},randomness:!1,randomnessObject:{strength:100,scale:[0,0,0],rotation:[0,0,0],position:[0,0,0],movement:1,seed:0,freqScale:10,noiseType:"perlin"}}}e.defaultData=t;function n(s,r){let i=ue({},s);if(VP.forEach(o=>{var a;Object.assign(i,{[o]:(a=r[o])!=null?a:s[o]})}),i.radial=ue({},s.radial),r.radial){let o=s.radial,a=r.radial;GP.forEach(l=>{var c;Object.assign(i.radial,{[l]:(c=a[l])!=null?c:o[l]})})}if(i.linear=ue({},s.linear),r.linear){let o=s.linear,a=r.linear;WP.forEach(l=>{var c;Object.assign(i.linear,{[l]:(c=a[l])!=null?c:o[l]})})}if(i.grid=ue({},s.grid),r.grid){let o=s.grid,a=r.grid;HP.forEach(l=>{var c;Object.assign(i.grid,{[l]:(c=a[l])!=null?c:o[l]})})}if(i.toObject=ue({},s.toObject),r.toObject){let o=s.toObject,a=r.toObject;jP.forEach(l=>{var c;Object.assign(i.toObject,{[l]:(c=a[l])!=null?c:o[l]})})}if(i.randomnessObject=ue({},s.randomnessObject),r.randomnessObject){let o=s.randomnessObject,a=r.randomnessObject;qP.forEach(l=>{var c;Object.assign(i.randomnessObject,{[l]:(c=a[l])!=null?c:o[l]})})}return i}e.merge=n})(cc||(cc={}));var J_;(e=>{e.defaultData={radial:{},linear:{},grid:{},toObject:{},randomnessObject:{}};let t=["radial","linear","grid","toObject","randomnessObject"];function n(s,r){let i=[];s.count!==void 0&&i.push({type:0,path:r,props:{count:s.count}});for(let o of t){let a=s[o];a&&Object.keys(a).length>0&&i.push({type:0,path:[...r,o],props:a})}return i}e.toOps=n})(J_||(J_={}));var VP=["count"],GP=["radius","start","end","position","scale","rotation"],WP=["position","scale","rotation"],HP=["count","size"],jP=["count","position","scale","rotation"],qP=["strength","scale","rotation","position","movement","seed","freqScale"],om;(e=>{let t={opacity:1,blendFunction:13,enabled:!1};e.defaultData={enabled:!1,pixelation:De(ue({},t),{blendFunction:16,granularity:15}),bloom:De(ue({},t),{blendFunction:16,intensity:1,blurScale:1,luminanceThreshold:.25,luminanceSmoothing:.025,kernelSize:3}),chromaticAberration:De(ue({},t),{offset:[2,2]}),vignette:De(ue({},t),{darkness:1,offset:0}),hueSaturation:De(ue({},t),{hue:3,saturation:0}),brightnessContrast:De(ue({},t),{brightness:.25,contrast:0}),depthOfField:De(ue({},t),{focalLength:2,focusDistance:2,bokehScale:2}),noise:De(ue({},t),{blendFunction:16})}})(om||(om={}));var e2;(e=>{e.all=["PointLight","SpotLight","DirectionalLight","HemisphereLight"];function t(n){return e.all.includes(n)}e.is=t})(e2||(e2={}));var t2;(e=>{function t(s){return n(s)}e.defaultData=t;function n(s){if(s==="PointLight")return{type:s,color:Ro.white,intensity:1,distance:2e3,decay:1,shadows:!0,shadowResolution:1024,shadowRadius:1,depth:1e5};if(s==="SpotLight")return{type:s,color:Ro.white,intensity:1,distance:2e3,decay:1,shadows:!0,penumbra:0,angle:30/180*Math.PI,depth:1e5,shadowResolution:1024,shadowRadius:1};if(s==="DirectionalLight")return{type:s,color:Ro.white,intensity:1,shadows:!0,size:1e3,depth:1e5,shadowResolution:1024,shadowRadius:1};throw new Error("not implemented")}})(t2||(t2={}));var n2;(e=>{e.defaultData={castShadow:!0,receiveShadow:!0};function t(n,s){return n.castShadow===s.castShadow&&n.receiveShadow===s.receiveShadow}e.equals=t})(n2||(n2={}));var s2;(e=>{e.defaultData={flatShading:!1,wireframe:!1,side:0};function t(n,s){return n.flatShading===s.flatShading&&n.side===s.side&&n.wireframe===s.wireframe}e.equals=t})(s2||(s2={}));var r2;(e=>e.defaultData=ue(ue({},s2.defaultData),n2.defaultData))(r2||(r2={}));var bv;(e=>(e.defaultVideo={data:"",thumb:"/_assets/_videos/catThumb.png",type:"video",name:"Cat video"},e.maxSize=3e7))(bv||(bv={}));var XP=["mode","gradientType","noiseType","displacementType","projection","cnormal","crop","axis","side"],nie=["wrapping","image","video"],Qi;(e=>{function t(i,o){let c=o,{texture:a}=c,l=qh(c,["texture"]);if(Object.assign(i,l),a){let h=i.texture;h&&Object.assign(h,a)}}e.patch=t;function n(i,o){return i==="light"&&o?s(o):r(i)}e.defaultData=n;function s(i){switch(i){case"phong":return{category:"phong",specular:{r:.2,g:.2,b:.2},shininess:5,type:"light",alpha:.6,visible:!0,mode:0};case"toon":return{category:"toon",specular:{r:.2,g:.2,b:.2},shininess:10,type:"light",alpha:1,visible:!0,mode:0};case"lambert":return{category:"lambert",emissive:{r:0,g:0,b:0},type:"light",alpha:1,visible:!0,mode:0};case"physical":return{category:"physical",roughness:.2,metalness:.2,reflectivity:.2,type:"light",alpha:1,visible:!0,mode:0}}}function r(i){switch(i){case"texture":return{alpha:1,visible:!0,size:[128,128],mode:0,axis:"x",side:2,type:"texture",projection:0,texture:{image:"image_0",wrapping:1e3,repeat:[1,1],offset:[0,0]},crop:!1};case"video":return{alpha:1,visible:!0,size:[128,128],mode:0,axis:"x",side:2,type:"video",projection:0,texture:{video:bv.defaultVideo,wrapping:1001,repeat:[1,1],offset:[0,0]},crop:!0};case"color":return{type:"color",alpha:1,visible:!0,mode:0,color:_i.fromHex(4737101)};case"depth":return{type:"depth",alpha:1,visible:!0,mode:0,gradientType:1,smooth:!1,isVector:!0,isWorldSpace:!1,origin:[0,0,0],direction:[1,0,0],colors:[[1,1,1,1],[0,0,0,1]],steps:[0,1],near:50,far:200};case"normal":return{type:"normal",alpha:1,visible:!0,mode:0,cnormal:[1,1,1]};case"gradient":return{type:"gradient",alpha:1,visible:!0,mode:0,gradientType:0,smooth:!1,colors:[[0,0,0,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]],steps:[0,1,1,1,1,1,1,1,1,1],num:2,angle:0,offset:[0,0],morph:[0,0]};case"noise":return{type:"noise",alpha:1,visible:!0,mode:0,size:[100,100,100],noiseType:0,scale:1,move:1,colorA:De(ue({},_i.fromHex(6710886)),{a:1}),colorB:De(ue({},_i.fromHex(6710886)),{a:1}),colorC:De(ue({},_i.fromHex(16777215)),{a:1}),colorD:De(ue({},_i.fromHex(16777215)),{a:1}),distortion:[1,1],fA:[1.7,9.2],fB:[8.3,2.8]};case"fresnel":return{type:"fresnel",alpha:1,visible:!0,mode:0,color:Ro.fromHexAndA(16777215,1),bias:.1,scale:1,intensity:2,factor:1};case"rainbow":return{type:"rainbow",alpha:1,visible:!0,mode:0,filmThickness:30,movement:0,wavelengths:[0,0,0],noiseStrength:0,noiseScale:1,offset:[0,0,0]};case"toon":return{type:"toon",alpha:1,visible:!0,mode:0,positioning:2,colors:[[0,0,0,1],[.5,.5,.5,1],[.5,.5,.5,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]],steps:[0,.475,.525,1,1,1,1,1,1,1],num:4,source:[0,1e3,0],isWorldSpace:!0,noiseStrength:0,noiseScale:1,shadowColor:Ro.fromHexAndA(0,0),offset:[0,0,0]};case"outline":return{type:"outline",alpha:1,visible:!0,mode:0,outlineColor:Ro.fromHexAndA(0,1),contourColor:Ro.fromHexAndA(0,1),outlineWidth:2,contourWidth:5,outlineThreshold:.4,contourThreshold:0,outlineSmoothing:0,contourFrequency:10,contourDirection:[0,1,0],positionalLines:!1,compensation:!0};case"matcap":return{type:"matcap",alpha:1,visible:!0,mode:0,texture:{image:"matcap_0",wrapping:1001,repeat:[1,1],offset:[0,0]}};case"transmission":return{type:"transmission",alpha:1,visible:!0,mode:0,thickness:10,ior:1.5,roughness:1};case"displace":return{type:"displace",displacementType:"noise",noiseType:0,scale:10,movement:1,offset:[0,0,0],intensity:8,visible:!0}}}})(Qi||(Qi={}));var Ci;(e=>{function t(c){return!c.layers.some(h=>h.data.type==="texture"&&h.data.projection!==0||h.data.type==="depth"&&!h.data.isWorldSpace||h.data.type==="noise"||h.data.type==="displace")}e.isMergable=t;function n(c){let h="";return c.layers.forEach(u=>{Object.entries(u.data).forEach(([d,p])=>{h+=`${d}${p}`,Array.isArray(p)?p.forEach(f=>h+=`${f}`):typeof p=="object"?Object.values(p).forEach(f=>{typeof f=="number"?h+=`${f.toFixed(4)}`:h+=`${f}`}):h+=`${p}`})}),h}e.getHash=n;function s(){return{layers:new Qt}}e.defaultEmptyData=s;function r(c="layer1",h="layer2"){return o("phong",c,h)}e.defaultData=r;function i(c,h){return De(ue({},c),{name:h})}e.withName=i;function o(c,h="layer1",u="layer2"){let d=new Qt;return d.push({fi:0,data:Qi.defaultData("light",c),id:h}),d.push({fi:1,data:Qi.defaultData("color"),id:u}),{layers:d}}e.defaultTwoLayerData=o;function a(c,h="phong",u="layer1",d="layer2"){let p=Qi.defaultData("texture");Object.assign(p.texture,{image:c});let f=new Qt;return f.push({fi:0,data:p,id:u}),f.push({fi:1,data:Qi.defaultData("light",h),id:d}),{layers:f}}e.defaultTwoLayerTextureData=a;function l(c,h="phong",u="layer1",d="layer2"){let p=Qi.defaultData("video");Object.assign(p.texture,{video:c});let f=new Qt;return f.push({fi:0,data:p,id:u}),f.push({fi:1,data:Qi.defaultData("light",h),id:d}),{layers:f}}e.defaultTwoLayerVideoTextureData=l})(Ci||(Ci={}));var wv;(e=>{function t(){return{points:new Qt,roundness:0,shapeHoles:[],isClosed:!1}}e.defaultData=t})(wv||(wv={}));var Sv;(e=>{function t(n){return n==="PolygonGeometry"||n==="RectangleGeometry"||n==="StarGeometry"||n==="TriangleGeometry"||n==="EllipseGeometry"}e.is2DParametricMesh=t})(Sv||(Sv={}));var Md;(e=>{function t(n){if(n==="RectangleGeometry")return{width:320,height:320,type:n,cornerRadius:[0,0,0,0],cornerType:0,depth:0,extrudeBevelSize:0,extrudeBevelSegments:1};if(n==="VectorGeometry")return{width:1,height:1,type:n,subdivisions:12,shape:wv.defaultData(),depth:0,extrudeBevelSize:0,extrudeBevelSegments:1};if(n==="BooleanGeometry")return{type:n,operation:2,width:0,height:0,depth:0,phongAngle:35};if(n==="TextGeometry")return{type:n,width:100,height:100,depth:0,horizontalAlign:1,verticalAlign:1,fontSize:16,lineHeight:1.2,letterSpacing:0,text:"",textTransform:1,font:"Roboto_regular",extrudeBevelSize:0,extrudeBevelSegments:1};throw new Error("not implemented")}e.defaultData=t})(Md||(Md={}));var KP;(e=>{function t(s){return s==="Component"||s==="Instance"}e.isComponentRelated=t;function n(s){return s==="Empty"||s==="Instance"}e.isEmptyOrComponent=n})(KP||(KP={}));var Pd;(e=>{e.identity=De(ue({},Z_.identity),{hiddenMatrix:Dd.identity});function t(r){return{position:r.position,rotation:r.rotation,scale:r.scale,hiddenMatrix:r.hiddenMatrix}}e.fromObject=t;function n(r,i){return{position:(i==null?void 0:i.position)||r.position,rotation:(i==null?void 0:i.rotation)||r.rotation,scale:(i==null?void 0:i.scale)||r.scale,hiddenMatrix:(i==null?void 0:i.hiddenMatrix)||r.hiddenMatrix}}e.merge=n;function s(r,i){return{position:Du.isEqual(r.position,i.position)?null:i.position,rotation:Du.isEqual(r.rotation,i.rotation)?null:i.rotation,scale:Du.isEqual(r.scale,i.scale)?null:i.scale,hiddenMatrix:Dd.isEqual(r.hiddenMatrix,i.hiddenMatrix)?null:i.hiddenMatrix}}e.diff=s})(Pd||(Pd={}));var i2;(e=>e.defaultData={fusedBody:!0,rigidBody:"positioned",density:1,pointMass:0,gravityScale:1,friction:.5,damping:0,restitution:.2,colliderType:"convex",enabledRotation:[!0,!0,!0],enabledTranslation:[!0,!0,!0]})(i2||(i2={}));var Zi;(e=>e.defaultData=De(ue({states:new Qt,events:new Qt,visible:!0,raycastLock:!1,physics:null},Pd.identity),{cloner:null}))(Zi||(Zi={}));var YP;(e=>e.defaultData=ue({type:"Empty"},Zi.defaultData))(YP||(YP={}));var QP;(e=>e.defaultData=ue({type:"Component"},Zi.defaultData))(QP||(QP={}));var Od;(e=>e.defaultData=ue(ue({type:"Mesh"},Zi.defaultData),r2.defaultData))(Od||(Od={}));var _v;(e=>e.defaultData=ue(ue(ue({},Zi.defaultData),Pd.identity),im.defaultData))(_v||(_v={}));var o2;(e=>{function t(n){return ue(ue({},Zi.defaultData),t2.defaultData(n))}e.defaultData=t})(o2||(o2={}));var Cv;(e=>{function t(s,r,i=0){for(;i<r.length;){let o=s?s[r[i]]:void 0;if(r.length===i+1)return o;if(o)s=o.descendants,i+=1;else return}}e.resolveWithDes=t;function n(s,r,i=0){let o=t(s,r,i);if(o){let a=Object.keys(o);if(a.length===1&&a[0]==="descendants")return}return o}e.resolve=n})(Cv||(Cv={}));var Rd;(e=>{e.rootOverrideProps=["physics"],e.compositeNonOptionalOverrideProps=["geometry"],e.compositeEntireOverrideOverrideProps=["material"];function t(s,r){return De(ue(ue({},Zi.defaultData),r),{component:s,overrides:new sr,physics:void 0,type:"Instance"})}e.ofComponent=t;function n(s){let r=Pd.fromObject(s.data);return t(s.id,r)}e.fromComponentData=n})(Rd||(Rd={}));var a2;(e=>(e.defaultCamera=ue({position:[0,0,1e3],scale:[1,1,1],rotation:[0,0,0],hiddenMatrix:Dd.identity,name:"Play Camera",visible:!0,raycastLock:!1,physics:i2.defaultData,states:new Qt,events:new Qt,cloner:null},im.defaultData),e.KeysByResetCategory={States:["states"],Events:["events"],Material:["material","materials"],Geometry:["geometry"],Position:["position"],Rotation:["rotation"],Scale:["scale"],Transform:["position","scale","rotation","hiddenMatrix"],Name:["name"],Visibility:["visible","raycastLock","flatShading","wireframe","side"],Shadows:["castShadow","receiveShadow"],Cloner:["cloner"],Physics:["physics"]},e.defaultMeshObject=De(ue(ue({name:"Rectangle"},Zi.defaultData),Od.defaultData),{geometry:Md.defaultData("RectangleGeometry"),material:Ci.defaultTwoLayerData("phong","layer1","layer2")}),e.defaultBooleanObject=De(ue(ue({name:"Boolean"},Zi.defaultData),Od.defaultData),{geometry:Md.defaultData("BooleanGeometry"),material:Ci.defaultTwoLayerData("phong","layer1","layer2")}),e.defaultTextObject=De(ue(ue({name:"Text"},Zi.defaultData),Od.defaultData),{geometry:Md.defaultData("TextGeometry"),material:Ci.defaultTwoLayerData("phong","layer1","layer2")})))(a2||(a2={}));var Pu;(e=>{function t(i,o){let a={name:o};return i.type==="Mesh"?(a.geometry={},"material"in i&&(a.material={layers:new sr}),"materials"in i&&(a.materials=i.materials.map(l=>({layers:new sr})))):Mu.is(i.type)&&(a.perspective={},a.orthographic={}),a}e.newEmpty=t;function n(i,o){if(o===void 0)return i;let a=ue({},i);return"material"in a&&"material"in o&&o.material&&(a.material=uv(a.material,l=>{if(typeof l!="string")for(let[c,h]of Object.entries(o.material.layers)){let u=l.layers.data(c);u&&Qi.patch(u,h)}}).data),a.materials&&o.materials&&(a.materials=uv(a.materials,l=>{var c,h;for(let u=0;u<a.materials.length;u++){let d=o.materials[u];if(typeof d!="string")for(let[p,f]of Object.entries(d.layers)){let g=(h=(c=l[u])==null?void 0:c.layers)==null?void 0:h.data(p);g&&Qi.patch(g,f)}}}).data),a}function s(i,o){let a,l=[],c={orthographic:0,perspective:0,geometry:0};function h(u,d){for(let[f,g]of Object.entries(d.layers)){let p=g,{texture:m}=p,y=qh(p,["texture"]);if(m!==void 0&&Object.keys(m).length>0){let v={path:[...u,"layers",f,"texture"],props:m,type:0};l.push(v)}if(Object.keys(y).length>0){let v={path:[...u,"layers",f],props:y,type:0};l.push(v)}}}for(let[u,d]of Object.entries(o))if(u!=="name")if(u==="cloner")l.push(...J_.toOps(d,["cloner"]));else if(u==="material")h(["material"],d);else if(u==="materials")for(let[p,f]of Object.entries(d))h(["materials",p],f);else if(c[u]===0){if(Object.keys(d).length>0){let p={path:[u],props:d,type:0};l.push(p)}}else a===void 0&&(a={path:[],props:{},type:0},l.push(a)),a.props[u]=d;return l}e.toOps=s;function r(i,o){var l,c;if(o===void 0)return i;let a=ue({},i);if(Object.assign(a,Pd.merge(a,o)),Mu.is(i.type)){a.orthographic=ue({},a.orthographic),a.perspective=ue({},a.perspective);let h=o;((l=h.orthographic)==null?void 0:l.zoom)!==void 0&&(a.orthographic.zoom=h.orthographic.zoom),((c=h.perspective)==null?void 0:c.zoom)!==void 0&&(a.perspective.zoom=h.perspective.zoom),h.isUpVectorFlipped!==void 0&&(a.isUpVectorFlipped=h.isUpVectorFlipped),h.targetOffset!==void 0&&(a.targetOffset=h.targetOffset)}else if(i.type==="Mesh")o.geometry&&(a.geometry=ue({},a.geometry),Object.assign(a.geometry,o.geometry)),(o.material||o.materials)&&(a=n(a,o)),a.cloner&&"cloner"in o&&Object.assign(a,{cloner:cc.merge(a.cloner,o.cloner)});else if(i.type==="Empty")a.cloner&&"cloner"in o&&Object.assign(a,{cloner:cc.merge(a.cloner,o.cloner)});else if(e2.is(i.type)){let h=o;h.intensity!==void 0&&(a.intensity=h.intensity),h.color!==void 0&&(typeof h.color=="string"?a.color=h.color:a.color=_i.clone(h.color))}return a}e.patch=r})(Pu||(Pu={}));var Tv;(e=>e.defaultData={enabled:!1,useBackgroundColor:!1,color:_i.white,near:.1,far:2e3})(Tv||(Tv={}));var Ev;(e=>e.defaultData={enablePan:!0,enableZoom:!0,enableRotate:!0,enableDamping:!0,rotationLimitsMode:0,rotationVerticalOffset:{min:Math.PI/4,max:Math.PI/4},rotationHorizontalOffset:{min:Math.PI/4,max:Math.PI/4},rotationSoftLimit:2,panLimitsMode:0,panVerticalOffset:{min:250,max:250},panHorizontalOffset:{min:250,max:250},panSoftLimit:2,zoomLimitsEnabled:!1,zoomLimits:{min:.1,max:2},autoRotate:!1,autoRotateSpeed:2,autoRotateClockwise:!0,hoverRotatePanMode:0,hoverRotatePanStrength:20,isTouchZoom:!0,orbitTouches:2,panTouches:3,resetHoverEffectOnPointerLeave:!0,autoZoom:!1})(Ev||(Ev={}));var Ld;(e=>e.defaultData={orbitControls:Ev.defaultData,playCamera:null,withBackground:!0,preventScroll:!1,hideCursor:!1,settings:{image:{format:"jpg",ratio:1},video:{format:"mp4",imageFormat:"jpg",fps:30,mbps:80,ratio:typeof window<"u"?Math.floor(window.devicePixelRatio):1,stopMode:"manual",duration:5e3},web:{compress:!0,preset:1,preload:!0}},stopRaycast:!0,joystickSizeAndXYOffset:Array(12).fill(0).map((t,n)=>{let s=0,r=0;return n<5?r=-30:n<10&&(r=30),n===0||n===10||n===5?s=30:(n===4||n===11||n===9)&&(s=-30),[120,[s,r],"show"]}),gameControlObject:null})(Ld||(Ld={}));function Fd(e,t){return Object.setPrototypeOf(e,t),e}var sie=()=>typeof window>"u"?!1:window.navigator.userAgent.toLowerCase().includes(" electron/"),rie=()=>typeof window>"u"?!1:window.navigator.platform.toUpperCase().includes("MAC"),iie=()=>typeof window>"u"?!1:/iPad|iPhone|iPod/.test(window.navigator.userAgent)||Av&&"ontouchend"in document,oie=()=>typeof window>"u"?!1:window.navigator.userAgent.toLowerCase().indexOf("firefox")>-1,aie=()=>typeof window>"u"?!1:"ontouchstart"in window||navigator.maxTouchPoints>0,lie=()=>{if(typeof window>"u")return!1;let e=navigator.userAgent,t=navigator.vendor;return/Safari/i.test(e)&&/Apple Computer/.test(t)},cie=()=>{if(typeof window>"u")return null;let e=navigator.userAgent.match(/Version\/(\d+\.\d)/);return e&&e[1]};sie();var Av=rie(),l2=iie(),uie=oie(),Br=aie(),Iv=lie(),Nv=Number(cie());function ZP(e){return Array.isArray(e)?e:[e]}function hie(e,t){let n=0;for(;n<e.length&&n<t.length;){if(e[n]<t[n])return-1;if(e[n]>t[n])return 1;n+=1}return n!==t.length?-1:n!==e.length?1:0}function kv(e){return Av?e.metaKey:e.ctrlKey}var Pt=[],Dv={},am={},Mv={};function JP(e){Pt.includes(e)||Pt.push(e)}function $d(e){delete Dv[e.pointerId];for(let t=0;t<Pt.length;t++)if(Pt[t].pointerId===e.pointerId){Pt.splice(t,1);break}}function die(){Pt.splice(0,Pt.length)}function Pv(e){if(e.pointerType!=="touch")return;let t=Dv[e.pointerId];t===void 0&&(t={x:0,y:0},Dv[e.pointerId]=t),t.x=e.pageX,t.y=e.pageY}function c2(e){let t=e.pointerId===Pt[0].pointerId?Pt[1]:Pt[0];return Dv[t.pointerId]}function eO(e){am[e.key]=!0,Mv[e.key]=Mv[e.key]===void 0?1:Mv[e.key]+1}function tO(e){if(Av&&am.Meta)for(let t in am)am[t]=!1;else am[e.key]=!1;Mv={}}function pie(e){e.addEventListener("pointerdown",JP,!0),e.addEventListener("pointerdown",Pv,!0),e.addEventListener("pointermove",Pv,!0),e.addEventListener("pointerup",$d,!0),e.addEventListener("pointercancel",$d,!0),e.addEventListener("pointerleave",$d,!0),window.addEventListener("keydown",eO,!0),window.addEventListener("keyup",tO,!0)}function fie(e){e.removeEventListener("pointerdown",JP,!0),e.removeEventListener("pointerdown",Pv,!0),e.removeEventListener("pointermove",Pv,!0),e.removeEventListener("pointerup",$d,!0),e.removeEventListener("pointercancel",$d,!0),e.removeEventListener("pointerleave",$d,!0),window.removeEventListener("keydown",eO,!0),window.removeEventListener("keyup",tO,!0)}var Ti;(e=>e.defaultData={ambientLight:{enabled:!0,color:{r:.8274509803921568,g:.8274509803921568,b:.8274509803921568},intensity:.75,depth:100,groundColor:{r:.5098039215686274,g:.5098039215686274,b:.5098039215686274},softShadows:!0,softShadowQuality:"low"},usePhysics:!1,gravity:-10,pixelsPerMeter:200,skinWidthRelative:.02,stepThreshRelative:.3,slopeThresh:65})(Ti||(Ti={}));var u2;(e=>{e.TRASH_CAN_ID="830a2708-8ed9-49cf-a68e-085299892222";function t(r={withLight:!0,withSquare:!0}){let i=new ei,o=a2.defaultMeshObject;return r.withLight===!0&&i.push({fi:-1,data:De(ue({},o2.defaultData("DirectionalLight")),{position:[200,300,300],name:"Directional Light",intensity:.7}),id:"830a2708-8ed9-49cf-a68e-085299899103",children:[]}),r.withSquare===!0&&i.push({fi:1,id:"7ba78968-2a55-48f2-b14c-5191da3e075e",data:o,children:[]}),i}e.defaultData={backgroundColor:Ro.fromHexAndA(1908256,1),postprocessing:om.defaultData,fog:Tv.defaultData,objects:t(),environment:Ti.defaultData,publish:Ld.defaultData},e.emptyData=function(r){return{backgroundColor:Ro.fromHexAndA(1908256,1),postprocessing:om.defaultData,fog:Tv.defaultData,objects:r?t(r):new ei,environment:Ti.defaultData,publish:Ld.defaultData}};function n(r){return De(ue({},e.defaultData),{objects:Fd(r,ei.prototype)})}e.withObjs=n;function s(r,i){return n([{id:r,data:i,children:[],fi:0}])}e.withObj=s})(u2||(u2={}));var Ov;(e=>{function t(){let s={};return s["89b10010-844c-11ec-a8a3-0242ac120002"]={r:.5,g:.5,b:.5,a:1,name:"Default Color"},Fd(s,Ps.prototype)}e.defaultColors=t;function n(){return{materials:new Ps,images:new Ps,videos:new Ps,colors:new Ps,audios:new Ps,fonts:new Ps,penumbraSize:[.5,.5,.5]}}e.emptyData=n})(Ov||(Ov={}));function nO(e){e.layers.forEach(t=>{if(t.type==="depth"&&t.colorA!==void 0){let n=t.colorA,s=t.colorB,r=[[n.r,n.g,n.b,n.a],[s.r,s.g,s.b,s.a]],i=[0,1];for(let a=2;a<10;a++)r.push(r[1]),i.push(1);let o=De(ue({},rv(xr(t),"type","visible","isVector","isWorldSpace","origin","alpha","mode")),{near:Math.max(0,t.near),far:Math.max(0,t.far),colors:r,steps:i,num:2,direction:[1,0,0],smooth:!1,gradientType:1});Object.assign(t,o)}else if(t.type==="depth"&&t.gradientType===1&&(t.near<0||t.far<0)){let n=De(ue({},xr(t)),{near:Math.max(t.near,0),far:Math.max(t.far,0)});Object.assign(t,n)}})}function Rv(e,t){Object.values(e.shared.materials).forEach(n=>t(n))}function Lv(e,t){e.scene.objects.traverse((n,s)=>{"materials"in s?s.materials.forEach(r=>{typeof r!="string"&&t(r)}):"material"in s&&typeof s.material!="string"&&t(s.material)})}function mie(e){Object.assign(e.scene.publish,{orbitControls:ue(ue({},Ev.defaultData),xr(e.scene.publish.orbitControls))})}function gie(e){Object.assign(e.scene.publish.settings,{video:ue(ue({},Ld.defaultData.settings.video),xr(e.scene.publish.settings.video))})}function yie(e){function t(n){if(n.layers){for(let s of Object.values(n.layers))if(s){for(let[r,i]of Object.entries(s))if((XP.includes(r)||typeof i=="boolean")&&delete s[r],r==="texture")for(let[o,a]of Object.entries(i))(nie.includes(o)||typeof a=="boolean")&&delete i[o]}}}e.scene.objects.traverse((n,s)=>{s.states.forEach(r=>{let i=r;i.material?t(i.material):i.materials&&i.materials.forEach(o=>{t(o)})})})}function vie(e){e.scene.publish.withBackground=!0}function xie(e){e.scene.publish.settings.web={compress:!0,preload:!0,preset:1}}function bie(e){e.scene.objects.traverse((t,n)=>{let s=n.cloner;s&&(s.radial.scale=s.radial.scale.map(r=>r+1),s.linear.scale=s.linear.scale.map(r=>r+1))})}function wie(e){e.scene.objects.traverse((t,n)=>{let s=n.geometry;s&&(s.type==="DodecahedronGeometry"||s.type==="IcosahedronGeometry")&&(s.detail=Math.round(s.detail))})}function Sie(e){e.scene.objects.traverse((t,n)=>{let s=e.scene.objects.unproxy().parent(t);if(s){let r=xr(e.scene.objects.data(s));r&&r.type==="Mesh"&&r.geometry.type==="BooleanGeometry"&&n.type==="Mesh"&&(n.visible=xr(n).booleanExclude!==!0)}})}function _ie(e){e.scene.objects.traverse((t,n)=>{if(n.type==="Mesh"){let s=n;n.geometry.type==="NonParametricGeometry"?s.material!==void 0&&delete s.material:s.materials!==void 0&&delete s.materials}})}function Cie(e){function t(s){Object.setPrototypeOf(s,sr.prototype),s.texture&&Object.setPrototypeOf(s.texture,sr.prototype)}function n(s){Object.setPrototypeOf(s,sr.prototype);for(let r in s)t(s[r])}e.scene.objects.traverse((s,r)=>{r.states.forEach(i=>{let o=i;if(o.material){let a=xr(o.material).layers;n(a),o.material.layers=a}if(o.materials)for(let a=0;a<o.materials.length;a++){let l=o.materials[a],c=xr(l).layers;n(c),l.layers=c}})})}function sO(e){e.layers===void 0&&Object.assign(e,Ci.defaultTwoLayerData("lambert"))}function h2(e){!e.layers||e.layers.forEach(t=>{if(t.type==="depth"&&t.colors.length===10){let n=[...t.colors];n.push(t.colors[9]);let s=[...t.steps];s.push(t.steps[9]);let r=De(ue({},xr(t)),{colors:n,steps:s});Object.assign(t,r)}})}function Tie(e){e.scene.objects.traverse((t,n)=>{n.type==="Mesh"&&(n.geometry.type==="BooleanGeometry"||n.geometry.type==="SubdivGeometry")&&(n.geometry.phongAngle=35)})}function rO(e){e.scene.objects.traverse((t,n)=>{"materials"in n?n.materials.forEach(s=>{typeof s!="string"&&h2(s)}):"material"in n&&typeof n.material!="string"&&h2(n.material)}),Object.values(e.shared.materials).forEach(t=>h2(t))}function Eie(e){e.scene.environment.ambientLight.softShadows=!1,e.scene.environment.ambientLight.softShadowQuality="low",e.scene.objects.traverse((t,n)=>{(n.type==="DirectionalLight"||n.type==="SpotLight")&&(n.shadowResolution=1024,n.shadowRadius=1,n.depth=1e5)}),e.shared.penumbraSize=new Array(5).fill(.5)}function Aie(e){e.shared.audios=Fd({},Ps.prototype)}function Iie(e){e.shared.videos=Fd({},Ps.prototype)}function Nie(e){let t=e.shared.materials;Object.entries(t).forEach(([n,s])=>{if(!s.layers){let r={name:"Untitled Material",layers:[{fi:0,data:{type:"light",category:"phong",alpha:.6,visible:!0,mode:0,specular:{r:.2,g:.2,b:.2},shininess:5},id:"layer1"},{fi:1,data:{type:"color",alpha:1,visible:!0,mode:0,color:{r:.2823529411764706,g:.2823529411764706,b:.30196078431372547}},id:"layer2"}]};Object.assign(t,{[n]:r})}})}function kie(e){Object.entries(xr(e.shared.images)).filter(t=>t[1].asset===!1).map(t=>t[0]).forEach(t=>{delete e.shared.images[t]}),Object.entries(xr(e.shared.audios)).filter(t=>t[1].asset===!1).map(t=>t[0]).forEach(t=>{delete e.shared.audios[t]})}function Die(e){e.scene.publish.settings.web.preload=!1}function iO(e){e.layers&&e.layers.forEach(t=>{t.type==="depth"&&t.num!==void 0&&(t.colors=t.colors.slice(0,t.num),t.steps=t.steps.slice(0,t.num),delete t.num)})}function Mie(e){e.shared.fonts=Fd({},Ps.prototype)}function Pie(e){return e.replace(".typeface","").replace(/optimer/gi,"open sans").replace("space_mono","space mono").replace(/alma_mono/gi,"varela round").replace(/droid_sans_mono/gi,"noto sans mono").replace(/droid_sans|gentilis|gnomon_(simple|foreground)|helvetiker/gi,"roboto").replace(/droid_serif/gi,"roboto slab").replace("_sans"," sans").replace("crimson_text","crimson text").replace("medium_medium","medium").replace("fatface_fatface","fatface").replace("100hairline","thin").replace("200thin","extralight").replace("300light","light").replace("500medium","medium").replace("600semi","semibold").replace("800heavy","extrabold").replace("900black","black").replace(/bodoni_(11|16|24|36|48|72|96)([^_])/gi,"bodoni_$1_$2").replace(/bodoni_(11|16|24|36|48|72|96)/gi,"bodoni moda").replace(/(thin|hairline)(_regular)?/gi,"100").replace(/(extra|ultra)light(_regular)?/gi,"200").replace(/light(_regular)?/gi,"300").replace(/_book|_normal|_roman/gi,"_regular").replace(/medium(_regular)?/gi,"500").replace(/(semi|demi)bold(_regular)?/gi,"600").replace(/(extra|ultra)bold(_regular)?/gi,"800").replace(/bold(_regular)?/gi,"700").replace(/(black|heavy|fatface)(_regular)?/gi,"900").replace(/([1-9]00)_italic/gi,"$1italic").replace(/regularitalic/gi,"italic").replace(/regularitalic/gi,"italic").split(" ").map(t=>t.charAt(0).toUpperCase()+t.slice(1)).join(" ")}function Oie(e){let t=[];e.scene.objects.traverse((n,s)=>{let r=s;if(r.type==="TextFrame"){let i=Ci.defaultTwoLayerData("phong"),o=typeof r.color=="string"?e.shared.colors[r.color]:r.color;i.layers[1].data.color={r:o.r,g:o.g,b:o.b},i.layers[1].data.alpha=r.alpha;let a=Pie(r.font);e.shared.fonts[a]===void 0&&(e.shared.fonts[a]={name:a});let l=De(ue(ue({name:r.name},Zi.defaultData),Od.defaultData),{flatShading:!1,wireframe:!1,geometry:De(ue({},Md.defaultData("TextGeometry")),{width:r.width,height:r.height,font:a,depth:0,horizontalAlign:r.horizontalAlign,verticalAlign:r.verticalAlign,fontSize:r.fontSize*1.40625,lineHeight:r.lineHeight/1.40625,letterSpacing:r.letterSpacing-1,text:r.text,textTransform:r.textTransform,extrudeBevelSize:0,extrudeBevelSegments:1}),material:i,states:xr(r.states),events:xr(r.events),visible:r.visible,raycastLock:r.raycastLock,position:r.position,rotation:r.rotation,scale:r.scale,hiddenMatrix:r.hiddenMatrix}),c=xr(e.scene.objects).parent(n);e.scene.objects.insertAfter(c!=null?c:null,n,[{id:n+"new",data:l,children:[]}]),t.push(n)}}),t.forEach(n=>{e.scene.objects.delete(n)})}function Rie(e){let t={0:"MouseDown",1:"MouseUp",2:"MouseHover",5:"KeyDown",6:"KeyUp",7:"Start",9:"LookAt",10:"Follow",11:"Scroll",12:"Audio",13:"GameControl"};e.scene.objects.traverse((n,s)=>{s.events.forEach(r=>{if(t[Number(r.type)])if(Object.assign(r,{type:t[Number(r.type)]}),r.type==="Audio"&&"audioEvent"in r&&(Object.assign(r,{playAudio:r.audioEvent}),delete r.audioEvent),r.type==="GameControl")Object.assign(r,{gameActions:{idle:new Qt,move:new Qt,jump:new Qt}});else{let i=new Qt;Object.assign(r,{actions:i}),(r.type==="MouseDown"||r.type==="MouseUp"||r.type==="KeyDown"||r.type==="KeyUp")&&"url"in r&&i.push({fi:0,id:Kt.generateUUID(),data:{type:"Link",url:r.url,delay:0}}),"targets"in r&&(r.targets.forEach((o,a,l)=>{let c={state:void 0,repeat:0,delay:0,delayDirection:void 0,direction:"normal",duration:0,easing:4},h={easing:o.easing,duration:o.duration};o.easing===6?Object.assign(h,rv(o,"mass","stiffness","damping","velocity")):o.easing===5&&Object.assign(h,{control1:ue({},o.control1),control2:ue({},o.control2)});let u={repeat:o.repeat?-1:0,delay:o.delay,delayDirection:o.delayDirection,direction:o.cycle&&o.rewind?"pingpong-rewind":o.cycle?"pingpong":"normal"},d=ue(ue({state:o.state},u),h),p={allowSlerp:!0,type:"Transition",object:o.object,repeat:0,delay:0,delayDirection:void 0,direction:"normal",tweens:new Qt({fi:0,id:Kt.generateUUID(),data:c},{fi:1,id:Kt.generateUUID(),data:d})};i.push({fi:l,id:a,data:p})}),delete r.targets)}})})}function Lie(e){e.scene.objects.traverse((t,n)=>{function s(r,i){var l;let o=new Qt,a=[];if(n.events.forEach((c,h,u)=>{if(c.type==="Audio"&&c.trigger===i){let d;a.push(h),c.interaction==="play"?d=De(ue({},rv(c,"interaction","audio","delay","volume","loop")),{triggerAfter:"after"in c?c.after:void 0,toggle:"after"in c?c.toggle:void 0,type:"Audio"}):(c.interaction==="pause"||c.interaction==="stop")&&(d=De(ue({},rv(c,"interaction","delay","object","playAudio")),{type:"Audio"})),d&&o.push({fi:u,id:h,data:d})}}),a.forEach(c=>n.events.delete(c)),o.length){let c=(l=n.events.find(h=>h.type===r))==null?void 0:l.data;c?"actions"in c&&c.actions.insertBefore(null,o):n.events.insertBefore(null,[{id:Kt.generateUUID(),data:{type:r,actions:o}}])}}s("Start","start"),s("MouseDown","mouseDown"),s("MouseUp","mouseUp"),s("KeyDown","keyDown"),s("KeyUp","keyUp")})}function oO(e){var n;let t=(n=e.layers.find(s=>s.type==="light"))==null?void 0:n.data;if((t==null?void 0:t.category)==="basic"){let s=Qi.defaultData("light","phong"),r=t;Object.assign(r,s),r.visible=!1}}function aO(e){Rv(e,oO),Lv(e,oO)}function Fie(e){e.scene.objects.traverse((t,n)=>{n.type==="Mesh"&&n.geometry.type==="SubdivGeometry"&&(n.geometry.scaleBaked||(n.geometry.scaleBaked=[1,1,1]))})}function $ie(e){e.scene.objects.traverse((t,n)=>{(n.type==="Empty"||n.type==="Mesh")&&n.cloner&&!n.cloner.randomnessObject&&!n.cloner.toObject&&!n.cloner.randomness&&(n.cloner=De(ue({},n.cloner),{toObject:{object:"",spreadType:"random",scale:[0,0,0],rotation:[0,0,0],position:[0,0,0],axis:"x",seed:0,count:99,align:"normal"},randomness:!1,randomnessObject:{strength:100,scale:[0,0,0],rotation:[0,0,0],position:[0,0,0],movement:1,seed:0,freqScale:10,noiseType:"perlin"}}))})}function Bie(e){e.scene.objects.traverse((t,n)=>{n.type==="Mesh"&&n.geometry.type==="NonParametricGeometry"&&!("material"in n)&&!("materials"in n)&&(n.material=Ci.defaultTwoLayerData("phong"))})}function zie(e){e.scene.publish.orbitControls.autoZoom===void 0&&(e.scene.publish.orbitControls.autoZoom=!1),e.scene.objects.traverse((t,n)=>{(n.type==="OrthographicCamera"||n.type==="PerspectiveCamera")&&(n.orthographic.autoZoom===void 0&&(n.orthographic.autoZoom=!1),n.orthographic.autoZoomFrustumSize===void 0&&(n.orthographic.autoZoomFrustumSize=790))})}var lO=31;function Uie(e){var n;let t=(n=e.schema)!=null?n:0;t!==lO&&(console.warn("updating from ",t,"to ",lO),t<1&&(Lv(e,nO),Rv(e,nO),e.schema=1),t<2&&(mie(e),e.schema=2),t<3&&(yie(e),e.schema=3),t<4&&(vie(e),e.schema=4),t<5&&(xie(e),e.schema=5),t<6&&(bie(e),e.schema=6),t<7&&(wie(e),e.schema=7),t<8&&(e.schema=8),t<9&&(rO(e),e.schema=9),t<10&&(Tie(e),e.schema=10),t<11&&(Eie(e),e.schema=11),t<12&&(rO(e),e.schema=12),t<13&&(Aie(e),e.schema=13),t<14&&(Nie(e),e.schema=14),t<15&&(kie(e),e.schema=15),t<16&&(Die(e),e.schema=16),t<17&&(Lv(e,iO),Rv(e,iO),e.schema=17),t<18&&(Lv(e,sO),Rv(e,sO),e.schema=18),t<19&&(gie(e),e.schema=19),t<20&&(Mie(e),Oie(e),e.schema=20),t<21&&(Rie(e),Lie(e),e.schema=21),t<22&&(aO(e),e.schema=22),t<23&&(Fie(e),e.schema=23),t<24&&($ie(e),e.schema=24),(t<25||e.shared.videos===void 0)&&(Iie(e),t<25&&(e.schema=25)),t<26&&(Sie(e),e.schema=26),t<27&&(_ie(e),e.schema=27),t<28&&(aO(e),e.schema=28),t<29&&(Cie(e),e.schema=29),t<30&&(Bie(e),e.schema=30),t<31&&(zie(e),e.schema=31))}var d2;(e=>e.emptyImage={data:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII="})(d2||(d2={}));function Bd(e,t=!1){let n=e[0].index!==null,s=new Set(Object.keys(e[0].attributes)),r=new Set(Object.keys(e[0].morphAttributes)),i={},o={},a=e[0].morphTargetsRelative,l=new It,c=0;for(let h=0;h<e.length;++h){let u=e[h],d=0;if(n!==(u.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(let p in u.attributes){if(!s.has(p))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+'. All geometries must have compatible attributes; make sure "'+p+'" attribute exists among all geometries, or in none of them.'),null;i[p]===void 0&&(i[p]=[]),i[p].push(u.attributes[p]),d++}if(d!==s.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". Make sure all geometries have the same number of attributes."),null;if(a!==u.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(let p in u.morphAttributes){if(!r.has(p))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+".  .morphAttributes must be consistent throughout all geometries."),null;o[p]===void 0&&(o[p]=[]),o[p].push(u.morphAttributes[p])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(u.userData),t){let p;if(n)p=u.index.count;else if(u.attributes.position!==void 0)p=u.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". The geometry must have either an index or a position attribute"),null;l.addGroup(c,p,h),c+=p}}if(n){let h=0,u=[];for(let d=0;d<e.length;++d){let p=e[d].index;for(let f=0;f<p.count;++f)u.push(p.getX(f)+h);h+=e[d].attributes.position.count}l.setIndex(u)}for(let h in i){let u=cO(i[h]);if(!u)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+h+" attribute."),null;l.setAttribute(h,u)}for(let h in o){let u=o[h][0].length;if(u===0)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[h]=[];for(let d=0;d<u;++d){let p=[];for(let g=0;g<o[h].length;++g)p.push(o[h][g][d]);let f=cO(p);if(!f)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+h+" morphAttribute."),null;l.morphAttributes[h].push(f)}}return l}function cO(e){let t,n,s,r=0;for(let a=0;a<e.length;++a){let l=e[a];if(l.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(t===void 0&&(t=l.array.constructor),t!==l.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(n===void 0&&(n=l.itemSize),n!==l.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(s===void 0&&(s=l.normalized),s!==l.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;r+=l.array.length}let i=new t(r),o=0;for(let a=0;a<e.length;++a)i.set(e[a].array,o),o+=e[a].array.length;return new Lt(i,n,s)}var p2;(e=>(e.defaultColliderData={type:"capsule",height:200,radius:50,position:[0,0,0],rotation:[0,0,0]},e.defaultDataThirdPerson={moveMode:"walk",speedTranslate:1e3,speedRotate:100,rotationMode:"normal",rotBy:"keys",rotByTouch:"drag",delayPos:[.3,.3],delayRot:[.3,.3],keyAssignments:[["moveNegZ","W"],["moveNegX","A"],["movePosZ","S"],["movePosX","D"],["rotPosX","\u25B2"],["rotPosY","\u25C0"],["rotNegX","\u25BC"],["rotNegY","\u25B6"],["jump","Space"]],touchControl:!0,joystickPosLoc:5,joystickRotLoc:11,jumpTouchButtonLoc:9,collider:e.defaultColliderData,colliderHelperVisible:!0,collisionEnabled:!0,jumpPower:100,resetYPosition:-3e3,alignToGround:!1,autoOrientMove:!0,orientWith:"camera",orientMode:"radial",delayPosCamera:.3,delayRotCamera:.3,camera:"",cameraXAxis:"Limit",cameraYAxis:"Free",cameraRotXLimits:[0,Math.PI/2],cameraRotYLimits:[-Math.PI/2,Math.PI/2],gameActions:{idle:new Qt,move:new Qt,jump:new Qt}}))(p2||(p2={}));var Vie=Math.pow(2,-24),Fv=class{constructor(){}};function _a(e,t,n){return n.min.x=t[e],n.min.y=t[e+1],n.min.z=t[e+2],n.max.x=t[e+3],n.max.y=t[e+4],n.max.z=t[e+5],n}function uO(e){let t=-1,n=-1/0;for(let s=0;s<3;s++){let r=e[s+3]-e[s];r>n&&(n=r,t=s)}return t}function hO(e,t){t.set(e)}function dO(e,t,n){let s,r;for(let i=0;i<3;i++){let o=i+3;s=e[i],r=t[i],n[i]=s<r?s:r,s=e[o],r=t[o],n[o]=s>r?s:r}}function $v(e,t,n){for(let s=0;s<3;s++){let r=t[e+2*s],i=t[e+2*s+1],o=r-i,a=r+i;o<n[s]&&(n[s]=o),a>n[s+3]&&(n[s+3]=a)}}function lm(e){let t=e[3]-e[0],n=e[4]-e[1],s=e[5]-e[2];return 2*(t*n+n*s+s*t)}function Gie(e,t){if(!e.index){let n=e.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,r;n>65535?r=new Uint32Array(new s(4*n)):r=new Uint16Array(new s(2*n)),e.setIndex(new Lt(r,1));for(let i=0;i<n;i++)r[i]=i}}function Wie(e){if(!e.groups||!e.groups.length)return[{offset:0,count:e.index.count/3}];let t=[],n=new Set;for(let r of e.groups)n.add(r.start),n.add(r.start+r.count);let s=Array.from(n.values()).sort((r,i)=>r-i);for(let r=0;r<s.length-1;r++){let i=s[r],o=s[r+1];t.push({offset:i/3,count:(o-i)/3})}return t}function f2(e,t,n,s,r=null){let i=1/0,o=1/0,a=1/0,l=-1/0,c=-1/0,h=-1/0,u=1/0,d=1/0,p=1/0,f=-1/0,g=-1/0,m=-1/0,y=r!==null;for(let v=t*6,b=(t+n)*6;v<b;v+=6){let x=e[v+0],w=e[v+1],S=x-w,C=x+w;S<i&&(i=S),C>l&&(l=C),y&&x<u&&(u=x),y&&x>f&&(f=x);let _=e[v+2],T=e[v+3],E=_-T,A=_+T;E<o&&(o=E),A>c&&(c=A),y&&_<d&&(d=_),y&&_>g&&(g=_);let D=e[v+4],O=e[v+5],P=D-O,L=D+O;P<a&&(a=P),L>h&&(h=L),y&&D<p&&(p=D),y&&D>m&&(m=D)}s[0]=i,s[1]=o,s[2]=a,s[3]=l,s[4]=c,s[5]=h,y&&(r[0]=u,r[1]=d,r[2]=p,r[3]=f,r[4]=g,r[5]=m)}function Hie(e,t,n,s){let r=1/0,i=1/0,o=1/0,a=-1/0,l=-1/0,c=-1/0;for(let h=t*6,u=(t+n)*6;h<u;h+=6){let d=e[h+0];d<r&&(r=d),d>a&&(a=d);let p=e[h+2];p<i&&(i=p),p>l&&(l=p);let f=e[h+4];f<o&&(o=f),f>c&&(c=f)}s[0]=r,s[1]=i,s[2]=o,s[3]=a,s[4]=l,s[5]=c}function jie(e,t,n,s,r){let i=n,o=n+s-1,a=r.pos,l=r.axis*2;for(;;){for(;i<=o&&t[i*6+l]<a;)i++;for(;i<=o&&t[o*6+l]>=a;)o--;if(i<o){for(let c=0;c<3;c++){let h=e[i*3+c];e[i*3+c]=e[o*3+c],e[o*3+c]=h;let u=t[i*6+c*2+0];t[i*6+c*2+0]=t[o*6+c*2+0],t[o*6+c*2+0]=u;let d=t[i*6+c*2+1];t[i*6+c*2+1]=t[o*6+c*2+1],t[o*6+c*2+1]=d}i++,o--}else return i}}var xl=32,qie=(e,t)=>e.candidate-t.candidate,uc=new Array(xl).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Bv=new Float32Array(6);function Xie(e,t,n,s,r,i){let o=-1,a=0;if(i===0)o=uO(t),o!==-1&&(a=(t[o]+t[o+3])/2);else if(i===1)o=uO(e),o!==-1&&(a=Kie(n,s,r,o));else if(i===2){let l=lm(e),c=1.25*r,h=s*6,u=(s+r)*6;for(let d=0;d<3;d++){let p=t[d],f=(t[d+3]-p)/xl;if(r<xl/4){let g=[...uc];g.length=r;let m=0;for(let v=h;v<u;v+=6,m++){let b=g[m];b.candidate=n[v+2*d],b.count=0;let{bounds:x,leftCacheBounds:w,rightCacheBounds:S}=b;for(let C=0;C<3;C++)S[C]=1/0,S[C+3]=-1/0,w[C]=1/0,w[C+3]=-1/0,x[C]=1/0,x[C+3]=-1/0;$v(v,n,x)}g.sort(qie);let y=r;for(let v=0;v<y;v++){let b=g[v];for(;v+1<y&&g[v+1].candidate===b.candidate;)g.splice(v+1,1),y--}for(let v=h;v<u;v+=6){let b=n[v+2*d];for(let x=0;x<y;x++){let w=g[x];b>=w.candidate?$v(v,n,w.rightCacheBounds):($v(v,n,w.leftCacheBounds),w.count++)}}for(let v=0;v<y;v++){let b=g[v],x=b.count,w=r-b.count,S=b.leftCacheBounds,C=b.rightCacheBounds,_=0;x!==0&&(_=lm(S)/l);let T=0;w!==0&&(T=lm(C)/l);let E=1+1.25*(_*x+T*w);E<c&&(o=d,c=E,a=b.candidate)}}else{for(let y=0;y<xl;y++){let v=uc[y];v.count=0,v.candidate=p+f+y*f;let b=v.bounds;for(let x=0;x<3;x++)b[x]=1/0,b[x+3]=-1/0}for(let y=h;y<u;y+=6){let v=~~((n[y+2*d]-p)/f);v>=xl&&(v=xl-1);let b=uc[v];b.count++,$v(y,n,b.bounds)}let g=uc[xl-1];hO(g.bounds,g.rightCacheBounds);for(let y=xl-2;y>=0;y--){let v=uc[y],b=uc[y+1];dO(v.bounds,b.rightCacheBounds,v.rightCacheBounds)}let m=0;for(let y=0;y<xl-1;y++){let v=uc[y],b=v.count,x=v.bounds,w=uc[y+1].rightCacheBounds;b!==0&&(m===0?hO(x,Bv):dO(x,Bv,Bv)),m+=b;let S=0,C=0;m!==0&&(S=lm(Bv)/l);let _=r-m;_!==0&&(C=lm(w)/l);let T=1+1.25*(S*m+C*_);T<c&&(o=d,c=T,a=v.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${i} used.`);return{axis:o,pos:a}}function Kie(e,t,n,s){let r=0;for(let i=t,o=t+n;i<o;i++)r+=e[i*6+s*2];return r/n}function Yie(e,t){let n=e.attributes.position,s=n.array,r=e.index.array,i=r.length/3,o=new Float32Array(i*6),a=n.offset||0,l=3;n.isInterleavedBufferAttribute&&(l=n.data.stride);for(let c=0;c<i;c++){let h=c*3,u=c*6,d=r[h+0]*l+a,p=r[h+1]*l+a,f=r[h+2]*l+a;for(let g=0;g<3;g++){let m=s[d+g],y=s[p+g],v=s[f+g],b=m;y<b&&(b=y),v<b&&(b=v);let x=m;y>x&&(x=y),v>x&&(x=v);let w=(x-b)/2,S=g*2;o[u+S+0]=b+w,o[u+S+1]=w+(Math.abs(b)+w)*Vie,b<t[g]&&(t[g]=b),x>t[g+3]&&(t[g+3]=x)}}return o}function Qie(e,t){function n(y){d&&d(y/p)}function s(y,v,b,x=null,w=0){if(!f&&w>=l&&(f=!0,c&&(console.warn(`MeshBVH: Max depth of ${l} reached when generating BVH. Consider increasing maxDepth.`),console.warn(e))),b<=h||w>=l)return n(v+b),y.offset=v,y.count=b,y;let S=Xie(y.boundingData,x,o,v,b,u);if(S.axis===-1)return n(v+b),y.offset=v,y.count=b,y;let C=jie(a,o,v,b,S);if(C===v||C===v+b)n(v+b),y.offset=v,y.count=b;else{y.splitAxis=S.axis;let _=new Fv,T=v,E=C-v;y.left=_,_.boundingData=new Float32Array(6),f2(o,T,E,_.boundingData,i),s(_,T,E,i,w+1);let A=new Fv,D=C,O=b-E;y.right=A,A.boundingData=new Float32Array(6),f2(o,D,O,A.boundingData,i),s(A,D,O,i,w+1)}return y}Gie(e,t);let r=new Float32Array(6),i=new Float32Array(6),o=Yie(e,r),a=e.index.array,l=t.maxDepth,c=t.verbose,h=t.maxLeafTris,u=t.strategy,d=t.onProgress,p=e.index.count/3,f=!1,g=[],m=Wie(e);if(m.length===1){let y=m[0],v=new Fv;v.boundingData=r,Hie(o,y.offset,y.count,i),s(v,y.offset,y.count,i),g.push(v)}else for(let y of m){let v=new Fv;v.boundingData=new Float32Array(6),f2(o,y.offset,y.count,v.boundingData,i),s(v,y.offset,y.count,i),g.push(v)}return g}function Zie(e,t){let n=Qie(e,t),s,r,i,o=[],a=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let h=0;h<n.length;h++){let u=n[h],d=l(u),p=new a(32*d);s=new Float32Array(p),r=new Uint32Array(p),i=new Uint16Array(p),c(0,u),o.push(p)}return o;function l(h){return h.count?1:1+l(h.left)+l(h.right)}function c(h,u){let d=h/4,p=h/2,f=!!u.count,g=u.boundingData;for(let m=0;m<6;m++)s[d+m]=g[m];if(f){let m=u.offset,y=u.count;return r[d+6]=m,i[p+14]=y,i[p+15]=65535,h+32}else{let m=u.left,y=u.right,v=u.splitAxis,b;if(b=c(h+32,m),b/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return r[d+6]=b/4,b=c(b,y),r[d+7]=v,b}}}var Ca=class{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let n=1/0,s=-1/0;for(let r=0,i=e.length;r<i;r++){let o=e[r][t];n=o<n?o:n,s=o>s?o:s}this.min=n,this.max=s}setFromPoints(e,t){let n=1/0,s=-1/0;for(let r=0,i=t.length;r<i;r++){let o=t[r],a=e.dot(o);n=a<n?a:n,s=a>s?a:s}this.min=n,this.max=s}isSeparated(e){return this.min>e.max||e.min>this.max}};Ca.prototype.setFromBox=function(){let e=new I;return function(t,n){let s=n.min,r=n.max,i=1/0,o=-1/0;for(let a=0;a<=1;a++)for(let l=0;l<=1;l++)for(let c=0;c<=1;c++){e.x=s.x*a+r.x*(1-a),e.y=s.y*l+r.y*(1-l),e.z=s.z*c+r.z*(1-c);let h=t.dot(e);i=Math.min(h,i),o=Math.max(h,o)}this.min=i,this.max=o}}();(function(){let e=new Ca;return function(t,n){let s=t.points,r=t.satAxes,i=t.satBounds,o=n.points,a=n.satAxes,l=n.satBounds;for(let c=0;c<3;c++){let h=i[c],u=r[c];if(e.setFromPoints(u,o),h.isSeparated(e))return!1}for(let c=0;c<3;c++){let h=l[c],u=a[c];if(e.setFromPoints(u,s),h.isSeparated(e))return!1}}})();var Jie=function(){let e=new I,t=new I,n=new I;return function(s,r,i){let o=s.start,a=e,l=r.start,c=t;n.subVectors(o,l),e.subVectors(s.end,r.start),t.subVectors(r.end,r.start);let h=n.dot(c),u=c.dot(a),d=c.dot(c),p=n.dot(a),f=a.dot(a)*d-u*u,g,m;f!==0?g=(h*u-p*d)/f:g=0,m=(h+g*u)/d,i.x=g,i.y=m}}(),m2=function(){let e=new se,t=new I,n=new I;return function(s,r,i,o){Jie(s,r,e);let a=e.x,l=e.y;if(a>=0&&a<=1&&l>=0&&l<=1){s.at(a,i),r.at(l,o);return}else if(a>=0&&a<=1){l<0?r.at(0,o):r.at(1,o),s.closestPointToPoint(o,!0,i);return}else if(l>=0&&l<=1){a<0?s.at(0,i):s.at(1,i),r.closestPointToPoint(i,!0,o);return}else{let c;a<0?c=s.start:c=s.end;let h;l<0?h=r.start:h=r.end;let u=t,d=n;if(s.closestPointToPoint(h,!0,t),r.closestPointToPoint(c,!0,n),u.distanceToSquared(h)<=d.distanceToSquared(c)){i.copy(u),o.copy(h);return}else{i.copy(c),o.copy(d);return}}}}(),eoe=function(){let e=new I,t=new I,n=new ji,s=new qi;return function(r,i){let{radius:o,center:a}=r,{a:l,b:c,c:h}=i;if(s.start=l,s.end=c,s.closestPointToPoint(a,!0,e).distanceTo(a)<=o||(s.start=l,s.end=h,s.closestPointToPoint(a,!0,e).distanceTo(a)<=o)||(s.start=c,s.end=h,s.closestPointToPoint(a,!0,e).distanceTo(a)<=o))return!0;let u=i.getPlane(n);if(Math.abs(u.distanceToPoint(a))<=o){let d=u.projectPoint(a,t);if(i.containsPoint(d))return!0}return!1}}(),toe=1e-15;function zd(e){return Math.abs(e)<toe}var bl=class extends Jr{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new I),this.satBounds=new Array(4).fill().map(()=>new Ca),this.points=[this.a,this.b,this.c],this.sphere=new Wi,this.plane=new ji,this.needsUpdate=!0}intersectsSphere(e){return eoe(e,this)}update(){let e=this.a,t=this.b,n=this.c,s=this.points,r=this.satAxes,i=this.satBounds,o=r[0],a=i[0];this.getNormal(o),a.setFromPoints(o,s);let l=r[1],c=i[1];l.subVectors(e,t),c.setFromPoints(l,s);let h=r[2],u=i[2];h.subVectors(t,n),u.setFromPoints(h,s);let d=r[3],p=i[3];d.subVectors(n,e),p.setFromPoints(d,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,e),this.needsUpdate=!1}};bl.prototype.closestPointToSegment=function(){let e=new I,t=new I,n=new qi;return function(s,r=null,i=null){let{start:o,end:a}=s,l=this.points,c,h=1/0;for(let u=0;u<3;u++){let d=(u+1)%3;n.start.copy(l[u]),n.end.copy(l[d]),m2(n,s,e,t),c=e.distanceToSquared(t),c<h&&(h=c,r&&r.copy(e),i&&i.copy(t))}return this.closestPointToPoint(o,e),c=o.distanceToSquared(e),c<h&&(h=c,r&&r.copy(e),i&&i.copy(o)),this.closestPointToPoint(a,e),c=a.distanceToSquared(e),c<h&&(h=c,r&&r.copy(e),i&&i.copy(a)),Math.sqrt(h)}}();bl.prototype.intersectsTriangle=function(){let e=new bl,t=new Array(3),n=new Array(3),s=new Ca,r=new Ca,i=new I,o=new I,a=new I,l=new I,c=new qi,h=new qi,u=new qi;return function(d,p=null){this.needsUpdate&&this.update(),d.isExtendedTriangle?d.needsUpdate&&d.update():(e.copy(d),e.update(),d=e);let f=this.plane,g=d.plane;if(Math.abs(f.normal.dot(g.normal))>1-1e-10){let m=this.satBounds,y=this.satAxes;n[0]=d.a,n[1]=d.b,n[2]=d.c;for(let x=0;x<4;x++){let w=m[x],S=y[x];if(s.setFromPoints(S,n),w.isSeparated(s))return!1}let v=d.satBounds,b=d.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let x=0;x<4;x++){let w=v[x],S=b[x];if(s.setFromPoints(S,t),w.isSeparated(s))return!1}for(let x=0;x<4;x++){let w=y[x];for(let S=0;S<4;S++){let C=b[S];if(i.crossVectors(w,C),s.setFromPoints(i,t),r.setFromPoints(i,n),s.isSeparated(r))return!1}}return p&&(console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0)),!0}else{let m=this.points,y=!1,v=0;for(let D=0;D<3;D++){let O=m[D],P=m[(D+1)%3];c.start.copy(O),c.end.copy(P),c.delta(o);let L=y?h.start:h.end,B=zd(g.distanceToPoint(O));if(zd(g.normal.dot(o))&&B){h.copy(c),v=2;break}if((g.intersectLine(c,L)||B)&&!zd(L.distanceTo(P))){if(v++,y)break;y=!0}}if(v===1&&this.containsPoint(h.start))return p&&(p.start.copy(h.start),p.end.copy(h.start)),!0;if(v!==2)return!1;let b=d.points,x=!1,w=0;for(let D=0;D<3;D++){let O=b[D],P=b[(D+1)%3];c.start.copy(O),c.end.copy(P),c.delta(a);let L=x?u.start:u.end,B=zd(f.distanceToPoint(O));if(zd(f.normal.dot(a))&&B){u.copy(c),w=2;break}if((f.intersectLine(c,L)||B)&&!zd(L.distanceTo(P))){if(w++,x)break;x=!0}}if(w===1&&this.containsPoint(u.start))return p&&(p.start.copy(u.start),p.end.copy(u.start)),!0;if(w!==2)return!1;if(h.delta(o),u.delta(a),o.dot(a)<0){let D=u.start;u.start=u.end,u.end=D}let S=h.start.dot(o),C=h.end.dot(o),_=u.start.dot(o),T=u.end.dot(o),E=C<_,A=S<T;return S!==T&&_!==C&&E===A?!1:(p&&(l.subVectors(h.start,u.start),l.dot(o)>0?p.start.copy(h.start):p.start.copy(u.start),l.subVectors(h.end,u.end),l.dot(o)<0?p.end.copy(h.end):p.end.copy(u.end)),!0)}}}();bl.prototype.distanceToPoint=function(){let e=new I;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();bl.prototype.distanceToTriangle=function(){let e=new I,t=new I,n=["a","b","c"],s=new qi,r=new qi;return function(i,o=null,a=null){let l=o||a?s:null;if(this.intersectsTriangle(i,l))return(o||a)&&(o&&l.getCenter(o),a&&l.getCenter(a)),0;let c=1/0;for(let h=0;h<3;h++){let u,d=n[h],p=i[d];this.closestPointToPoint(p,e),u=p.distanceToSquared(e),u<c&&(c=u,o&&o.copy(e),a&&a.copy(p));let f=this[d];i.closestPointToPoint(f,e),u=f.distanceToSquared(e),u<c&&(c=u,o&&o.copy(f),a&&a.copy(e))}for(let h=0;h<3;h++){let u=n[h],d=n[(h+1)%3];s.set(this[u],this[d]);for(let p=0;p<3;p++){let f=n[p],g=n[(p+1)%3];r.set(i[f],i[g]),m2(s,r,e,t);let m=e.distanceToSquared(t);m<c&&(c=m,o&&o.copy(e),a&&a.copy(t))}}return Math.sqrt(c)}}();var Ta=class extends Ss{constructor(...e){super(...e),this.isOrientedBox=!0,this.matrix=new et,this.invMatrix=new et,this.points=new Array(8).fill().map(()=>new I),this.satAxes=new Array(3).fill().map(()=>new I),this.satBounds=new Array(3).fill().map(()=>new Ca),this.alignedSatBounds=new Array(3).fill().map(()=>new Ca),this.needsUpdate=!1}set(e,t,n){super.set(e,t),this.matrix.copy(n),this.needsUpdate=!0}copy(e){super.copy(e),this.matrix.copy(e.matrix),this.needsUpdate=!0}};Ta.prototype.update=function(){return function(){let e=this.matrix,t=this.min,n=this.max,s=this.points;for(let l=0;l<=1;l++)for(let c=0;c<=1;c++)for(let h=0;h<=1;h++){let u=1*l|2*c|4*h,d=s[u];d.x=l?n.x:t.x,d.y=c?n.y:t.y,d.z=h?n.z:t.z,d.applyMatrix4(e)}let r=this.satBounds,i=this.satAxes,o=s[0];for(let l=0;l<3;l++){let c=i[l],h=r[l],u=1<<l,d=s[u];c.subVectors(o,d),h.setFromPoints(c,s)}let a=this.alignedSatBounds;a[0].setFromPointsField(s,"x"),a[1].setFromPointsField(s,"y"),a[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();Ta.prototype.intersectsBox=function(){let e=new Ca;return function(t){this.needsUpdate&&this.update();let n=t.min,s=t.max,r=this.satBounds,i=this.satAxes,o=this.alignedSatBounds;if(e.min=n.x,e.max=s.x,o[0].isSeparated(e)||(e.min=n.y,e.max=s.y,o[1].isSeparated(e))||(e.min=n.z,e.max=s.z,o[2].isSeparated(e)))return!1;for(let a=0;a<3;a++){let l=i[a],c=r[a];if(e.setFromBox(l,t),c.isSeparated(e))return!1}return!0}}();Ta.prototype.intersectsTriangle=function(){let e=new bl,t=new Array(3),n=new Ca,s=new Ca,r=new I;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(e.copy(i),e.update(),i=e);let o=this.satBounds,a=this.satAxes;t[0]=i.a,t[1]=i.b,t[2]=i.c;for(let u=0;u<3;u++){let d=o[u],p=a[u];if(n.setFromPoints(p,t),d.isSeparated(n))return!1}let l=i.satBounds,c=i.satAxes,h=this.points;for(let u=0;u<3;u++){let d=l[u],p=c[u];if(n.setFromPoints(p,h),d.isSeparated(n))return!1}for(let u=0;u<3;u++){let d=a[u];for(let p=0;p<4;p++){let f=c[p];if(r.crossVectors(d,f),n.setFromPoints(r,t),s.setFromPoints(r,h),n.isSeparated(s))return!1}}return!0}}();Ta.prototype.closestPointToPoint=function(){return function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();Ta.prototype.distanceToPoint=function(){let e=new I;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();Ta.prototype.distanceToBox=function(){let e=["x","y","z"],t=new Array(12).fill().map(()=>new qi),n=new Array(12).fill().map(()=>new qi),s=new I,r=new I;return function(i,o=0,a=null,l=null){if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(a||l)&&(i.getCenter(r),this.closestPointToPoint(r,s),i.closestPointToPoint(s,r),a&&a.copy(s),l&&l.copy(r)),0;let c=o*o,h=i.min,u=i.max,d=this.points,p=1/0;for(let g=0;g<8;g++){let m=d[g];r.copy(m).clamp(h,u);let y=m.distanceToSquared(r);if(y<p&&(p=y,a&&a.copy(m),l&&l.copy(r),y<c))return Math.sqrt(y)}let f=0;for(let g=0;g<3;g++)for(let m=0;m<=1;m++)for(let y=0;y<=1;y++){let v=(g+1)%3,b=(g+2)%3,x=m<<v|y<<b,w=1<<g|m<<v|y<<b,S=d[x],C=d[w];t[f].set(S,C);let _=e[g],T=e[v],E=e[b],A=n[f],D=A.start,O=A.end;D[_]=h[_],D[T]=m?h[T]:u[T],D[E]=y?h[E]:u[T],O[_]=u[_],O[T]=m?h[T]:u[T],O[E]=y?h[E]:u[T],f++}for(let g=0;g<=1;g++)for(let m=0;m<=1;m++)for(let y=0;y<=1;y++){r.x=g?u.x:h.x,r.y=m?u.y:h.y,r.z=y?u.z:h.z,this.closestPointToPoint(r,s);let v=r.distanceToSquared(s);if(v<p&&(p=v,a&&a.copy(s),l&&l.copy(r),v<c))return Math.sqrt(v)}for(let g=0;g<12;g++){let m=t[g];for(let y=0;y<12;y++){let v=n[y];m2(m,v,s,r);let b=s.distanceToSquared(r);if(b<p&&(p=b,a&&a.copy(s),l&&l.copy(r),b<c))return Math.sqrt(b)}}return Math.sqrt(p)}}();var zv=new I,Uv=new I,Vv=new I,pO=new se,fO=new se,mO=new se,gO=new I;function noe(e,t,n,s,r,i){let o;return i===dr?o=e.intersectTriangle(s,n,t,!0,r):o=e.intersectTriangle(t,n,s,i!==Ao,r),o===null?null:{distance:e.origin.distanceTo(r),point:r.clone()}}function soe(e,t,n,s,r,i,o){zv.fromBufferAttribute(t,s),Uv.fromBufferAttribute(t,r),Vv.fromBufferAttribute(t,i);let a=noe(e,zv,Uv,Vv,gO,o);if(a){n&&(pO.fromBufferAttribute(n,s),fO.fromBufferAttribute(n,r),mO.fromBufferAttribute(n,i),a.uv=Jr.getUV(gO,zv,Uv,Vv,pO,fO,mO,new se));let l={a:s,b:r,c:i,normal:new I,materialIndex:0};Jr.getNormal(zv,Uv,Vv,l.normal),a.face=l,a.faceIndex=s}return a}function yO(e,t,n,s,r){let i=s*3,o=e.index.getX(i),a=e.index.getX(i+1),l=e.index.getX(i+2),c=soe(n,e.attributes.position,e.attributes.uv,o,a,l,t);return c?(c.faceIndex=s,r&&r.push(c),c):null}function roe(e,t,n,s,r,i){for(let o=s,a=s+r;o<a;o++)yO(e,t,n,o,i)}function ioe(e,t,n,s,r){let i=1/0,o=null;for(let a=s,l=s+r;a<l;a++){let c=yO(e,t,n,a);c&&c.distance<i&&(o=c,i=c.distance)}return o}function vO(e,t,n){return e===null||(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e.distance<n.near||e.distance>n.far)?null:e}function Ea(e,t,n,s){let r=e.a,i=e.b,o=e.c,a=t,l=t+1,c=t+2;n&&(a=n.getX(t),l=n.getX(t+1),c=n.getX(t+2)),r.x=s.getX(a),r.y=s.getY(a),r.z=s.getZ(a),i.x=s.getX(l),i.y=s.getY(l),i.z=s.getZ(l),o.x=s.getX(c),o.y=s.getY(c),o.z=s.getZ(c)}function xO(e,t,n,s,r,i,o){let a=n.index,l=n.attributes.position;for(let c=e,h=t+e;c<h;c++)if(Ea(o,c*3,a,l),o.needsUpdate=!0,s(o,c,r,i))return!0;return!1}var bO=class{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){let e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}};function hc(e,t){return t[e+15]===65535}function Ud(e,t){return t[e+6]}function cm(e,t){return t[e+14]}function um(e){return e+8}function hm(e,t){return t[e+6]}function ooe(e,t){return t[e+7]}var Vd=new Ss,Gv=new I,aoe=["x","y","z"];function g2(e,t,n,s,r){let i=e*2,o=Gd,a=dc,l=pc;if(hc(i,a)){let c=Ud(e,l),h=cm(i,a);roe(t,n,s,c,h,r)}else{let c=um(e);Wv(c,o,s,Gv)&&g2(c,t,n,s,r);let h=hm(e,l);Wv(h,o,s,Gv)&&g2(h,t,n,s,r)}}function y2(e,t,n,s){let r=e*2,i=Gd,o=dc,a=pc;if(hc(r,o)){let l=Ud(e,a),c=cm(r,o);return ioe(t,n,s,l,c)}else{let l=ooe(e,a),c=aoe[l],h=s.direction[c]>=0,u,d;h?(u=um(e),d=hm(e,a)):(u=hm(e,a),d=um(e));let p=Wv(u,i,s,Gv)?y2(u,t,n,s):null;if(p){let g=p.point[c];if(h?g<=i[d+l]:g>=i[d+l+3])return p}let f=Wv(d,i,s,Gv)?y2(d,t,n,s):null;return p&&f?p.distance<=f.distance?p:f:p||f||null}}var loe=function(){let e,t,n=[],s=new bO(()=>new Ss);return function(...i){e=s.getPrimitive(),t=s.getPrimitive(),n.push(e,t);let o=r(...i);s.releasePrimitive(e),s.releasePrimitive(t),n.pop(),n.pop();let a=n.length;return a>0&&(t=n[a-1],e=n[a-2]),o};function r(i,o,a,l,c=null,h=0,u=0){function d(v){let b=v*2,x=dc,w=pc;for(;!hc(b,x);)v=um(v),b=v*2;return Ud(v,w)}function p(v){let b=v*2,x=dc,w=pc;for(;!hc(b,x);)v=hm(v,w),b=v*2;return Ud(v,w)+cm(b,x)}let f=i*2,g=Gd,m=dc,y=pc;if(hc(f,m)){let v=Ud(i,y),b=cm(f,m);return _a(i,g,e),l(v,b,!1,u,h+i,e)}else{let v=um(i),b=hm(i,y),x=v,w=b,S,C,_,T;if(c&&(_=e,T=t,_a(x,g,_),_a(w,g,T),S=c(_),C=c(T),C<S)){x=b,w=v;let B=S;S=C,C=B,_=T}_||(_=e,_a(x,g,_));let E=hc(x*2,m),A=a(_,E,S,u+1,h+x),D;if(A===2){let B=d(x),F=p(x)-B;D=l(B,F,!0,u+1,h+x,_)}else D=A&&r(x,o,a,l,c,h,u+1);if(D)return!0;T=t,_a(w,g,T);let O=hc(w*2,m),P=a(T,O,C,u+1,h+w),L;if(P===2){let B=d(w),F=p(w)-B;L=l(B,F,!0,u+1,h+w,T)}else L=P&&r(w,o,a,l,c,h,u+1);return!!L}}}(),coe=function(){let e=new bl,t=new bl,n=new et,s=new Ta,r=new Ta;return function i(o,a,l,c,h=null){let u=o*2,d=Gd,p=dc,f=pc;if(h===null&&(l.boundingBox||l.computeBoundingBox(),s.set(l.boundingBox.min,l.boundingBox.max,c),h=s),hc(u,p)){let g=a,m=g.index,y=g.attributes.position,v=l.index,b=l.attributes.position,x=Ud(o,f),w=cm(u,p);if(n.copy(c).invert(),l.boundsTree)return _a(o,d,r),r.matrix.copy(n),r.needsUpdate=!0,l.boundsTree.shapecast({intersectsBounds:S=>r.intersectsBox(S),intersectsTriangle:S=>{S.a.applyMatrix4(c),S.b.applyMatrix4(c),S.c.applyMatrix4(c),S.needsUpdate=!0;for(let C=x*3,_=(w+x)*3;C<_;C+=3)if(Ea(t,C,m,y),t.needsUpdate=!0,S.intersectsTriangle(t))return!0;return!1}});for(let S=x*3,C=w+x*3;S<C;S+=3){Ea(e,S,m,y),e.a.applyMatrix4(n),e.b.applyMatrix4(n),e.c.applyMatrix4(n),e.needsUpdate=!0;for(let _=0,T=v.count;_<T;_+=3)if(Ea(t,_,v,b),t.needsUpdate=!0,e.intersectsTriangle(t))return!0}}else{let g=o+8,m=f[o+6];return _a(g,d,Vd),!!(h.intersectsBox(Vd)&&i(g,a,l,c,h)||(_a(m,d,Vd),h.intersectsBox(Vd)&&i(m,a,l,c,h)))}}}();function Wv(e,t,n,s){return _a(e,t,Vd),n.intersectBox(Vd,s)}var v2=[],Hv,Gd,dc,pc;function dm(e){Hv&&v2.push(Hv),Hv=e,Gd=new Float32Array(e),dc=new Uint16Array(e),pc=new Uint32Array(e)}function jv(){Hv=null,Gd=null,dc=null,pc=null,v2.length&&dm(v2.pop())}var x2=Symbol("skip tree generation"),b2=new Ss,w2=new Ss,Wd=new et,Ou=new Ta,pm=new Ta,fm=new I,qv=new I,uoe=new I,hoe=new I,doe=new I,wO=new Ss,Aa=new bO(()=>new bl),rr=class{static serialize(e,t={}){if(t.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),rr.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});t=ue({cloneBuffers:!0},t);let n=e.geometry,s=e._roots,r=n.getIndex(),i;return t.cloneBuffers?i={roots:s.map(o=>o.slice()),index:r.array.slice()}:i={roots:s,index:r.array},i}static deserialize(e,t,n={}){if(typeof n=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),rr.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});n=ue({setIndex:!0},n);let{index:s,roots:r}=e,i=new rr(t,De(ue({},n),{[x2]:!0}));if(i._roots=r,n.setIndex){let o=t.getIndex();if(o===null){let a=new Lt(e.index,1,!1);t.setIndex(a)}else o.array!==s&&(o.array.set(s),o.needsUpdate=!0)}return i}constructor(e,t={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:0,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[x2]:!1},t),t.useSharedArrayBuffer&&typeof SharedArrayBuffer>"u")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,t[x2]||(this._roots=Zie(e,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new Ss))),this.geometry=e}refit(e=null){e&&Array.isArray(e)&&(e=new Set(e));let t=this.geometry,n=t.index.array,s=t.attributes.position,r=s.array,i=s.offset||0,o=3;s.isInterleavedBufferAttribute&&(o=s.data.stride);let a,l,c,h,u=0,d=this._roots;for(let f=0,g=d.length;f<g;f++)a=d[f],l=new Uint32Array(a),c=new Uint16Array(a),h=new Float32Array(a),p(0,u),u+=a.byteLength;function p(f,g,m=!1){let y=f*2;if(c[y+15]===65535){let v=l[f+6],b=c[y+14],x=1/0,w=1/0,S=1/0,C=-1/0,_=-1/0,T=-1/0;for(let E=3*v,A=3*(v+b);E<A;E++){let D=n[E]*o+i,O=r[D+0],P=r[D+1],L=r[D+2];O<x&&(x=O),O>C&&(C=O),P<w&&(w=P),P>_&&(_=P),L<S&&(S=L),L>T&&(T=L)}return h[f+0]!==x||h[f+1]!==w||h[f+2]!==S||h[f+3]!==C||h[f+4]!==_||h[f+5]!==T?(h[f+0]=x,h[f+1]=w,h[f+2]=S,h[f+3]=C,h[f+4]=_,h[f+5]=T,!0):!1}else{let v=f+8,b=l[f+6],x=v+g,w=b+g,S=m,C=!1,_=!1;e?S||(C=e.has(x),_=e.has(w),S=!C&&!_):(C=!0,_=!0);let T=S||C,E=S||_,A=!1;T&&(A=p(v,g,S));let D=!1;E&&(D=p(b,g,S));let O=A||D;if(O)for(let P=0;P<3;P++){let L=v+P,B=b+P,F=h[L],M=h[L+3],U=h[B],z=h[B+3];h[f+P]=F<U?F:U,h[f+P+3]=M>z?M:z}return O}}}traverse(e,t=0){let n=this._roots[t],s=new Uint32Array(n),r=new Uint16Array(n);i(0);function i(o,a=0){let l=o*2,c=r[l+15]===65535;if(c){let h=s[o+6],u=r[l+14];e(a,c,new Float32Array(n,o*4,6),h,u)}else{let h=o+32/4,u=s[o+6],d=s[o+7];e(a,c,new Float32Array(n,o*4,6),d)||(i(h,a+1),i(u,a+1))}}}raycast(e,t=jl){let n=this._roots,s=this.geometry,r=[],i=t.isMaterial,o=Array.isArray(t),a=s.groups,l=i?t.side:t;for(let c=0,h=n.length;c<h;c++){let u=o?t[a[c].materialIndex].side:l,d=r.length;if(dm(n[c]),g2(0,s,u,e,r),jv(),o){let p=a[c].materialIndex;for(let f=d,g=r.length;f<g;f++)r[f].face.materialIndex=p}}return r}raycastFirst(e,t=jl){let n=this._roots,s=this.geometry,r=t.isMaterial,i=Array.isArray(t),o=null,a=s.groups,l=r?t.side:t;for(let c=0,h=n.length;c<h;c++){let u=i?t[a[c].materialIndex].side:l;dm(n[c]);let d=y2(0,s,u,e);jv(),d!=null&&(o==null||d.distance<o.distance)&&(o=d,i&&(d.face.materialIndex=a[c].materialIndex))}return o}intersectsGeometry(e,t){let n=this.geometry,s=!1;for(let r of this._roots)if(dm(r),s=coe(0,n,e,t),jv(),s)break;return s}shapecast(e,t,n){let s=this.geometry;if(e instanceof Function){if(t){let u=t;t=(d,p,f,g)=>{let m=p*3;return u(d,m,m+1,m+2,f,g)}}e={boundsTraverseOrder:n,intersectsBounds:e,intersectsTriangle:t,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}let r=Aa.getPrimitive(),{boundsTraverseOrder:i,intersectsBounds:o,intersectsRange:a,intersectsTriangle:l}=e;if(a&&l){let u=a;a=(d,p,f,g,m)=>u(d,p,f,g,m)?!0:xO(d,p,s,l,f,g,r)}else a||(l?a=(u,d,p,f)=>xO(u,d,s,l,p,f,r):a=(u,d,p)=>p);let c=!1,h=0;for(let u of this._roots){if(dm(u),c=loe(0,s,o,a,i,h),jv(),c)break;h+=u.byteLength}return Aa.releasePrimitive(r),c}bvhcast(e,t,n){let{intersectsRanges:s,intersectsTriangles:r}=n,i=this.geometry.index,o=this.geometry.attributes.position,a=e.geometry.index,l=e.geometry.attributes.position;Wd.copy(t).invert();let c=Aa.getPrimitive(),h=Aa.getPrimitive();if(r){let d=function(p,f,g,m,y,v,b,x){for(let w=g,S=g+m;w<S;w++){Ea(h,w*3,a,l),h.a.applyMatrix4(t),h.b.applyMatrix4(t),h.c.applyMatrix4(t),h.needsUpdate=!0;for(let C=p,_=p+f;C<_;C++)if(Ea(c,C*3,i,o),c.needsUpdate=!0,r(c,h,C,w,y,v,b,x))return!0}return!1};if(s){let p=s;s=function(f,g,m,y,v,b,x,w){return p(f,g,m,y,v,b,x,w)?!0:d(f,g,m,y,v,b,x,w)}}else s=d}e.getBoundingBox(w2),w2.applyMatrix4(t);let u=this.shapecast({intersectsBounds:d=>w2.intersectsBox(d),intersectsRange:(d,p,f,g,m,y)=>(b2.copy(y),b2.applyMatrix4(Wd),e.shapecast({intersectsBounds:v=>b2.intersectsBox(v),intersectsRange:(v,b,x,w,S)=>s(d,p,v,b,g,m,w,S)}))});return Aa.releasePrimitive(c),Aa.releasePrimitive(h),u}intersectsBox(e,t){return Ou.set(e.min,e.max,t),Ou.needsUpdate=!0,this.shapecast({intersectsBounds:n=>Ou.intersectsBox(n),intersectsTriangle:n=>Ou.intersectsTriangle(n)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t,n={},s={},r=0,i=1/0){e.boundingBox||e.computeBoundingBox(),Ou.set(e.boundingBox.min,e.boundingBox.max,t),Ou.needsUpdate=!0;let o=this.geometry,a=o.attributes.position,l=o.index,c=e.attributes.position,h=e.index,u=Aa.getPrimitive(),d=Aa.getPrimitive(),p=qv,f=uoe,g=null,m=null;s&&(g=hoe,m=doe);let y=1/0,v=null,b=null;return Wd.copy(t).invert(),pm.matrix.copy(Wd),this.shapecast({boundsTraverseOrder:x=>Ou.distanceToBox(x),intersectsBounds:(x,w,S)=>S<y&&S<i?(w&&(pm.min.copy(x.min),pm.max.copy(x.max),pm.needsUpdate=!0),!0):!1,intersectsRange:(x,w)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:S=>pm.distanceToBox(S),intersectsBounds:(S,C,_)=>_<y&&_<i,intersectsRange:(S,C)=>{for(let _=S*3,T=(S+C)*3;_<T;_+=3){Ea(d,_,h,c),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let E=x*3,A=(x+w)*3;E<A;E+=3){Ea(u,E,l,a),u.needsUpdate=!0;let D=u.distanceToTriangle(d,p,g);if(D<y&&(f.copy(p),m&&m.copy(g),y=D,v=E/3,b=_/3),D<r)return!0}}}});{let S=h?h.count:c.count;for(let C=0,_=S;C<_;C+=3){Ea(d,C,h,c),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let T=x*3,E=(x+w)*3;T<E;T+=3){Ea(u,T,l,a),u.needsUpdate=!0;let A=u.distanceToTriangle(d,p,g);if(A<y&&(f.copy(p),m&&m.copy(g),y=A,v=T/3,b=C/3),A<r)return!0}}}}}),Aa.releasePrimitive(u),Aa.releasePrimitive(d),y===1/0?null:(n.point?n.point.copy(f):n.point=f.clone(),n.distance=y,n.faceIndex=v,s&&(s.point?s.point.copy(m):s.point=m.clone(),s.point.applyMatrix4(Wd),f.applyMatrix4(Wd),s.distance=f.sub(s.point).length(),s.faceIndex=b),n)}closestPointToPoint(e,t={},n=0,s=1/0){let r=n*n,i=s*s,o=1/0,a=null;if(this.shapecast({boundsTraverseOrder:c=>(fm.copy(e).clamp(c.min,c.max),fm.distanceToSquared(e)),intersectsBounds:(c,h,u)=>u<o&&u<i,intersectsTriangle:(c,h)=>{c.closestPointToPoint(e,fm);let u=e.distanceToSquared(fm);return u<o&&(qv.copy(fm),o=u,a=h),u<r}}),o===1/0)return null;let l=Math.sqrt(o);return t.point?t.point.copy(qv):t.point=qv.clone(),t.distance=l,t.faceIndex=a,t}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(t=>{_a(0,new Float32Array(t),wO),e.union(wO)}),e}},SO=rr.prototype.raycast;rr.prototype.raycast=function(...e){if(e[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');let[t,n,s,r]=e;return SO.call(this,s,t.material).forEach(i=>{i=vO(i,t,n),i&&r.push(i)}),r}else return SO.apply(this,e)};var _O=rr.prototype.raycastFirst;rr.prototype.raycastFirst=function(...e){if(e[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');let[t,n,s]=e;return vO(_O.call(this,s,t.material),t,n)}else return _O.apply(this,e)};var CO=rr.prototype.closestPointToPoint;rr.prototype.closestPointToPoint=function(...e){if(e[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'),e.unshift();let t=e[1],n={};return e[1]=n,CO.apply(this,e),t&&t.copy(n.point),n.distance}else return CO.apply(this,e)};var TO=rr.prototype.closestPointToGeometry;rr.prototype.closestPointToGeometry=function(...e){let t=e[2],n=e[3];if(t&&t.isVector3||n&&n.isVector3){console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');let s={},r={},i=e[1];return e[2]=s,e[3]=r,TO.apply(this,e),t&&t.copy(s.point),n&&n.copy(r.point).applyMatrix4(i),s.distance}else return TO.apply(this,e)};var EO=rr.prototype.refit;rr.prototype.refit=function(...e){let t=e[0],n=e[1];if(n&&(n instanceof Set||Array.isArray(n))){console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');let s=new Set;n.forEach(r=>s.add(r)),t&&t.forEach(r=>s.add(r)),EO.call(this,s)}else EO.apply(this,e)};["intersectsGeometry","shapecast","intersectsBox","intersectsSphere"].forEach(e=>{let t=rr.prototype[e];rr.prototype[e]=function(...n){return(n[0]===null||n[0].isMesh)&&(n.shift(),console.warn(`MeshBVH: The function signature for "${e}" has changed and no longer takes Mesh. See docs for new signature.`)),t.apply(this,n)}});var mm=J0(y6()),poe=.5*(Math.sqrt(3)-1),gm=(3-Math.sqrt(3))/6,foe=1/3,Ia=1/6,ym=e=>Math.floor(e)|0,AO=new Float64Array([1,1,-1,1,1,-1,-1,-1,1,0,-1,0,1,0,-1,0,0,1,0,-1,0,1,0,-1]),S2=new Float64Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1]);function _2(e=Math.random){let t=IO(e),n=new Float64Array(t).map(r=>AO[r%12*2]),s=new Float64Array(t).map(r=>AO[r%12*2+1]);return function(r,i){let o=0,a=0,l=0,c=(r+i)*poe,h=ym(r+c),u=ym(i+c),d=(h+u)*gm,p=h-d,f=u-d,g=r-p,m=i-f,y,v;g>m?(y=1,v=0):(y=0,v=1);let b=g-y+gm,x=m-v+gm,w=g-1+2*gm,S=m-1+2*gm,C=h&255,_=u&255,T=.5-g*g-m*m;if(T>=0){let D=C+t[_],O=n[D],P=s[D];T*=T,o=T*T*(O*g+P*m)}let E=.5-b*b-x*x;if(E>=0){let D=C+y+t[_+v],O=n[D],P=s[D];E*=E,a=E*E*(O*b+P*x)}let A=.5-w*w-S*S;if(A>=0){let D=C+1+t[_+1],O=n[D],P=s[D];A*=A,l=A*A*(O*w+P*S)}return 70*(o+a+l)}}function moe(e=Math.random){let t=IO(e),n=new Float64Array(t).map(i=>S2[i%12*3]),s=new Float64Array(t).map(i=>S2[i%12*3+1]),r=new Float64Array(t).map(i=>S2[i%12*3+2]);return function(i,o,a){let l,c,h,u,d=(i+o+a)*foe,p=ym(i+d),f=ym(o+d),g=ym(a+d),m=(p+f+g)*Ia,y=p-m,v=f-m,b=g-m,x=i-y,w=o-v,S=a-b,C,_,T,E,A,D;x>=w?w>=S?(C=1,_=0,T=0,E=1,A=1,D=0):x>=S?(C=1,_=0,T=0,E=1,A=0,D=1):(C=0,_=0,T=1,E=1,A=0,D=1):w<S?(C=0,_=0,T=1,E=0,A=1,D=1):x<S?(C=0,_=1,T=0,E=0,A=1,D=1):(C=0,_=1,T=0,E=1,A=1,D=0);let O=x-C+Ia,P=w-_+Ia,L=S-T+Ia,B=x-E+2*Ia,F=w-A+2*Ia,M=S-D+2*Ia,U=x-1+3*Ia,z=w-1+3*Ia,$=S-1+3*Ia,R=p&255,H=f&255,K=g&255,Y=.6-x*x-w*w-S*S;if(Y<0)l=0;else{let Z=R+t[H+t[K]];Y*=Y,l=Y*Y*(n[Z]*x+s[Z]*w+r[Z]*S)}let X=.6-O*O-P*P-L*L;if(X<0)c=0;else{let Z=R+C+t[H+_+t[K+T]];X*=X,c=X*X*(n[Z]*O+s[Z]*P+r[Z]*L)}let oe=.6-B*B-F*F-M*M;if(oe<0)h=0;else{let Z=R+E+t[H+A+t[K+D]];oe*=oe,h=oe*oe*(n[Z]*B+s[Z]*F+r[Z]*M)}let ie=.6-U*U-z*z-$*$;if(ie<0)u=0;else{let Z=R+1+t[H+1+t[K+1]];ie*=ie,u=ie*ie*(n[Z]*U+s[Z]*z+r[Z]*$)}return 32*(l+c+h+u)}}function IO(e){let t=new Uint8Array(512);for(let n=0;n<512/2;n++)t[n]=n;for(let n=0;n<512/2-1;n++){let s=n+~~(e()*(256-n)),r=t[n];t[n]=t[s],t[s]=r}for(let n=256;n<512;n++)t[n]=t[n-256];return t}var Lo=new Jr,goe=class{constructor(e){this.weightAttribute=null;let t=e.geometry;if(!t.isBufferGeometry||t.attributes.position.itemSize!==3)throw new Error("THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.");t.index&&(t=t.toNonIndexed()),this.geometry=t,this.randomFunction=Math.random,this.positionAttribute=this.geometry.getAttribute("position"),this.distribution=null}build(){let e=this.positionAttribute,t=new Float32Array(e.count/3);for(let s=0;s<e.count;s+=3){let r=1;Lo.a.fromBufferAttribute(e,s),Lo.b.fromBufferAttribute(e,s+1),Lo.c.fromBufferAttribute(e,s+2),r*=Lo.getArea(),t[s/3]=r}this.distribution=new Float32Array(e.count/3);let n=0;for(let s=0;s<t.length;s++)n+=t[s],this.distribution[s]=n;return this}setRandomGenerator(e){return this.randomFunction=e,this}sample(e,t){if(this.distribution){let n=this.distribution[this.distribution.length-1],s=this.binarySearch(this.randomFunction()*n);return this.sampleFace(s,e,t)}}binarySearch(e){if(!this.distribution)return 0;let t=this.distribution,n=0,s=t.length-1,r=-1;for(;n<=s;){let i=Math.ceil((n+s)/2);if(i===0||t[i-1]<=e&&t[i]>e){r=i;break}else e<t[i]?s=i-1:n=i+1}return r}sampleFace(e,t,n){let s=this.randomFunction(),r=this.randomFunction();return s+r>1&&(s=1-s,r=1-r),Lo.a.fromBufferAttribute(this.positionAttribute,e*3),Lo.b.fromBufferAttribute(this.positionAttribute,e*3+1),Lo.c.fromBufferAttribute(this.positionAttribute,e*3+2),t.set(0,0,0).addScaledVector(Lo.a,s).addScaledVector(Lo.b,r).addScaledVector(Lo.c,1-(s+r)),Lo.getNormal(n),this}},yoe=J0(gk()),voe=new et,xoe=new et,boe=new et,Xv;(e=>{function t(n){return n&&n.__isSPEObject}e.is=t})(Xv||(Xv={}));var C2=e=>class extends e{constructor(){super(...arguments);this.hiddenMatrix=new et,this.matrixWorldRigid=new et,this.shearScale=new et,this.shearScaleInv=new et}get __isSPEObject(){return!0}isDescendantOf(t){t instanceof Ln&&(t=t.uuid);let n=this;for(;n.parent;){if(n.parent.uuid===t)return!0;n=n.parent}return!1}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.multiplyMatrices(this.hiddenMatrix,this.matrix):(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.hiddenMatrix),this.matrixWorld.multiplyMatrices(this.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);for(let n of this.children)n.updateMatrixWorld(t)}updateWorldMatrix(t,n){let s=this.parent;if(t&&s!==null&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.multiplyMatrices(this.hiddenMatrix,this.matrix):(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.hiddenMatrix),this.matrixWorld.multiplyMatrices(this.matrixWorld,this.matrix)),n)for(let r of this.children)r.updateWorldMatrix(!1,!0)}traverseObject(t,n=0){if(t(this,n)!==!0)for(let s of this.children)Xv.is(s)&&s.traverseObject(t,n+1)}updateMatrixWorldSVD(){let t=this.matrixWorld.elements,n=[[t[0],t[4],t[8]],[t[1],t[5],t[9]],[t[2],t[6],t[10]]],{u:s,v:r,q:i}=(0,yoe.SVD)(n),o=voe.set(s[0][0],s[0][1],s[0][2],0,s[1][0],s[1][1],s[1][2],0,s[2][0],s[2][1],s[2][2],0,0,0,0,1),a=xoe.set(r[0][0],r[0][1],r[0][2],0,r[1][0],r[1][1],r[1][2],0,r[2][0],r[2][1],r[2][2],0,0,0,0,1),l=boe.copy(a).transpose();this.shearScale.makeScale(i[0],i[1],i[2]).multiply(l).premultiply(a),this.shearScaleInv.copy(this.shearScale).invert(),this.matrixWorldRigid.multiplyMatrices(o,l).copyPosition(this.matrixWorld),i.every(c=>Math.abs(i[0]-c)<.01)?this.hasNonUniformScale=!1:this.hasNonUniformScale=!0}attach(t,n){this.updateWorldMatrix(!0,!1);let s=new et().copy(this.matrixWorld).invert();return t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),s.multiply(t.parent.matrixWorld)),"hiddenMatrix"in t&&t.hiddenMatrix instanceof et?t.hiddenMatrix.premultiply(s):t.applyMatrix4(s),t.updateWorldMatrix(!1,!1),this.add(t),n!==void 0&&(this.children.pop(),this.children.splice(n,0,t)),this}},woe=class extends C2(Ln){},Soe=e=>e.type==="Mesh",Ru=class extends woe{constructor(e){super();this.object=e,this.matrixAutoUpdate=!1}expand(){let e=0,t=this.object.entityChildren(e);for(;t;){let n=this.children[e];(n==null?void 0:n.object)!==t&&(n&&this.remove(n),n=new Ru(t),this.add(n),n.matrixAutoUpdate=!1,n.matrix=t.matrix,n.hiddenMatrix=t.hiddenMatrix),n.expand(),e+=1,t=this.object.entityChildren(e)}for(;this.children.length>e;)this.remove(this.children[e])}get visible(){var e;return this.object.visible||this.object.dataPatched.visible&&((e=this.object.dataPatched.cloner)==null?void 0:e.hideBase)===!0}set visible(e){}get castShadow(){return this.object.castShadow}set castShadow(e){}get receiveShadow(){return this.object.receiveShadow}set receiveShadow(e){}get isMesh(){return Soe(this.object)}get isLight(){return this.object.isLight}get layers(){return this.object.layers}set layers(e){}get isCamera(){return!1}get geometry(){if(this.object.geometry)return this.object.geometry}get material(){if(this.object.material)return this.object.material}},Lu=new I,Fu=new I,Hd=new et,NO=[new I(-1,1,1),new I(-1,-1,1),new I(1,-1,1),new I(1,1,1),new I(-1,1,-1),new I(-1,-1,-1),new I(1,-1,-1),new I(1,1,-1)],_oe=[[0,3],[1,2],[5,6],[4,7],[0,1],[3,2],[7,6],[4,5],[0,4],[1,5],[2,6],[3,7]],Coe=[[0,2],[7,5],[4,1],[3,6],[4,3],[1,6]],kO=(e,t,n)=>{e.updateEntityBoxSize(Lu,Fu),Hd.copy(t).multiply(e.matrixWorld),Fu.x===0&&Fu.y===0&&Fu.z===0?n.push(new I(Lu.x,Lu.y,Lu.z).applyMatrix4(Hd)):NO.forEach(s=>{n.push(s.clone().multiply(Fu).add(Lu).applyMatrix4(Hd))})},DO=class extends Ss{constructor(){super(...arguments);this.matrix=new et,this.vertices=[],this.faces=[],this.edges=[],this.centerEdges=[]}copy(e){return super.copy(e),this.matrix.copy(e.matrix),this.vertices=e.vertices.map(t=>t.clone()),this.faces=e.faces.map(t=>t.clone()),this.edges=e.edges.map(t=>t.clone()),this.centerEdges=e.centerEdges.map(t=>t.clone()),this}setFromObjectSize(e,t=!1){e.updateWorldMatrix(!1,t),this.makeEmpty(),this.matrix.copy(e.matrixWorld);let n=new et().copy(e.matrixWorld).invert();return this.expandByObjectSize(e,n,t)}expandByObjectSize(e,t,n=!1){let s=[];return n===!0?e.traverseEntity(r=>{r.visible&&kO(r,t,s)}):kO(e,t,s),this.setFromPoints(s)}getCenter(e){return e=super.getCenter(e),e.applyMatrix4(this.matrix),e}getPositionToCenter(e){return e=super.getCenter(e),e.applyMatrix4(Hd.copy(this.matrix).setPosition(0,0,0)),e}computeVertices(){this.getSize(Fu).multiplyScalar(.5),this.getCenter(Lu),Hd.copy(this.matrix).setPosition(Lu),this.vertices=NO.map(e=>e.clone().multiply(Fu).applyMatrix4(Hd))}computeEdges(){this.vertices.length>0&&this.computeVertices(),this.edges=_oe.map(([e,t])=>new qi(this.vertices[e],this.vertices[t])),this.centerEdges=this.edges.map(e=>e.getCenter(new I))}computeFaces(){this.vertices.length>0&&this.computeVertices(),this.faces=Coe.map(([e,t])=>this.vertices[e].clone().add(this.vertices[t]).multiplyScalar(.5))}},fc={Cloner:()=>{},changeEntityProptotype:()=>{},createEntity:()=>{}},fs;(e=>{function t(n){return n&&n.__isEntity}e.is=t})(fs||(fs={}));var Ei=e=>fs.is(e),MO=e=>class extends C2(e){constructor(){super(...arguments);this.raycastLock=!1,this.scaleLock=!1,this.disposed=!1,this.stateSelection=null,this.instances=[],this.prevState=null,this.currentState=null,this.reversibleToState=null,this.currentTransitionEvent=null,this._singleBBox=new DO,this._recursiveBBox=new DO,this.singleBBoxNeedsUpdate=!0,this.recursiveBBoxNeedsUpdate=!0}get __isEntity(){return!0}entityChildren(t){let n=this.children[t];if(fs.is(n))return n}get isConcreteEntity(){return typeof this.identity=="string"}get isVirtualEntity(){return typeof this.identity!="string"}get isInstanceRoot(){return this.isConcreteEntity&&this.data.type==="Instance"}nearestInstanceSelfOrParent(){let t=this;for(;t.data.type!=="Instance";){let n=t.parent;if(fs.is(n))t=n;else return}return t}forInstancesRec(t){this.instances.forEach(n=>{n.disposed||t(n),n.forInstancesRec(t)})}super_Entity(t,n){typeof t=="string"&&(this.uuid=t),this.identity=t,this.data=n,this.matrixAutoUpdate=!1,this.dataPatched=this.data}changeSelectedState(t,n,s=!1){if(!(this.data.states.length===0&&!s)){for(let r of this.data.states)Pu.toOps(this.data,r.data).forEach(i=>{let o=O_.replaceProps(i,this.data);this.updateByPatchedOp(o,this.data,n)});if(t!==null){let r=this.data.states.data(t);r&&(this.dataPatched=Pu.patch(this.data,r),Pu.toOps(this.data,r).forEach(i=>{this.updateByPatchedOp(i,this.dataPatched,n)}))}else this.dataPatched=this.data;s&&this.updateTransformState(this.dataPatched),this.stateSelection=t}}get singleBBox(){return this.singleBBoxNeedsUpdate&&(this.singleBBoxNeedsUpdate=!1,this._singleBBox.setFromObjectSize(this,!1),this._singleBBox.computeVertices(),this._singleBBox.computeEdges(),this._singleBBox.computeFaces()),this._singleBBox}get recursiveBBox(){return this.recursiveBBoxNeedsUpdate&&(this.recursiveBBoxNeedsUpdate=!1,this._recursiveBBox.setFromObjectSize(this,!0),this._recursiveBBox.computeVertices(),this._recursiveBBox.computeEdges(),this._recursiveBBox.computeFaces()),this._recursiveBBox}updateEntityBoxSize(t,n){t.setScalar(0),n.setScalar(0)}resetBBoxNeedsUpdateSelf(){this.singleBBoxNeedsUpdate=!0,this.recursiveBBoxNeedsUpdate=!0}resetBBoxNeedsUpdate(){this.resetBBoxNeedsUpdateSelf(),this.traverseAncestors(t=>{Ei(t)&&t.resetBBoxNeedsUpdateSelf()}),this.traverseEntity(t=>{t.resetBBoxNeedsUpdateSelf()})}find(t){let n;return this.traverseEntity(s=>{s.uuid===t&&(n=s)}),n}traverseSortNextHelper(){let t=this.parent;if(t){let n=t.children,s=n.indexOf(this)+1;if(fs.is(n[s]))return n[s];if(fs.is(t))return t.traverseSortNextHelper()}}sortNext(){let t=this.children;return this.children.length>0&&fs.is(this.children[0])?t[0]:this.traverseSortNextHelper()}goUp(t){let n=this;for(;t>0&&n!==null;)n=n.parent,t-=1;return n}hasAnccestorOrSelf(t){return this===t||this.hasAnccestor(t)}hasAnccestor(t){let n=this.parent;for(;n;){if(t===n)return!0;n=n.parent}return!1}countToAccestor(t){let n=0,s=this;for(;s!==t;){if(s===null)return-1;s=s.parent,n+=1}return n}forEachEntity(t){for(let n of this.children)Ei(n)&&t(n)}traverseEntityAncestors(t){this.traverseAncestors(n=>{fs.is(n)&&t(n)})}traverseEntity(t,n=0){if(t(this,n)!==!0)for(let s of this.children)Ei(s)&&s.traverseEntity(t,n+1)}traverseVisibleEntity(t){t(this);for(let n of this.children)Ei(n)&&n.visible&&n.traverseVisibleEntity(t)}updateMatrix(){super.updateMatrix(),this.cloner&&this.cloner.onObjUpdateMatrix(),this.dispatchEvent({type:"updateMatrix"})}copy(t,n=!0){return super.copy(t,!1),this.raycastLock=t.raycastLock,this.scaleLock=t.scaleLock,this.hiddenMatrix.copy(t.hiddenMatrix),this}hasEntityChild(){return this.children.some(t=>Ei(t))}isAncestorOf(t){if(this.uuid===t)return!1;let n=!1;return this.traverseEntity(s=>{s.uuid===t&&(n=!0)}),n}toObjectTransformState(t=[]){this.updateWorldMatrix(!0,!1);let n={position:this.position.toArray(),rotation:[this.rotation.x,this.rotation.y,this.rotation.z],scale:this.scale.toArray(),hiddenMatrix:this.hiddenMatrix.toArray()};return I_(n,t)}updateTransformState(t){var s;let n=!1;return t.position&&(this.position.fromArray(t.position),n=!0),t.rotation&&(this.rotation.fromArray(t.rotation),n=!0),t.scale&&(n=!0,this.scale.fromArray(t.scale)),t.hiddenMatrix!==void 0&&(n=!0,this.hiddenMatrix.fromArray((s=t.hiddenMatrix)!=null?s:Dd.identity)),n&&(this.updateMatrix(),this.resetBBoxNeedsUpdate(),this.invalidateClonerTransform(this),this.traverseEntityAncestors(r=>{r.invalidateClonerTransform(this)})),t.position&&t.rotation&&t.scale&&t.hiddenMatrix!==void 0&&this.updateWorldMatrix(!1,!0),n}dispose(){this.disposed=!0,this.cloner&&(this.cloner.removeFromParent(),this.cloner=void 0)}disposeChildrenRecursively(){for(let t of this.children)fs.is(t)&&t.disposeRecursively()}disposeRecursively(){this.dispose(),this.children.forEach(t=>{fs.is(t)&&t.disposeRecursively()})}toState(t=[]){let n=ue({name:this.name,visible:this.visible,raycastLock:this.raycastLock},this.toObjectTransformState(t));return I_(n,t)}updateByOp(t,n,s,r){let i=this.data;this.data=n;let o=t,a=Nu(t.path,["states","*"]);if(a!==null){if(t.type===0){let[h]=a;if((this==null?void 0:this.stateSelection)===h){let u=ue({},t.props);if(Object.values(t.props).some(d=>d===void 0)){let d=this.data;if(d!==void 0){let p=xa.zoom(d,t.path.slice(2));if(p)for(let f in t.props)t.props[f]===void 0&&f in p&&(u[f]=p[f])}}o=De(ue({},t),{props:u,path:t.path.slice(2)})}}}else if(t.type===0){let h=this.stateSelection?this.data.states.data(this.stateSelection):void 0;if(h!==void 0){if(t.props.name!==void 0&&h.name){let l=h,{name:d}=l;h=qh(l,["name"])}if(t.props.material!==void 0&&"material"in h){let c=h,{material:d}=c;h=qh(c,["material"])}let u=xa.removeOverridden(t.path,t.props,h);o=De(ue({},t),{props:u})}}if(this.updateByPatchedOpBase(o,Pu.patch(this.data,this.stateSelection?this.data.states.data(this.stateSelection):void 0),s),Nu(t.path,["overrides"])){let h=[],u=[...t.path];for(h.push(u[1]),u.splice(0,2);u.length>0&&u[0]==="descendants";)h.push(u[1]),u.splice(0,2);if(h[h.length-1]===void 0){if(t.type===0)for(let d of Object.keys(t.props)){h[h.length-1]=d;let p=s.scene.findInstance([this.uuid,...h]);p&&(p.overrideData=t.props[d],p.updateState(Iu.apply(p.component.data,p.overrideData),s))}}else{let d=s.scene.findInstance([this.uuid,...h]);if(d){let p=xa.zoom(d.component.data,u);if(t=De(ue({},t),{path:u}),t.type===0){let f=t.props;if(p)for(let[g,m]of Object.entries(t.props))m===void 0&&(f===t.props&&(f=ue({},t.props)),f[g]=p[g]);t=De(ue({},t),{props:f})}d.overrideData=Cv.resolve(n.overrides,h),d.updateByOp(t,wi.applySimple(d.data,t),s,!1)}}}else if(this.instances.length>0){let h;if(t.path.length===0&&t.type===0){let u;for(let d of Rd.rootOverrideProps)d in t.props&&(u===void 0&&(u={}),u[d]=t.props[d]);u&&(h=De(ue({},t),{props:u}))}else for(let u of Rd.rootOverrideProps)if(Nu(t.path,[u])){h=t;break}h!==void 0&&this.instances.forEach(u=>{if(u.isInstanceRoot){let d=Iu.filterOp(u.overrideData,h);d&&u.updateByOp(d,wi.applySimple(u.data,d),s,!0)}}),this.instances.forEach(u=>{if(!u.isInstanceRoot){let d=Iu.filterOp(u.overrideData,t);if(d){let p;i===u.data&&t===d?p=n:p=wi.applySimple(u.data,d),u.updateByOp(d,p,s,!0)}}})}}updateByPatchedOpBase(t,n,s){if(this.dataPatched=n,t.path.length===0&&t.type===0)t.props.type!==void 0&&!Mu.is(t.props.type)&&fc.changeEntityProptotype(this,n,s);else if(t.path.length===1&&t.path[0]==="geometry"&&t.type===0&&"type"in t.props){fc.changeEntityProptotype(this,n,s);for(let r of this.children)fs.is(r)&&r.updateVisible()}this.updateByPatchedOp(t,n,s)}updateByPatchedOp(t,n,s){if(t.path.length===0&&t.type===0&&this.updateState(t.props,s),Nu(t.path,["cloner"])!==null){let r=wi.drop(t,1);r.path.length===0&&r.type===0&&r.props.disabled===!0?this.setFromClonerState(null,s):this.cloner?this.cloner.updateState(n.cloner,s.scene):(this.setFromClonerState(n.cloner,s),this.expandCloner(s.scene)),this.updateVisible()}}updateVisible(){var t,n,s;this.visible=this.dataPatched.visible&&(((n=(t=this.dataPatched.cloner)==null?void 0:t.disabled)!=null?n:!0)||((s=this.dataPatched.cloner)==null?void 0:s.hideBase)!==!0)}updateState_Entity(t,n){t.name!==void 0&&(this.name=t.name),t.raycastLock!==void 0&&(this.raycastLock=t.raycastLock),t.visible!==void 0&&(this.updateVisible(),this.resetBBoxNeedsUpdate()),"cloner"in t&&t.cloner!==void 0&&(this.setFromClonerState(t.cloner,n),this.updateVisible()),this.updateTransformState(t)}get attachedSurfaceCloners(){return this.children.filter(t=>t instanceof fc.Cloner&&t.parameters.type==="toObject")}setFromClonerState(t,n){this.disposed||(t===null||t.disabled?(this.cloner&&this.cloner.removeFromParent(),this.cloner=void 0):(this.cloner===void 0&&(this.cloner=new fc.Cloner(this,t),n.scene.addPendingExpandCloner(this)),this.cloner.updateState(t,n.scene)))}expandCloner(t){!this.disposed&&this.cloner&&this.cloner.expandClones(t)}invalidateClonerTransform(t){this.cloner&&this.cloner.invalidateTransform(t)}},Toe=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var o,a,l,c,h;let n=Object.assign({},(o=t==null?void 0:t.parameters)!=null?o:{width:100,radialSegments:64,heightSegments:1,openEnded:!1,thetaStart:0,thetaLength:360,cornerRadius:0,cornerSegments:8,hollow:0},e.parameters),s=n.width/2,r=(a=n.radiusTop)!=null?a:s,i=(l=n.radiusBottom)!=null?l:s;return r===i?(r=s,i=s):r>i?(r=s,i=i*s/r):(r=r*s/i,i=s),{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((c=n.height)!=null?c:n.width),depth:Math.abs((h=n.depth)!=null?h:n.width),radiusTop:r,radiusBottom:i})}}static build(e){let{width:t,depth:n,height:s,radialSegments:r,heightSegments:i,openEnded:o,thetaStart:a,thetaLength:l,radiusTop:c,radiusBottom:h,cornerRadius:u,cornerSegments:d,hollow:p}=e.parameters,f;return u||p?f=new OO(c,h,s,r,i,o,a,l*Math.PI/180,u,u,d,p):f=new US(c,h,s,r,i,o,a,l*Math.PI/180),f.scale(1,1,n/t),Object.assign(f,{userData:De(ue({},e),{type:"CylinderGeometry"})})}};function mc(e,t,n){n.x=e.x*t.x,n.y=e.y,n.z=e.x*t.y}function PO(e){return new se(e.y,-e.x)}var OO=class extends It{constructor(e,t,n,s,r,i,o,a,l,c,h,u,d=!1){super(),this.type="RoundedCylinderBufferGeometry",e=e!==void 0?e:1,t=t!==void 0?t:1,n=n||1,s=Math.floor(s)||8,r=Math.floor(r)||1,i=i!==void 0?i:!1,o=o!==void 0?o:0,a=a!==void 0?a:Math.PI*2,i&&(l=0,c=0);let p=[],f=[],g=[],m=[],y=0,v=n/2,b=new I,x=new I;d&&e==0&&(e=l),d&&t==0&&(t=c);let w=new se(e,v),S=new se(t,-v),C=null,_=null,T=null,E=null,A=w.clone().sub(S),D=0,O=0,P=0;u>0&&(D=Math.min(e,t)*(1-u),O=e-D,P=t-D);let L=w.clone();L.x-=D;let B=Math.PI-A.angle(),F=A.angle(),M=Math.tan(F/2),U=Math.tan(B/2),z=M+U,$=u?z:U,R=u?z:M;if(l=Math.min(l,(e-O)/$,A.length()/z),c=Math.min(c,(t-P)/R,A.length()/z),l>0){let ie=l/M;C=w.clone().sub(new se(ie,l)),u&&(T=C.clone(),T.x-=D-z*l),w.sub(A.clone().setLength(ie))}if(c>0){let ie=c/U;_=S.clone().sub(new se(ie,-c)),S.add(A.clone().setLength(ie)),u&&(E=_.clone(),E.x-=D-z*c,L.sub(A.clone().setLength(ie)))}A=w.clone().sub(S);let H=A.length()<.5,K=[];for(let ie=0;ie<=s;ie++){let Z=[],ce=ie/s,ge=ce*a+o,_e=new se(Math.sin(ge),Math.cos(ge));E&&_?(Y(Z,ce,_e,B,c,E,-1,!0),Y(Z,ce,_e,F,c,_,-1,!1)):_?(X(Z,_e,_.x,0,-1),Y(Z,ce,_e,F,c,_,-1,!1)):i||X(Z,_e,t,P,-1);let be=PO(A).normalize();if(mc(be,_e,b),!H)for(let Me=0;Me<=r;Me++){let Ie=Me/r,Le=A.clone().multiplyScalar(Ie).add(S);mc(Le,_e,x),f.push(x.x,x.y,x.z),g.push(b.x,b.y,b.z),m.push(ce,.5+x.y/n),Z.push(y++)}if(T&&C?(Y(Z,ce,_e,B,l,C,1,!1),Y(Z,ce,_e,F,l,T,1,!0)):C?(Y(Z,ce,_e,B,l,C,1,!1),X(Z,_e,C.x,0,1)):i||X(Z,_e,e,O,1),u&&!H){let Me=PO(A).multiplyScalar(-1).normalize();mc(Me,_e,b);for(let Ie=0;Ie<=r;Ie++){let Le=Ie/r,Ue=A.clone().multiplyScalar(-Le).add(L);mc(Ue,_e,x),f.push(x.x,x.y,x.z),g.push(b.x,b.y,b.z),m.push(ce,.5+x.y/n),Z.push(y++)}}u&&!i&&Z.push(Z[0]),K.push(Z)}for(let ie=0;ie<K.length-1;ie++)for(let Z=0;Z<K[0].length-1;Z++){if(i&&u&&Z==r)continue;let ce=K[ie][Z],ge=K[ie+1][Z],_e=K[ie+1][Z+1],be=K[ie][Z+1],Me=f[_e*3+0],Ie=f[_e*3+2];p.push(ce,ge,be),(Me!=0||Ie!=0)&&p.push(ge,_e,be)}a<Math.PI*2&&(oe(-1,K[0],o),oe(1,K[K.length-1],o+a)),this.setIndex(p),this.setAttribute("position",new ot(f,3)),this.setAttribute("normal",new ot(g,3)),this.setAttribute("uv",new ot(m,2));function Y(ie,Z,ce,ge,_e,be,Me,Ie){for(let Le=0;Le<h+1;Le++){let Ue=Le/h,$e=Me<0?Ue:1-Ue;Ie&&($e-=1),$e*=ge;let We=new se(Math.sin($e),Math.cos($e)*Me),Rt=We.clone().multiplyScalar(_e).add(be);mc(Rt,ce,x),f.push(x.x,x.y,x.z),mc(We,ce,b),g.push(b.x,b.y,b.z),m.push(Z,.5+x.y/n),ie.push(y++)}}function X(ie,Z,ce,ge,_e){let be=new I,Me=new se,Ie=[ce,ge];_e<0&&Ie.reverse();for(let Le of Ie)Me.set(Le,v*_e),mc(Me,Z,be),f.push(be.x,be.y,be.z),g.push(0,_e,0),m.push(.5,.5),ie.push(y++)}function oe(ie,Z,ce){let ge=new se(Math.sin(ce),Math.cos(ce)),_e=new se(-Math.cos(ce),Math.sin(ce)),be=new I,Me=ie<0?(Ue,$e,We)=>p.push(Ue,$e,We):(Ue,$e,We)=>p.push(Ue,We,$e),Ie=new se((e+t+O+P)/4,0);mc(Ie,ge,be),f.push(be.x,be.y,be.z),g.push(_e.x,0,_e.y),m.push(.5,.5);let Le=y++;for(let Ue of Z){let $e=f.slice(Ue*3,Ue*3+3);f.push(...$e),g.push(_e.x,0,_e.y);let We=m.slice(Ue*2,Ue*2+2);m.push(...We),y++}for(let Ue=Le+1;Ue<y-1;Ue++)Me(Le,Ue,Ue+1);Me(Le,y-1,Le+1)}}},Eoe=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var s,r,i;let n=Object.assign({},(s=t==null?void 0:t.parameters)!=null?s:{width:100,radialSegments:32,heightSegments:8,openEnded:!1,thetaStart:0,thetaLength:360,cornerRadiusTop:0,cornerRadiusBottom:0,cornerSegments:8},e.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((r=n.height)!=null?r:n.width),depth:Math.abs((i=n.depth)!=null?i:n.width)})}}static build(e){let{width:t,depth:n,height:s,radialSegments:r,heightSegments:i,openEnded:o,thetaStart:a,thetaLength:l,cornerRadiusTop:c,cornerRadiusBottom:h,cornerSegments:u}=e.parameters,d;return c>0||h>0||l<360?d=new OO(0,t/2,s,r,i,o,a,l*Math.PI/180,c,h,u,0,!0):d=new sM(t/2,s,r,i,o),d.scale(1,1,n/t),Object.assign(d,{userData:De(ue({},e),{type:"ConeGeometry"})})}},Aoe=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var s,r,i;let n=Object.assign({},(s=t==null?void 0:t.parameters)!=null?s:{width:100,widthSegments:1,heightSegments:1,depthSegments:1,cornerRadius:0,cornerSegments:8},e.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((r=n.height)!=null?r:n.width),depth:Math.abs((i=n.depth)!=null?i:n.width)})}}static build(e){let{width:t,height:n,depth:s,widthSegments:r,heightSegments:i,depthSegments:o,cornerRadius:a,cornerSegments:l}=e.parameters,c;return a==0?c=new pa(t,n,s,r,i,o):c=new Ioe(t,n,s,r,i,o,a,l),Object.assign(c,{userData:De(ue({},e),{type:"CubeGeometry"})})}},T2=Math.PI/2,Ioe=class extends It{constructor(e=1,t=1,n=1,s=1,r=1,i=1,o=0,a=4){super(),this.type="BoxGeometry";let l=this;s=Math.floor(s),r=Math.floor(r),i=Math.floor(i),a=Math.floor(a),o=Math.min(o,e/2,t/2,n/2);let c=[],h=[],u=[],d=[],p=0,f=0;g("z","y","x",-1,-1,n,t,e,i,r,0),g("z","y","x",1,-1,n,t,-e,i,r,1),g("x","z","y",1,1,e,n,t,s,i,2),g("x","z","y",1,-1,e,n,-t,s,i,3),g("x","y","z",1,-1,e,t,n,s,r,4),g("x","y","z",-1,-1,e,t,-n,s,r,5),o>0&&(m("z","y","x",-1,-1,1,n,t,e,i,0),m("z","y","x",1,-1,-1,n,t,e,i,1),m("z","y","x",-1,1,-1,n,t,e,i,1),m("z","y","x",1,1,1,n,t,e,i,0),m("x","y","z",-1,-1,-1,e,t,n,s,0),m("x","y","z",1,-1,1,e,t,n,s,1),m("x","y","z",-1,1,1,e,t,n,s,0),m("x","y","z",1,1,-1,e,t,n,s,1),m("y","x","z",-1,-1,1,t,e,n,r,0),m("y","x","z",1,-1,-1,t,e,n,r,1),m("y","x","z",1,1,1,t,e,n,r,1),m("y","x","z",-1,1,-1,t,e,n,r,0),y(1,1,1),y(-1,1,1),y(1,-1,1),y(-1,-1,1),y(1,1,-1),y(-1,1,-1),y(1,-1,-1),y(-1,-1,-1)),this.setIndex(c),this.setAttribute("position",new ot(h,3)),this.setAttribute("normal",new ot(u,3)),this.setAttribute("uv",new ot(d,2));function g(v,b,x,w,S,C,_,T,E,A,D){let O=(C-2*o)/E,P=(_-2*o)/A,L=C/2-o,B=_/2-o,F=T/2,M=E+1,U=A+1,z=0,$=0,R=new I;for(let H=0;H<U;H++){let K=H*P-B;for(let Y=0;Y<M;Y++){let X=Y*O-L;R[v]=X*w,R[b]=K*S,R[x]=F,h.push(R.x,R.y,R.z),R[v]=0,R[b]=0,R[x]=T>0?1:-1,u.push(R.x,R.y,R.z),d.push(Y/E),d.push(1-H/A),z+=1}}for(let H=0;H<A;H++)for(let K=0;K<E;K++){let Y=p+K+M*H,X=p+K+M*(H+1),oe=p+(K+1)+M*(H+1),ie=p+(K+1)+M*H;c.push(Y,X,ie),c.push(X,oe,ie),$+=6}l.addGroup(f,$,D),f+=$,p+=z}function m(v,b,x,w,S,C,_,T,E,A,D){let O=(_-2*o)/A,P=_/2-o,L=T/2-o,B=E/2,F=A+1,M=0,U=0,z=new I,$=new I;for(let R=0;R<a+1;R++){let H=R/a*T2,K=Math.sin(H)*o,Y=(1-Math.cos(H))*o,X=Math.sin(H),oe=Math.cos(H);z[b]=(L+K)*S,z[x]=(B-Y)*C,$[v]=0,$[b]=X*Math.sign(z[b]),$[x]=oe*Math.sign(z[x]);for(let ie=0;ie<F;ie++){let Z=ie*O-P;z[v]=Z*w,h.push(z.x,z.y,z.z),u.push($.x,$.y,$.z),d.push(ie/A),d.push(0),M+=1}}for(let R=0;R<a;R++)for(let H=0;H<A;H++){let K=p+H+F*R,Y=p+H+F*(R+1),X=p+(H+1)+F*(R+1),oe=p+(H+1)+F*R;c.push(K,Y,oe),c.push(Y,X,oe),U+=6}l.addGroup(f,U,D),f+=U,p+=M}function y(v,b,x){let w=new I,S=new I(e/2,t/2,n/2);S.subScalar(o);let C=[],_=v*b*x>0?(E,A,D)=>c.push(E,A,D):(E,A,D)=>c.push(E,D,A);for(let E=0;E<=a;E++){let A=[],D=T2*(1-E/a),O=Math.cos(D),P=Math.sin(D),L=0;for(let B=0;B<=E;B++){let F=Math.cos(L),M=Math.sin(L);w.x=O*F,w.y=P,w.z=O*M;let U=S.clone().addScaledVector(w,o);h.push(v*U.x,b*U.y,x*U.z),u.push(v*w.x,b*w.y,x*w.z),d.push(0,0),A.push(p++),L+=T2/E}C.push(A)}let T=C.length-1;for(let E=0;E<T;E++){let A=C[E],D=C[E+1],O=A.length-1;_(A[0],D[1],D[0]);for(let P=1;P<=O;P++)_(A[P-1],A[P],D[P]),_(A[P],D[P+1],D[P])}}}},E2=class extends It{constructor(e=[],t=[],n="",s=1,r=.2,i=4){super(),this.type="PolyhedronGeometryRound";let o=[],a=[],l=[];c(),h(),this.setAttribute("position",new ot(o,3)),this.setAttribute("normal",new ot(l,3)),this.setAttribute("uv",new ot(a,2));return;function c(){var F;r=Math.min(1-1e-5,r),r==0&&(i=0);let u={IcosahedronGeometry:5,DodecahedronGeometry:3,HexahedronGeometry:3,OctahedronGeometry:4,TetrahedronGeometry:3}[n],d=new I,p=d.clone(),f=new Jr,g=r*s,m=s-g,y=i+1,v=new I,b=(M,U)=>v.subVectors(M,U).normalize(),x=(M,U)=>Array(M).fill(void 0).map(U),w=x(e.length/3,(M,U)=>new I().fromArray(e,U*3).setLength(s)),S=[],C=1e6;for(let M=0;M<w.length;M++){let U=w[M],z=[],$,R,H,K=1e10,Y=-1;for(;(Y=t.indexOf(M,Y+1))!=-1;){let Z=Y-Y%3;$=t[Z+(Y+1)%3],R=t[Z+(Y+2)%3],H=U.distanceToSquared(w[$]),K=Math.min(K,H),z.push([$,R,H])}K+=1e-6;let X=[],oe=0,ie=z.length;for(let Z=0;Z<ie;Z++){[$,R,H]=z[oe];let ce=((F=S[$])==null?void 0:F.includes(M))==!0;H<=K&&X.push($+ +ce*C),oe=z.findIndex(ge=>ge[0]==R)}S.push(X)}let _=[];{let M=0,U=0,z,$,R=u==3;for(let H=0;H<=i;H++){z=H*(H+1)/2,$=(H+1)*(H+2)/2;for(let K=0;K<i-H;K++)[M,U]=[z+K+H+2,$+K+H+3],_.push(z,$,...R?[U,z]:[M,$],U,M),[z,$]=[M,U];_.push(z,$,z+i+2)}}let T=d.clone(),E=d.clone(),A=d.clone(),D=d.clone(),O=d.clone(),P=[],L=x(w.length,()=>x(u,()=>d.clone()));for(let M=0;M<w.length;M++){d.copy(w[M]).normalize(),T.copy(d).multiplyScalar(m);let U=S[M];for(let X=0;X<U.length;X++){let oe=U[X],ie=U[(X+1)%u];f.setFromPointsAndIndices(w,M,oe%C,ie%C),f.b.sub(f.a).setLength(1e10).add(f.a),f.c.sub(f.a).setLength(1e10).add(f.a),f.closestPointToPoint(T,L[M][X])}let z=[],$=[],R=[],H=new I;i==0&&[...L[M]].reduce((X,oe)=>X.add(oe),H).multiplyScalar(1/u);for(let X=0;X<u;X++){let oe=[],ie=(X-1+u)%u,Z=L[M][ie],ce=L[M][X];d.copy(Z).sub(T),p.copy(ce).sub(T);let ge=T.angleTo(d),_e=d.angleTo(p),be=Math.cos(ge)*g;i==0?E.copy(H):E.copy(T).setLength(m+be),$.push(be);let Me=[E,Z,ce];for(let Ie=0;Ie<2;Ie++){let Le=Me[Ie],Ue=Me[Ie+1];D.subVectors(Le,T),O.subVectors(Ue,T),A.crossVectors(D,O).normalize();for(let $e=0;$e<y;$e++){let We=[ge,_e][Ie]*$e/y;d.copy(D).applyAxisAngle(A,We).add(T),z.push(d.clone()),Ie&&(b(d,T),oe.push([$e==0?Le:d.clone(),v.clone()]))}Ie&&(b(Ue,T),oe.push([Ue,v.clone()]))}R.push(oe)}P.push(R);let K=2*y,Y=2;for(let X=0;X<u;X++){let oe=K*X,ie=K*((X+1)%u),Z=[z[oe]];for(let ge=1;ge<y;ge++){D=z[oe+ge],O=z[ie+ge],Z.push(D);for(let _e=1,be=ge-Y+1;_e<=be;_e++)d.lerpVectors(D,O,_e/(be+1)),d.sub(T).setLength($[X]).add(T),Z.push(d.clone());Z.push(O)}for(let ge=0;ge<y;ge++)Z.push(z[ge+y+oe]);Z.push(z[ie+y]);let ce=_.map(ge=>Z[ge]);o.push(...ce.map(ge=>[ge.x,ge.y,ge.z]).flat()),l.push(...ce.map(ge=>(b(ge,T),[v.x,v.y,v.z])).flat())}}let B=[];for(let M=0;M<S.length;M++)for(let U=0;U<u;U++){let z=S[M][U];if(z<C){let $=S[z].findIndex(K=>K%C==M),R=P[M][U],H=P[z][$];for(let K=0;K<y;K++){let Y=R[K],X=H[y-K],oe=R[K+1],ie=H[y-(K+1)];[Y,X,oe,oe,X,ie].forEach(Z=>{o.push(Z[0].x,Z[0].y,Z[0].z),l.push(Z[1].x,Z[1].y,Z[1].z)})}B.push(R[0][0],H[y][0],R[y][0],H[0][0])}}for(;B.length;){let M,U,z,$;[M,U]=B.splice(0,2);let R=[M];for(;M!=U;)R.push(U),z=B.indexOf(U),$=z%2,U=B.splice(z-$,2)[1-$];v.subVectors(R[0],R[1]).cross(d.subVectors(R[0],R[2])).normalize();let H=v.dot(R[0])<0;H&&v.negate();for(let K=1;K<=R.length-2;K++)[R[K+ +H],R[K+1-+H],R[0]].forEach(Y=>{o.push(Y.x,Y.y,Y.z),l.push(v.x,v.y,v.z)})}}function h(){let u=new I;for(let S=0;S<o.length;S+=3){u.x=o[S+0],u.y=o[S+1],u.z=o[S+2];let C=x(u)/2/Math.PI+.5,_=w(u)/Math.PI+.5;a.push(C,1-_)}let d=new I,p=new I,f=new I,g=new I,m=new se,y=new se,v=new se,b=(S,C,_,T)=>{T<0&&S.x===1&&(a[C]=S.x-1),_.x===0&&_.z===0&&(a[C]=T/2/Math.PI+.5)};for(let S=0,C=0;S<o.length;S+=9,C+=6){d.set(o[S+0],o[S+1],o[S+2]),p.set(o[S+3],o[S+4],o[S+5]),f.set(o[S+6],o[S+7],o[S+8]),m.set(a[C+0],a[C+1]),y.set(a[C+2],a[C+3]),v.set(a[C+4],a[C+5]),g.copy(d).add(p).add(f).divideScalar(3);let _=x(g);b(m,C+0,d,_),b(y,C+2,p,_),b(v,C+4,f,_)}for(let S=0;S<a.length;S+=6){let C=a[S+0],_=a[S+2],T=a[S+4],E=Math.max(C,_,T),A=Math.min(C,_,T);E>.9&&A<.1&&(C<.2&&(a[S+0]+=1),_<.2&&(a[S+2]+=1),T<.2&&(a[S+4]+=1))}function x(S){return Math.atan2(S.z,-S.x)}function w(S){return Math.atan2(-S.y,Math.sqrt(S.x*S.x+S.z*S.z))}}}static fromJSON(e){return new E2(e.vertices,e.indices,e.radius,e.corner,e.cornerSides)}},Noe=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var s,r,i;let n=Object.assign({},(s=t==null?void 0:t.parameters)!=null?s:{width:100,detail:0,corner:0,cornerSides:4},e.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((r=n.height)!=null?r:n.width),depth:Math.abs((i=n.depth)!=null?i:n.width)})}}static build(e){let{width:t,height:n,depth:s,detail:r,corner:i,cornerSides:o}=e.parameters,a=r===0&&i!==0?new RO(t*.5,i,o):new rM(t*.5,r);return a.scale(1,n/t,s/t),Object.assign(a,{userData:De(ue({},e),{type:"DodecahedronGeometry"})})}},RO=class extends E2{constructor(e=1,t=.2,n=4){let s=(1+Math.sqrt(5))/2,r=1/s,i=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-s,0,-r,s,0,r,-s,0,r,s,-r,-s,0,-r,s,0,r,-s,0,r,s,0,-s,0,-r,s,0,-r,-s,0,r,s,0,r],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],a="DodecahedronGeometry";super(i,o,a,e,t,n),this.type=a}static fromJSON(e){return new RO(e.radius,e.corner,e.cornerSides)}},vm=1e-12,A2=class{constructor(e){this.position=new se,this.startPosition=new se,this.uuid=Kt.generateUUID(),this.position=e.clone()}start(){this.reset()}reset(){this.startPosition.copy(this.position)}applyOffset(e){this.position.copy(this.startPosition).add(e)}copy(e){return this.position.copy(e.position),this.startPosition.copy(e.startPosition),this}clone(){return new A2(this.position).copy(this)}toJSON(){return[this.position.x,this.position.y]}},I2=class extends A2{constructor(e){super(e.position);this.parent=e}copy(e){return super.copy(e),this}clone(){return new I2(this.parent).copy(this)}},jd=class extends A2{constructor(e,t){super(t);this.controls=[],this.roundness=0,this.areControlsDirectionsMirrored=!0,this.uuid=e,this.controls.push(new I2(this),new I2(this))}static create(e,t){let n=new jd(e,new se(...t.position));return n.controls[0].position.set(...t.controlPrevious.position),n.controls[1].position.set(...t.controlNext.position),n.roundness=t.roundness,n.areControlsDirectionsMirrored=t.areControlsDirectionsMirrored,n}getOppositeControl(e){let t=this.controls.indexOf(e);return t===0?this.controls[1]:t===1?this.controls[0]:null}applyOffsetToControls(e,t=1){for(let n=0,s=this.controls.length;n<s;n++){let r=this.controls[n];this.position.distanceTo(r.position)<=t?r.position.copy(this.position):r.applyOffset(e)}}controlsMoved(){return!(this.position.equals(this.controls[0].position)&&this.position.equals(this.controls[1].position))}copy(e){return super.copy(e),this.controls[0].copy(e.controls[0]),this.controls[1].copy(e.controls[1]),this.roundness=e.roundness,this.uuid=e.uuid,this}clone(){return new jd(this.uuid,this.position).copy(this)}toJSON(){return super.toJSON().concat(this.controls[0].toJSON(),this.controls[1].toJSON(),[this.roundness])}computeTangents(){var n,s;let e=(n=this.curveBefore)==null?void 0:n.getTangentAt(1),t=(s=this.curveAfter)==null?void 0:s.getTangentAt(0);return[e,t]}computeNormals(e=new se,t=new se){let[n,s]=this.computeTangents();return n&&s&&(LO(n,e),LO(s,t)),[e,t]}computeTangent(e=new se){let[t,n]=this.computeTangents();return t&&n&&e.copy(t).add(n).normalize(),e}computeNormal(e=new se){let[t,n]=this.computeNormals();return e.copy(t).add(n).normalize(),e}};function LO(e,t=new se){let n=e.length();return t.set(-e.y/n,e.x/n)}var N2=e=>e,qd=new se,Kv=new se,koe=new se,Doe=new se,Moe=new se,Poe=new se,FO=new I,$O=new I;function Ooe(e){let t=new se;t.addVectors(e.v0,qd.subVectors(e.v1,e.v0).multiplyScalar(2/3));let n=new se;return n.addVectors(e.v2,Kv.subVectors(e.v1,e.v2).multiplyScalar(2/3)),new Mo(e.v0,t,n,e.v2)}function xm(e,t,n=Number.EPSILON){return Math.abs(e-t)<n}function Roe(e,t,n=Number.EPSILON){return e.distanceTo(t)<n}function Loe(e,t,n=Number.EPSILON){return e.distanceTo(t)<n}function BO(e,t,n){let s=Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2)),r=Math.sqrt(Math.pow(t.x-n.x,2)+Math.pow(t.y-n.y,2)),i=Math.sqrt(Math.pow(n.x-e.x,2)+Math.pow(n.y-e.y,2));return Math.acos((r*r+s*s-i*i)/(2*r*s))}function Foe(e,t,n){return UO(e,t)&&UO(t,n)&&k2(e.position,t.position,n.position)}function k2(e,t,n){return qd.copy(t).sub(e).cross(Kv.copy(n).sub(e))===0}function $oe(e,t,n,s,r){let i=Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2)),o=(e.y+t.y)/2,a=(e.x+t.x)/2,l=Math.sqrt(Math.pow(n,2)-Math.pow(i/2,2))*(e.y-t.y)/i,c=Math.sqrt(Math.pow(n,2)-Math.pow(i/2,2))*(t.x-e.x)/i;return s.set(a+l,o+c),r.set(a-l,o-c),[s,r]}function Boe(e,t,n){let s=e.distanceTo(n),r=t.distanceTo(n);return s<r?t:e}function zoe(e,t,n,s,r,i){let o=t.x-e.x,a=t.y-e.y,l=n.x-e.x,c=n.y-e.y,h=Math.sqrt((o+l)*(o+l)+(a+c)*(a+c)),u;return BO(t,e,n)>Math.PI&&(h*=-1),xm(c,a)?u=(a+c)*(s/h-.5)*8/3/(o-l):u=(o+l)*(s/h-.5)*8/3/(c-a),r.set(t.x-u*a,t.y+u*o),i.set(n.x+u*c,n.y-u*l),[r,i]}function zO(e,t){return e.position.equals(e.controls[1].position)&&t.position.equals(t.controls[0].position)}function UO(e,t){return k2(e.position,e.controls[1].position,t.position)&&k2(e.position,t.controls[0].position,t.position)}function Uoe(e,t,n,s,r=.5){let i=qd.subVectors(t,e).multiplyScalar(r).add(e),o=Kv.subVectors(n,t).multiplyScalar(r).add(t),a=koe.subVectors(s,n).multiplyScalar(r).add(n),l=i,c=Doe.subVectors(o,i).multiplyScalar(r).add(i),h=Moe.subVectors(a,o).multiplyScalar(r).add(o),u=a,d=Poe.subVectors(h,c).multiplyScalar(r).add(c);return[e.x,e.y,l.x,l.y,c.x,c.y,d.x,d.y,h.x,h.y,u.x,u.y,s.x,s.y]}function Voe(e,t,n=12,s=!0){let r=$O.set(0,0,0),i,o=0;for(let a=0;a<t.length;a++){let l=N2(t[a]),c=qd,h=$u(l,n);for(let u=0;u<=h;u++)if(l instanceof Mo||l instanceof sc||l instanceof Po){if(l.getPoint(u/h,c),r.set(c.x,c.y,0),i!==void 0&&Loe(i,r))continue;i===void 0&&(i=FO),i.copy(r),e.setXYZ(o,r.x,r.y,r.z),o++}}return s&&o>1&&!(e.getX(o-1)===e.getX(0)&&e.getY(o-1)===e.getY(0)&&e.getZ(o-1)===e.getZ(0))&&(e.setXYZ(o,e.getX(0),e.getY(0),e.getZ(0)),o++),e}function Goe(e,t,n,s=12,r=!0){let i=$O.set(0,0,0),o=0,a=[];for(let l=0;l<t.length;l++){if(n[l]===!1)continue;let c,h=N2(t[l]),u=qd,d=$u(h,s);a.push(d);for(let p=0;p<=d;p++)if(h instanceof Mo||h instanceof sc||h instanceof Po){if(h.getPoint(p/d,u),i.set(u.x,u.y,0),c==null?void 0:c.equals(i))continue;c===void 0?c=FO:(e.setXYZ(o,c.x,c.y,c.z),o++,e.setXYZ(o,i.x,i.y,i.z),o++),c.copy(i)}}return r&&o>1&&!(e.getX(o-1)===e.getX(0)&&e.getY(o-1)===e.getY(0)&&e.getZ(o-1)===e.getZ(0))&&(e.setXYZ(o,e.getX(0),e.getY(0),e.getZ(0)),o++),a}function VO(e,t=12,n=!1){let s=[];for(let r=0,i=e.length;r<i;r++){let o=e[r],a=0;if(n&&o.roundedCurveCorner!==void 0){let l=$u(o.roundedCurveCorner,t)*.5;r>0&&(s[r-1]+=l),a+=l}o.curveAfter!==void 0&&(a+=$u(o.curveAfter,t)),s.push(a)}return e.length>0&&n&&e[0].roundedCurveCorner!==void 0&&(s[e.length-1]+=$u(e[0].roundedCurveCorner,t)*.5),s}function $u(e,t=12){return e&&e instanceof ky?t*2:e&&(e instanceof Po||e instanceof tM)?1:e&&e instanceof zS?t*e.points.length:t}function Woe(e,t,n=12,s=!0){let r,i=0;for(let o=0;o<t.length;o++){let a=N2(t[o]),l=$u(a,n),c=qd;for(let h=0;h<=l;h++)if(a instanceof Mo||a instanceof sc||a instanceof Po){if(a.getPoint(h/l,c),r!==void 0&&Roe(r,c,vm))continue;r===void 0&&(r=Kv),r.copy(c),e.push(c.x,c.y),i++}}return xm(e[0],e[e.length-2],vm)&&xm(e[1],e[e.length-1],vm)&&(e.pop(),e.pop()),s&&i>1&&!(xm(e[i-1],e[1],vm)&&xm(e[i-2],e[0],vm))&&(e.push(e[0],e[1]),i++),e}var D2=new se,Hoe=new se,joe=new se,qoe=new se,Xoe=new se,Koe=new se,is=class extends Py{constructor(e=100,t=100){super();this.points=[],this.shapeHoles=[],this.plane=new ji(new I(0,0,-1)),this.subdivision=0,this.controlSnapDistance=4,this.pointIDs=0,this.isMesh2D=!1,this._roundness=0,this.isClosed=!1,this.useCubicForRoundedCorners=!0,this.uuid=Kt.generateUUID(),this.needsUpdate=!1,this.roundedCurves=[],this._width=e,this._height=t}static createFromState(e,t,n){let s=new is;return s.isClosed=e.isClosed,s.points=e.points.map(r=>jd.create(r.id,r.data)),typeof e.roundness=="number"&&(s.roundness=e.roundness),s.shapeHoles=e.shapeHoles.map(r=>is.createFromState(r)),t!==void 0&&n!==void 0&&s.applySize(t,n),s.update(),s}get width(){return this._width}get height(){return this._height}get roundness(){return this._roundness}set roundness(e){if(this._roundness!==e){this._roundness=e;for(let t=0,n=this.points.length;t<n;t++)this.points[t].roundness=e;this.needsUpdate=!0}}getPointsIndexesByIds(e){return e.map(t=>this.getPointIndexById(t)).filter(t=>t>=0)}getPointIndexById(e){let t=this.points.length,n=this.points.findIndex(s=>s.uuid===e);if(n<0){let s=t;for(let r=0,i=this.shapeHoles.length;r<i;r++){let o=this.shapeHoles[r],a=o.points.length,l=o.getPointIndexById(e);if(l<0)s+=a;else return l+s}}return n}getLineIndexById(e){return this.getPointIndexById(e)}getBezierPoint(e){if(e<=this.points.length-1)return this.points[e];if(this.shapeHoles.length>0){let t=this.points.length;for(let n=0,s=this.shapeHoles.length;n<s;n++){let r=this.shapeHoles[n],i=e-t;if(i<=r.points.length-1)return r.points[i];t+=r.points.length}}throw new Error("This shape does not have a point for this index: "+e)}getBezierPointIndex(e){let t=this.points.indexOf(e);if(t>=0)return t;if(t=this.points.length,this.shapeHoles.length>0)for(let n=0,s=this.shapeHoles.length;n<s;n++){let r=this.shapeHoles[n],i=r.points.indexOf(e);if(i>=0)return t+i;t+=r.points.length}return-1}getAllPoints(){let e=[].concat(...this.shapeHoles.map(t=>t.points));return[...this.points,...e]}applySize(e,t){e===0&&(e=.001),t===0&&(t=.001),this._width=e,this._height=t}applyScale(e,t){let n=D2.set(e,t);for(let s=0,r=this.points.length;s<r;s++){let i=this.points[s];i.position.multiply(n),i.controls[0].position.multiply(n),i.controls[1].position.multiply(n)}for(let s=0,r=this.shapeHoles.length;s<r;s++)this.shapeHoles[s].applyScale(e,t);this._update()}createPoint(e,t=0,n=Kt.generateUUID()){let s;e instanceof se?s=e:s=new se(e,t);let r=new jd(n,s);return r.roundness=this.roundness,r}addPoint(e){this.points.push(e),this.needsUpdate=!0}addPointAt(e,t){this.points.splice(t,0,e),this.needsUpdate=!0}getPointByUuid(e){for(let t=0,n=this.points.length;t<n;t++){let s=this.points[t];if(s.uuid===e)return s}for(let t=0,n=this.shapeHoles.length;t<n;t++){let s=this.shapeHoles[t].getPointByUuid(e);if(s)return s}}getFirstPoint(){return this.points[0]}getLastPoint(){return this.points[this.points.length-1]}removePoint(e){let t=this.points.indexOf(e);t>=0&&this.points.splice(t,1),this.needsUpdate=!0}removePointById(e){let t=this.points.find(n=>n.uuid===e);t&&this.removePoint(t)}update(){for(let e=0,t=this.shapeHoles.length;e<t;e++)this.shapeHoles[e].update();this._update()}extractShapePointsToBuffer(e,t=12,n=!1){this.subdivision=t,this.curveDivisions===void 0&&this.computeCurveDivisions(t);let s=n?this.roundedCurveDivisions:this.curveDivisions;return Voe(e,n?this.roundedCurves:this.curves,t,this.autoClose),s.reduce((r,i)=>r+i,0)+1}computeCurveDivisions(e=12){return this.curveDivisions=VO(this.points,e,!1),this.roundedCurveDivisions=VO(this.points,e,!0),this.curveDivisions}extractFilteredShapePointsToBuffer(e,t,n=12){return Goe(e,this.curves,t,n,this.autoClose).reduce((s,r)=>s+r,0)*2}extractShapePointsToFlatArray(e,t=12){return this.subdivision=t,this.curveDivisions===void 0&&this.computeCurveDivisions(t),Woe(e,this.roundedCurves,t,this.autoClose)}getCurveIndexFromVertexId(e,t=!1){let n=0;this.curveDivisions===void 0&&this.computeCurveDivisions(this.subdivision);let s=t?this.roundedCurveDivisions:this.curveDivisions,r=0;t&&this.points[0].roundedCurveCorner!==void 0&&(r=$u(this.points[0].roundedCurveCorner,this.subdivision)*.5);let i=e-r;i<0&&(i+=s.reduce((o,a)=>o+a,0));for(let o=0,a=s.length;o<a;o++){let l=s[o];if(i<n+l)return[o,(i-n+1)/l];n+=l}return[0,1]}getCurveT(e,t,n){let s=this.points[e],r=this.points[e>=this.points.length-1?0:e+1],i=this.curveDivisions,o=i[e];if(zO(s,r)){let l=s.position.distanceTo(r.position);return s.position.distanceTo(D2.set(n.x,n.y))/l}let a=0;for(let l=0;l<e;l++)a+=i[l];return(t-a)/o}dispose(){}_applyCurveForPoint(e,t){zO(t,e)?this.lineTo(e.position.x,e.position.y):this.bezierCurveTo(t.controls[1].position.x,t.controls[1].position.y,e.controls[0].position.x,e.controls[0].position.y,e.position.x,e.position.y);let n=this.curves[this.curves.length-1];e.curveBefore=n,t.curveAfter=n;let s=n.clone();e.roundedCurveBefore=s,t.roundedCurveAfter=s,e.roundedCurveCorner=void 0,this.roundedCurves.push(s)}_update(){var t,n;if(this.curves=[],this.roundedCurves=[],!this.points.length)return;for(let s=0,r=this.points.length;s<r;s++){let i=this.points[s];if(s===0)this.moveTo(i.position.x,i.position.y);else{let o=this.points[s-1];this._applyCurveForPoint(i,o)}}let e=this.getLastPoint();if((e==null?void 0:e.curveAfter)&&(e.curveAfter=void 0),this.isClosed){let s=this.points[0],r=this.points[this.points.length-1];this._applyCurveForPoint(s,r)}if(this.points.length>2){let s=0;for(let r=0,i=this.points.length;r<i;r++){let o=this.points[r],a=(t=this.points[r-1])!=null?t:this.points[this.points.length-1],l=(n=this.points[r+1])!=null?n:this.points[0],c=o.roundness,h=a&&l&&Foe(a,o,l);if(!o.controlsMoved()&&c>0&&!h){let u=o.curveBefore,d=o.curveAfter;if(u===void 0||d===void 0)continue;let p=o.roundedCurveBefore,f=o.roundedCurveAfter,g=u.getLength(),m=d.getLength(),y=Math.min(c,g*.499),v=Math.min(c,m*.499),b=Math.min(y,v),x=1-b/g,w=b/m,S=u.getPointAt(x,D2),C=d.getPointAt(w,Hoe);this._subSplitCurve(u,p,x,S,void 0),this._subSplitCurve(d,f,w,void 0,C);let _;if(this.useCubicForRoundedCorners){let T=BO(S,o.position,C)/2,E=Math.tan(T)*S.distanceTo(o.position),[A,D]=$oe(S,C,E,joe,qoe),O=Boe(A,D,o.position),[P,L]=zoe(O,S,C,E,Xoe,Koe);_=new Mo(S.clone(),P.clone(),L.clone(),C.clone())}else _=new sc(S.clone(),o.position.clone(),C.clone());o.roundedCurveCorner=_,this.roundedCurves.splice(r+s,0,_),s++}}}}_subSplitCurve(e,t,n,s,r){if(e instanceof Po)s!==void 0&&t.v2.copy(s),r!==void 0&&t.v1.copy(r);else{let i=e,o=t,a=i.getUtoTmapping(n,0),l=Uoe(i.v0,i.v1,i.v2,i.v3,a);return s!==void 0&&(o.v0.set(l[0],l[1]),o.v1.set(l[2],l[3]),o.v2.set(l[4],l[5]),o.v3.set(l[6],l[7])),r!==void 0&&(o.v0.set(l[6],l[7]),o.v1.set(l[8],l[9]),o.v2.set(l[10],l[11]),o.v3.set(l[12],l[13])),o}return t}clone(){let e=new is(this._width,this._height);return e.points=this.points.map(t=>t.clone()),e.isClosed=this.isClosed,e.roundness=this.roundness,e.isMesh2D=this.isMesh2D,e.shapeHoles=this.shapeHoles.map(t=>t.clone()),e}toJSON(){return{points:this.points.reduce((e,t)=>e.concat(t.toJSON()),[]),shapeHoles:this.shapeHoles.map(e=>e.toJSON()),isClosed:this.isClosed,roundness:this.roundness}}fromJSON(e){var n;this.points=[],this.pointIDs=0;let t=e.points.length/7;for(let s=0;s<t;s++){let r=s*7,i=e.points[r+0],o=e.points[r+1],a=e.points[r+2],l=e.points[r+3],c=e.points[r+4],h=e.points[r+5],u=e.points[r+6],d=new jd(Kt.generateUUID(),new se(i,o));d.controls[0].position.set(a,l),d.controls[1].position.set(c,h),d.roundness=u,this.points.push(d)}return this.shapeHoles=((n=e.shapeHoles)==null?void 0:n.length)?e.shapeHoles.map(s=>{let r=new is;return r.fromJSON(s),r}):[],this.isClosed=e.isClosed,this._roundness=e.roundness,this._update(),this}fromShape(e){let t=(s,r)=>{r instanceof Mo&&r.v3.equals(s.position)&&s.controls[0].position.copy(r.v2)},n=s=>{let r=[],i,o;for(i=0,o=s.length;i<o;i++)s[i]instanceof sc&&(s[i]=Ooe(s[i]));for(i=0,o=s.length;i<o;i++){let c=s[i],h=i>0?s[i-1]:null,u;c instanceof Mo?(u=this.createPoint(c.v0),u.controls[1].position.copy(c.v1)):c instanceof Po&&(u=this.createPoint(c.v1)),u!==void 0&&(h!==null&&t(u,h),r.push(u))}let a=s[s.length-1],l=!1;return a instanceof Mo?a.v3.equals(r[0].position)&&(r[0].controls[0].position.copy(a.v2),l=!0):a instanceof Po&&a.v2.equals(r[0].position)&&(l=!0),this.isClosed=l,r};return this.points=n(e.curves),e instanceof Py&&(this.shapeHoles=e.holes.map(s=>{let r=new is;return r.fromShape(s),r})),this.update(),this}updatePoint(e,t){let n=this.getPointByUuid(e);n&&(t.position!==void 0&&n.position.fromArray(t.position),t.roundness!==void 0&&(n.roundness=t.roundness),t.areControlsDirectionsMirrored!==void 0&&(n.areControlsDirectionsMirrored=t.areControlsDirectionsMirrored),this.needsUpdate=!0)}updatePreviousControl(e,t){var s;let n=(s=this.getPointByUuid(e))==null?void 0:s.controls[0];n&&(t.position&&n.position.fromArray(t.position),this.needsUpdate=!0)}updateNextControl(e,t){var s;let n=(s=this.getPointByUuid(e))==null?void 0:s.controls[1];n&&(t.position&&n.position.fromArray(t.position),this.needsUpdate=!0)}},M2=Math.PI*2;function P2({x:e,y:t},n,s,r,i){return{x:e*n+r,y:t*s+i}}function Yoe(e,t){let n=t===1.5707963267948966?.551915024494:t===-1.5707963267948966?-.551915024494:1.3333333333333333*Math.tan(t/4),s=Math.cos(e),r=Math.sin(e),i=Math.cos(e+t),o=Math.sin(e+t);return[{x:s-r*n,y:r+s*n},{x:i+o*n,y:o-i*n},{x:i,y:o}]}function GO(e,t,n,s){let r=e*s-t*n<0?-1:1,i=Math.min(1,Math.max(-1,e*n+t*s));return r*Math.acos(i)}function Qoe(e,t,n,s,r,i,o,a,l,c){let h=Math.pow(r,2),u=Math.pow(i,2),d=Math.pow(o,2),p=Math.pow(a,2),f=h*u-h*p-u*d;f<0&&(f=0),f/=h*p+u*d,f=Math.sqrt(f)*(l===c?-1:1);let g=f*r/i*a,m=f*-i/r*o,y=g+(e+n)/2,v=m+(t+s)/2,b=(o-g)/r,x=(a-m)/i,w=(-o-g)/r,S=(-a-m)/i,C=GO(1,0,b,x),_=GO(b,x,w,S);return!c&&_>0&&(_-=M2),c&&_<0&&(_+=M2),{centerx:y,centery:v,ang1:C,ang2:_}}function Zoe({px:e,py:t,cx:n,cy:s,rx:r,ry:i,largeArcFlag:o,sweepFlag:a}){let l=[];if(r===0||i===0)return[];let c=(e-n)/2,h=(t-s)/2;if(c===0&&h===0)return[];r=Math.abs(r),i=Math.abs(i);let u=Math.pow(c,2)/Math.pow(r,2)+Math.pow(h,2)/Math.pow(i,2);u>1&&(r*=Math.sqrt(u),i*=Math.sqrt(u));let d=Qoe(e,t,n,s,r,i,c,h,o,a),{ang1:p,ang2:f}=d,{centerx:g,centery:m}=d,y=Math.abs(f)/(M2/4);Math.abs(1-y)<1e-7&&(y=1);let v=Math.max(Math.ceil(y),1);f/=v;for(let b=0;b<v;b++)l.push(Yoe(p,f)),p+=f;return l.map(b=>{let{x,y:w}=P2(b[0],r,i,g,m),{x:S,y:C}=P2(b[1],r,i,g,m),{x:_,y:T}=P2(b[2],r,i,g,m);return{x1:x,y1:w,x2:S,y2:C,x:_,y:T}})}var Wn;(function(e){e[e.ODD=0]="ODD",e[e.NONZERO=1]="NONZERO",e[e.POSITIVE=2]="POSITIVE",e[e.NEGATIVE=3]="NEGATIVE",e[e.ABS_GEQ_TWO=4]="ABS_GEQ_TWO"})(Wn||(Wn={}));var ir;(function(e){e[e.POLYGONS=0]="POLYGONS",e[e.CONNECTED_POLYGONS=1]="CONNECTED_POLYGONS",e[e.BOUNDARY_CONTOURS=2]="BOUNDARY_CONTOURS"})(ir||(ir={}));function Ct(e,t){if(!e)throw t||"Assertion Failed!"}var vt=function(){function e(){}return e.vertEq=function(t,n){return t.s===n.s&&t.t===n.t},e.vertLeq=function(t,n){return t.s<n.s||t.s===n.s&&t.t<=n.t},e.transLeq=function(t,n){return t.t<n.t||t.t===n.t&&t.s<=n.s},e.edgeGoesLeft=function(t){return e.vertLeq(t.Dst,t.Org)},e.edgeGoesRight=function(t){return e.vertLeq(t.Org,t.Dst)},e.vertL1dist=function(t,n){return Math.abs(t.s-n.s)+Math.abs(t.t-n.t)},e.edgeEval=function(t,n,s){Ct(e.vertLeq(t,n)&&e.vertLeq(n,s));var r=n.s-t.s,i=s.s-n.s;return r+i>0?r<i?n.t-t.t+(t.t-s.t)*(r/(r+i)):n.t-s.t+(s.t-t.t)*(i/(r+i)):0},e.edgeSign=function(t,n,s){Ct(e.vertLeq(t,n)&&e.vertLeq(n,s));var r=n.s-t.s,i=s.s-n.s;return r+i>0?(n.t-s.t)*r+(n.t-t.t)*i:0},e.transEval=function(t,n,s){Ct(e.transLeq(t,n)&&e.transLeq(n,s));var r=n.t-t.t,i=s.t-n.t;return r+i>0?r<i?n.s-t.s+(t.s-s.s)*(r/(r+i)):n.s-s.s+(s.s-t.s)*(i/(r+i)):0},e.transSign=function(t,n,s){Ct(e.transLeq(t,n)&&e.transLeq(n,s));var r=n.t-t.t,i=s.t-n.t;return r+i>0?(n.s-s.s)*r+(n.s-t.s)*i:0},e.vertCCW=function(t,n,s){return t.s*(n.t-s.t)+n.s*(s.t-t.t)+s.s*(t.t-n.t)>=0},e.interpolate=function(t,n,s,r){return t=t<0?0:t,s=s<0?0:s,t<=s?s===0?(n+r)/2:n+(r-n)*(t/(t+s)):r+(n-r)*(s/(t+s))},e.intersect=function(t,n,s,r,i){var o,a,l;e.vertLeq(t,n)||(l=t,t=n,n=l),e.vertLeq(s,r)||(l=s,s=r,r=l),e.vertLeq(t,s)||(l=t,t=s,s=l,l=n,n=r,r=l),e.vertLeq(s,n)?e.vertLeq(n,r)?(o=e.edgeEval(t,s,n),a=e.edgeEval(s,n,r),o+a<0&&(o=-o,a=-a),i.s=e.interpolate(o,s.s,a,n.s)):(o=e.edgeSign(t,s,n),a=-e.edgeSign(t,r,n),o+a<0&&(o=-o,a=-a),i.s=e.interpolate(o,s.s,a,r.s)):i.s=(s.s+n.s)/2,e.transLeq(t,n)||(l=t,t=n,n=l),e.transLeq(s,r)||(l=s,s=r,r=l),e.transLeq(t,s)||(l=t,t=s,s=l,l=n,n=r,r=l),e.transLeq(s,n)?e.transLeq(n,r)?(o=e.transEval(t,s,n),a=e.transEval(s,n,r),o+a<0&&(o=-o,a=-a),i.t=e.interpolate(o,s.t,a,n.t)):(o=e.transSign(t,s,n),a=-e.transSign(t,r,n),o+a<0&&(o=-o,a=-a),i.t=e.interpolate(o,s.t,a,r.t)):i.t=(s.t+n.t)/2},e}(),bm=function(){function e(){this.next=null,this.prev=null,this.anEdge=null,this.trail=null,this.n=0,this.marked=!1,this.inside=!1}return e}(),Yv=function(){function e(t){this.side=t,this.next=null,this.Org=null,this.Sym=null,this.Onext=null,this.Lnext=null,this.Lface=null,this.activeRegion=null,this.winding=0}return Object.defineProperty(e.prototype,"Rface",{get:function(){return this.Sym.Lface},set:function(t){this.Sym.Lface=t},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"Dst",{get:function(){return this.Sym.Org},set:function(t){this.Sym.Org=t},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"Oprev",{get:function(){return this.Sym.Lnext},set:function(t){this.Sym.Lnext=t},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"Lprev",{get:function(){return this.Onext.Sym},set:function(t){this.Onext.Sym=t},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"Dprev",{get:function(){return this.Lnext.Sym},set:function(t){this.Lnext.Sym=t},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"Rprev",{get:function(){return this.Sym.Onext},set:function(t){this.Sym.Onext=t},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"Dnext",{get:function(){return this.Sym.Onext.Sym},set:function(t){this.Sym.Onext.Sym=t},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"Rnext",{get:function(){return this.Sym.Lnext.Sym},set:function(t){this.Sym.Lnext.Sym=t},enumerable:!0,configurable:!0}),e}(),Xd=function(){function e(){this.next=null,this.prev=null,this.anEdge=null,this.coords=[0,0,0],this.s=0,this.t=0,this.pqHandle=0,this.n=0,this.idx=0}return e}(),WO=function(){function e(){var t=new Xd,n=new bm,s=new Yv(0),r=new Yv(1);t.next=t.prev=t,t.anEdge=null,n.next=n.prev=n,s.next=s,s.Sym=r,r.next=r,r.Sym=s,this.vHead=t,this.fHead=n,this.eHead=s,this.eHeadSym=r}return e.prototype.makeEdge_=function(t){var n=new Yv(0),s=new Yv(1);t.Sym.side<t.side&&(t=t.Sym);var r=t.Sym.next;return s.next=r,r.Sym.next=n,n.next=t,t.Sym.next=s,n.Sym=s,n.Onext=n,n.Lnext=s,n.Org=null,n.Lface=null,n.winding=0,n.activeRegion=null,s.Sym=n,s.Onext=s,s.Lnext=n,s.Org=null,s.Lface=null,s.winding=0,s.activeRegion=null,n},e.prototype.splice_=function(t,n){var s=t.Onext,r=n.Onext;s.Sym.Lnext=n,r.Sym.Lnext=t,t.Onext=r,n.Onext=s},e.prototype.makeVertex_=function(t,n,s){var r=t;Ct(r,"Vertex can't be null!");var i=s.prev;r.prev=i,i.next=r,r.next=s,s.prev=r,r.anEdge=n;var o=n;do o.Org=r,o=o.Onext;while(o!==n)},e.prototype.makeFace_=function(t,n,s){var r=t;Ct(r,"Face can't be null");var i=s.prev;r.prev=i,i.next=r,r.next=s,s.prev=r,r.anEdge=n,r.trail=null,r.marked=!1,r.inside=s.inside;var o=n;do o.Lface=r,o=o.Lnext;while(o!==n)},e.prototype.killEdge_=function(t){t.Sym.side<t.side&&(t=t.Sym);var n=t.next,s=t.Sym.next;n.Sym.next=s,s.Sym.next=n},e.prototype.killVertex_=function(t,n){var s=t.anEdge,r=s;do r.Org=n,r=r.Onext;while(r!==s);var i=t.prev,o=t.next;o.prev=i,i.next=o},e.prototype.killFace_=function(t,n){var s=t.anEdge,r=s;do r.Lface=n,r=r.Lnext;while(r!==s);var i=t.prev,o=t.next;o.prev=i,i.next=o},e.prototype.makeEdge=function(){var t=new Xd,n=new Xd,s=new bm,r=this.makeEdge_(this.eHead);return this.makeVertex_(t,r,this.vHead),this.makeVertex_(n,r.Sym,this.vHead),this.makeFace_(s,r,this.fHead),r},e.prototype.splice=function(t,n){var s=!1,r=!1;if(t!==n){if(n.Org!==t.Org&&(r=!0,this.killVertex_(n.Org,t.Org)),n.Lface!==t.Lface&&(s=!0,this.killFace_(n.Lface,t.Lface)),this.splice_(n,t),!r){var i=new Xd;this.makeVertex_(i,n,t.Org),t.Org.anEdge=t}if(!s){var o=new bm;this.makeFace_(o,n,t.Lface),t.Lface.anEdge=t}}},e.prototype.delete=function(t){var n=t.Sym,s=!1;if(t.Lface!==t.Rface&&(s=!0,this.killFace_(t.Lface,t.Rface)),t.Onext===t)this.killVertex_(t.Org,null);else if(t.Rface.anEdge=t.Oprev,t.Org.anEdge=t.Onext,this.splice_(t,t.Oprev),!s){var r=new bm;this.makeFace_(r,t,t.Lface)}n.Onext===n?(this.killVertex_(n.Org,null),this.killFace_(n.Lface,null)):(t.Lface.anEdge=n.Oprev,n.Org.anEdge=n.Onext,this.splice_(n,n.Oprev)),this.killEdge_(t)},e.prototype.addEdgeVertex=function(t){var n=this.makeEdge_(t),s=n.Sym;this.splice_(n,t.Lnext),n.Org=t.Dst;var r=new Xd;return this.makeVertex_(r,s,n.Org),n.Lface=s.Lface=t.Lface,n},e.prototype.splitEdge=function(t){var n=this.addEdgeVertex(t),s=n.Sym;return this.splice_(t.Sym,t.Sym.Oprev),this.splice_(t.Sym,s),t.Dst=s.Org,s.Dst.anEdge=s.Sym,s.Rface=t.Rface,s.winding=t.winding,s.Sym.winding=t.Sym.winding,s.idx=t.idx,s.Sym.idx=t.Sym.idx,s},e.prototype.connect=function(t,n){var s=!1,r=this.makeEdge_(t),i=r.Sym;if(n.Lface!==t.Lface&&(s=!0,this.killFace_(n.Lface,t.Lface)),this.splice_(r,t.Lnext),this.splice_(i,n),r.Org=t.Dst,i.Org=n.Org,r.Lface=i.Lface=t.Lface,t.Lface.anEdge=i,!s){var o=new bm;this.makeFace_(o,r,t.Lface)}return r},e.prototype.zapFace=function(t){var n=t.anEdge,s,r,i,o,a;r=n.Lnext;do s=r,r=s.Lnext,s.Lface=null,s.Rface===null&&(s.Onext===s?this.killVertex_(s.Org,null):(s.Org.anEdge=s.Onext,this.splice_(s,s.Oprev)),i=s.Sym,i.Onext===i?this.killVertex_(i.Org,null):(i.Org.anEdge=i.Onext,this.splice_(i,i.Oprev)),this.killEdge_(s));while(s!=n);o=t.prev,a=t.next,a.prev=o,o.next=a},e.prototype.countFaceVerts_=function(t){var n=t.anEdge,s=0;do s++,n=n.Lnext;while(n!==t.anEdge);return s},e.prototype.mergeConvexFaces=function(t){var n,s,r,i,o,a,l;for(n=this.fHead.next;n!==this.fHead;n=n.next)if(n.inside)for(s=n.anEdge,o=s.Org;r=s.Lnext,i=s.Sym,i&&i.Lface&&i.Lface.inside&&(a=this.countFaceVerts_(n),l=this.countFaceVerts_(i.Lface),a+l-2<=t&&vt.vertCCW(s.Lprev.Org,s.Org,i.Lnext.Lnext.Org)&&vt.vertCCW(i.Lprev.Org,i.Org,s.Lnext.Lnext.Org)&&(r=i.Lnext,this.delete(i),s=null,i=null)),!(s&&s.Lnext.Org===o);)s=r;return!0},e.prototype.check=function(){var t=this.fHead,n=this.vHead,s=this.eHead,r,i,o,a,l,c;for(i=t,i=t;(r=i.next)!==t;i=r){Ct(r.prev===i),l=r.anEdge;do Ct(l.Sym!==l),Ct(l.Sym.Sym===l),Ct(l.Lnext.Onext.Sym===l),Ct(l.Onext.Sym.Lnext===l),Ct(l.Lface===r),l=l.Lnext;while(l!==r.anEdge)}for(Ct(r.prev===i&&r.anEdge===null),a=n,a=n;(o=a.next)!==n;a=o){Ct(o.prev===a),l=o.anEdge;do Ct(l.Sym!==l),Ct(l.Sym.Sym===l),Ct(l.Lnext.Onext.Sym===l),Ct(l.Onext.Sym.Lnext===l),Ct(l.Org===o),l=l.Onext;while(l!==o.anEdge)}for(Ct(o.prev===a&&o.anEdge===null),c=s,c=s;(l=c.next)!==s;c=l)Ct(l.Sym.next===c.Sym),Ct(l.Sym!==l),Ct(l.Sym.Sym===l),Ct(l.Org!==null),Ct(l.Dst!==null),Ct(l.Lnext.Onext.Sym===l),Ct(l.Onext.Sym.Lnext===l);Ct(l.Sym.next===c.Sym&&l.Sym===this.eHeadSym&&l.Sym.Sym===l&&l.Org===null&&l.Dst===null&&l.Lface===null&&l.Rface===null)},e}(),HO=function(){function e(){this.handle=null}return e}(),jO=function(){function e(){this.key=null,this.node=0}return e}(),Joe=function(){function e(t,n){this.leq=n,this.max=0,this.nodes=[],this.handles=[],this.initialized=!1,this.freeList=0,this.size=0,this.max=t,this.nodes=[],this.handles=[];for(var s=0;s<t+1;s++)this.nodes[s]=new HO,this.handles[s]=new jO;this.initialized=!1,this.nodes[1].handle=1,this.handles[1].key=null}return e.prototype.floatDown_=function(t){var n=this.nodes,s=this.handles,r,i,o;for(r=n[t].handle;;){if(o=t<<1,o<this.size&&this.leq(s[n[o+1].handle].key,s[n[o].handle].key)&&++o,Ct(o<=this.max),i=n[o].handle,o>this.size||this.leq(s[r].key,s[i].key)){n[t].handle=r,s[r].node=t;break}n[t].handle=i,s[i].node=t,t=o}},e.prototype.floatUp_=function(t){var n=this.nodes,s=this.handles,r,i,o;for(r=n[t].handle;;){if(o=t>>1,i=n[o].handle,o===0||this.leq(s[i].key,s[r].key)){n[t].handle=r,s[r].node=t;break}n[t].handle=i,s[i].node=t,t=o}},e.prototype.init=function(){for(var t=this.size;t>=1;--t)this.floatDown_(t);this.initialized=!0},e.prototype.min=function(){return this.handles[this.nodes[1].handle].key},e.prototype.insert=function(t){var n,s;if(n=++this.size,n*2>this.max){this.max*=2;var r,i;for(i=this.nodes.length,this.nodes.length=this.max+1,r=i;r<this.nodes.length;r++)this.nodes[r]=new HO;for(i=this.handles.length,this.handles.length=this.max+1,r=i;r<this.handles.length;r++)this.handles[r]=new jO}return this.freeList===0?s=n:(s=this.freeList,this.freeList=this.handles[s].node),this.nodes[n].handle=s,this.handles[s].node=n,this.handles[s].key=t,this.initialized&&this.floatUp_(n),s},e.prototype.extractMin=function(){var t=this.nodes,n=this.handles,s=t[1].handle,r=n[s].key;return this.size>0&&(t[1].handle=t[this.size].handle,n[t[1].handle].node=1,n[s].key=null,n[s].node=this.freeList,this.freeList=s,--this.size,this.size>0&&this.floatDown_(1)),r},e.prototype.delete=function(t){var n=this.nodes,s=this.handles,r;Ct(t>=1&&t<=this.max&&s[t].key!==null),r=s[t].node,n[r].handle=n[this.size].handle,s[n[r].handle].node=r,--this.size,r<=this.size&&(r<=1||this.leq(s[n[r>>1].handle].key,s[n[r].handle].key)?this.floatDown_(r):this.floatUp_(r)),s[t].key=null,s[t].node=this.freeList,this.freeList=t},e}(),O2=function(){function e(){this.eUp=null,this.nodeUp=null,this.windingNumber=0,this.inside=!1,this.sentinel=!1,this.dirty=!1,this.fixUpperEdge=!1}return e}(),qO=function(){function e(){this.key=null,this.next=null,this.prev=null}return e}(),eae=function(){function e(t,n){this.frame=t,this.leq=n,this.head=new qO,this.head.next=this.head,this.head.prev=this.head}return e.prototype.min=function(){return this.head.next},e.prototype.max=function(){return this.head.prev},e.prototype.insert=function(t){return this.insertBefore(this.head,t)},e.prototype.search=function(t){var n=this.head;do n=n.next;while(n.key!==null&&!this.leq(this.frame,t,n.key));return n},e.prototype.insertBefore=function(t,n){do t=t.prev;while(t.key!==null&&!this.leq(this.frame,t.key,n));var s=new qO;return s.key=n,s.next=t.next,t.next.prev=s,s.prev=t,t.next=s,s},e.prototype.delete=function(t){t.next.prev=t.prev,t.prev.next=t.next},e}(),tae=function(){function e(){}return e.regionBelow=function(t){return t.nodeUp.prev.key},e.regionAbove=function(t){return t.nodeUp.next.key},e.debugEvent=function(t){},e.addWinding=function(t,n){t.winding+=n.winding,t.Sym.winding+=n.Sym.winding},e.edgeLeq=function(t,n,s){var r=t.event,i=n.eUp,o=s.eUp;if(i.Dst===r)return o.Dst===r?vt.vertLeq(i.Org,o.Org)?vt.edgeSign(o.Dst,i.Org,o.Org)<=0:vt.edgeSign(i.Dst,o.Org,i.Org)>=0:vt.edgeSign(o.Dst,r,o.Org)<=0;if(o.Dst===r)return vt.edgeSign(i.Dst,r,i.Org)>=0;var a=vt.edgeEval(i.Dst,r,i.Org),l=vt.edgeEval(o.Dst,r,o.Org);return a>=l},e.deleteRegion=function(t,n){n.fixUpperEdge&&Ct(n.eUp.winding===0),n.eUp.activeRegion=null,t.dict.delete(n.nodeUp)},e.fixUpperEdge=function(t,n,s){Ct(n.fixUpperEdge),t.mesh.delete(n.eUp),n.fixUpperEdge=!1,n.eUp=s,s.activeRegion=n},e.topLeftRegion=function(t,n){var s=n.eUp.Org,r;do n=e.regionAbove(n);while(n.eUp.Org===s);if(n.fixUpperEdge){if(r=t.mesh.connect(e.regionBelow(n).eUp.Sym,n.eUp.Lnext),r===null)return null;e.fixUpperEdge(t,n,r),n=e.regionAbove(n)}return n},e.topRightRegion=function(t){var n=t.eUp.Dst;do t=e.regionAbove(t);while(t.eUp.Dst===n);return t},e.addRegionBelow=function(t,n,s){var r=new O2;return r.eUp=s,r.nodeUp=t.dict.insertBefore(n.nodeUp,r),r.fixUpperEdge=!1,r.sentinel=!1,r.dirty=!1,s.activeRegion=r,r},e.isWindingInside=function(t,n){switch(t.windingRule){case Wn.ODD:return(n&1)!=0;case Wn.NONZERO:return n!==0;case Wn.POSITIVE:return n>0;case Wn.NEGATIVE:return n<0;case Wn.ABS_GEQ_TWO:return n>=2||n<=-2}throw new Error("Invalid winding rulle")},e.computeWinding=function(t,n){n.windingNumber=e.regionAbove(n).windingNumber+n.eUp.winding,n.inside=e.isWindingInside(t,n.windingNumber)},e.finishRegion=function(t,n){var s=n.eUp,r=s.Lface;r.inside=n.inside,r.anEdge=s,e.deleteRegion(t,n)},e.finishLeftRegions=function(t,n,s){for(var r,i=null,o=n,a=n.eUp;o!==s;){if(o.fixUpperEdge=!1,i=e.regionBelow(o),r=i.eUp,r.Org!=a.Org){if(!i.fixUpperEdge){e.finishRegion(t,o);break}r=t.mesh.connect(a.Lprev,r.Sym),e.fixUpperEdge(t,i,r)}a.Onext!==r&&(t.mesh.splice(r.Oprev,r),t.mesh.splice(a,r)),e.finishRegion(t,o),a=i.eUp,o=i}return a},e.addRightEdges=function(t,n,s,r,i,o){var a,l,c,h,u=!0;c=s;do Ct(vt.vertLeq(c.Org,c.Dst)),e.addRegionBelow(t,n,c.Sym),c=c.Onext;while(c!==r);for(i===null&&(i=e.regionBelow(n).eUp.Rprev),l=n,h=i;a=e.regionBelow(l),c=a.eUp.Sym,c.Org===h.Org;)c.Onext!==h&&(t.mesh.splice(c.Oprev,c),t.mesh.splice(h.Oprev,c)),a.windingNumber=l.windingNumber-c.winding,a.inside=e.isWindingInside(t,a.windingNumber),l.dirty=!0,!u&&e.checkForRightSplice(t,l)&&(e.addWinding(c,h),e.deleteRegion(t,l),t.mesh.delete(h)),u=!1,l=a,h=c;l.dirty=!0,Ct(l.windingNumber-c.winding===a.windingNumber),o&&e.walkDirtyRegions(t,l)},e.spliceMergeVertices=function(t,n,s){t.mesh.splice(n,s)},e.vertexWeights=function(t,n,s){var r=vt.vertL1dist(n,t),i=vt.vertL1dist(s,t),o=.5*i/(r+i),a=.5*r/(r+i);t.coords[0]+=o*n.coords[0]+a*s.coords[0],t.coords[1]+=o*n.coords[1]+a*s.coords[1],t.coords[2]+=o*n.coords[2]+a*s.coords[2]},e.getIntersectData=function(t,n,s,r,i,o){n.coords[0]=n.coords[1]=n.coords[2]=0,n.idx=-1,e.vertexWeights(n,s,r),e.vertexWeights(n,i,o)},e.checkForRightSplice=function(t,n){var s=e.regionBelow(n),r=n.eUp,i=s.eUp;if(vt.vertLeq(r.Org,i.Org)){if(vt.edgeSign(i.Dst,r.Org,i.Org)>0)return!1;vt.vertEq(r.Org,i.Org)?r.Org!==i.Org&&(t.pq.delete(r.Org.pqHandle),e.spliceMergeVertices(t,i.Oprev,r)):(t.mesh.splitEdge(i.Sym),t.mesh.splice(r,i.Oprev),n.dirty=s.dirty=!0)}else{if(vt.edgeSign(r.Dst,i.Org,r.Org)<0)return!1;e.regionAbove(n).dirty=n.dirty=!0,t.mesh.splitEdge(r.Sym),t.mesh.splice(i.Oprev,r)}return!0},e.checkForLeftSplice=function(t,n){var s=e.regionBelow(n),r=n.eUp,i=s.eUp,o;if(Ct(!vt.vertEq(r.Dst,i.Dst)),vt.vertLeq(r.Dst,i.Dst)){if(vt.edgeSign(r.Dst,i.Dst,r.Org)<0)return!1;e.regionAbove(n).dirty=n.dirty=!0,o=t.mesh.splitEdge(r),t.mesh.splice(i.Sym,o),o.Lface.inside=n.inside}else{if(vt.edgeSign(i.Dst,r.Dst,i.Org)>0)return!1;n.dirty=s.dirty=!0,o=t.mesh.splitEdge(i),t.mesh.splice(r.Lnext,i.Sym),o.Rface.inside=n.inside}return!0},e.checkForIntersect=function(t,n){var s=e.regionBelow(n),r=n.eUp,i=s.eUp,o=r.Org,a=i.Org,l=r.Dst,c=i.Dst,h,u,d=new Xd,p,f;if(Ct(!vt.vertEq(c,l)),Ct(vt.edgeSign(l,t.event,o)<=0),Ct(vt.edgeSign(c,t.event,a)>=0),Ct(o!==t.event&&a!==t.event),Ct(!n.fixUpperEdge&&!s.fixUpperEdge),o===a||(h=Math.min(o.t,l.t),u=Math.max(a.t,c.t),h>u))return!1;if(vt.vertLeq(o,a)){if(vt.edgeSign(c,o,a)>0)return!1}else if(vt.edgeSign(l,a,o)<0)return!1;return e.debugEvent(t),vt.intersect(l,o,c,a,d),Ct(Math.min(o.t,l.t)<=d.t),Ct(d.t<=Math.max(a.t,c.t)),Ct(Math.min(c.s,l.s)<=d.s),Ct(d.s<=Math.max(a.s,o.s)),vt.vertLeq(d,t.event)&&(d.s=t.event.s,d.t=t.event.t),p=vt.vertLeq(o,a)?o:a,vt.vertLeq(p,d)&&(d.s=p.s,d.t=p.t),vt.vertEq(d,o)||vt.vertEq(d,a)?(e.checkForRightSplice(t,n),!1):!vt.vertEq(l,t.event)&&vt.edgeSign(l,t.event,d)>=0||!vt.vertEq(c,t.event)&&vt.edgeSign(c,t.event,d)<=0?c===t.event?(t.mesh.splitEdge(r.Sym),t.mesh.splice(i.Sym,r),n=e.topLeftRegion(t,n),r=e.regionBelow(n).eUp,e.finishLeftRegions(t,e.regionBelow(n),s),e.addRightEdges(t,n,r.Oprev,r,r,!0),!0):l===t.event?(t.mesh.splitEdge(i.Sym),t.mesh.splice(r.Lnext,i.Oprev),s=n,n=e.topRightRegion(n),f=e.regionBelow(n).eUp.Rprev,s.eUp=i.Oprev,i=e.finishLeftRegions(t,s,null),e.addRightEdges(t,n,i.Onext,r.Rprev,f,!0),!0):(vt.edgeSign(l,t.event,d)>=0&&(e.regionAbove(n).dirty=n.dirty=!0,t.mesh.splitEdge(r.Sym),r.Org.s=t.event.s,r.Org.t=t.event.t),vt.edgeSign(c,t.event,d)<=0&&(n.dirty=s.dirty=!0,t.mesh.splitEdge(i.Sym),i.Org.s=t.event.s,i.Org.t=t.event.t),!1):(t.mesh.splitEdge(r.Sym),t.mesh.splitEdge(i.Sym),t.mesh.splice(i.Oprev,r),r.Org.s=d.s,r.Org.t=d.t,r.Org.pqHandle=t.pq.insert(r.Org),e.getIntersectData(t,r.Org,o,l,a,c),e.regionAbove(n).dirty=n.dirty=s.dirty=!0,!1)},e.walkDirtyRegions=function(t,n){for(var s=e.regionBelow(n),r,i;;){for(;s.dirty;)n=s,s=e.regionBelow(s);if(!n.dirty&&(s=n,n=e.regionAbove(n),n===null||!n.dirty))return;if(n.dirty=!1,r=n.eUp,i=s.eUp,r.Dst!==i.Dst&&e.checkForLeftSplice(t,n)&&(s.fixUpperEdge?(e.deleteRegion(t,s),t.mesh.delete(i),s=e.regionBelow(n),i=s.eUp):n.fixUpperEdge&&(e.deleteRegion(t,n),t.mesh.delete(r),n=e.regionAbove(s),r=n.eUp)),r.Org!==i.Org)if(r.Dst!==i.Dst&&!n.fixUpperEdge&&!s.fixUpperEdge&&(r.Dst===t.event||i.Dst===t.event)){if(e.checkForIntersect(t,n))return}else e.checkForRightSplice(t,n);r.Org===i.Org&&r.Dst===i.Dst&&(e.addWinding(i,r),e.deleteRegion(t,n),t.mesh.delete(r),n=e.regionAbove(s))}},e.connectRightVertex=function(t,n,s){var r,i=s.Onext,o=e.regionBelow(n),a=n.eUp,l=o.eUp,c=!1;if(a.Dst!==l.Dst&&e.checkForIntersect(t,n),vt.vertEq(a.Org,t.event)&&(t.mesh.splice(i.Oprev,a),n=e.topLeftRegion(t,n),i=e.regionBelow(n).eUp,e.finishLeftRegions(t,e.regionBelow(n),o),c=!0),vt.vertEq(l.Org,t.event)&&(t.mesh.splice(s,l.Oprev),s=e.finishLeftRegions(t,o,null),c=!0),c){e.addRightEdges(t,n,s.Onext,i,i,!0);return}vt.vertLeq(l.Org,a.Org)?r=l.Oprev:r=a,r=t.mesh.connect(s.Lprev,r),e.addRightEdges(t,n,r,r.Onext,r.Onext,!1),r.Sym.activeRegion.fixUpperEdge=!0,e.walkDirtyRegions(t,n)},e.connectLeftDegenerate=function(t,n,s){var r,i,o,a,l;if(r=n.eUp,vt.vertEq(r.Org,s)){Ct(!1),e.spliceMergeVertices(t,r,s.anEdge);return}if(!vt.vertEq(r.Dst,s)){t.mesh.splitEdge(r.Sym),n.fixUpperEdge&&(t.mesh.delete(r.Onext),n.fixUpperEdge=!1),t.mesh.splice(s.anEdge,r),e.sweepEvent(t,s);return}Ct(!1),n=e.topRightRegion(n),l=e.regionBelow(n),o=l.eUp.Sym,i=a=o.Onext,l.fixUpperEdge&&(Ct(i!==o),e.deleteRegion(t,l),t.mesh.delete(o),o=i.Oprev),t.mesh.splice(s.anEdge,o),vt.edgeGoesLeft(i)||(i=null),e.addRightEdges(t,n,o.Onext,a,i,!0)},e.connectLeftVertex=function(t,n){var s,r,i,o,a,l,c=new O2;if(c.eUp=n.anEdge.Sym,s=t.dict.search(c).key,r=e.regionBelow(s),!!r){if(o=s.eUp,a=r.eUp,vt.edgeSign(o.Dst,n,o.Org)===0){e.connectLeftDegenerate(t,s,n);return}if(i=vt.vertLeq(a.Dst,o.Dst)?s:r,s.inside||i.fixUpperEdge){if(i===s)l=t.mesh.connect(n.anEdge.Sym,o.Lnext);else{var h=t.mesh.connect(a.Dnext,n.anEdge);l=h.Sym}i.fixUpperEdge?e.fixUpperEdge(t,i,l):e.computeWinding(t,e.addRegionBelow(t,s,l)),e.sweepEvent(t,n)}else e.addRightEdges(t,s,n.anEdge,n.anEdge,null,!0)}},e.sweepEvent=function(t,n){t.event=n,e.debugEvent(t);for(var s=n.anEdge;s.activeRegion===null;)if(s=s.Onext,s===n.anEdge){e.connectLeftVertex(t,n);return}var r=e.topLeftRegion(t,s.activeRegion);Ct(r!==null);var i=e.regionBelow(r),o=i.eUp,a=e.finishLeftRegions(t,i,null);a.Onext===o?e.connectRightVertex(t,r,a):e.addRightEdges(t,r,a.Onext,o,o,!0)},e.addSentinel=function(t,n,s,r){var i=new O2,o=t.mesh.makeEdge();o.Org.s=s,o.Org.t=r,o.Dst.s=n,o.Dst.t=r,t.event=o.Dst,i.eUp=o,i.windingNumber=0,i.inside=!1,i.fixUpperEdge=!1,i.sentinel=!0,i.dirty=!1,i.nodeUp=t.dict.insert(i)},e.initEdgeDict=function(t){t.dict=new eae(t,e.edgeLeq);var n=t.bmax[0]-t.bmin[0],s=t.bmax[1]-t.bmin[1],r=t.bmin[0]-n,i=t.bmax[0]+n,o=t.bmin[1]-s,a=t.bmax[1]+s;e.addSentinel(t,r,i,o),e.addSentinel(t,r,i,a)},e.doneEdgeDict=function(t){for(var n,s=0;(n=t.dict.min().key)!==null;)n.sentinel||(Ct(n.fixUpperEdge),Ct(++s==1)),Ct(n.windingNumber===0),e.deleteRegion(t,n)},e.removeDegenerateEdges=function(t){var n,s,r,i=t.mesh.eHead;for(n=i.next;n!==i;n=s)s=n.next,r=n.Lnext,vt.vertEq(n.Org,n.Dst)&&n.Lnext.Lnext!==n&&(e.spliceMergeVertices(t,r,n),t.mesh.delete(n),n=r,r=n.Lnext),r.Lnext===n&&(r!==n&&((r===s||r===s.Sym)&&(s=s.next),t.mesh.delete(r)),(n===s||n===s.Sym)&&(s=s.next),t.mesh.delete(n))},e.initPriorityQ=function(t){var n,s,r,i=0;for(r=t.mesh.vHead,s=r.next;s!==r;s=s.next)i++;for(i+=8,n=t.pq=new Joe(i,vt.vertLeq),r=t.mesh.vHead,s=r.next;s!==r;s=s.next)s.pqHandle=n.insert(s);return s!==r?!1:(n.init(),!0)},e.donePriorityQ=function(t){t.pq=null},e.removeDegenerateFaces=function(t,n){var s,r,i;for(s=n.fHead.next;s!==n.fHead;s=r)r=s.next,i=s.anEdge,Ct(i.Lnext!==i),i.Lnext.Lnext===i&&(e.addWinding(i.Onext,i),t.mesh.delete(i));return!0},e.computeInterior=function(t,n){n===void 0&&(n=!0);var s,r;if(e.removeDegenerateEdges(t),!e.initPriorityQ(t))return!1;for(e.initEdgeDict(t);(s=t.pq.extractMin())!==null;){for(;r=t.pq.min(),!(r===null||!vt.vertEq(r,s));)r=t.pq.extractMin(),e.spliceMergeVertices(t,s.anEdge,r.anEdge);e.sweepEvent(t,s)}return t.event=t.dict.min().key.eUp.Org,e.debugEvent(t),e.doneEdgeDict(t),e.donePriorityQ(t),e.removeDegenerateFaces(t,t.mesh)?(n&&t.mesh.check(),!0):!1},e}(),nae=function(){function e(){this.mesh=new WO,this.normal=[0,0,0],this.sUnit=[0,0,0],this.tUnit=[0,0,0],this.bmin=[0,0],this.bmax=[0,0],this.windingRule=Wn.ODD,this.dict=null,this.pq=null,this.event=null,this.vertexIndexCounter=0,this.vertices=[],this.vertexIndices=[],this.vertexCount=0,this.elements=[],this.elementCount=0}return e.prototype.dot_=function(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]},e.prototype.normalize_=function(t){var n=t[0]*t[0]+t[1]*t[1]+t[2]*t[2];if(!n)throw"Zero-size vector!";n=Math.sqrt(n),t[0]/=n,t[1]/=n,t[2]/=n},e.prototype.longAxis_=function(t){var n=0;return Math.abs(t[1])>Math.abs(t[0])&&(n=1),Math.abs(t[2])>Math.abs(t[n])&&(n=2),n},e.prototype.computeNormal_=function(t){var n,s,r,i,o,a,l=[0,0,0],c=[0,0,0],h=[0,0,0],u=[0,0,0],d=[0,0,0],p=[null,null,null],f=[null,null,null],g=this.mesh.vHead;n=g.next;for(var m=0;m<3;++m)i=n.coords[m],c[m]=i,f[m]=n,l[m]=i,p[m]=n;for(n=g.next;n!==g;n=n.next)for(var y=0;y<3;++y)i=n.coords[y],i<c[y]&&(c[y]=i,f[y]=n),i>l[y]&&(l[y]=i,p[y]=n);var v=0;if(l[1]-c[1]>l[0]-c[0]&&(v=1),l[2]-c[2]>l[v]-c[v]&&(v=2),c[v]>=l[v]){t[0]=0,t[1]=0,t[2]=1;return}for(a=0,s=f[v],r=p[v],h[0]=s.coords[0]-r.coords[0],h[1]=s.coords[1]-r.coords[1],h[2]=s.coords[2]-r.coords[2],n=g.next;n!==g;n=n.next)u[0]=n.coords[0]-r.coords[0],u[1]=n.coords[1]-r.coords[1],u[2]=n.coords[2]-r.coords[2],d[0]=h[1]*u[2]-h[2]*u[1],d[1]=h[2]*u[0]-h[0]*u[2],d[2]=h[0]*u[1]-h[1]*u[0],o=d[0]*d[0]+d[1]*d[1]+d[2]*d[2],o>a&&(a=o,t[0]=d[0],t[1]=d[1],t[2]=d[2]);a<=0&&(t[0]=t[1]=t[2]=0,t[this.longAxis_(h)]=1)},e.prototype.checkOrientation_=function(){for(var t=this.mesh.fHead,n,s=this.mesh.vHead,r,i=0,o=t.next;o!==t;o=o.next)if(r=o.anEdge,!(r.winding<=0))do i+=(r.Org.s-r.Dst.s)*(r.Org.t+r.Dst.t),r=r.Lnext;while(r!==o.anEdge);if(i<0){for(n=s.next;n!==s;n=n.next)n.t=-n.t;this.tUnit[0]=-this.tUnit[0],this.tUnit[1]=-this.tUnit[1],this.tUnit[2]=-this.tUnit[2]}},e.prototype.projectPolygon_=function(){var t=this.mesh.vHead,n=[0,0,0],s,r,i=!1;n[0]=this.normal[0],n[1]=this.normal[1],n[2]=this.normal[2],!n[0]&&!n[1]&&!n[2]&&(this.computeNormal_(n),i=!0),s=this.sUnit,r=this.tUnit;var o=this.longAxis_(n);s[o]=0,s[(o+1)%3]=1,s[(o+2)%3]=0,r[o]=0,r[(o+1)%3]=0,r[(o+2)%3]=n[o]>0?1:-1;for(var a=t.next;a!==t;a=a.next)a.s=this.dot_(a.coords,s),a.t=this.dot_(a.coords,r);i&&this.checkOrientation_();for(var l=!0,c=t.next;c!==t;c=c.next)l?(this.bmin[0]=this.bmax[0]=c.s,this.bmin[1]=this.bmax[1]=c.t,l=!1):(c.s<this.bmin[0]&&(this.bmin[0]=c.s),c.s>this.bmax[0]&&(this.bmax[0]=c.s),c.t<this.bmin[1]&&(this.bmin[1]=c.t),c.t>this.bmax[1]&&(this.bmax[1]=c.t))},e.prototype.addWinding_=function(t,n){t.winding+=n.winding,t.Sym.winding+=n.Sym.winding},e.prototype.tessellateMonoRegion_=function(t,n){var s,r;if(s=n.anEdge,!(s.Lnext!==s&&s.Lnext.Lnext!==s))throw"Mono region invalid";for(;vt.vertLeq(s.Dst,s.Org);s=s.Lprev);for(;vt.vertLeq(s.Org,s.Dst);s=s.Lnext);r=s.Lprev;for(var i=void 0;s.Lnext!==r;)if(vt.vertLeq(s.Dst,r.Org)){for(;r.Lnext!==s&&(vt.edgeGoesLeft(r.Lnext)||vt.edgeSign(r.Org,r.Dst,r.Lnext.Dst)<=0);)i=t.connect(r.Lnext,r),r=i.Sym;r=r.Lprev}else{for(;r.Lnext!==s&&(vt.edgeGoesRight(s.Lprev)||vt.edgeSign(s.Dst,s.Org,s.Lprev.Org)>=0);)i=t.connect(s,s.Lprev),s=i.Sym;s=s.Lnext}if(r.Lnext===s)throw"Mono region invalid";for(;r.Lnext.Lnext!==s;)i=t.connect(r.Lnext,r),r=i.Sym;return!0},e.prototype.tessellateInterior_=function(t){for(var n,s=t.fHead.next;s!==t.fHead;s=n)if(n=s.next,s.inside&&!this.tessellateMonoRegion_(t,s))return!1;return!0},e.prototype.discardExterior_=function(t){for(var n,s=t.fHead.next;s!==t.fHead;s=n)n=s.next,s.inside||t.zapFace(s)},e.prototype.setWindingNumber_=function(t,n,s){for(var r,i=t.eHead.next;i!==t.eHead;i=r)r=i.next,i.Rface.inside!==i.Lface.inside?i.winding=i.Lface.inside?n:-n:s?t.delete(i):i.winding=0},e.prototype.getNeighbourFace_=function(t){return!t.Rface||!t.Rface.inside?-1:t.Rface.n},e.prototype.outputPolymesh_=function(t,n,s,r){var i,o=0,a=0,l;s>3&&t.mergeConvexFaces(s);for(var c=t.vHead.next;c!==t.vHead;c=c.next)c.n=-1;for(var h=t.fHead.next;h!==t.fHead;h=h.next)if(h.n=-1,!!h.inside){i=h.anEdge,l=0;do{var c=i.Org;c.n===-1&&(c.n=a,a++),l++,i=i.Lnext}while(i!==h.anEdge);if(l>s)throw"Face vertex greater that support polygon";h.n=o,++o}this.elementCount=o,n===ir.CONNECTED_POLYGONS&&(o*=2),this.elements=[],this.elements.length=o*s,this.vertexCount=a,this.vertices=[],this.vertices.length=a*r,this.vertexIndices=[],this.vertexIndices.length=a;for(var c=t.vHead.next;c!==t.vHead;c=c.next)if(c.n!==-1){var u=c.n*r;this.vertices[u+0]=c.coords[0],this.vertices[u+1]=c.coords[1],r>2&&(this.vertices[u+2]=c.coords[2]),this.vertexIndices[c.n]=c.idx}for(var d=0,h=t.fHead.next;h!==t.fHead;h=h.next)if(h.inside){i=h.anEdge,l=0;do{var c=i.Org;this.elements[d++]=c.n,l++,i=i.Lnext}while(i!==h.anEdge);for(var p=l;p<s;++p)this.elements[d++]=-1;if(n===ir.CONNECTED_POLYGONS){i=h.anEdge;do this.elements[d++]=this.getNeighbourFace_(i),i=i.Lnext;while(i!==h.anEdge);for(var f=l;f<s;++f)this.elements[d++]=-1}}},e.prototype.outputContours_=function(t,n){var s,r,i=0,o=0;this.vertexCount=0,this.elementCount=0;for(var a=t.fHead.next;a!==t.fHead;a=a.next)if(a.inside){r=s=a.anEdge;do this.vertexCount++,s=s.Lnext;while(s!==r);this.elementCount++}this.elements=[],this.elements.length=this.elementCount*2,this.vertices=[],this.vertices.length=this.vertexCount*n,this.vertexIndices=[],this.vertexIndices.length=this.vertexCount;var l=0,c=0,h=0;i=0;for(var a=t.fHead.next;a!==t.fHead;a=a.next)if(a.inside){o=0,r=s=a.anEdge;do this.vertices[l++]=s.Org.coords[0],this.vertices[l++]=s.Org.coords[1],n>2&&(this.vertices[l++]=s.Org.coords[2]),this.vertexIndices[c++]=this.vertexIdCallback?this.vertexIdCallback(s):s.Org.idx,o++,s=s.Lnext;while(s!==r);this.elements[h++]=i,this.elements[h++]=o,i+=o}},e.prototype.addContour=function(t,n){this.mesh===null&&(this.mesh=new WO),t<2&&(t=2),t>3&&(t=3);for(var s=null,r=0;r<n.length;r+=t)s===null?(s=this.mesh.makeEdge(),this.mesh.splice(s,s.Sym)):(this.mesh.splitEdge(s),s=s.Lnext),s.Org.coords[0]=n[r+0],s.Org.coords[1]=n[r+1],t>2?s.Org.coords[2]=n[r+2]:s.Org.coords[2]=0,s.Org.idx=this.vertexIndexCounter++,this.edgeCreateCallback&&this.edgeCreateCallback(s),s.winding=1,s.Sym.winding=-1},e.prototype.tesselate=function(t,n,s,r,i,o){if(t===void 0&&(t=Wn.ODD),n===void 0&&(n=ir.POLYGONS),o===void 0&&(o=!0),this.vertices=[],this.elements=[],this.vertexIndices=[],this.vertexIndexCounter=0,i&&(this.normal[0]=i[0],this.normal[1]=i[1],this.normal[2]=i[2]),this.windingRule=t,r<2&&(r=2),r>3&&(r=3),!this.mesh)return!1;this.projectPolygon_(),tae.computeInterior(this,o);var a=this.mesh;return n===ir.BOUNDARY_CONTOURS?this.setWindingNumber_(a,1,!0):this.tessellateInterior_(a),o&&a.check(),n===ir.BOUNDARY_CONTOURS?this.outputContours_(a,r):this.outputPolymesh_(a,n,s,r),!0},e}();function wm(e){var t=e.windingRule,n=t===void 0?Wn.ODD:t,s=e.elementType,r=s===void 0?ir.POLYGONS:s,i=e.polySize,o=i===void 0?3:i,a=e.vertexSize,l=a===void 0?2:a,c=e.normal,h=c===void 0?[0,0,1]:c,u=e.contours,d=u===void 0?[]:u,p=e.strict,f=p===void 0?!0:p,g=e.debug,m=g===void 0?!1:g;if(!d&&f)throw new Error("Contours can't be empty");if(d){var y=new nae;e.edgeCreateCallback&&(y.edgeCreateCallback=e.edgeCreateCallback),e.vertexIdCallback&&(y.vertexIdCallback=e.vertexIdCallback);for(var v=0;v<d.length;v++)y.addContour(l||2,d[v]);return y.tesselate(n,r,o,l,h,f),{vertices:y.vertices,vertexIndices:y.vertexIndices,vertexCount:y.vertexCount,elements:y.elements,elementCount:y.elementCount,mesh:m?y.mesh:void 0}}}Wn.ODD;Wn.NONZERO;Wn.POSITIVE;Wn.NEGATIVE;Wn.ABS_GEQ_TWO;ir.POLYGONS;ir.CONNECTED_POLYGONS;ir.BOUNDARY_CONTOURS;var XO=class extends It{constructor(e,t=12,n={}){super();var d,p,f;this.type="ShapeGeometry",this.windingRule=Wn.ODD,this.elementType=ir.POLYGONS,this.polySize=3,this.vertexSize=2,this.strict=!0,this._shape=e,this._curveSegments=t,this._triangulationOptions=Object.assign({windingRule:Wn.ODD,elementType:ir.POLYGONS,polySize:3,vertexSize:2,strict:!0},n);let s=this._shape.extractShapePointsToFlatArray([],this._curveSegments),r=this._shape.shapeHoles.map(g=>g.extractShapePointsToFlatArray([],this._curveSegments)),i,o=!0,a=!0,l,c;for(let g=0,m=s.length/2;g<m;g++){let y=g*2,v=s[y+0],b=s[y+1];if(l!==void 0&&v!==l&&(o=!1),c!==void 0&&b!==c&&(a=!1),l=v,c=b,!o&&!a)break}!o&&!a&&(i=wm({contours:[s,...r],windingRule:this._triangulationOptions.windingRule,elementType:this._triangulationOptions.elementType,polySize:this._triangulationOptions.polySize,vertexSize:this._triangulationOptions.vertexSize,strict:this._triangulationOptions.strict}));let h=(d=i==null?void 0:i.vertexCount)!=null?d:1,u=(p=i==null?void 0:i.elementCount)!=null?p:1;if(this._positionAttribute=new Lt(new Float32Array(h*3),3),this._normalAttribute=new Lt(new Float32Array(h*3),3),this._uvAttribute=new Lt(new Float32Array(h*2),2),this._indexAttribute=new Lt(new Uint32Array(u*3),1),i){let g=1/0,m=-1/0,y=1/0,v=-1/0;for(let w=0,S=h;w<S;w++){let C=w*2,_=i.vertices[C+0],T=i.vertices[C+1];_<g&&(g=_),_>m&&(m=_),T<y&&(y=T),T>v&&(v=T)}let b=m-g,x=v-y;for(let w=0,S=h;w<S;w++){let C=w*2,_=i.vertices[C+0],T=i.vertices[C+1],E=(_-g)/b,A=(T-y)/x;this._positionAttribute.setXYZ(w,_,T,0),this._normalAttribute.setXYZ(w,0,0,1),this._uvAttribute.setXY(w,E,A)}for(let w=0,S=u;w<S;w++){let C=w*3,_=i.elements[C+0],T=i.elements[C+1],E=i.elements[C+2];this._indexAttribute.setX(C+0,_),this._indexAttribute.setX(C+1,T),this._indexAttribute.setX(C+2,E)}}this.setAttribute("position",this._positionAttribute),this.setAttribute("normal",this._normalAttribute),this.setAttribute("uv",this._uvAttribute),this.setIndex(this._indexAttribute),this.setDrawRange(0,((f=i==null?void 0:i.elementCount)!=null?f:1)*3)}clone(){let e=new XO(this._shape,this._curveSegments);return e.userData=C_(this.userData),e}},R2=class{constructor(e=256,t=!1){this.capacity=e,this.size=0,this.debug=t,this.debug&&console.log(`allocating with cap ${e}`);let n=e*R2.eSize;this.buffer=new ArrayBuffer(n);let s=Float32Array.BYTES_PER_ELEMENT,r=0;this.positions=new Float32Array(this.buffer,r*s,3*e),r+=3*e,this.normals=new Float32Array(this.buffer,r*s,3*e),r+=3*e,this.uvs=new Float32Array(this.buffer,r*s,2*e)}realloc(e,t=!1){if(e<this.size)throw Error("cannot shrink buffer");if(e<=this.capacity&&!t)return;this.debug&&console.log(`resizing from ${this.capacity} \u2192 ${e}`);let n=e*R2.eSize,s=new ArrayBuffer(n),r=Float32Array.BYTES_PER_ELEMENT,i=0,o=new Float32Array(s,i*r,3*e);i+=3*e;let a=new Float32Array(s,i*r,3*e);i+=3*e;let l=new Float32Array(s,i*r,2*e);o.set(this.positions.slice(0,this.size*3)),a.set(this.normals.slice(0,this.size*3)),l.set(this.uvs.slice(0,this.size*2)),this.buffer=s,this.positions=o,this.normals=a,this.uvs=l,this.capacity=e}get(e=1){let t=this.size+e;if(t>this.capacity){let s=this.capacity;for(;t>s;)s*=2;this.realloc(s)}let n=this.size;return this.size=t,n}reserve(e){let t=this.size+e;t>this.capacity&&this.realloc(t)}shrink(){this.debug&&console.log(`shrinking ${this.capacity} \u2192 ${this.size}`),this.realloc(this.size,!0)}},KO=R2;KO.eSize=(3+3+2)*Float32Array.BYTES_PER_ELEMENT;var L2=(e,t)=>([n,s])=>(s<n&&(s+=t),(e>=n?e:e+t)<=s),YO=class extends It{constructor(e,t,n=0,s=12,r=3,i=Wn.ODD){super();this.type="ShapeGeometry",this.vertexCache={},this._shape=e,this._depth=t,this._bevel=n,this._curveSegments=s,this._bevelSegmentsInput=r,n<=0?(this._bevelSize=0,this._bevelSegments=0):(this._bevelSize=Math.min(n,t/2-1e-12),this._bevelSegments=Math.floor(r));let o=this._shape.extractShapePointsToFlatArray([],s),a=this._shape.shapeHoles.map(S=>{let C=S.extractShapePointsToFlatArray([],s),_=[];for(let T=C.length-1;T>=1;T-=2){let E=C[T-1],A=C[T-0];_.push(E,A)}return _}),l=wm({windingRule:i,elementType:ir.BOUNDARY_CONTOURS,vertexSize:2,strict:!0,contours:[o]}),c=wm({windingRule:Wn.ODD,elementType:ir.BOUNDARY_CONTOURS,vertexSize:2,strict:!0,contours:[...a]});if(!l)throw new Error("error generating geometry");let h=l.elementCount;if(c){l.elementCount+=c.elementCount;for(let S=0;S<c.elements.length;S++){let C=c.elements[S],_=S%2==0?l.vertexCount:0;l.elements.push(C+_)}for(let S=0;S<c.vertexIndices.length;S++){let C=c.vertexIndices[S],_=l.vertexCount;l.vertexIndices.push(C+_)}for(let S=0;S<c.vertices.length;S++){let C=c.vertices[S];l.vertices.push(C)}}let u=1/0,d=-1/0,p=1/0,f=-1/0;for(let S=0,C=l.vertexCount;S<C;S++){let _=S*2,T=l.vertices[_+0],E=l.vertices[_+1];T<u&&(u=T),T>d&&(d=T),E<p&&(p=E),E>f&&(f=E)}this._minX=u,this._minY=p,this._width=d-u,this._height=f-p;let g=l.vertexCount*2*(2+this._bevelSegments);this._buffer=new KO(g);let m=[],y=[];for(let S=l.elementCount-1;S>=0;S--){let C=S>=h,_=S*2,T=l.elements[_+0],E=l.elements[_+1],A=T+E,D={start:T,count:E,normals:[],continuous:[],concave:[]},O=T,P=A-1,L=T+1,B=this._shape.roundedCurves.length;do{let z=O-T,$=l.vertices[P*2+0],R=l.vertices[P*2+1],H=l.vertices[O*2+0],K=l.vertices[O*2+1],Y=l.vertices[L*2+0],X=l.vertices[L*2+1],oe=H-$,ie=K-R,Z=Math.sqrt(oe*oe+ie*ie);oe/=Z,ie/=Z;let ce=H-Y,ge=K-X,_e=Math.sqrt(ce*ce+ge*ge);ce/=_e,ge/=_e,D.normals[z*2+0]=-ge,D.normals[z*2+1]=ce,D.concave[z]=oe*ge-ie*ce>0;let be=l.vertexIndices[O];if(Array.isArray(be))D.continuous[z]=!1;else{let[Me,Ie]=this._shape.getCurveIndexFromVertexId(be-1,!0);if(Ie>0&&Ie<1)D.continuous[z]=!0;else{let Le=Ie===1?Me+1:Me-1;Le=(Le+B)%B;let Ue=Ie===1?0:1,$e=this._shape.roundedCurves[Me].getTangent(Ie),We=this._shape.roundedCurves[Le].getTangent(Ue);D.continuous[z]=$e.dot(We)>.95}}C&&(D.normals[z*2+0]*=-1,D.normals[z*2+1]*=-1),[P,O,L]=[O,L,L+1],L>=A&&(L-=E)}while(L!==T+1);let F=[];F.push({bevelI:0,angle:0,size:0,boundary:{vertices:l.vertices.slice(T*2,A*2),vertexCount:E,vertexIndices:new Array(E).fill(!0).map((z,$)=>[$,$]),elements:[0,E],elementCount:1,mesh:null},reverseMap:[],insetPoints:l.vertices.slice(T*2,A*2)});for(let z=1;z<=this._bevelSegments;z++){let $=z/this._bevelSegments*Math.PI/2,R=(1-Math.cos($))*this._bevelSize,H=[],K=[],Y=[],X=[],oe=0;for(let Z=0;Z<E;Z++){let ce=Z*2,ge=(Z-1+E)%E*2,_e=l.vertices[D.start*2+ce+0],be=l.vertices[D.start*2+ce+1],Me=-D.normals[ge+0]*R,Ie=-D.normals[ge+1]*R,Le=-D.normals[ce+0]*R,Ue=-D.normals[ce+1]*R;if(D.concave[Z]||!D.concave[Z]&&C){let $e=Math.atan2(Ie,Me),We=Math.atan2(Ue,Le);We>$e&&(We-=Math.PI*2);let Rt=We-$e;if(D.continuous[Z]||C){let ct=$e+Rt/2,j=Math.cos(ct)*R,V=Math.sin(ct)*R;H[2*oe+0]=_e+j*(C?-1:1),H[2*oe+1]=be+V*(C?-1:1),X[oe]=Z,oe++}else{let ct=Math.max(1,Math.floor(s/4*Math.abs(Rt)/Math.PI));for(let j=0;j<=ct;j++){let V=$e+Rt*(j/ct),we=Math.cos(V)*R,Pe=Math.sin(V)*R;H[2*oe+0]=_e+we,H[2*oe+1]=be+Pe,X[oe]=Z,oe++}}}else H[2*oe+0]=_e+Me,H[2*oe+1]=be+Ie,X[oe]=Z,K[Z]=oe,oe++,H[2*oe+0]=_e,H[2*oe+1]=be,X[oe]=Z,oe++,H[2*oe+0]=_e+Le,H[2*oe+1]=be+Ue,X[oe]=Z,Y[Z]=oe,oe++}let ie=wm({windingRule:Wn.POSITIVE,elementType:ir.BOUNDARY_CONTOURS,vertexSize:2,strict:!0,contours:[H],edgeCreateCallback:Z=>{let ce=Z.Org.idx,ge=X[ce],_e=X[(ce+1)%X.length];Z.idx=[ge,_e],Z.Sym.idx=[_e,ge]},vertexIdCallback:Z=>{let ce=Z.Lprev.idx;return[ce?ce[1]:0,Z.idx[0]]}});if(!ie)throw console.log("Error"),new Error(`error generating bevel geometry for ${z}'th loop`);if(!ie.vertexCount)break;for(let Z=0;Z<ie.vertexIndices.length;Z++){let[ce,ge]=ie.vertexIndices[Z];if(ce===ge)continue;let _e=ge;ge<ce&&(_e+=E);for(let be=ce;be<_e;be++){let Me=be%E,Ie=(be+1)%E;if(!D.continuous[Me]||!D.continuous[Ie]){ie.vertexIndices[Z]=[ce,Me],ie.vertexIndices.splice(Z+1,0,[Ie,ge]),ie.vertices.splice((Z+1)*2,0,ie.vertices[Z*2],ie.vertices[Z*2+1]);break}}}F.push({bevelI:z,angle:$,size:R,boundary:ie,reverseMap:X,insetPoints:H})}let M=(z,$,R)=>{let H=0,K=z.boundary.vertexIndices.length;for(;H<K&&R(z.boundary.vertexIndices[$]);)$=($+1)%K,H++;return H},U=m.length;for(let z=1;z<F.length;z++){let $=F[z-1],R=F[z],H=$.boundary.vertexIndices.length,K=R.boundary.vertexIndices.length;if(!H||!K)break;let Y=D.concave.length,X=0,oe=L2(X,E);for(;!$.boundary.vertexIndices.filter(oe).length||!R.boundary.vertexIndices.filter(oe).length;)X++,oe=L2(X,E);let ie=$.boundary.vertexIndices.findIndex(oe),Z=R.boundary.vertexIndices.findIndex(oe);do ie=(ie+1)%H;while(oe($.boundary.vertexIndices[ie]));do Z=(Z+1)%K;while(oe(R.boundary.vertexIndices[Z]));X=(X+1)%E;let ce=X,ge=this.buildBevelVert(D,$,(ie-1+H)%H),_e=this.buildBevelVert(D,R,(Z-1+K)%K),be=ge,Me=_e,Ie,Le,Ue=!1;do{oe=L2(X,E);let $e=M($,ie,oe),We=M(R,Z,oe),Rt=Ue;if(Ue=!1,$e&&!We){for(let ct=0;ct<$e;ct++)Ie=this.buildBevelVert(D,$,(ie+ct)%H,ct/($e-1)),m.push(be.topN,Ie.topP,Me.topN),m.push(Ie.bottomP,be.bottomN,Me.bottomN),be=Ie;Ue=!0}else if(!$e&&We)for(let ct=0;ct<We;ct++)Le=this.buildBevelVert(D,R,(Z+ct)%K,ct/(We-1)),m.push(Me.topN,be.topP,Le.topP),m.push(be.bottomP,Me.bottomN,Le.bottomP),Me=Le;else if($e&&We)if(Ie=this.buildBevelVert(D,$,ie,0),Le=this.buildBevelVert(D,R,Z,0),Rt?(m.push(be.topN,Le.topP,Me.topN),m.push(be.topN,Ie.topP,Le.topP),m.push(Le.bottomP,be.bottomN,Me.bottomN),m.push(Le.bottomP,Ie.bottomP,be.bottomN)):(m.push(Me.topN,be.topN,Ie.topP),m.push(Me.topN,Ie.topP,Le.topP),m.push(Ie.bottomP,be.bottomN,Me.bottomN),m.push(Ie.bottomP,Me.bottomN,Le.bottomP)),be=Ie,Me=Le,$e===We)for(let ct=1;ct<$e;ct++)Ie=this.buildBevelVert(D,$,(ie+ct)%H,ct/($e-1)),Le=this.buildBevelVert(D,R,(Z+ct)%K,ct/(We-1)),m.push(be.topN,Ie.topP,Me.topN),m.push(Me.topN,Ie.topP,Le.topP),m.push(Ie.bottomP,be.bottomN,Me.bottomN),m.push(Ie.bottomP,Me.bottomN,Le.bottomP),be=Ie,Me=Le;else if($e>We){let ct=$e/We,j=0;for(let V=1;V<$e;V++)Ie=this.buildBevelVert(D,$,(ie+V)%H,V/($e-1)),m.push(be.topN,Ie.topP,Me.topN),m.push(Ie.bottomP,be.bottomN,Me.bottomN),be=Ie,V>(j+1)*ct&&(j++,Le=this.buildBevelVert(D,R,(Z+j)%K,j/(We-1)),m.push(Me.topN,Ie.topP,Le.topP),m.push(Ie.bottomP,Me.bottomN,Le.bottomP),Me=Le)}else{let ct=We/$e,j=0;for(let V=1;V<We;V++)Le=this.buildBevelVert(D,R,(Z+V)%K,V/(We-1)),m.push(Me.topN,Ie.topP,Le.topP),m.push(Ie.bottomP,Me.bottomN,Le.bottomP),Me=Le,V>(j+1)*ct&&(j++,Ie=this.buildBevelVert(D,$,(ie+j)%H,j/($e-1)),m.push(be.topN,Ie.topP,Me.topN),m.push(Ie.bottomP,be.bottomN,Me.bottomN),be=Ie)}ie=(ie+$e)%H,Z=(Z+We)%K,X=(X+1)%Y}while(X!==ce)}{let z=F[0];for(let $=0,R=z.boundary.vertexCount;$<R;$++){let H=this.buildBevelVert(D,z,$),K=this.buildBevelVert(D,z,($+1)%R);m.push(K.topP,H.topN,H.bottomN),m.push(K.topP,H.bottomN,K.bottomP)}}if(C){let z=[];for(let $=m.length-1;$>=U+2;$-=3){let R=m[$-2],H=m[$-1],K=m[$-0];z.push(K,H,R)}m.splice(U,m.length-U,...z)}if(C){let z=[];for(let $=F[F.length-1].boundary.vertices.length-1;$>=1;$-=2){let R=F[F.length-1].boundary.vertices[$-1],H=F[F.length-1].boundary.vertices[$-0];z.push(R,H)}y.push(z)}if(!C){let z=F[F.length-1],$=wm({windingRule:F.length>1?Wn.POSITIVE:Wn.ODD,elementType:ir.POLYGONS,vertexSize:2,strict:!0,contours:[z.insetPoints,...y]});if(!$)throw new Error("Error generating geometry for surface");a.length===0&&Object.assign(this,{capStartIndex:m.length});for(let R=0;R<$.elementCount*3;R+=3){let H=this.buildSurfaceVert($,$.elements[R+0]),K=this.buildSurfaceVert($,$.elements[R+1]),Y=this.buildSurfaceVert($,$.elements[R+2]);m.push(H.top,K.top,Y.top),m.push(Y.bottom,K.bottom,H.bottom)}}this.vertexCache={}}this._buffer.shrink();let v=new Lt(Uint32Array.from(m),1),b=new Lt(this._buffer.positions,3),x=new Lt(this._buffer.normals,3),w=new Lt(this._buffer.uvs,2);b.needsUpdate=!0,x.needsUpdate=!0,w.needsUpdate=!0,v.needsUpdate=!0,this.setAttribute("position",b),this.setAttribute("normal",x),this.setAttribute("uv",w),this.setIndex(v)}buildSurfaceVert(e,t){let n=t.toString();if(n in this.vertexCache)return this.vertexCache[n];let s=e.vertices[t*2+0],r=e.vertices[t*2+1],i=(s-this._minX)/this._width,o=(r-this._minY)/this._height,a=this._buffer.get(2),l=a*3,c=a*2,h={top:a+0,bottom:a+1};return this._buffer.positions[l+0]=s,this._buffer.positions[l+1]=r,this._buffer.positions[l+2]=this._depth,this._buffer.normals[l+0]=0,this._buffer.normals[l+1]=0,this._buffer.normals[l+2]=1,this._buffer.uvs[c+0]=i,this._buffer.uvs[c+1]=o,this._buffer.positions[l+3]=s,this._buffer.positions[l+4]=r,this._buffer.positions[l+5]=0,this._buffer.normals[l+3]=0,this._buffer.normals[l+4]=0,this._buffer.normals[l+5]=-1,this._buffer.uvs[c+2]=i,this._buffer.uvs[c+3]=o,this.vertexCache[n]=h,h}buildBevelVert(e,t,n,s=1){let r=`${t.bevelI}:${n}`;if(r in this.vertexCache)return this.vertexCache[r];let[i,o]=t.boundary.vertexIndices[n],a,l,c,h;i!==o?(l=i,a=o,h=!1,c=e.continuous[l]&&e.continuous[a]):(a=i,l=(a-1+e.count)%e.count,h=e.concave[a]&&t.bevelI>0,c=e.continuous[a]||h);let u=Math.cos(t.angle),d=Math.sin(t.angle),p=n*2,f=a*2,g=l*2,m=t.boundary.vertices[p+0],y=t.boundary.vertices[p+1],v=(1-d)*this._bevelSize,b=(m-this._minX)/this._width,x=(y-this._minY)/this._height,w=e.normals[f+0],S=e.normals[f+1],C=e.normals[g+0],_=e.normals[g+1];if(h){let O=C-w,P=_-S;w=w+O*(1-s),S=S+P*(1-s);let L=Math.sqrt(w*w+S*S);w/=L,S/=L}let T=this._buffer.get(c?2:4),E=T*3,A=T*2,D={i:n,fi:a,topP:T+0,topN:T+0,bottomP:T+1,bottomN:T+1};return this._buffer.positions[E+0]=m,this._buffer.positions[E+1]=y,this._buffer.positions[E+2]=this._depth-v,this._buffer.normals[E+0]=w*u,this._buffer.normals[E+1]=S*u,this._buffer.normals[E+2]=d,this._buffer.uvs[A+0]=b,this._buffer.uvs[A+1]=x,this._buffer.positions[E+3]=m,this._buffer.positions[E+4]=y,this._buffer.positions[E+5]=v,this._buffer.normals[E+3]=w*u,this._buffer.normals[E+4]=S*u,this._buffer.normals[E+5]=-d,this._buffer.uvs[A+2]=x,this._buffer.uvs[A+3]=b,c||(T+=2,E+=6,A+=4,D.topP=T+0,D.bottomP=T+1,this._buffer.positions[E+0]=m,this._buffer.positions[E+1]=y,this._buffer.positions[E+2]=this._depth-v,this._buffer.normals[E+0]=C*u,this._buffer.normals[E+1]=_*u,this._buffer.normals[E+2]=d,this._buffer.uvs[A+0]=b,this._buffer.uvs[A+1]=x,this._buffer.positions[E+3]=m,this._buffer.positions[E+4]=y,this._buffer.positions[E+5]=v,this._buffer.normals[E+3]=C*u,this._buffer.normals[E+4]=_*u,this._buffer.normals[E+5]=-d,this._buffer.uvs[A+2]=x,this._buffer.uvs[A+3]=b),this.vertexCache[r]=D,D}clone(){let e=new YO(this._shape,this._depth,this._bevel,this._curveSegments,this._bevelSegmentsInput);return e.userData=C_(this.userData),e}},Bu=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var c,h,u,d,p,f,g;let n=Object.assign({},(c=t==null?void 0:t.parameters)!=null?c:{width:100,subdivisions:40,roundness:0,extrudeBevelSize:0,extrudeBevelSegments:3,windingRule:Wn.ODD},e.parameters),s=Math.abs(n.width),r=Math.abs((h=n.height)!=null?h:n.width),i=Math.abs((u=n.depth)!=null?u:0),o=(d=e.shape)!=null?d:t==null?void 0:t.shape,a=(p=o==null?void 0:o.roundness)!=null?p:n.roundness;o!==void 0&&(o instanceof is?(o.width!==s||o.height!==r)&&o.applySize(s,r):o=new is(s,r).fromJSON(o),((f=e.parameters)==null?void 0:f.roundness)!==void 0&&((g=e.parameters)==null?void 0:g.roundness)>0&&o.update());let l=o!=null?o:new is(s,r);return{parameters:Object.assign(n,{width:s,height:r,depth:i,roundness:a}),shape:l}}static build(e){let{depth:t,extrudeBevelSize:n,extrudeBevelSegments:s,subdivisions:r,roundness:i,windingRule:o}=e.parameters;e.shape.roundness=i;let a;return t<=0?a=new XO(e.shape,r,{windingRule:o}):a=new YO(e.shape,t,n,r,s,o),Object.assign(a,{userData:De(ue({},e),{type:"VectorGeometry"})})}},QO=Math.PI*2,sae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var s,r,i;let n=Object.assign({},(s=t==null?void 0:t.parameters)!=null?s:{width:100,depth:0,spikes:64,angle:360,innerRadius:0,extrudeBevelSize:0,extrudeBevelSegments:1},e.parameters);return{shape:e.shape&&e.shape instanceof is?e.shape:new is,parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((r=n.height)!=null?r:n.width),depth:Math.abs((i=n.depth)!=null?i:0)})}}static build(e){let{width:t,height:n,spikes:s,angle:r,innerRadius:i,depth:o,extrudeBevelSize:a,extrudeBevelSegments:l}=e.parameters,c=e.shape,h=t*.5,u=n*.5,d=rae(c,h,u,r*Math.PI/180,s,i);c.isClosed=!0,c.update();let p=Bu.create({shape:c,parameters:{subdivisions:d,depth:o,extrudeBevelSize:a,extrudeBevelSegments:l}});return Object.assign(p,{userData:De(ue({},e),{type:"EllipseGeometry"})})}};function rae(e,t,n,s,r,i){if(s>=QO)return r>30||r%4==0?(oae(e,t,n,i),Math.round(r/4)):ZO(e,s,r,t,n,i);s=Math.max(s,.001);let o={x:0,y:n},a=s+Math.PI*.5,l={x:Math.cos(a)*t,y:Math.sin(a)*n},c=Zoe({px:o.x,py:o.y,cx:l.x,cy:l.y,rx:t,ry:n,largeArcFlag:s>Math.PI,sweepFlag:!0});return r>30||r%c.length==0?iae(e,o.x,o.y,c,r,t,n,i):ZO(e,s,r,t,n,i)}function iae(e,t,n,s,r,i,o,a){let l=Math.round(r/s.length);e.addPoint(Kd(t,n));for(let c=0,h=s.length;c<h;c++){let u=s[c],d=e.points[c],p=Kd(u.x,u.y);d.controls[1].position.set(u.x1,u.y1),p.controls[0].position.set(u.x2,u.y2),e.addPoint(p)}return a>0?JO(e,i,o,a):e.addPoint(Kd(0,0)),l}function ZO(e,t,n,s,r,i){let o=-t/n;for(let a=0;a<=n;a++){let l=o*a,c=Math.sin(l)*s,h=Math.cos(l)*r;e.addPoint(Kd(c,h))}return t<QO?i>0?JO(e,s,r,i):e.addPoint(Kd(0,0)):(e.removePoint(e.points[e.points.length-1]),i>0&&eR(e,s,r,i)),1}function oae(e,t,n,s=0,r=0,i=0){let o=.5522847498,a=t*o,l=n*o;e.addPoint(Qv(r-t,i,r-t,i-l,r-t,i+l)),e.addPoint(Qv(r,i+n,r-a,i+n,r+a,i+n)),e.addPoint(Qv(r+t,i,r+t,i+l,r+t,i-l)),e.addPoint(Qv(r,i-n,r+a,i-n,r-a,i-n)),s>0&&eR(e,t,n,s)}function Kd(e,t){return new jd(Kt.generateUUID(),new se(e,t))}function Qv(e,t,n,s,r,i){let o=Kd(e,t);return o.controls[0].position.set(n,s),o.controls[1].position.set(r,i),o}function JO(e,t,n,s){tR(e,t,n,s).forEach(r=>e.addPoint(r))}function eR(e,t,n,s){let r=tR(e,t,n,s),i=new is;r.forEach(o=>i.addPoint(o)),i.isClosed=!0,e.shapeHoles.push(i)}function tR(e,t,n,s){let r=s*t/100,i=r*(Math.abs(n)/Math.abs(t)),o=new se(r/t,i/n),a=e.points.map(l=>{let c=l.clone();return c.uuid=Kt.generateUUID(),c}).reverse();return a.forEach(l=>{l.position.multiply(o);let c=l.controls[0].position.clone().multiply(o),h=l.controls[1].position.clone().multiply(o);l.controls[0].position.copy(h),l.controls[1].position.copy(c)}),a}var aae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var a,l,c;let n=Object.assign({},(a=t==null?void 0:t.parameters)!=null?a:{width:100,revolutions:2,segments:40,pathRadius:10,pathType:0,pathSegments:30,cornerRadius:30,cornerSegments:4},e.parameters),s=Math.abs(n.width),r=Math.abs((l=n.height)!=null?l:s),i=Math.abs((c=n.depth)!=null?c:s),o=Math.abs(Math.min(s,i))/2;return{parameters:Object.assign(n,{width:s,height:r,depth:i,radius:o,segments:Math.round(n.segments),pathSegments:Math.round(n.pathSegments),cornerSegments:Math.round(n.cornerSegments)})}}static build(e){let{width:t,height:n,depth:s,radius:r,revolutions:i,segments:o,pathRadius:a,pathType:l,pathSegments:c,cornerRadius:h,cornerSegments:u}=e.parameters,d=new F2(!1,t,n,s,r,i,o,a,l,c,h,u);return Object.assign(d,{userData:De(ue({},e),{type:"HelixGeometry"})})}},F2=class extends It{constructor(e=!0,t=1,n=1,s=1,r=1,i=1,o=1,a=1,l=1,c=1,h=1,u=1,d=!1){super();let p=e&&i===1;p&&(u=0),h>100&&(h=100);let f=()=>new I,g=new I,m=f(),y=f(),v=f(),b,x,w,S,C,_,T,E,A=f(),D=f(),O=f(),P=f(),L=f(),B=f(),F=f(),M=f(),U=n-2*a+.001,z=U/i,$=Math.ceil(o*i),R=$+1,H=U/$,K=-U/2,Y=c+1,X=2*Math.PI/c,oe=Math.PI/2/u,ie=.01,Z=Math.min((1-h/100)*a,a-ie),ce=a-Z,ge=0,_e=2,be=u*_e+_e,Me=Y*be/_e,Ie=Me+Y*R,Le=Y*(R+be),[Ue,$e,We]=[3,3,2].map(He=>Array(Le*He).fill(0)),Rt=[],ct=r-a;function j(He,Xe){let te=Math.PI/2;_=Xe*H,E=2*Math.PI*(_%z)/z+te,_+=K,T=Math.sin(E)*ct,C=Math.cos(E)*ct,e?He.set(C,T,_):He.set(C,_,T)}j(g,-1e-10),j(m,0),A.copy(g),j(g,1);let V=g.distanceTo(m),we=p?0:ce+Z,Pe=V*$+2*we,Be=Z,je=Pe-we;for(let He=0;He<=$;He++){j(y,He),M.subVectors(y,A).normalize(),A.copy(y),B.copy(y).setComponent(+e+1,0).normalize(),F.crossVectors(M,B).normalize();let Xe=He===0,te=He===$,Ke=Xe?3*Math.PI/2:oe,qe=Xe?Be:je,Et=Xe?Y:Ie,it=Xe?0:Le-Y,At=M.clone().multiplyScalar(Xe?-ce:ce).add(y),Ge=M.clone().multiplyScalar(Xe?-1:1).normalize();for(let yt=0;yt<Y;yt++){let nt=yt*X;if(D.addVectors(g.copy(B).multiplyScalar(a*Math.cos(nt)),m.copy(F).multiplyScalar(a*Math.sin(nt))),O.copy(D).normalize(),Xe||te){p||(ge=it+yt,[0,1,2].forEach(Je=>{Ue[ge*3+Je]=At.getComponent(Je),$e[ge*3+Je]=Ge.getComponent(Je)}),We[ge*2]=+te,We[ge*2+1]=yt/c),m.copy(O).multiplyScalar(Z),v.addVectors(y,m);for(let Je=0;Je<u;Je++){let mt=Je*oe+Ke;P.addVectors(g.copy(M).multiplyScalar(ce*Math.sin(mt)),m.copy(O).multiplyScalar(ce*Math.cos(mt))),L.copy(P).normalize(),m.addVectors(v,P),P.normalize(),ge=Et+Je*Y+yt,[0,1,2].forEach(rn=>{Ue[ge*3+rn]=m.getComponent(rn),$e[ge*3+rn]=L.getComponent(rn)});let Dt=+Xe+Math.sin(mt);We[ge*2]=(qe+ce*Dt)/Pe,We[ge*2+1]=yt/c}}m.addVectors(y,D),ge=Me+He*Y+yt,[0,1,2].forEach(Je=>{Ue[ge*3+Je]=m.getComponent(Je),$e[ge*3+Je]=O.getComponent(Je)}),We[ge*2]=(we+He*V)/Pe,We[ge*2+1]=yt/c}}let pt=R+2*u+_e,[Te,ut]=[+p,pt-1];d&&(ut-=1);for(let He=Te;He<=ut-1;He++){let Xe=p&&He===ut-1;for(let te=0;te<Y-1;te++)b=He*Y+te,x=b+1,w=(Xe?te:b)+Y,S=(Xe?te+1:x)+Y,He===0?Rt.push(x,S,w):He===pt-2?Rt.push(b,x,w):Rt.push(b,x,w,x,S,w)}this.setIndex(Rt),this.setAttribute("position",new ot(Ue,3)),this.setAttribute("normal",new ot($e,3)),this.setAttribute("uv",new ot(We,2))}},lae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var s,r,i;let n=Object.assign({},(s=t==null?void 0:t.parameters)!=null?s:{width:100,detail:0,corner:0,cornerSides:4},e.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((r=n.height)!=null?r:n.width),depth:Math.abs((i=n.depth)!=null?i:n.width)})}}static build(e){let{width:t,height:n,depth:s,detail:r,corner:i,cornerSides:o}=e.parameters,a=r===0&&i!==0?new nR(t*.5,i,o):new dM(t*.5,r);return a.scale(1,n/t,s/t),Object.assign(a,{userData:De(ue({},e),{type:"IcosahedronGeometry"})})}},nR=class extends E2{constructor(e=1,t=.2,n=4){let s=(1+Math.sqrt(5))/2,r=[-1,s,0,1,s,0,-1,-s,0,1,-s,0,0,-1,s,0,1,s,0,-1,-s,0,1,-s,s,0,-1,s,0,1,-s,0,-1,-s,0,1],i=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],o="IcosahedronGeometry";super(r,i,o,e,t,n),this.type=o}static fromJSON(e){return new nR(e.radius,e.corner,e.cornerSides)}},cae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var s,r,i,o,a;((r=(s=e.parameters)==null?void 0:s.points)!=null?r:[]).forEach(l=>{Array.isArray(l)&&(l.x=l[0],l.y=l[1])});let n=Object.assign({},(i=t==null?void 0:t.parameters)!=null?i:{width:100,segments:64,verticalSegments:64,points:[{x:0,y:-50,id:0},{x:50,y:-50,id:1},{x:50,y:50,id:2},{x:0,y:50,id:3}]},e.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((o=n.height)!=null?o:n.width),depth:Math.abs((a=n.depth)!=null?a:n.width)})}}static build(e){let{points:t,segments:n,verticalSegments:s}=e.parameters,r=new Py;r.moveTo(t[0].x,t[0].y),r.bezierCurveTo(t[1].x,t[1].y,t[2].x,t[2].y,t[3].x,t[3].y);let i=new nM(r.extractPoints(s).shape,n);return i.rotateZ(Math.PI),Object.assign(i,{userData:De(ue({},e),{type:"LatheGeometry"})})}},Na=new et,$2=new Ln,Zv=new I,Jv=class extends Zr{constructor(){super(),this.uuid=Kt.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}applyMatrix4(e){let t=new Or().getNormalMatrix(e);for(let n=0,s=this.vertices.length;n<s;n++)this.vertices[n].applyMatrix4(e);for(let n=0,s=this.faces.length;n<s;n++){let r=this.faces[n];r.normal.applyMatrix3(t).normalize();for(let i=0,o=r.vertexNormals.length;i<o;i++)r.vertexNormals[i].applyMatrix3(t).normalize()}return this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this}rotateX(e){return Na.makeRotationX(e),this.applyMatrix4(Na),this}rotateY(e){return Na.makeRotationY(e),this.applyMatrix4(Na),this}rotateZ(e){return Na.makeRotationZ(e),this.applyMatrix4(Na),this}translate(e,t,n){return Na.makeTranslation(e,t,n),this.applyMatrix4(Na),this}scale(e,t,n){return Na.makeScale(e,t,n),this.applyMatrix4(Na),this}lookAt(e){return $2.lookAt(e),$2.updateMatrix(),this.applyMatrix4($2.matrix),this}fromBufferGeometry(e){let t=this,n=e.index!==null?e.index:void 0,s=e.attributes;if(s.position===void 0)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;let r=s.position,i=s.normal,o=s.color,a=s.uv,l=s.uv2;l!==void 0&&(this.faceVertexUvs[1]=[]);for(let u=0;u<r.count;u++)t.vertices.push(new I().fromBufferAttribute(r,u)),o!==void 0&&t.colors.push(new _t().fromBufferAttribute(o,u));function c(u,d,p,f){let g=o===void 0?[]:[t.colors[u].clone(),t.colors[d].clone(),t.colors[p].clone()],m=i===void 0?[]:[new I().fromBufferAttribute(i,u),new I().fromBufferAttribute(i,d),new I().fromBufferAttribute(i,p)],y=new B2(u,d,p,m,g,f);t.faces.push(y),a!==void 0&&t.faceVertexUvs[0].push([new se().fromBufferAttribute(a,u),new se().fromBufferAttribute(a,d),new se().fromBufferAttribute(a,p)]),l!==void 0&&t.faceVertexUvs[1].push([new se().fromBufferAttribute(l,u),new se().fromBufferAttribute(l,d),new se().fromBufferAttribute(l,p)])}let h=e.groups;if(h.length>0)for(let u=0;u<h.length;u++){let d=h[u],p=d.start,f=d.count;for(let g=p,m=p+f;g<m;g+=3)n!==void 0?c(n.getX(g),n.getX(g+1),n.getX(g+2),d.materialIndex):c(g,g+1,g+2,d.materialIndex)}else if(n!==void 0)for(let u=0;u<n.count;u+=3)c(n.getX(u),n.getX(u+1),n.getX(u+2));else for(let u=0;u<r.count;u+=3)c(u,u+1,u+2);return this.computeFaceNormals(),e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Zv).negate(),this.translate(Zv.x,Zv.y,Zv.z),this}normalize(){this.computeBoundingSphere();let e=this.boundingSphere.center,t=this.boundingSphere.radius,n=t===0?1:1/t,s=new et;return s.set(n,0,0,-n*e.x,0,n,0,-n*e.y,0,0,n,-n*e.z,0,0,0,1),this.applyMatrix4(s),this}computeFaceNormals(){let e=new I,t=new I;for(let n=0,s=this.faces.length;n<s;n++){let r=this.faces[n],i=this.vertices[r.a],o=this.vertices[r.b],a=this.vertices[r.c];e.subVectors(a,o),t.subVectors(i,o),e.cross(t),e.normalize(),r.normal.copy(e)}}computeVertexNormals(e=!0){let t=new Array(this.vertices.length);for(let n=0,s=this.vertices.length;n<s;n++)t[n]=new I;if(e){let n=new I,s=new I;for(let r=0,i=this.faces.length;r<i;r++){let o=this.faces[r],a=this.vertices[o.a],l=this.vertices[o.b],c=this.vertices[o.c];n.subVectors(c,l),s.subVectors(a,l),n.cross(s),t[o.a].add(n),t[o.b].add(n),t[o.c].add(n)}}else{this.computeFaceNormals();for(let n=0,s=this.faces.length;n<s;n++){let r=this.faces[n];t[r.a].add(r.normal),t[r.b].add(r.normal),t[r.c].add(r.normal)}}for(let n=0,s=this.vertices.length;n<s;n++)t[n].normalize();for(let n=0,s=this.faces.length;n<s;n++){let r=this.faces[n],i=r.vertexNormals;i.length===3?(i[0].copy(t[r.a]),i[1].copy(t[r.b]),i[2].copy(t[r.c])):(i[0]=t[r.a].clone(),i[1]=t[r.b].clone(),i[2]=t[r.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeFlatVertexNormals(){this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){let n=this.faces[e],s=n.vertexNormals;s.length===3?(s[0].copy(n.normal),s[1].copy(n.normal),s[2].copy(n.normal)):(s[0]=n.normal.clone(),s[1]=n.normal.clone(),s[2]=n.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeMorphNormals(){for(let t=0,n=this.faces.length;t<n;t++){let s=this.faces[t];s.__originalFaceNormal?s.__originalFaceNormal.copy(s.normal):s.__originalFaceNormal=s.normal.clone(),s.__originalVertexNormals||(s.__originalVertexNormals=[]);for(let r=0,i=s.vertexNormals.length;r<i;r++)s.__originalVertexNormals[r]?s.__originalVertexNormals[r].copy(s.vertexNormals[r]):s.__originalVertexNormals[r]=s.vertexNormals[r].clone()}let e=new Jv;e.faces=this.faces;for(let t=0,n=this.morphTargets.length;t<n;t++){if(!this.morphNormals[t]){this.morphNormals[t]={},this.morphNormals[t].faceNormals=[],this.morphNormals[t].vertexNormals=[];let r=this.morphNormals[t].faceNormals,i=this.morphNormals[t].vertexNormals;for(let o=0,a=this.faces.length;o<a;o++){let l=new I,c={a:new I,b:new I,c:new I};r.push(l),i.push(c)}}let s=this.morphNormals[t];e.vertices=this.morphTargets[t].vertices,e.computeFaceNormals(),e.computeVertexNormals();for(let r=0,i=this.faces.length;r<i;r++){let o=this.faces[r],a=s.faceNormals[r],l=s.vertexNormals[r];a.copy(o.normal),l.a.copy(o.vertexNormals[0]),l.b.copy(o.vertexNormals[1]),l.c.copy(o.vertexNormals[2])}}for(let t=0,n=this.faces.length;t<n;t++){let s=this.faces[t];s.normal=s.__originalFaceNormal,s.vertexNormals=s.__originalVertexNormals}}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ss),this.boundingBox.setFromPoints(this.vertices)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Wi),this.boundingSphere.setFromPoints(this.vertices)}merge(e,t,n=0){if(!(e&&e.isGeometry)){console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e);return}let s,r=this.vertices.length,i=this.vertices,o=e.vertices,a=this.faces,l=e.faces,c=this.colors,h=e.colors;t!==void 0&&(s=new Or().getNormalMatrix(t));for(let u=0,d=o.length;u<d;u++){let p=o[u].clone();t!==void 0&&p.applyMatrix4(t),i.push(p)}for(let u=0,d=h.length;u<d;u++)c.push(h[u].clone());for(let u=0,d=l.length;u<d;u++){let p=l[u],f,g,m=p.vertexNormals,y=p.vertexColors,v=new B2(p.a+r,p.b+r,p.c+r);v.normal.copy(p.normal),s!==void 0&&v.normal.applyMatrix3(s).normalize();for(let b=0,x=m.length;b<x;b++)f=m[b].clone(),s!==void 0&&f.applyMatrix3(s).normalize(),v.vertexNormals.push(f);v.color.copy(p.color);for(let b=0,x=y.length;b<x;b++)g=y[b],v.vertexColors.push(g.clone());v.materialIndex=p.materialIndex+n,a.push(v)}for(let u=0,d=e.faceVertexUvs.length;u<d;u++){let p=e.faceVertexUvs[u];this.faceVertexUvs[u]===void 0&&(this.faceVertexUvs[u]=[]);for(let f=0,g=p.length;f<g;f++){let m=p[f],y=[];for(let v=0,b=m.length;v<b;v++)y.push(m[v].clone());this.faceVertexUvs[u].push(y)}}}mergeMesh(e){if(!(e&&e.isMesh)){console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e);return}e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)}mergeVertices(e=4){let t={},n=[],s=[],r=Math.pow(10,e);for(let a=0,l=this.vertices.length;a<l;a++){let c=this.vertices[a],h=Math.round(c.x*r)+"_"+Math.round(c.y*r)+"_"+Math.round(c.z*r);t[h]===void 0?(t[h]=a,n.push(this.vertices[a]),s[a]=n.length-1):s[a]=s[t[h]]}let i=[];for(let a=0,l=this.faces.length;a<l;a++){let c=this.faces[a];c.a=s[c.a],c.b=s[c.b],c.c=s[c.c];let h=[c.a,c.b,c.c];for(let u=0;u<3;u++)if(h[u]===h[(u+1)%3]){i.push(a);break}}for(let a=i.length-1;a>=0;a--){let l=i[a];this.faces.splice(l,1);for(let c=0,h=this.faceVertexUvs.length;c<h;c++)this.faceVertexUvs[c].splice(l,1)}let o=this.vertices.length-n.length;return this.vertices=n,o}setFromPoints(e){this.vertices=[];for(let t=0,n=e.length;t<n;t++){let s=e[t];this.vertices.push(new I(s.x,s.y,s.z||0))}return this}sortFacesByMaterialIndex(){let e=this.faces,t=e.length;for(let a=0;a<t;a++)e[a]._id=a;function n(a,l){return a.materialIndex-l.materialIndex}e.sort(n);let s=this.faceVertexUvs[0],r=this.faceVertexUvs[1],i,o;s&&s.length===t&&(i=[]),r&&r.length===t&&(o=[]);for(let a=0;a<t;a++){let l=e[a]._id;i&&i.push(s[l]),o&&o.push(r[l])}i&&(this.faceVertexUvs[0]=i),o&&(this.faceVertexUvs[1]=o)}toJSON(){let e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),this.parameters!==void 0){let p=this.parameters;for(let f in p)p[f]!==void 0&&(e[f]=p[f]);return e}let t=[];for(let p=0;p<this.vertices.length;p++){let f=this.vertices[p];t.push(f.x,f.y,f.z)}let n=[],s=[],r={},i=[],o={},a=[],l={};for(let p=0;p<this.faces.length;p++){let f=this.faces[p],g=!0,m=!1,y=this.faceVertexUvs[0][p]!==void 0,v=f.normal.length()>0,b=f.vertexNormals.length>0,x=f.color.r!==1||f.color.g!==1||f.color.b!==1,w=f.vertexColors.length>0,S=0;if(S=c(S,0,0),S=c(S,1,g),S=c(S,2,m),S=c(S,3,y),S=c(S,4,v),S=c(S,5,b),S=c(S,6,x),S=c(S,7,w),n.push(S),n.push(f.a,f.b,f.c),n.push(f.materialIndex),y){let C=this.faceVertexUvs[0][p];n.push(d(C[0]),d(C[1]),d(C[2]))}if(v&&n.push(h(f.normal)),b){let C=f.vertexNormals;n.push(h(C[0]),h(C[1]),h(C[2]))}if(x&&n.push(u(f.color)),w){let C=f.vertexColors;n.push(u(C[0]),u(C[1]),u(C[2]))}}function c(p,f,g){return g?p|1<<f:p&~(1<<f)}function h(p){let f=p.x.toString()+p.y.toString()+p.z.toString();return r[f]!==void 0||(r[f]=s.length/3,s.push(p.x,p.y,p.z)),r[f]}function u(p){let f=p.r.toString()+p.g.toString()+p.b.toString();return o[f]!==void 0||(o[f]=i.length,i.push(p.getHex())),o[f]}function d(p){let f=p.x.toString()+p.y.toString();return l[f]!==void 0||(l[f]=a.length/2,a.push(p.x,p.y)),l[f]}return e.data={},e.data.vertices=t,e.data.normals=s,i.length>0&&(e.data.colors=i),a.length>0&&(e.data.uvs=[a]),e.data.faces=n,e}clone(){return new Jv().copy(this)}copy(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;let t=e.vertices;for(let u=0,d=t.length;u<d;u++)this.vertices.push(t[u].clone());let n=e.colors;for(let u=0,d=n.length;u<d;u++)this.colors.push(n[u].clone());let s=e.faces;for(let u=0,d=s.length;u<d;u++)this.faces.push(s[u].clone());for(let u=0,d=e.faceVertexUvs.length;u<d;u++){let p=e.faceVertexUvs[u];this.faceVertexUvs[u]===void 0&&(this.faceVertexUvs[u]=[]);for(let f=0,g=p.length;f<g;f++){let m=p[f],y=[];for(let v=0,b=m.length;v<b;v++){let x=m[v];y.push(x.clone())}this.faceVertexUvs[u].push(y)}}let r=e.morphTargets;for(let u=0,d=r.length;u<d;u++){let p={};if(p.name=r[u].name,r[u].vertices!==void 0){p.vertices=[];for(let f=0,g=r[u].vertices.length;f<g;f++)p.vertices.push(r[u].vertices[f].clone())}if(r[u].normals!==void 0){p.normals=[];for(let f=0,g=r[u].normals.length;f<g;f++)p.normals.push(r[u].normals[f].clone())}this.morphTargets.push(p)}let i=e.morphNormals;for(let u=0,d=i.length;u<d;u++){let p={};if(i[u].vertexNormals!==void 0){p.vertexNormals=[];for(let f=0,g=i[u].vertexNormals.length;f<g;f++){let m=i[u].vertexNormals[f],y={};y.a=m.a.clone(),y.b=m.b.clone(),y.c=m.c.clone(),p.vertexNormals.push(y)}}if(i[u].faceNormals!==void 0){p.faceNormals=[];for(let f=0,g=i[u].faceNormals.length;f<g;f++)p.faceNormals.push(i[u].faceNormals[f].clone())}this.morphNormals.push(p)}let o=e.skinWeights;for(let u=0,d=o.length;u<d;u++)this.skinWeights.push(o[u].clone());let a=e.skinIndices;for(let u=0,d=a.length;u<d;u++)this.skinIndices.push(a[u].clone());let l=e.lineDistances;for(let u=0,d=l.length;u<d;u++)this.lineDistances.push(l[u]);let c=e.boundingBox;c!==null&&(this.boundingBox=c.clone());let h=e.boundingSphere;return h!==null&&(this.boundingSphere=h.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this}toBufferGeometry(){let e=new uae().fromGeometry(this),t=new It,n=new Float32Array(e.vertices.length*3);if(t.setAttribute("position",new Lt(n,3).copyVector3sArray(e.vertices)),e.normals.length>0){let s=new Float32Array(e.normals.length*3);t.setAttribute("normal",new Lt(s,3).copyVector3sArray(e.normals))}if(e.colors.length>0){let s=new Float32Array(e.colors.length*3);t.setAttribute("color",new Lt(s,3).copyColorsArray(e.colors))}if(e.uvs.length>0){let s=new Float32Array(e.uvs.length*2);t.setAttribute("uv",new Lt(s,2).copyVector2sArray(e.uvs))}if(e.uvs2.length>0){let s=new Float32Array(e.uvs2.length*2);t.setAttribute("uv2",new Lt(s,2).copyVector2sArray(e.uvs2))}t.groups=e.groups;for(let s in e.morphTargets){let r=[],i=e.morphTargets[s];for(let o=0,a=i.length;o<a;o++){let l=i[o],c=new ot(l.data.length*3,3);c.name=l.name,r.push(c.copyVector3sArray(l.data))}t.morphAttributes[s]=r}if(e.skinIndices.length>0){let s=new ot(e.skinIndices.length*4,4);t.setAttribute("skinIndex",s.copyVector4sArray(e.skinIndices))}if(e.skinWeights.length>0){let s=new ot(e.skinWeights.length*4,4);t.setAttribute("skinWeight",s.copyVector4sArray(e.skinWeights))}return e.boundingSphere!==null&&(t.boundingSphere=e.boundingSphere.clone()),e.boundingBox!==null&&(t.boundingBox=e.boundingBox.clone()),t}computeTangents(){console.error("THREE.Geometry: .computeTangents() has been removed.")}computeLineDistances(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")}applyMatrix(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}dispose(){this.dispatchEvent({type:"dispose"})}static createBufferGeometryFromObject(e){let t=new It,n=e.geometry;if(e.isPoints||e.isLine){let s=new ot(n.vertices.length*3,3),r=new ot(n.colors.length*3,3);if(t.setAttribute("position",s.copyVector3sArray(n.vertices)),t.setAttribute("color",r.copyColorsArray(n.colors)),n.lineDistances&&n.lineDistances.length===n.vertices.length){let i=new ot(n.lineDistances.length,1);t.setAttribute("lineDistance",i.copyArray(n.lineDistances))}n.boundingSphere!==null&&(t.boundingSphere=n.boundingSphere.clone()),n.boundingBox!==null&&(t.boundingBox=n.boundingBox.clone())}else e.isMesh&&(t=n.toBufferGeometry());return t}};Jv.prototype.isGeometry=!0;var uae=class{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(e){let t=[],n,s,r,i=e.faces;for(s=0;s<i.length;s++){let o=i[s];o.materialIndex!==r&&(r=o.materialIndex,n!==void 0&&(n.count=s*3-n.start,t.push(n)),n={start:s*3,materialIndex:r})}n!==void 0&&(n.count=s*3-n.start,t.push(n)),this.groups=t}fromGeometry(e){let t=e.faces,n=e.vertices,s=e.faceVertexUvs,r=s[0]&&s[0].length>0,i=s[1]&&s[1].length>0,o=e.morphTargets,a=o.length,l;if(a>0){l=[];for(let m=0;m<a;m++)l[m]={name:o[m].name,data:[]};this.morphTargets.position=l}let c=e.morphNormals,h=c.length,u;if(h>0){u=[];for(let m=0;m<h;m++)u[m]={name:c[m].name,data:[]};this.morphTargets.normal=u}let d=e.skinIndices,p=e.skinWeights,f=d.length===n.length,g=p.length===n.length;n.length>0&&t.length===0&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let m=0;m<t.length;m++){let y=t[m];this.vertices.push(n[y.a],n[y.b],n[y.c]);let v=y.vertexNormals;if(v.length===3)this.normals.push(v[0],v[1],v[2]);else{let x=y.normal;this.normals.push(x,x,x)}let b=y.vertexColors;if(b.length===3)this.colors.push(b[0],b[1],b[2]);else{let x=y.color;this.colors.push(x,x,x)}if(r===!0){let x=s[0][m];x!==void 0?this.uvs.push(x[0],x[1],x[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",m),this.uvs.push(new se,new se,new se))}if(i===!0){let x=s[1][m];x!==void 0?this.uvs2.push(x[0],x[1],x[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",m),this.uvs2.push(new se,new se,new se))}for(let x=0;x<a;x++){let w=o[x].vertices;l[x].data.push(w[y.a],w[y.b],w[y.c])}for(let x=0;x<h;x++){let w=c[x].vertexNormals[m];u[x].data.push(w.a,w.b,w.c)}f&&this.skinIndices.push(d[y.a],d[y.b],d[y.c]),g&&this.skinWeights.push(p[y.a],p[y.b],p[y.c])}return this.computeGroups(e),this.verticesNeedUpdate=e.verticesNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),this}},B2=class{constructor(e,t,n,s,r,i=0){this.a=e,this.b=t,this.c=n,this.normal=s&&s.isVector3?s:new I,this.vertexNormals=Array.isArray(s)?s:[],this.color=r&&r.isColor?r:new _t,this.vertexColors=Array.isArray(r)?r:[],this.materialIndex=i}clone(){return new this.constructor().copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,n=e.vertexNormals.length;t<n;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,n=e.vertexColors.length;t<n;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}},hae=["a","b","c"];function dae(e,t){switch(t){case"c":return e.c;case"b":return e.b;case"a":default:return e.a}}function z2(e,t,n){let s=Math.min(e,t),r=Math.max(e,t),i=s+"_"+r;return n.get(i)}function U2(e,t,n,s,r,i){let o=Math.min(e,t),a=Math.max(e,t),l=o+"_"+a,c;if(s.has(l))c=s.get(l);else{let h=n[o],u=n[a];c={a:h,b:u,newEdge:null,faces:[]},s.set(l,c)}c.faces.push(r),i[e].edges.push(c),i[t].edges.push(c)}function pae(e,t,n,s){let r,i,o;for(r=0,i=e.length;r<i;r++)n[r]={edges:[]};for(r=0,i=t.length;r<i;r++)o=t[r],U2(o.a,o.b,e,s,o,n),U2(o.b,o.c,e,s,o,n),U2(o.c,o.a,e,s,o,n)}function ex(e,t,n,s,r){e.push(new B2(t,n,s,void 0,void 0,r))}function Yd(e,t){return Math.abs(t-e)/2+Math.min(e,t)}function tx(e,t,n,s){e.push([t.clone(),n.clone(),s.clone()])}var fae=class{constructor(e=1){this.subdivisions=e}modify(e){e instanceof It?e=new Jv().fromBufferGeometry(e):e=e.clone(),e.mergeVertices();let t=this.subdivisions;for(;t-- >0;)this._smooth(e);return e.computeFaceNormals(),e.computeVertexNormals(),e}_smooth(e){let t=new I,n,s,r,i,o,a=e.vertices,l=e.faces,c=e.faceVertexUvs[0],h=c!==void 0&&c.length>0,u=[],d=new Map;pae(a,l,u,d);let p=[],f,g,m,y,v,b,x;for(let oe of Array.from(d.keys())){for(g=d.get(oe),m=new I,v=3/8,b=1/8,x=g.faces.length,x!=2&&(v=.5,b=0,x!=1),m.addVectors(g.a,g.b).multiplyScalar(v),t.set(0,0,0),i=0;i<x;i++){for(y=g.faces[i],o=0;o<3&&(f=a[dae(y,hae[o])],!(f!==g.a&&f!==g.b));o++);f&&t.add(f)}t.multiplyScalar(b),m.add(t),g.newEdge=p.length,p.push(m)}let w,S,C,_,T,E,A,D=[];for(s=0,r=a.length;s<r;s++){for(E=a[s],T=u[s].edges,n=T.length,n==3?w=3/16:n>3&&(w=3/(8*n)),S=1-n*Number(w),C=w,n<=2&&(n==2?(S=3/4,C=1/8):n==1||n==0),A=E.clone().multiplyScalar(S),t.set(0,0,0),i=0;i<n;i++)_=T[i],f=_.a!==E?_.a:_.b,t.add(f);t.multiplyScalar(Number(C)),A.add(t),D.push(A)}let O=D.concat(p),P=D.length,L,B,F,M=[],U=[],z,$,R,H,K=new se,Y=new se,X=new se;for(s=0,r=l.length;s<r;s++)y=l[s],L=Number(z2(y.a,y.b,d).newEdge)+P,B=Number(z2(y.b,y.c,d).newEdge)+P,F=Number(z2(y.c,y.a,d).newEdge)+P,ex(M,L,B,F,y.materialIndex),ex(M,y.a,L,F,y.materialIndex),ex(M,y.b,B,L,y.materialIndex),ex(M,y.c,F,B,y.materialIndex),h&&(z=c[s],$=z[0],R=z[1],H=z[2],K.set(Yd($.x,R.x),Yd($.y,R.y)),Y.set(Yd(R.x,H.x),Yd(R.y,H.y)),X.set(Yd($.x,H.x),Yd($.y,H.y)),tx(U,K,Y,X),tx(U,$,K,X),tx(U,R,Y,K),tx(U,H,X,Y));e.vertices=O,e.faces=M,h&&(e.faceVertexUvs[0]=U)}},Os=new I,mae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var i,o;let n=(o=(i=e.geometry)!=null?i:t==null?void 0:t.geometry)!=null?o:new It().copy(new pa(100,100,100)),s;t===void 0?(n.computeBoundingBox(),n.boundingBox.getSize(Os),s={width:Os.x,height:Os.y,depth:Os.z,subdivisions:0}):s=t.parameters;let r=ue(ue({},s),e.parameters);return{parameters:{width:Math.abs(r.width),height:Math.abs(r.height),depth:Math.abs(r.depth),subdivisions:Math.abs(r.subdivisions)},geometry:n}}static build(e){var l;let{width:t,height:n,depth:s,subdivisions:r}=e.parameters,i=(l=e.geometry)!=null?l:new It().copy(new pa(100,100,100)),o=i.userData.parameters;o===void 0?(i.computeBoundingBox(),i.boundingBox.getSize(Os)):Os.set(o.width,o.height,o.depth),(t!==Os.x||n!==Os.y||s!==Os.z)&&i.scale(Os.x===0?1:t/Os.x,Os.y===0?1:n/Os.y,Os.z===0?1:s/Os.z);let a=i.originalGeometry;return r>0?(a===void 0||(o==null?void 0:o.subdivisions)!==r)&&(a===void 0&&(a=i),i=new fae(r).modify(a).toBufferGeometry()):(a!==void 0&&(i=a),a=void 0,i.getAttribute("normal")===void 0&&i.computeVertexNormals()),a!==void 0&&Object.assign(i,{originalGeometry:a}),delete e.geometry,Object.assign(i,{userData:De(ue({},e),{type:"NonParametricGeometry"})})}static loadFromUrl(e,t,n){new bM(n).load(e,s=>{let r=this.normalizeInputs({geometry:s});s.boundingBox.getSize(Os);let i=100/Os.x;Object.assign(r.parameters,{width:100,height:Os.y*i,depth:Os.z*i}),t(this.build(r))})}},gae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var s,r,i;let n=Object.assign({},(s=t==null?void 0:t.parameters)!=null?s:{width:100,depth:0,spikes:5,cornerRadius:0,extrudeBevelSize:0,extrudeBevelSegments:3},e.parameters);return{shape:e.shape&&e.shape instanceof is?e.shape:new is,parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((r=n.height)!=null?r:n.width),depth:Math.abs((i=n.depth)!=null?i:0)})}}static build(e){let{width:t,height:n,spikes:s,cornerRadius:r,depth:i,extrudeBevelSize:o,extrudeBevelSegments:a}=e.parameters,l=e.shape,c=t*.5,h=n*.5,u=0,d=0,p=2*Math.PI/s;for(let g=0;g<s;g++){let m=p*g,y=u+Math.sin(m)*c,v=d+Math.cos(m)*h;l.addPoint(l.createPoint(y,v))}l.isClosed=!0;for(let g=0,m=l.points.length;g<m;g++)l.points[g].roundness=r;l.roundness=r,l.update();let f=Bu.create({shape:l,parameters:{roundness:r,depth:i,extrudeBevelSize:o,extrudeBevelSegments:a}});return Object.assign(f,{userData:De(ue({},e),{type:"PolygonGeometry"})})}},yae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var s,r,i;let n=Object.assign({},(s=t==null?void 0:t.parameters)!=null?s:{width:100,radialSegments:4,heightSegments:1,cornerRadius:0,cornerSegments:8,openEnded:!1},e.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((r=n.height)!=null?r:n.width),depth:Math.abs((i=n.depth)!=null?i:n.width)})}}static build(e){let{width:t,height:n,depth:s,radialSegments:r,heightSegments:i,openEnded:o,cornerRadius:a,cornerSegments:l}=e.parameters,c=new xae(t*.5,n,r,i,o,a,l);return c.scale(1,1,s/t),Object.assign(c,{userData:De(ue({},e),{type:"PyramidGeometry"})})}};function Sm(e,t,n){n.x=e.x*t.x,n.y=e.y,n.z=e.x*t.y}function V2(e,t,n,s,r,i){let o=t.clone().sub(e),a=n.clone().sub(e),l=o.angleTo(a);if(o.normalize(),a.normalize(),s===r){let c=o.add(a).normalize();i.copy(e).addScaledVector(c,s/Math.sin(l/2))}else{let c=o.angleTo(a);i.copy(e),i.addScaledVector(o,r/Math.sin(c)),i.addScaledVector(a,s/Math.sin(c))}}function vae(e,t,n){let s=e.clone().sub(t),r=n.clone().sub(t);return s.projectOnVector(r),s.add(t)}var xae=class extends It{constructor(e=.5,t=1,n=4,s=1,r=!1,i=0,o=4){super(),n=Math.floor(Math.max(3,n)),s=Math.floor(s),o=Math.floor(o);let a=[],l=[],c=[],h=[],u=0,d=t/2,p=Math.PI/n,f=e*Math.cos(Math.PI/n),g=2*Math.PI/n,m=(n-2)*Math.PI/n,y=Math.PI-m,v=new I(0,-d,0),b=new I(0,d,0),x=new se(e,-d),w=new se(f,-d),S=new se(0,b.y).sub(w),C=new se(0,b.y).sub(x),_=new se(S.y,-S.x).normalize(),T=new se(C.y,-C.x).normalize(),E=e*Math.cos(Math.PI/n)*Math.tan((Math.PI-S.angle())/2)-1e-8;i=Math.min(i,E);let A;{let F=new I(_.x,_.y,0),M=new I(Math.cos(g)*F.x,F.y,Math.sin(g)*F.x);A=F.angleTo(M)}let D=i/Math.tan((Math.PI-S.angle())/2),O=i/Math.tan((Math.PI-A)/2),P=new I;if(!r){l.push(v.x,v.y,v.z),c.push(0,-1,0),h.push(0,0);let F=u++,M=[],U=x.clone(),z=D/Math.cos(Math.PI/n);U.x-=z;for(let $=0;$<n;$++){let R=$/n*Math.PI*2+p,H=new se(Math.sin(R),Math.cos(R));Sm(U,H,P),l.push(P.x,P.y,P.z),c.push(0,-1,0),h.push(0,0),M.push(u++)}for(let $=0;$<M.length;$++)a.push(M[$],F,M[($+1)%M.length])}{let F=new I,M=new I,U=new I,z=new I,$=new I,R=new I;for(let H=0;H<n;H++){let K=H/n*Math.PI*2+p,Y=(H+.5)/n*Math.PI*2+p,X=(H+1)/n*Math.PI*2+p,oe=new se(Math.sin(K),Math.cos(K)),ie=new se(Math.sin(Y),Math.cos(Y)),Z=new se(Math.sin(X),Math.cos(X));Sm(x,oe,M),Sm(x,Z,U),Sm(_,ie,F),V2(b,M,U,O,O,z),l.push(z.x,z.y,z.z),V2(M,b,U,O,D,$),l.push($.x,$.y,$.z),V2(U,M,b,D,O,R),l.push(R.x,R.y,R.z),c.push(F.x,F.y,F.z),c.push(F.x,F.y,F.z),c.push(F.x,F.y,F.z),h.push(0,0),h.push(0,0),h.push(0,0);let ce=u++,ge=u++,_e=u++;if(a.push(ce,ge,_e),i>0){{let Ie=M.clone().add(U).multiplyScalar(.5),Le=b.clone().sub(Ie).normalize(),Ue=v.clone().sub(Ie).normalize().add(Le).normalize().multiplyScalar(-1),$e=R.clone().sub($);L(Ie,$e,Ue,S.angle())}let be,Me;{let Ie=new I;Sm(T,Z,Ie);let Le=R.clone().add(z).multiplyScalar(.5);Le=vae(Le,U,b);let Ue=R.clone().sub(z);[be,Me]=L(Le,Ue,Ie,A,z.y)}{let Ie=be,Le=Ie.clone().setY(0).normalize(),Ue=new I(0,-1,0),$e=Le.clone().cross(Ue);B(Ie,Le,Ue,$e)}{let Ie=S.angle(),Le=Math.PI-Ie,Ue=b.clone();Ue.y-=i/Math.sin(Ie-Math.PI/2);let $e=new I,We=[];for(let ct=0;ct<o;ct++){let j=[],V=Math.PI/2-Le*ct/o,we=Math.cos(V),Pe=Math.sin(V),Be=Y;for(let je=0;je<=ct;je++){let pt=Math.cos(Be),Te=Math.sin(Be);F.x=we*Te,F.y=Pe,F.z=we*pt,$e.copy(Ue).addScaledVector(F,i),l.push($e.x,$e.y,$e.z),c.push(F.x,F.y,F.z),h.push(0,0),j.push(u++),Be+=Math.PI*2/ct/n}We.push(j)}Me.reverse(),We.push(Me);let Rt=We.length-1;for(let ct=0;ct<Rt;ct++){let j=We[ct],V=We[ct+1],we=j.length-1;a.push(V[1],j[0],V[0]);for(let Pe=1;Pe<=we;Pe++)a.push(j[Pe],j[Pe-1],V[Pe]),a.push(V[Pe+1],j[Pe],V[Pe])}}}}}this.setIndex(a),this.setAttribute("position",new ot(l,3)),this.setAttribute("normal",new ot(c,3)),this.setAttribute("uv",new ot(h,2));function L(F,M,U,z,$){let R=-z/2,H=(Math.PI-z)/2,K=M.clone().normalize().cross(U);F.addScaledVector(U,-i/Math.sin(H));let Y=new I,X=new I,oe=1,ie=u,Z=[];for(let ce=0;ce<=o;ce++){let ge=R+ce/o*z;X.set(0,0,0),X.addScaledVector(K,Math.sin(ge)),X.addScaledVector(U,Math.cos(ge));for(let _e=0;_e<=oe;_e++){let be=_e/oe-.5;if(Y.copy(F),Y.addScaledVector(M,be),Y.addScaledVector(X,i),$!=null){let Me=Math.max(0,Y.y-$);Y.addScaledVector(M,-Me/M.y)}l.push(Y.x,Y.y,Y.z),c.push(X.x,X.y,X.z),h.push(0,0),_e===0&&Z.push(u),u++}}for(let ce=0;ce<o;ce++)for(let ge=0;ge<oe;ge++){let _e=ie+ge+(oe+1)*ce,be=_e+(oe+1),Me=be+1,Ie=_e+1;a.push(_e,be,Ie),a.push(be,Me,Ie)}return[F.clone().addScaledVector(M,.5),Z]}function B(F,M,U,z){let $=Math.PI/2,R=C.angle()-$,H=[],K=new I,Y=new I;for(let oe=0;oe<=o;oe++){let ie=[],Z=oe/o;for(let ce=0;ce<=oe;ce++){let ge=((oe?ce/oe:0)-.5)*y,_e=Math.cos(ge),be=Math.sin(ge),Me=Math.atan(Math.tan(R)*_e),Ie=($+Me)*Z,Le=Math.cos(Ie),Ue=Math.sin(Ie);K.set(0,0,0),K.addScaledVector(M,Ue*_e),K.addScaledVector(U,Le),K.addScaledVector(z,Ue*be),Y.copy(F).addScaledVector(K,i),l.push(Y.x,Y.y,Y.z),c.push(K.x,K.y,K.z),h.push(0,0),ie.push(u++)}H.push(ie)}let X=H.length-1;for(let oe=0;oe<X;oe++){let ie=H[oe],Z=H[oe+1],ce=ie.length-1;a.push(ie[0],Z[1],Z[0]);for(let ge=1;ge<=ce;ge++)a.push(ie[ge-1],ie[ge],Z[ge]),a.push(ie[ge],Z[ge+1],Z[ge])}}}},bae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var r,i,o,a;let n=Object.assign({},(r=t==null?void 0:t.parameters)!=null?r:{width:100,depth:0,cornerRadius:[0,0,0,0],cornerType:1,extrudeBevelSize:0,extrudeBevelSegments:1},e.parameters),s=Object.assign((i=t==null?void 0:t.ui)!=null?i:{enabledIndieCorners:!1},e.ui);return{shape:e.shape&&e.shape instanceof is?e.shape:new is,parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((o=n.height)!=null?o:n.width),depth:Math.abs((a=n.depth)!=null?a:0)}),ui:s}}static build(e){let t=e.shape,{width:n,height:s,cornerRadius:r,cornerType:i,depth:o,extrudeBevelSize:a,extrudeBevelSegments:l}=e.parameters,c={x:n*.5,y:s*.5},h={x:-c.x,y:-c.y},u={x:c.x,y:c.y};function d(x,w,S){return w>n&&S>s?Math.min(x*n/w,x*s/S):w>n?x*n/w:S>s?x*s/S:x}let p=[];p[0]=r[0]===0?0:d(r[0],r[0]+r[3],r[0]+r[1]),p[1]=r[1]===0?0:d(r[1],r[1]+r[2],r[1]+r[0]),p[2]=r[2]===0?0:d(r[2],r[2]+r[1],r[2]+r[3]),p[3]=r[3]===0?0:d(r[3],r[3]+r[0],r[3]+r[2]);let f=h.x,g=u.x,m=u.y,y=h.y;t.addPoint(t.createPoint(f,m)),t.addPoint(t.createPoint(g,m)),t.addPoint(t.createPoint(g,y)),t.addPoint(t.createPoint(f,y)),t.isClosed=!0;let v=!0;for(let x=0,w=t.points.length;x<w;x++)t.points[x].roundness=p[x],x>0&&p[x]!==p[x-1]&&(v=!1);v&&(t.roundness=p[0]),t.useCubicForRoundedCorners=i!==1,t.update();let b=Bu.create({shape:t,parameters:{depth:o,extrudeBevelSize:a,extrudeBevelSegments:l}});return Object.assign(b,{userData:De(ue({},e),{type:"RectangleGeometry"})})}},wae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var s,r,i;let n=Object.assign({},(s=t==null?void 0:t.parameters)!=null?s:{width:100,widthSegments:64,heightSegments:64,phiStart:0,phiLength:2*Math.PI,thetaStart:0,thetaLength:Math.PI},e.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((r=n.height)!=null?r:n.width),depth:Math.abs((i=n.depth)!=null?i:n.width)})}}static build(e){let{width:t=100,height:n=t,depth:s=t,widthSegments:r=64,heightSegments:i=64,phiStart:o,phiLength:a,thetaStart:l,thetaLength:c}=e.parameters,h=new HS(.5*t,r,i,o,a,l,c);return h.scale(1,n/t,s/t),Object.assign(h,{userData:De(ue({},e),{type:"SphereGeometry"})})}},Sae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var s,r;let n=Object.assign({},(s=t==null?void 0:t.parameters)!=null?s:{width:100,depth:0,widthSegments:8,heightSegments:8},e.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((r=n.height)!=null?r:n.width),depth:0})}}static build(e){let{width:t=100,height:n=t,widthSegments:s=8,heightSegments:r=8}=e.parameters,i=new _y(t,n,s,r);return i.scale(1,1,1),Object.assign(i,{userData:De(ue({},e),{type:"PlaneGeometry"})})}},_ae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var s,r,i;let n=Object.assign({},(s=t==null?void 0:t.parameters)!=null?s:{width:100,angle:90,cornerRadius:24,cornerSegments:8},e.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((r=n.height)!=null?r:n.width),depth:Math.abs((i=n.depth)!=null?i:n.width)})}}static build(e){let{width:t,height:n,depth:s,angle:r,cornerRadius:i,cornerSegments:o}=e.parameters,a=new Cae(t,n,s,r,i,o);return Object.assign(a,{userData:De(ue({},e),{type:"BackdropGeometry"})})}},Cae=class extends It{constructor(e=1,t=1,n=1,s=90,r=10,i=24){super(),this.type="BackdropGeometry";let o=[],a=[],l=[],c=.001;r==0&&(i=1),i=Math.max(1,Math.floor(i)),r=Math.min(r,100),s=Math.min(180-c,s),s*=Math.PI/180;let h=[],u=Math.PI/2,d=(oe=0,ie=0,Z=0)=>new I(oe,ie,Z),p=d(),f=d(),[g,m,y]=[t/2,e/2,n/2],v=-m,b=+m,[x,w,S]=[d(v,-g,+y),d(v,-g,-y),d(v,+g,-y)],C=(oe,ie=!1)=>Math.sin(oe-Math.PI/(1+ +ie)),_=(oe,ie=!1)=>Math.cos(oe-Math.PI/(1+ +ie));S.y=Math.sin(s)*t-g;let T=Math.cos(s)*t-y,E=x.z-c;s<=u?(S.z=Math.min(T,E),S.z==E&&(S.y-=(T-E)/Math.tan(u-s))):w.z=Math.min(w.z-T-y,x.z-c),p.subVectors(x,w),f.subVectors(S,w);let A=Math.min(p.length(),f.length())*r/100,D=A*Math.tan(s/2),O=A/Math.cos(s/2),P=p.clone().normalize().add(f.normalize()).setLength(O).add(w);p.set(0,C(s,!0),_(s,!0)),h.push([S,p.clone()]);let L=(Math.PI-s)/i;for(let oe=0;oe<=i;oe++){let ie=u+s+oe*L;p.set(0,Math.sin(ie)*D,Math.cos(ie)*D),p.add(P),f.set(0,C(ie),_(ie)),h.push([p.clone(),f.clone()])}h.push([x,d(0,1,0)]);let B=Math.sin(L/2)*D*2,F=h.length-1,M=h[0][0].distanceTo(h[1][0]),U=h[F-1][0].distanceTo(h[F][0]),z=M+B*i+U;h[0].push(1);for(let oe=0;oe<=i;oe++)h[oe+1].push(1-(M+oe*B)/z);h[F].push(0);let[$,R,H]=h[0],K,Y,X;for(let oe=1;oe<h.length;oe++)[K,Y,X]=h[oe],o.push(v,$.y,$.z,v,K.y,K.z,b,$.y,$.z,b,$.y,$.z,v,K.y,K.z,b,K.y,K.z),a.push(0,R.y,R.z,0,Y.y,Y.z,0,R.y,R.z,0,R.y,R.z,0,Y.y,Y.z,0,Y.y,Y.z),l.push(0,H,0,X,1,H,1,H,0,X,1,X),[$,R,H]=[K,Y,X];this.setAttribute("position",new ot(o,3)),this.setAttribute("normal",new ot(a,3)),this.setAttribute("uv",new ot(l,2))}},Tae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var s,r,i;let n=Object.assign({},(s=t==null?void 0:t.parameters)!=null?s:{width:100,depth:0,innerRadiusPercent:38.19,spikes:5,cornerRadius:0,angle:360,extrudeBevelSize:0,extrudeBevelSegments:1},e.parameters);return{shape:e.shape&&e.shape instanceof is?e.shape:new is,parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((r=n.height)!=null?r:n.width),depth:Math.abs((i=n.depth)!=null?i:0)})}}static build(e){let{width:t,height:n,innerRadiusPercent:s,spikes:r,cornerRadius:i,angle:o,depth:a,extrudeBevelSize:l,extrudeBevelSegments:c}=e.parameters,h=e.shape,u=t*.5,d=n*.5,p=0,f=0,g=o*Math.PI/360/r,m=Math.PI/2*3*-1,y=u*s/100,v=d*s/100;if(r===3&&s===50){g=2*Math.PI/r;for(let x=0;x<r;x++){let w=g*x,S=p+Math.sin(w)*u,C=f+Math.cos(w)*d;h.addPoint(h.createPoint(S,C))}}else for(let x=0;x<r;x++){let w=p+Math.cos(m)*u,S=f+Math.sin(m)*d;h.addPoint(h.createPoint(w,S)),m+=g,w=p+Math.cos(m)*y,S=f+Math.sin(m)*v,h.addPoint(h.createPoint(w,S)),m+=g}h.isClosed=!0;for(let x=0,w=h.points.length;x<w;x++)h.points[x].roundness=i;h.roundness=i,h.update();let b=Bu.create({shape:h,parameters:{roundness:i,depth:a,extrudeBevelSize:l,extrudeBevelSegments:c}});return Object.assign(b,{userData:De(ue({},e),{type:"StarGeometry"})})}},Eae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var s,r,i;let n=Object.assign({},(s=t==null?void 0:t.parameters)!=null?s:{width:100,depth:0},e.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((r=n.height)!=null?r:n.width),depth:Math.abs((i=n.depth)!=null?i:0)})}}static build(e){let{width:t,height:n}=e.parameters,s=new _y(t,n);return Object.assign(s,{userData:De(ue({},e),{type:"TextFrameGeometry"})})}},Aae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var o,a,l;let n=Object.assign({},(o=t==null?void 0:t.parameters)!=null?o:{width:100,radialSegments:32,tubularSegments:64,arc:Math.PI*2,cornerRadius:30,cornerSegments:8},e.parameters),s=Math.abs(n.width),r=Math.abs((a=n.height)!=null?a:n.width),i=Math.round(Math.abs((l=n.depth)!=null?l:n.width*.25));return{parameters:Object.assign(n,{width:s,height:r,depth:i})}}static build(e){let{width:t,height:n,depth:s,radialSegments:r,tubularSegments:i,arc:o,cornerRadius:a,cornerSegments:l}=e.parameters,c=Iae(t,n,s,t*.5,o,i,0,0,r,a,l);return c.scale(1,n/t,1),Object.assign(c,{userData:De(ue({},e),{type:"TorusGeometry"})})}};function Iae(e,t,n,s,r,i,o,a,l,c,h){return[t,n]=[n,t],o=t/2,r/=2*Math.PI,r==1&&(c=0),new F2(!0,e,t,n,s,r,i,o,a,l,c,h)}var Nae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var s,r,i,o;let n=Object.assign({},(s=t==null?void 0:t.parameters)!=null?s:{width:100,tubularSegments:64,radialSegments:32,p:2,q:3},e.parameters);return{parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((r=n.height)!=null?r:n.width),depth:Math.abs((i=n.depth)!=null?i:n.width),tube:(o=n.tube)!=null?o:n.width*.125})}}static build(e){let{width:t,tube:n,tubularSegments:s,radialSegments:r,p:i,q:o}=e.parameters,a=t*.5;a!==n&&(a-=n);let l=new pM(a,n,s,r,i,o);return Object.assign(l,{userData:De(ue({},e),{type:"TorusKnotGeometry"})})}},kae=class{static create(e){return this.build(this.normalizeInputs(e))}static normalizeInputs(e,t){var s,r,i;let n=Object.assign({},(s=t==null?void 0:t.parameters)!=null?s:{width:100,depth:0,spikes:5,cornerRadius:0,extrudeBevelSize:0,extrudeBevelSegments:1,isRect:!1},e.parameters);return{shape:e.shape&&e.shape instanceof is?e.shape:new is,parameters:Object.assign(n,{width:Math.abs(n.width),height:Math.abs((r=n.height)!=null?r:n.width*(n.isRect?1:Math.sqrt(3)/2)),depth:Math.abs((i=n.depth)!=null?i:0)})}}static build(e){let{width:t=100,height:n,cornerRadius:s,depth:r,extrudeBevelSize:i,extrudeBevelSegments:o,isRect:a}=e.parameters,l=e.shape,c=t*.5,h=n*.5;a?(l.addPoint(l.createPoint(-c,h)),l.addPoint(l.createPoint(c,-h)),l.addPoint(l.createPoint(-c,-h))):(l.addPoint(l.createPoint(0,h)),l.addPoint(l.createPoint(c,-h)),l.addPoint(l.createPoint(-c,-h))),l.isClosed=!0;for(let d=0,p=l.points.length;d<p;d++)l.points[d].roundness=s;l.roundness=s,l.update();let u=Bu.create({shape:l,parameters:{roundness:s,depth:r,extrudeBevelSize:i,extrudeBevelSegments:o}});return Object.assign(u,{userData:De(ue({},e),{type:"TriangleGeometry"})})}};function Dae(){let e=new It;return e.setAttribute("position",new Lt(new Float32Array([]),3)),e.setIndex(new Lt(new Uint16Array([]),1)),e}var Mae=12,Pae=1,sR=class extends It{constructor(e,t){super();this.charWidths=[],this.charCoords=[],this.wrappedText=[],this.isLowResolution=!1,this.vectorShapes=[],this.userData={parameters:e,type:"TextGeometry"};let n=t.getFont(e.font);(n==null?void 0:n.isLoaded)?(this.font=n,this.update(e)):this.updateFont(e.font,t).then(()=>{this.update(e),t==null||t.requestRender()})}async updateFont(e,t){let n=t.getFont(e);n&&(this.font=n,await n.loadingPromise)}update(e){let t=this.font;if(this.userData={parameters:e,type:"TextGeometry"},!(t==null?void 0:t.isLoaded)){console.warn("Cannot update text because its font is not loaded");return}let{width:n,height:s,depth:r,extrudeBevelSize:i,extrudeBevelSegments:o,text:a,textTransform:l}=e,c=l===2?a.toUpperCase():l===3?a.toLowerCase():a,h=Oae(e,t,c),{shapes:u,charWidths:d,charCoords:p}=t.generateShapes(h,e),f=n*.5,g=s*.5,m=u.map(b=>new is().fromShape(b));this.vectorShapes=m;let y=m.map(b=>Bu.create({shape:b,parameters:{depth:r,extrudeBevelSegments:o,extrudeBevelSize:i,windingRule:r<=0?Wn.NONZERO:Wn.ODD,subdivisions:this.isLowResolution&&r>0?Pae:Mae}})),v=y.length?Bd(y):Dae();v.translate(-f,g,0),this.dispose(),this.wrappedText=h,this.charCoords=p,this.charWidths=d,this.deleteAttribute("extrudeNormal"),Object.entries(v.attributes).forEach(([b,x])=>{this.setAttribute(b,x)}),this.setIndex(v.index),this.computeBoundingSphere()}clone(){let e=Fd(new It,sR.prototype);return e.copy(this),console.log("CloneGeometry",this,e),e}copy(e){return Object.entries(e.attributes).forEach(([t,n])=>{this.setAttribute(t,n)}),this.setIndex(e.index),this.userData={parameters:ue({},e.userData.parameters),type:"TextGeometry"},this}async setText(e){this.font&&await this.font.loadingPromise,await this.update(De(ue({},this.userData.parameters),{text:e}))}get text(){var e;return(e=this.userData.parameters.text)!=null?e:""}};function Oae(e,t,n){n=n!=null?n:e.text;let s=[""],r="";for(let i of n)r+=i,i===" "||i===`
`?(s[s.length-1]+=r,r="",i===`
`&&s.push("")):t.getTextWidth(s[s.length-1]+r,e)>e.width&&(s[s.length-1].length&&s.push(""),t.getTextWidth(s[s.length-1]+r,e)>e.width&&(r.length===1?(s[s.length-1]+=r,r=""):(s[s.length-1]+=r.slice(0,-1),r=r[r.length-1],s.push(""))));return s[s.length-1]+=r,s}var rR,G2=new Promise(e=>{rR=e}),iR=!1;async function Rae(){if(iR)return;let e="https://unpkg.com/@splinetool/modelling-wasm@0.9.203/build",[t,n]=await Promise.all([import("./process.e037bce6.js"),fetch(`${e}/process.wasm`).then(i=>i.arrayBuffer())]),s=t.default,r=await s({wasmBinary:n});rR(r),iR=!0}function nx(e,t,n){let s={parameters:e,type:e.type};if(e.type==="VectorGeometry"){let i=is.createFromState(e.shape,e.width,e.height);s.shape=i}else if(e.type==="NonParametricGeometry")e.data.groups&&e.data.groups.forEach(i=>{var o;return i.materialIndex=Math.max((o=i.materialIndex)!=null?o:0,0)}),s.geometry=new bM().parse(e);else{if(e.type==="SubdivGeometry")return new zr(e,n);if(e.type==="TextGeometry")return new sR(e,t)}let r;try{r=mR(s)}catch(i){console.error(i)}if(!r){let i=is.createFromState(wv.defaultData(),100,100);s.shape=i,r=mR(s)}return r}var Lae=new et;function W2(e,t,n,s){let r=e.position.array,i=e.normal.array,o=Lae.makeScale(t,n,s).invert().elements,a,l,c;for(var h=0,u=r.length;h<u;h+=3)r[h]*=t,r[h+1]*=n,r[h+2]*=s,a=i[h],l=i[h+1],c=i[h+2],i[h]=o[0]*a+o[4]*l+o[8]*c,i[h+1]=o[1]*a+o[5]*l+o[9]*c,i[h+2]=o[2]*a+o[6]*l+o[10]*c;e.position.needsUpdate=!0,e.normal.needsUpdate=!0}var sx=new Ss,Qd=new I,wt;G2.then(e=>{wt=e});var oR=new Float32Array([10,10,0,-10,10,0,-10,-10,0,10,-10,0]),aR=new Uint32Array([0,1,2,3]),lR=new Uint8Array([4]),zr=class extends It{constructor(e,t){super();this.data=e,this.flatShading=t,this.subdivPointer=0,this.rebuild(),this.freeSubdivPointer()}mutateDirectlyScaleBaked(e,t){this.freeSubdivPointer();let n=this.data.scaleBaked,s=Du.div(t,n);this.subdividedGeometry&&W2(this.subdividedGeometry.attributes,...s),this.originalGeometry&&W2(this.originalGeometry.attributes,...s),this.data=e;let r=this.userData.parameters;this.userData.parameters={width:r.width*s[0],height:r.height*s[1],depth:r.depth*s[2]},this.originalGeometry.boundingSphere.center.multiply(Qd.fromArray(s));let i=Qd.set(r.width,r.height,r.depth).length();this.originalGeometry.boundingSphere.radius=i/2}ensureSubdivPointer(){return this.subdivPointer===0&&this.rebuild(),this.subdivPointer}rebuild(){var r;let e,t,n;try{({originalGeometry:e,subdividedGeometry:t,subdivPointer:n}=zr.build(this.data,void 0,!this.flatShading,void 0))}catch{e=new pa(100,100,100),n=0}this.subdivPointer=n,this.originalGeometry=e,this.subdividedGeometry=t!=null?t:void 0;let s=(r=this.subdividedGeometry)!=null?r:this.originalGeometry;Object.assign(this,s),this.calcBoundingBox()}freeSubdivPointer(){this.subdivPointer&&(zr.freeSubdivPointer(this.subdivPointer),this.subdivPointer=0)}dispose(){super.dispose(),this.freeSubdivPointer()}calcBoundingBox(){let e=this.originalGeometry;e.boundingSphere===null&&(e.boundingSphere=new Wi,this.subdividedGeometry&&(this.subdividedGeometry.boundingSphere=e.boundingSphere));let t=e.attributes.position,n=e.boundingSphere.center;sx.setFromBufferAttribute(t),sx.getCenter(n),e.boundingSphere.radius=n.distanceTo(sx.max),isNaN(e.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this),sx.getSize(Qd);let s={width:Qd.x,height:Qd.y,depth:Qd.z};return this.userData.parameters=s,s}static build(e,t,n,s){var l;let r,i,o,a=(l=e==null?void 0:e.phongAngle)!=null?l:35;n===!1&&(a=-1),t&&(wt.free_bvh(t),wt.free_subdivision_surface(t));try{r=zr.allocate(e,s)}catch(c){console.error(c,e),r=zr.allocate({positionWASM:oR,indexWASM:aR,verticesPerFaceWASM:lR},s)}if(wt.set_destination_refinement_level(r,0),i=zr.buildLevel(r,!0,a),e.subdivisions>0)try{wt.set_destination_refinement_level(r,e.subdivisions),o=zr.buildLevel(r,!1,a)}catch{try{wt.set_destination_refinement_level(r,e.subdivisions-1),o=zr.buildLevel(r,!1,a)}catch{o=null}}else o=null;return{subdivPointer:r,originalGeometry:i,subdividedGeometry:o}}static primitiveToQuads(e,t,n){e.widthSegments>16&&(e.widthSegments=16),e.heightSegments>16&&(e.heightSegments=16),e.depthSegments>16&&(e.depthSegments=16),e.radialSegments>16&&(e.radialSegments=16),e.type==="DodecahedronGeometry"&&(e.detail=0);let s;if(e.type==="TorusGeometry"&&e.arc===Math.PI*2){let{width:c,height:h,depth:u,arc:d,tubularSegments:p,radialSegments:f}=e;s=new F2(!0,c,u,h,c*.5,d/(2*Math.PI),p,u/2,0,f,0,0,!0)}else s=e.shape!==void 0?t.geometry:nx(e,n,!1);let r,i,o,a;({positions:r,triIndices:a}=H2(s.getAttribute("position"),s.getIndex()));let l;if(e.type==="CylinderGeometry"&&e.cornerRadius===0&&e.hollow===0&&e.openEnded===!1){let c=e.radialSegments*e.heightSegments*3*2,h=c+e.radialSegments*3;l=[c,h]}return{indices:i,verticesPerFace:o}=uR(r,a,s,l),{positions:r,indices:i,verticesPerFace:o}}static allocate(e,t){var b;let n,s,r,i=[],o=[];e.positionWASM&&e.positionWASM.length>0?(n=e.positionWASM,s=e.indexWASM,r=e.verticesPerFaceWASM):(n=oR,s=aR,r=lR);let a=n.length,l=s.length,c=r.length,h=n.length+i.length+o.length,u=s.length+r.length,d=h*Float32Array.BYTES_PER_ELEMENT+u*Uint32Array.BYTES_PER_ELEMENT,p=h*Float32Array.BYTES_PER_ELEMENT,f=wt._malloc(d),g=new Float32Array(wt.HEAPF32.buffer,f,h),m=new Uint32Array(wt.HEAPU32.buffer,f+p,u);g.set(n,0),g.set(i,n.length),g.set(o,n.length+i.length),m.set(s,0),m.set(r,s.length);let y;((b=e==null?void 0:e.scaleBaked)==null?void 0:b.some(x=>x!==1))&&(y=new et().makeScale(...e.scaleBaked)),t&&(y?y.premultiply(t):y=t);let v=y?wt.alloc_subdivision_surface2(f,a,f+p,l,f+p+s.length*Uint32Array.BYTES_PER_ELEMENT,c,y.elements):wt.alloc_subdivision_surface(f,a,f+p,l,f+p+s.length*Uint32Array.BYTES_PER_ELEMENT,c);return wt._free(f),v}static buildLevel(e,t,n,s,r){let i=r?wt.get_mesh_data2(e,t?wt.Level.CONTROL:wt.Level.REFINED,n,r.elements):wt.get_mesh_data(e,t?wt.Level.CONTROL:wt.Level.REFINED,n),o=8,a=wt.HEAPU32.subarray(i>>2,(i>>2)+o),l=a.subarray(4,4+4),c=0,h=wt.HEAPU32[a[c]>>2],u=wt.HEAPF32.subarray(h>>2,(h>>2)+l[c]);c++;let d=wt.HEAPU32[a[c]>>2],p=wt.HEAPF32.subarray(d>>2,(d>>2)+l[c]);c++;let f=wt.HEAPU32[a[c]>>2],g=wt.HEAPU32.subarray(f>>2,(f>>2)+l[c]);c++;let m=wt.HEAPU32[a[c]>>2],y=wt.HEAPU32.subarray(m>>2,(m>>2)+l[c]);if(c++,s===void 0){let v=new It;if(v.setIndex(new Lf(y,1)),v.setAttribute("position",new ot(u,3)),v.setAttribute("normal",new ot(p,3)),t){v.setAttribute("faceMap",new Lf(g,1));let b=new Float32Array(p.length/3*4).fill(0);v.setAttribute("color",new Lt(b,4))}return wt.free_mesh_data(i),v.userData.type="SubdivGeometry",v}s.getAttribute("position").copyArray(u),s.getAttribute("normal").copyArray(p),s.attributes.position.needsUpdate=!0,s.attributes.normal.needsUpdate=!0,wt.free_mesh_data(i)}static freeSubdivPointer(e){wt.free_bvh(e),wt.free_subdivision_surface(e)}static buildControlCageWireframe(e,t,n){let s=wt.get_wireframe_data_for_base_level(e),r=4,i=wt.HEAPU32.subarray(s>>2,(s>>2)+r),o=i.subarray(2,2+2),a=0,l=wt.HEAPU32[i[a]>>2],c=wt.HEAPF32.subarray(l>>2,(l>>2)+o[a]);a++;let h=wt.HEAPU32[i[a]>>2],u=wt.HEAPU32.subarray(h>>2,(h>>2)+o[a]);if(t===void 0){let d=new It;d.setAttribute("position",new ot(c,3));let p=new Float32Array(c.length);for(let f=0,g=c.length;f<g;)p[f++]=n.r,p[f++]=n.g,p[f++]=n.b;return d.setAttribute("color",new Lt(p,3)),d.setIndex(new Lf(u,1)),wt.free_wireframe_data_for_base_level(s),d}t.getAttribute("position").copyArray(c),t.attributes.position.needsUpdate=!0,wt.free_wireframe_data_for_base_level(s)}static updateCollabMesh(e,t,n){let s=t===0;s||wt.set_destination_refinement_level(e,t);let r=n?wt.get_topological_data2(e,s?wt.Level.CONTROL:wt.Level.REFINED,n.elements):wt.get_topological_data(e,s?wt.Level.CONTROL:wt.Level.REFINED),i=6,o=wt.HEAPU32.subarray(r>>2,(r>>2)+i),a=o.subarray(3,3+3),l=0,c=wt.HEAPU32[o[l]>>2],h=new Float32Array(wt.HEAPF32.subarray(c>>2,(c>>2)+a[l]));l++;let u=wt.HEAPU32[o[l]>>2],d=new Uint32Array(wt.HEAPU32.subarray(u>>2,(u>>2)+a[l]));l++;let p=wt.HEAPU32[o[l]>>2],f=new Uint8Array(wt.HEAPU32.subarray(p>>2,(p>>2)+a[l]));return wt.free_topological_data(r),{positions:h,indices:d,verticesPerFace:f}}},cR=["getX","getY","getZ"];function H2(e,t){let n={},s=t?t.count:e.count,r=0,i=[],o=[],a=1e4;for(let c=0;c<s;c++){let h=t?t.getX(c):c,u="";for(let d=0;d<3;d++)u+=`${~~(e[cR[d]](h)*a)},`;if(u in n)i.push(n[u]);else{for(let d=0;d<3;d++)o.push(e[cR[d]](h));n[u]=r,i.push(r),r++}}let l=[];for(let c=0;c<i.length;c+=3)i[c]===i[c+1]||i[c]===i[c+2]||i[c+1]===i[c+2]||l.push(i[c],i[c+1],i[c+2]);return{positions:o,triIndices:l}}var rx=new I,j2=new I,q2=new I,X2=new I;function uR(e,t,n,s){var o;let r=[],i=[];if(n.userData.shape!==void 0&&n.userData.parameters.depth===0&&n.userData.shape.shapeHoles.length===0){let a=n.userData.shape.extractShapePointsToFlatArray([]),l=n.userData.parameters.spikes;if(n.userData.type==="EllipseGeometry"&&l<=24&&l%4==0&&n.userData.parameters.angle>=360){let u=a.length/2/l;a=a.filter((d,p)=>Math.floor(p/2)%u==0)}let c=0;for(let u=0;u<a.length;u+=2)c+=(a[u]-a[(u===0?a.length:u)-2])*(a[u+1]+a[(u===0?a.length:u)-1]);e.length=0;let h=0;if(c<0)for(let u=0;u<a.length;u+=2)e.push(a[u],a[u+1],0),r.push(h++);else for(let u=a.length-2;u>=0;u-=2)e.push(a[u],a[u+1],0),r.push(h++);return i.push(h),{indices:r,verticesPerFace:i}}for(let a=0,l=(o=n.capStartIndex)!=null?o:t.length;a<l;)if(t[a+1]===t[a+3]&&t[a+2]===t[a+5]||t[a+0]===t[a+3]&&t[a+2]===t[a+4]){rx.set(e[t[a]*3],e[t[a]*3+1],e[t[a]*3+2]),j2.set(e[t[a+1]*3],e[t[a+1]*3+1],e[t[a+1]*3+2]),q2.set(e[t[a+4]*3],e[t[a+4]*3+1],e[t[a+4]*3+2]),X2.set(e[t[a+5]*3],e[t[a+5]*3+1],e[t[a+5]*3+2]),j2.sub(rx).normalize(),q2.sub(rx).normalize(),X2.sub(rx).normalize();let c=j2.cross(q2).dot(X2);Math.abs(c)>.005||s&&s.some((h,u)=>u%2==1?!1:a>=s[u]&&a<s[u+1])?(r.push(t[a],t[a+1],t[a+2]),i.push(3),a+=3):(r.push(t[a],t[a+1],t[a+4],t[a+5]),i.push(4),a+=6)}else r.push(t[a],t[a+1],t[a+2]),i.push(3),a+=3;if(n.capStartIndex!==void 0){let a=[],l=[],c=0,h=new Float32Array([n.userData.parameters.depth])[0];for(let u=0,d=0;u<e.length;u+=3,d++)e[u+2]===0&&(a.push(d),c++),e[u+2]===h&&l.push(d);if(n.userData.parameters.extrudeBevelSize===0){let u=l[0];l[0]=l[1],l[1]=u}a.reverse(),r.push(...a,...l),i.push(c,c)}return{indices:r,verticesPerFace:i}}var gc={};m6(gc,{calcBoolean:()=>Uae,calcBooleanTopological:()=>zae,freeMeshSet:()=>Wae,getMeshSet:()=>Vae,transformMeshSet:()=>Gae});var hR,Fae=new Promise(e=>{hR=e}),dR=!1;async function $ae(){if(dR)return;let e="https://unpkg.com/@splinetool/boolean-wasm@0.9.203/build",[t,n]=await Promise.all([import("./boolean.db7c387d.js"),fetch(`${e}/boolean.wasm`).then(i=>i.arrayBuffer())]),s=t.default,r=await s({wasmBinary:n});hR(r),dR=!0}var Yt,Zd;Fae.then(e=>Yt=e);function Bae(e,t,n){let s,{positions:r,triIndices:i}=H2(e.getAttribute("position"),e.getIndex()),o;if(t&&n){let{indices:a,verticesPerFace:l}=uR(r,i,e);o=l.length,s=[];for(let c=0,h=0;c<o;c++){s.push(l[c]);for(let u=0;u<l[c];u++)s.push(a[h++])}}else{let a=i.length;s=Array(a+a/3),o=0;for(let l=0,c=0;c<s.length;)s[c++]=3,o++,s[c++]=i[l++],s[c++]=i[l++],s[c++]=i[l++]}return{positions:r,faceIndices:s,nFaces:o}}function pR(e){let t=e.length,n=t*Uint32Array.BYTES_PER_ELEMENT,s=t*Float32Array.BYTES_PER_ELEMENT,r=Number.isInteger(e[0])?n:s,i=Yt._malloc(r);return(Number.isInteger(e[0])?new Uint32Array(Yt.HEAPU32.buffer,i,t):new Float32Array(Yt.HEAPF32.buffer,i,t)).set(e,0),i}function fR(e){switch(e){case 0:return Yt.OP.UNION;case 1:return Yt.OP.INTERSECTION;case 2:return Yt.OP.A_MINUS_B;case 3:return Yt.OP.B_MINUS_A;case 4:return Yt.OP.SYMMETRIC_DIFFERENCE;case 5:return Yt.OP.ALL;default:throw new Error("Unknown boolean operation "+e)}}function zae(e,t){Zd===void 0&&(Zd=Yt.init_csg());let n=pR(e),s=Yt.csg_calc_topological(Zd,n,e.length,fR(t));Yt._free(n);let r=6,i=Yt.HEAPU32.subarray(s>>2,(s>>2)+r),o=i.subarray(3,3+3),a=0,l=Yt.HEAPU32[i[a]>>2],c=new Float32Array(Yt.HEAPF32.subarray(l>>2,(l>>2)+o[a]));a++;let h=Yt.HEAPU32[i[a]>>2],u=new Uint32Array(Yt.HEAPU32.subarray(h>>2,(h>>2)+o[a]));a++;let d=Yt.HEAPU32[i[a]>>2],p=new Uint8Array(Yt.HEAPU32.subarray(d>>2,(d>>2)+o[a]));return Yt.free_mesh_data(s),{positions:c,indices:u,verticesPerFace:p}}function Uae(e,t,n,s){Zd===void 0&&(Zd=Yt.init_csg());let r=pR(e),i=Yt.csg_calc(Zd,r,e.length,s,fR(t));Yt._free(r);let o=5,a=Yt.HEAPU32.subarray(i>>2,(i>>2)+o),l=a.subarray(2,2+3),c=0,h=Yt.HEAPU32[a[c]>>2],u=Yt.HEAPF32.subarray(h>>2,(h>>2)+l[c]);c++;let d=Yt.HEAPU32[a[c]>>2],p=Yt.HEAPF32.subarray(d>>2,(d>>2)+l[c]);c++;let f=l[c];n.setAttribute("position",new ot(u,3)),n.setAttribute("normal",new ot(p,3));let g=Yt.HEAPF32.subarray((i>>2)+5,(i>>2)+5+6);return n.boundingSphere===null&&(n.boundingSphere=new Wi),n.boundingSphere.center.set(g[0],g[1],g[2]),n.boundingSphere.radius=(g[3]**2+g[4]**2+g[5]**2)**.5,n.userData.parameters={width:g[3]*2,height:g[4]*2,depth:g[5]*2},Yt.free_mesh_data(i),f}function Vae(e,t,n){if(Yt===void 0)return-1;let s,r,i;if(t&&e.userData.positions!==void 0){let g=e.userData;i=g.verticesPerFace.length,s=g.positions,r=Array(g.verticesPerFace.reduce((m,y)=>m+y,0)+i);for(let m=0,y=0,v=0;m<g.verticesPerFace.length;m++){r[v++]=g.verticesPerFace[m];for(let b=0;b<g.verticesPerFace[m];b++)r[v++]=g.indices[y++]}}else({positions:s,faceIndices:r,nFaces:i}=Bae(e,t,n));let o=s.length,a=r.length,l=s.length,c=r.length,h=l*Float32Array.BYTES_PER_ELEMENT+c*Uint32Array.BYTES_PER_ELEMENT,u=l*Float32Array.BYTES_PER_ELEMENT,d=Yt._malloc(h),p=new Float32Array(Yt.HEAPF32.buffer,d,l),f=new Uint32Array(Yt.HEAPU32.buffer,d+u,c);return p.set(s,0),f.set(r,0),Yt.get_csg_mesh(d,o,d+u,a,i)}function Gae(e,t){Yt.transform_csg_mesh(e,t.elements)}function Wae(e){Yt.free_csg_mesh(e)}var Hae={ConeGeometry:Eoe,CubeGeometry:Aoe,CylinderGeometry:Toe,DodecahedronGeometry:Noe,EllipseGeometry:sae,HelixGeometry:aae,IcosahedronGeometry:lae,LatheGeometry:cae,NonParametricGeometry:mae,PolygonGeometry:gae,PyramidGeometry:yae,RectangleGeometry:bae,SphereGeometry:wae,PlaneGeometry:Sae,BackdropGeometry:_ae,StarGeometry:Tae,TextFrameGeometry:Eae,TorusGeometry:Aae,TorusKnotGeometry:Nae,TriangleGeometry:kae,VectorGeometry:Bu},mR=e=>Hae[e.type].create(e);function _m(e){return e!==null&&"booleanOp"in e}var gR=class extends MO(bi){constructor(){super(...arguments);this.booleanMeshSetAddress=-1,this.booleanWasTransformed=!1,this.booleanMatrixInvOld=new et}updateVisible(){super.updateVisible(),this.visible=!_m(this.parent)&&this.visible,_m(this.parent)&&this.parent.invalidateDownstreamBooleanData()}freeBooleanPointer(){this.booleanMeshSetAddress!==-1&&(gc.freeMeshSet(this.booleanMeshSetAddress),this.booleanMeshSetAddress=-1)}invalidateDownstreamBooleanData(e=!1){return e?this.booleanWasTransformed=!0:this.freeBooleanPointer(),_m(this.parent)?this.parent.invalidateDownstreamBooleanData():this}invalidateUpstreamBooleanData(){this.freeBooleanPointer();for(let e of this.children)e instanceof gR&&(e.freeBooleanPointer(),_m(e)&&e.invalidateUpstreamBooleanData())}updateTransformState(e){let t=super.updateTransformState(e);return t&&_m(this.parent)&&this.invalidateDownstreamBooleanData(!0),t}},ix=new Ss;function yR(e,t=0,n=e.count,s,r){let i=1/0,o=1/0,a=1/0,l=-1/0,c=-1/0,h=-1/0;for(let u=t;u<n;u++){let d=e.getX(u),p=e.getY(u),f=e.getZ(u);d<i&&(i=d),p<o&&(o=p),f<a&&(a=f),d>l&&(l=d),p>c&&(c=p),f>h&&(h=f)}ix.min.set(i,o,a),ix.max.set(l,c,h),ix.getCenter(s),ix.getSize(r).multiplyScalar(.5)}var jae=new It,qae=new Rf,Ai=class extends gR{constructor(e,t){super(jae,qae),this.super_Entity(e,t)}updateState(e,t){this.updateState_Entity(e,t)}updateEntityBoxSize(e,t){let n=this.geometry.getAttribute("position");n!==void 0?yR(n,this.geometry.drawRange.start,this.geometry.drawRange.count<1/0?this.geometry.drawRange.count:n.count,e,t):super.updateEntityBoxSize(e,t)}},vR=class{constructor(e){e=e!=null?e:{},this.name=e.name,this.type=e.type,this.node=e.node,this.size=e.size,this.needsUpdate=e.needsUpdate}get value(){return this.node.value}set value(e){this.node.value=e}},yc=class{constructor(e){this.hashProperties=void 0,this.isNode=!0,this.shortcuts={},this.uuid=Kt.generateUUID(),this.type=e,this.name=""}analyze(e,t){t=t!=null?t:{},e.analyzing=!0,this.build(e.addFlow(t.slot,t.cache,t.context),"v4"),e.clearVertexNodeCode(),e.clearFragmentNodeCode(),e.removeFlow(),e.analyzing=!1}analyzeAndFlow(e,t,n){return n=n!=null?n:{},this.analyze(e,n),this.flow(e,t,n)}flow(e,t,n){n=n!=null?n:{},e.addFlow(n.slot,n.cache,n.context);let s={result:this.build(e,t),code:e.clearNodeCode(),extra:e.context.extra};return e.removeFlow(),s}build(e,t,n){t=t!=null?t:this.getType(e,t);let s=e.getNodeData(n!=null?n:this);return e.analyzing&&this.appendDepsNode(e,s,t),e.nodes.indexOf(this)===-1&&e.nodes.push(this),this.updateFrame!==void 0&&e.updaters.indexOf(this)===-1&&e.updaters.push(this),this.generate(e,t,n)}updateFrame(e){}generateReadonly(e,t,n,s,r,i){return""}generate(e,t,n,s,r){return""}parse(e,t,n,s){}appendDepsNode(e,t,n){t.deps=(t.deps||0)+1;let s=e.getTypeLength(n);(s>(t.outputMax||0)||this.getType(e,n))&&(t.outputMax=s,t.output=n)}setName(e){this.name=e}getName(){return this.name}getType(e,t){return t==="sampler2D"||t==="samplerCube"?t:this.type}getHash(){let e="{",t,n;for(t in this)n=this[t],n instanceof yc&&(e+='"'+t+'":'+n.getHash()+",");if(this.hashProperties)for(let s=0;s<this.hashProperties.length;s++)t=this.hashProperties[s],n=this[t],e+='"'+t+'":"'+String(n)+'",';return e+='"id":"'+this.uuid+'"}',e}},Xae=class{constructor(){this.nodes={},this.keywords={}}add(e){this.nodes[e.name]=e}addKeyword(e,t,n){n=n!==void 0?n:!0,this.keywords[e]={callback:t,cache:n}}remove(e){delete this.nodes[e.name]}removeKeyword(e){delete this.keywords[e]}get(e){return this.nodes[e]}getKeyword(e,t){return this.keywords[e].callback(t)}getKeywordData(e){return this.keywords[e]}contains(e){return this.nodes[e]!==void 0}containsKeyword(e){return this.keywords[e]!==void 0}},ni=new Xae,In=class extends yc{constructor(e,t){super(e);this.scope="",t=t!=null?t:{},this.shared=t.shared!==void 0?t.shared:!0,this.unique=t.unique!==void 0?t.unique:!1}build(e,t,n,s){if(t=t!=null?t:this.getType(e),this.getShared(e,t)){let r=this.getUnique(e,t);r&&this.uuid===void 0&&(this.uuid=Kt.generateUUID()),n=e.getUUID(n!=null?n:this.getUUID(),!r);let i=e.getNodeData(n),o=i.output||this.getType(e);if(e.analyzing)return(i.deps||0)>0||this.getLabel()?(this.appendDepsNode(e,i,t),this.generate(e,t,n)):super.build(e,t,n);if(r)return i.name=i.name||super.build(e,t,n),i.name;if(!this.getLabel()&&(!this.getShared(e,o)||e.context.ignoreCache||i.deps===1))return super.build(e,t,n);n=this.getUUID(!1);let a=this.getTemp(e,n);if(a)return e.format(a,o,t);{a=super.generate(e,t,n,i.output,s);let l=this.generate(e,o,n);return e.addNodeCode(a+" = "+l+";"),e.format(a,o,t)}}return super.build(e,t,n)}getShared(e,t){return t!=="sampler2D"&&t!=="samplerCube"&&this.shared}getUnique(e,t){return this.unique}setLabel(e){return this.label=e,this}getLabel(){return this.label}getUUID(e){let t=this.uuid;return typeof this.scope=="string"&&(t=this.scope+"-"+t),t}getTemp(e,t){t=t||this.uuid;let n=e.getVars()[t];return n?n.name:void 0}generate(e,t,n,s,r){return this.getShared(e,t)||console.error("TempNode is not shared"),n=n!=null?n:this.uuid,e.getTempVar(n,s!=null?s:this.getType(e),r,this.getLabel()).name}},Ii=class extends In{constructor(e,t){t=t!=null?t:{},t.shared=t.shared!==void 0?t.shared:!1;super(e,t);this.readonly=!1}setReadonly(e){return this.readonly=e,this.hashProperties=this.readonly?["value"]:void 0,this}getReadonly(){return this.readonly}generate(e,t,n,s,r,i){n=e.getUUID(n!=null?n:this.getUUID()),s=s!=null?s:this.getType(e);let o=e.getNodeData(n);return this.getReadonly()&&this.generateReadonly!==void 0?this.generateReadonly(e,t,n,s,r,i):e.isShader("vertex")?(o.vertex||(o.vertex=e.createVertexUniform(s,this,r,i,this.getLabel())),e.format(o.vertex.name,s,t)):(o.fragment||(o.fragment=e.createFragmentUniform(s,this,r,i,this.getLabel())),e.format(o.fragment.name,s,t))}},Ji=class extends Ii{constructor(e=0,t){super("v2");this.nodeType="Vector2",this.value=e instanceof se?e:new se(e,t)}get x(){return this.value.x}set x(e){this.value.x=e}get y(){return this.value.y}set y(e){this.value.y=e}generateReadonly(e,t,n,s,r,i){return e.format("vec2("+this.value.x+", "+this.value.y+")",s,t)}},eo=class extends Ii{constructor(e=0,t,n){super("v3");this.nodeType="Vector3",this.value=e instanceof I?e:new I(e,t,n)}get x(){return this.value.x}set x(e){this.value.x=e}get y(){return this.value.y}set y(e){this.value.y=e}get z(){return this.value.z}set z(e){this.value.z=e}generateReadonly(e,t,n,s,r,i){return e.format("vec3("+this.value.x+", "+this.value.y+", "+this.value.z+")",s,t)}},Ni=class extends _t{constructor(e,t,n,s){super(e,t,n);this.isColorA=!0,this.a=s}setRGBA(e,t,n,s){super.setRGB(e,t,n),this.a=s}copy(e){return super.copy(e),this.a="a"in e?e.a:1,this}clone(){return new this.constructor(this.r,this.g,this.b,this.a)}get x(){return this.r}get y(){return this.g}get z(){return this.b}get w(){return this.a}set x(e){this.r=e}set y(e){this.g=e}set z(e){this.b=e}set w(e){this.a=e}},zu=class extends Ii{constructor(e){super("v4");this.nodeType="Vector4",this.value=e instanceof Ni?e:new Ni(e.r,e.g,e.b,e.a)}generateReadonly(e,t,n,s,r,i){return e.format("vec4("+this.value.r+", "+this.value.g+", "+this.value.b+", "+this.value.a+")",s,t)}},Kae=/^\s*([a-z_0-9]+)\s([a-z_0-9]+)\s*\((.*?)\)/i,xR=/[a-z_0-9]+/gi,ft=class extends In{constructor(e,t,n,s,r){super(r);this.src="",this.nodeType="Function",this.useKeywords=!0,this.includes=[],this.extensions={},this.keywords={},this.isMethod=r===void 0,this.isInterface=!1,this.parse(e,t,n,s)}getShared(e,t){return!this.isMethod}getType(e){return e.getTypeByFormat(this.type)}getInputByName(e){if(this.inputs){let t=this.inputs.length;for(;t--;)if(this.inputs[t].name===e)return this.inputs[t]}}getIncludeByName(e){if(this.includes){let t=this.includes.length;for(;t--;)if(this.includes[t].name===e)return this.includes[t]}}generate(e,t,n,s,r){let i,o=0,a=this.src;if(this.includes)for(let c=0;c<this.includes.length;c++)e.include(this.includes[c],this);for(let c in this.extensions)e.extensions[c]=!0;let l=[];for(;i=xR.exec(this.src);)l.push(i);for(let c=0;c<l.length;c++){let h=l[c],u=h[0],d=this.isMethod?!this.getInputByName(u):!0,p=u;if(this.keywords[u]||this.useKeywords&&d&&ni.containsKeyword(u)){let f=this.keywords[u];if(!f){let g=ni.getKeywordData(u);g.cache&&(f=e.keywords[u]),f=f||ni.getKeyword(u,e),g.cache&&(e.keywords[u]=f)}p=f.build(e)}u!==p&&a[h.index+o-1]!=="."&&(a=a.substring(0,h.index+o)+p+a.substring(h.index+u.length+o),o+=p.length-u.length),this.getIncludeByName(p)===void 0&&ni.contains(p)&&e.include(ni.get(p))}return t==="source"?a:this.isMethod?(this.isInterface||e.include(this,void 0,a),this.name):e.format("( "+a+" )",this.getType(e),t)}parse(e,t,n,s){if(this.src=e||"",this.includes=t!=null?t:[],this.extensions=n!=null?n:{},this.keywords=s!=null?s:{},this.isMethod){let r=Kae.exec(this.src);if(this.inputs=[],r&&r.length==4){this.type=r[1],this.name=r[2];let i=r[3].match(xR);if(i){let o=0;for(;o<i.length;){let a=i[o++],l;a==="in"||a==="out"||a==="inout"?l=i[o++]:(l=a,a="");let c=i[o++];this.inputs.push({name:c,type:l,qualifier:a})}}this.isInterface=this.src.indexOf("{")===-1}else this.type="",this.name=""}}},Yae=/^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i,bR=class extends In{constructor(e="",t){super();this.src="",this.useDefine=!1,this.nodeType="Const",this.parse(e||bR.PI,void 0,void 0,void 0,t)}getType(e){return e.getTypeByFormat(this.type)}parse(e,t,n,s,r){this.src=e||"";let i,o,a="",l=Yae.exec(e);this.useDefine=r!=null?r:this.src.charAt(0)==="#",l&&l.length>1?(o=l[1],i=l[2],a=l[3]):(i=this.src,o="f"),this.name=i,this.type=o,this.value=a}build(e,t){if(t==="source"){if(this.value)return this.useDefine?"#define "+this.name+" "+this.value:"const "+this.type+" "+this.name+" = "+this.value+";";if(this.useDefine)return this.src}return e.include(this),e.format(this.name,this.getType(e),t)}generate(e,t,n,s,r){return e.format(this.name,this.getType(e),t)}},Sn=bR;Sn.PI="PI",Sn.PI2="PI2",Sn.RECIPROCAL_PI="RECIPROCAL_PI",Sn.RECIPROCAL_PI2="RECIPROCAL_PI2",Sn.LOG2="LOG2",Sn.EPSILON="EPSILON";var Qae=new RegExp(`^structs*([a-z_0-9]+)s*{s*((.|
)*?)}`,"gim"),Zae=new RegExp("s*(w*?)s*(w*?)(=|;)","gim"),wR=class extends In{constructor(e=""){super();this.inputs=[],this.src="",this.nodeType="Struct",this.parse(e)}getType(e){return e.getTypeByFormat(this.name)}getInputByName(e){let t=this.inputs.length;for(;t--;)if(this.inputs[t].name===e)return this.inputs[t]}generate(e,t,n,s,r){return t==="source"?this.src+";":e.format("( "+this.src+" )",this.getType(e),t)}parse(e=""){this.src=e,this.inputs=[];let t=Qae.exec(e);if(t){let n=t[2],s;for(;s=Zae.exec(n);)this.inputs.push({type:s[1],name:s[2]});this.name=t[1]}else this.name="";this.type=this.name}},K2=class extends In{constructor(e){super("v2",{shared:!1});this.nodeType="UV",this.index=e!=null?e:0}generate(e,t){e.requires.uv[this.index]=!0;let n=this.index>0?this.index+1:"",s=e.isShader("vertex")?"uv"+n:"vUv"+n;return e.format(s,this.getType(e),t)}};ni.addKeyword("uv",function(){return new K2});ni.addKeyword("uv2",function(){return new K2(1)});var Jd=class extends In{constructor(e,t){super("v4");this.nodeType="ColorSpace",this.input=e,this.method=t!=null?t:Jd.LINEAR_TO_LINEAR,this.hashProperties=["method"]}static getEncodingComponents(e){switch(e){case ha:return["Linear"];case Gt:return["sRGB"];default:return[]}}generate(e,t){var o;let n=this.input.build(e,"v4"),s=this.getType(e),r=Jd.Nodes[this.method],i=e.include(r);if(i===Jd.LINEAR_TO_LINEAR)return e.format(n,s,t);if(((o=r.inputs)==null?void 0:o.length)===2){let a=this.factor.build(e,"f");return e.format(i+"( "+n+", "+a+" )",s,t)}else return e.format(i+"( "+n+" )",s,t)}fromEncoding(e){let t=Jd.getEncodingComponents(e);this.method="LinearTo"+t[0],this.factor=t[1]}fromDecoding(e){let t=Jd.getEncodingComponents(e);this.method=t[0]+"ToLinear",this.factor=t[1]}},ka=Jd;ka.Nodes={LinearToLinear:new ft(["vec4 LinearToLinear( in vec4 value ) {","	return value;","}"].join(`
`)),sRGBToLinear:new ft(["vec4 sRGBToLinear( in vec4 value ) {","	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );","}"].join(`
`)),LinearTosRGB:new ft(["vec4 LinearTosRGB( in vec4 value ) {","	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );","}"].join(`
`))},ka.LINEAR_TO_LINEAR="LinearToLinear",ka.SRGB_TO_LINEAR="sRGBToLinear",ka.LINEAR_TO_SRGB="LinearTosRGB";var Hn=class extends ft{constructor(e="",t,n,s,r){super(e,r,s,n,t);this.nodeType="Expression"}},vc=class extends Ii{constructor(e=new mr,t,n,s){super("v4",{shared:!0});this.nodeType="Texture",this.value=e,this.uv=t!=null?t:new K2,this.bias=n,this.project=s!==void 0?s:!1}getTexture(e,t){return super.generate(e,t,this.value.uuid,"t")}generate(e,t){var c;if(t==="sampler2D")return this.getTexture(e,t);let n=this.getTexture(e,t),s=this.uv.build(e,this.project?"v4":"v2"),r=this.bias?this.bias.build(e,"f"):void 0;r===void 0&&e.context.bias&&(r=e.context.bias.setTexture(this).build(e,"f"));let i,o;this.project?i="texture2DProj":i=r?"tex2DBias":"tex2D",r?o=i+"( "+n+", "+s+", "+r+" )":o=i+"( "+n+", "+s+" )";let a={include:e.isShader("vertex"),ignoreCache:!0},l=this.getType(e);return e.addContext(a),this.colorSpace=(c=this.colorSpace)!=null?c:new ka(new Hn("",l)),this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)),this.colorSpace.input.parse(o),o=this.colorSpace.build(e,l),e.removeContext(),e.format(o,l,t)}},lt=class extends Ii{constructor(e){super("f");this.nodeType="Float",this.value=e!=null?e:0}generateReadonly(e,t,n,s,r,i){return e.format(this.value+(this.value%1?"":".0"),s,t)}},SR=class extends In{constructor(e,t){super();this.inputs=[],this.nodeType="FunctionCall",this.value=e,this.inputs=t!=null?t:[]}getFunction(){return this.value}getType(e){return this.value.getType(e)}generate(e,t,n,s,r){s=this.getType(e);let i=this.value,o=i.build(e,t)+"( ",a=[];if(i.inputs){for(let l=0;l<i.inputs.length;l++){let c=i.inputs[l],h=this.inputs[l]||this.inputs[c.name];a.push(h.build(e,e.getTypeByFormat(c.type)))}o+=a.join(", ")+" )"}return e.format(o,s,t)}},_R=class extends In{constructor(e,t,n=_R.ADD){super();this.nodeType="Operator",this.type=e.type,this.a=e,this.b=t,this.op=n}getType(e){let t=this.a.getType(e),n=this.b.getType(e);return e.isTypeMatrix(t)?"v4":e.getTypeLength(n)>e.getTypeLength(t)?n:t}generate(e,t){let n=this.getType(e);this.type=n;let s=this.a.build(e,n),r=this.b.build(e,n);return e.format("( "+s+" "+this.op+" "+r+" )",n,t)}},Da=_R;Da.ADD="+",Da.SUB="-",Da.MUL="*",Da.DIV="/";var _n=class extends In{constructor(e,t=_n.ABS,n,s){super();this.nodeType="Math",this.a=e,typeof t!="string"?this.b=t:s=t,typeof n!="string"?this.c=n:s=n,this.method=s,this.hashProperties=["method"]}getNumInputs(e){switch(this.method){case _n.MIX:case _n.CLAMP:case _n.REFRACT:case _n.SMOOTHSTEP:case _n.FACEFORWARD:return 3;case _n.MIN:case _n.MAX:case _n.MOD:case _n.STEP:case _n.REFLECT:case _n.DISTANCE:case _n.DOT:case _n.CROSS:case _n.POW:return 2;default:return 1}}getInputType(e){let t=e.getTypeLength(this.a.getType(e)),n=this.b?e.getTypeLength(this.b.getType(e)):0,s=this.c?e.getTypeLength(this.c.getType(e)):0;return t>n&&t>s?this.a.getType(e):n>s?this.b.getType(e):this.c.getType(e)}getType(e){switch(this.method){case _n.LENGTH:case _n.DISTANCE:case _n.DOT:return"f";case _n.CROSS:return"v3"}return this.getInputType(e)}generate(e,t){let n,s,r,i=this.a?e.getTypeLength(this.a.getType(e)):0,o=this.b?e.getTypeLength(this.b.getType(e)):0,a=this.c?e.getTypeLength(this.c.getType(e)):0,l=this.getInputType(e),c=this.getType(e);switch(this.type=c,this.method){case _n.NEGATE:return e.format("( -"+this.a.build(e,l)+" )",l,t);case _n.INVERT:return e.format("( 1.0 - "+this.a.build(e,l)+" )",l,t);case _n.CROSS:n=this.a.build(e,"v3"),s=this.b.build(e,"v3");break;case _n.STEP:n=this.a.build(e,i===1?"f":l),s=this.b.build(e,l);break;case _n.MIN:case _n.MAX:case _n.MOD:n=this.a.build(e,l),s=this.b.build(e,o===1?"f":l);break;case _n.REFRACT:n=this.a.build(e,l),s=this.b.build(e,l),r=this.c.build(e,"f");break;case _n.MIX:n=this.a.build(e,l),s=this.b.build(e,l),r=this.c.build(e,a===1?"f":l);break;default:n=this.a.build(e,l),this.b&&(s=this.b.build(e,l)),this.c&&(r=this.c.build(e,l));break}let h=[];h.push(n),s&&h.push(s),r&&h.push(r);let u=this.getNumInputs(e);if(h.length!==u)throw Error(`Arguments not match used in "${this.method}". Require ${u}, currently ${h.length}.`);return e.format(this.method+"( "+h.join(", ")+" )",c,t)}},Mt=_n;Mt.RAD="radians",Mt.DEG="degrees",Mt.EXP="exp",Mt.EXP2="exp2",Mt.LOG="log",Mt.LOG2="log2",Mt.SQRT="sqrt",Mt.INV_SQRT="inversesqrt",Mt.FLOOR="floor",Mt.CEIL="ceil",Mt.NORMALIZE="normalize",Mt.FRACT="fract",Mt.SATURATE="saturate",Mt.SIN="sin",Mt.COS="cos",Mt.TAN="tan",Mt.ASIN="asin",Mt.ACOS="acos",Mt.ARCTAN="atan",Mt.ABS="abs",Mt.SIGN="sign",Mt.LENGTH="length",Mt.NEGATE="negate",Mt.INVERT="invert",Mt.MIN="min",Mt.MAX="max",Mt.MOD="mod",Mt.STEP="step",Mt.REFLECT="reflect",Mt.DISTANCE="distance",Mt.DOT="dot",Mt.CROSS="cross",Mt.POW="pow",Mt.MIX="mix",Mt.CLAMP="clamp",Mt.REFRACT="refract",Mt.SMOOTHSTEP="smoothstep",Mt.FACEFORWARD="faceforward";var Cm=class extends In{constructor(e,t,n){super("v4");this.nodeType="TextureCubeUV",this.value=e,this.uv=t,this.bias=n}bilinearCubeUV(e,t,n,s){var a,l,c,h;let r=new SR(Cm.Nodes.bilinearCubeUV,[t,n,s]);this.colorSpaceTL=(a=this.colorSpaceTL)!=null?a:new ka(new Hn("","v4")),this.colorSpaceTL.fromDecoding(e.getTextureEncodingFromMap(this.value.value)),this.colorSpaceTL.input.parse(r.build(e)+".tl"),this.colorSpaceTR=(l=this.colorSpaceTR)!=null?l:new ka(new Hn("","v4")),this.colorSpaceTR.fromDecoding(e.getTextureEncodingFromMap(this.value.value)),this.colorSpaceTR.input.parse(r.build(e)+".tr"),this.colorSpaceBL=(c=this.colorSpaceBL)!=null?c:new ka(new Hn("","v4")),this.colorSpaceBL.fromDecoding(e.getTextureEncodingFromMap(this.value.value)),this.colorSpaceBL.input.parse(r.build(e)+".bl"),this.colorSpaceBR=(h=this.colorSpaceBR)!=null?h:new ka(new Hn("","v4")),this.colorSpaceBR.fromDecoding(e.getTextureEncodingFromMap(this.value.value)),this.colorSpaceBR.input.parse(r.build(e)+".br");let i={include:e.isShader("vertex"),ignoreCache:!0};e.addContext(i),this.colorSpaceTLExp=new Hn(this.colorSpaceTL.build(e,"v4"),"v4"),this.colorSpaceTRExp=new Hn(this.colorSpaceTR.build(e,"v4"),"v4"),this.colorSpaceBLExp=new Hn(this.colorSpaceBL.build(e,"v4"),"v4"),this.colorSpaceBRExp=new Hn(this.colorSpaceBR.build(e,"v4"),"v4"),e.removeContext();let o=new Hn("mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )","v4");return o.keywords.cubeUV_TL=this.colorSpaceTLExp,o.keywords.cubeUV_TR=this.colorSpaceTRExp,o.keywords.cubeUV_BL=this.colorSpaceBLExp,o.keywords.cubeUV_BR=this.colorSpaceBRExp,o.keywords.cubeUV=r,o}generate(e,t){if(e.isShader("fragment")){let n=this.uv,s=this.bias||e.context.roughness,r=new SR(Cm.Nodes.roughnessToMip,[s]),i=new Mt(r,Cm.Nodes.m0,Cm.Nodes.cubeUV_maxMipLevel,Mt.CLAMP),o=new Mt(i,Mt.FLOOR),a=new Mt(i,Mt.FRACT),l=this.bilinearCubeUV(e,this.value,n,o),c=this.bilinearCubeUV(e,this.value,n,new Da(o,new lt(1).setReadonly(!0),Da.ADD)),h=new Mt(l,c,a,Mt.MIX);return e.format(h.build(e),"v4",t)}else return console.warn("TextureCubeUVNode is not compatible with "+e.shader+" shader."),e.format("vec4( 0.0 )",this.getType(e),t)}},Y2=Cm;Y2.Nodes=function(){let e=new wR(`struct TextureCubeUVData {
			vec4 tl;
			vec4 tr;
			vec4 br;
			vec4 bl;
			vec2 f;
		}`),t=new Sn("float cubeUV_maxMipLevel 8.0",!0),n=new Sn("float cubeUV_minMipLevel 4.0",!0),s=new Sn("float cubeUV_maxTileSize 256.0",!0),r=new Sn("float cubeUV_minTileSize 16.0",!0),i=new ft(`float getFace(vec3 direction) {
				vec3 absDirection = abs(direction);
				float face = -1.0;
				if (absDirection.x > absDirection.z) {
					if (absDirection.x > absDirection.y)
						face = direction.x > 0.0 ? 0.0 : 3.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				} else {
					if (absDirection.z > absDirection.y)
						face = direction.z > 0.0 ? 2.0 : 5.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				}
				return face;
		}`);i.useKeywords=!1;let o=new ft(`vec2 getUV(vec3 direction, float face) {
				vec2 uv;
				if (face == 0.0) {
					uv = vec2(direction.z, direction.y) / abs(direction.x); // pos x
				} else if (face == 1.0) {
					uv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y
				} else if (face == 2.0) {
					uv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z
				} else if (face == 3.0) {
					uv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x
				} else if (face == 4.0) {
					uv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y
				} else {
					uv = vec2(direction.x, direction.y) / abs(direction.z); // neg z
				}
				return 0.5 * (uv + 1.0);
		}`);o.useKeywords=!1;let a=new ft(`TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
			float face = getFace(direction);
			float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
			mipInt = max(mipInt, cubeUV_minMipLevel);
			float faceSize = exp2(mipInt);
			float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
			vec2 uv = getUV(direction, face) * (faceSize - 1.0);
			vec2 f = fract(uv);
			uv += 0.5 - f;
			if (face > 2.0) {
				uv.y += faceSize;
				face -= 3.0;
			}
			uv.x += face * faceSize;
			if(mipInt < cubeUV_maxMipLevel){
				uv.y += 2.0 * cubeUV_maxTileSize;
			}
			uv.y += filterInt * 2.0 * cubeUV_minTileSize;
			uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
			uv *= texelSize;
			vec4 tl = texture2D(envMap, uv);
			uv.x += texelSize;
			vec4 tr = texture2D(envMap, uv);
			uv.y += texelSize;
			vec4 br = texture2D(envMap, uv);
			uv.x -= texelSize;
			vec4 bl = texture2D(envMap, uv);
			return TextureCubeUVData( tl, tr, br, bl, f );
		}`,[e,i,o,t,n,s,r]);a.useKeywords=!1;let l=new Sn("float r0 1.0",!0),c=new Sn("float v0 0.339",!0),h=new Sn("float m0 -2.0",!0),u=new Sn("float r1 0.8",!0),d=new Sn("float v1 0.276",!0),p=new Sn("float m1 -1.0",!0),f=new Sn("float r4 0.4",!0),g=new Sn("float v4 0.046",!0),m=new Sn("float m4 2.0",!0),y=new Sn("float r5 0.305",!0),v=new Sn("float v5 0.016",!0),b=new Sn("float m5 3.0",!0),x=new Sn("float r6 0.21",!0),w=new Sn("float v6 0.0038",!0),S=new Sn("float m6 4.0",!0),C=[l,c,h,u,d,p,f,g,m,y,v,b,x,w,S],_=new ft(`float roughnessToMip(float roughness) {
			float mip = 0.0;
			if (roughness >= r1) {
				mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
			} else if (roughness >= r4) {
				mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
			} else if (roughness >= r5) {
				mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
			} else if (roughness >= r6) {
				mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
			} else {
				mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25
			}
			return mip;
		}`,C);return{bilinearCubeUV:a,roughnessToMip:_,m0:h,cubeUV_maxMipLevel:t}}();var ep=class extends In{constructor(e){super("v3");this.nodeType="Normal",this.scope=e!=null?e:ep.VIEW}getShared(){return this.scope===ep.WORLD}build(e,t,n,s){let r=e.context[this.scope+"Normal"];return r?r.build(e,t,n,s):super.build(e,t,n)}generate(e,t,n,s,r){let i;switch(this.scope){case ep.VIEW:e.isShader("vertex")?i="transformedNormal":i="geometryNormal";break;case ep.LOCAL:e.isShader("vertex")?i="objectNormal":(e.requires.normal=!0,i="vObjectNormal");break;case ep.WORLD:e.isShader("vertex")?i="inverseTransformDirection( transformedNormal, viewMatrix ).xyz":(e.requires.worldNormal=!0,i="vWNormal");break}return e.format(i,this.getType(e),t)}},si=ep;si.LOCAL="local",si.WORLD="world",si.VIEW="view",si.NORMAL="normal";ni.addKeyword("viewNormal",function(){return new si(si.VIEW)});ni.addKeyword("localNormal",function(){return new si(si.NORMAL)});ni.addKeyword("worldNormal",function(){return new si(si.WORLD)});var wl=class extends In{constructor(e){super("v3");this.nodeType="Position",this.scope=e!=null?e:wl.LOCAL}getType(){switch(this.scope){case wl.PROJECTION:return"v4"}return this.type}getShader(){switch(this.scope){case wl.LOCAL:case wl.WORLD:return!1}return!0}generate(e,t,n,s,r){let i;switch(this.scope){case wl.LOCAL:e.isShader("vertex")?i="transformed":(e.requires.position=!0,i="vPosition");break;case wl.WORLD:if(e.isShader("vertex"))return"( modelMatrix * vec4( transformed, 1.0 ) ).xyz";e.requires.worldPosition=!0,i="vWPosition";break;case wl.VIEW:i=e.isShader("vertex")?"-mvPosition.xyz":"vViewPosition";break;case wl.PROJECTION:i=e.isShader("vertex")?"( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )":"vec4( 0.0 )";break}return e.format(i,this.getType(),t)}},Fo=wl;Fo.LOCAL="local",Fo.WORLD="world",Fo.VIEW="view",Fo.PROJECTION="projection";ni.addKeyword("position",function(){return new Fo});ni.addKeyword("worldPosition",function(){return new Fo(Fo.WORLD)});ni.addKeyword("viewPosition",function(){return new Fo(Fo.VIEW)});var Ma=class extends In{constructor(e){super("v3");this.nodeType="Reflect",this.scope=e!=null?e:Ma.CUBE}getUnique(e){return!e.context.viewNormal}getType(){switch(this.scope){case Ma.SPHERE:return"v2"}return this.type}generate(e,t){let n=this.getUnique(e);if(e.isShader("fragment")){let s;switch(this.scope){case Ma.VECTOR:{let r=new si(si.VIEW),i=e.context.roughness,o=r.build(e,"v3"),a=new Fo(Fo.VIEW).build(e,"v3"),l=i?i.build(e,"f"):void 0,c=`reflect( -normalize( ${a} ), ${o} )`;l&&(c=`normalize( mix( ${c}, ${o}, ${l} * ${l} ) )`);let h=`inverseTransformDirection( ${c}, viewMatrix )`;n?(e.addNodeCode(`vec3 reflectVec = ${h};`),s="reflectVec"):s=h;break}case Ma.CUBE:{let r=new Ma(Ma.VECTOR).build(e,"v3"),i="vec3( -"+r+".x, "+r+".yz )";n?(e.addNodeCode(`vec3 reflectCubeVec = ${i};`),s="reflectCubeVec"):s=i;break}case Ma.SPHERE:{let r="normalize( ( viewMatrix * vec4( "+new Ma(Ma.VECTOR).build(e,"v3")+", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5";n?(e.addNodeCode(`vec2 reflectSphereVec = ${r};`),s="reflectSphereVec"):s=r;break}}return e.format(s,this.getType(),t)}else return console.warn("ReflectNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.type,t)}},tp=Ma;tp.CUBE="cube",tp.SPHERE="sphere",tp.VECTOR="vector";var Jae=class extends In{constructor(e=new vc,t,n){super("v4");this.nodeType="TextureCube",this.value=e,this.radianceNode=new Y2(this.value,t!=null?t:new tp(tp.VECTOR),n),this.irradianceNode=new Y2(this.value,new si(si.WORLD),new lt(1).setReadonly(!0))}generate(e,t){return e.isShader("fragment")?(e.require("irradiance"),e.context.bias&&e.context.bias.setTexture(this.value),(e.slot==="irradiance"?this.irradianceNode:this.radianceNode).build(e,t)):(console.warn("TextureCubeNode is not compatible with "+e.shader+" shader."),e.format("vec4( 0.0 )",this.getType(e),t))}},ele=class extends Ii{constructor(e=new _S,t,n){super("v4",{shared:!0});this.nodeType="CubeTexture",this.value=e,this.uv=t!=null?t:new tp,this.bias=n}getTexture(e,t){return super.generate(e,t,this.value.uuid,"tc")}generate(e,t){var l,c;if(t==="samplerCube")return this.getTexture(e,t);let n=this.getTexture(e,t),s=(l=this.uv)==null?void 0:l.build(e,"v3"),r=this.bias?this.bias.build(e,"f"):void 0;r===void 0&&e.context.bias&&(r=e.context.bias.setTexture(this).build(e,"f"));let i;r?i="texCubeBias( "+n+", "+s+", "+r+" )":i="texCube( "+n+", "+s+" )";let o={include:e.isShader("vertex"),ignoreCache:!0},a=this.getType(e);return e.addContext(o),this.colorSpace=(c=this.colorSpace)!=null?c:new ka(new Hn("",a)),this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)),this.colorSpace.input.parse(i),i=this.colorSpace.build(e,a),e.removeContext(),e.format(i,a,t)}},CR=["x","y","z","w"],tle=["float","vec2","vec3","vec4"],nle={float:"f",vec2:"v2",vec3:"v3",vec4:"v4",mat4:"v4",int:"i",bool:"b","float[]":"f[]","vec4[]":"v4[]"},sle={t:"sampler2D",tc:"samplerCube",b:"bool",i:"int",f:"float",c:"vec3",v2:"vec2",v3:"vec3",v4:"vec4",m3:"mat3",m4:"mat4","f[]":"float[]","v4[]":"vec4[]"},rle=class{constructor(){this.includes={consts:{},functions:{},structs:{}},this.cache="",this.slot="",this.shader="",this.context={},this.getIncludesCode=function(){function e(t,n){return t.deps.length-n.deps.length}return function(t,n){let s=this.getIncludes(t,n);if(!s)return"";let r="";s=s.sort(e);for(let i=0;i<s.length;i++)s[i].src&&(r+=s[i].src+`
`);return r}}(),this.slots=[],this.caches=[],this.contexts=[],this.keywords={},this.nodeData={},this.fragmentVariables={},this.fragmentParsVariables={},this.vertexParsVariables={},this.requires={uv:[],color:[],transparent:!1,irradiance:!1,position:!1,worldPosition:!1,normal:!1,worldNormal:!1,vWorldViewDir:!1,modelMatrix:!1,viewMatrix:!1,projectionMatrix:!1},this.includes={consts:[],functions:[],structs:[]},this.attributes={},this.prefixCode=["#ifdef TEXTURE_LOD_EXT","	#define texCube(a, b) textureCube(a, b)","	#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)","	#define tex2D(a, b) texture2D(a, b)","	#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)","#else","	#define texCube(a, b) textureCube(a, b)","	#define texCubeBias(a, b, c) textureCube(a, b, c)","	#define tex2D(a, b) texture2D(a, b)","	#define tex2DBias(a, b, c) texture2D(a, b, c)","#endif",`
			// NOTE: Include Spline's blending modes. This could be part of BlendNode
			#define SPE_BLENDING_NORMAL 0
			#define SPE_BLENDING_MULTIPLY 1
			#define SPE_BLENDING_SCREEN 2
			#define SPE_BLENDING_OVERLAY 3

			vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, b, alpha );
			}

			vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, a * b, alpha );
			}

			vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );
				return mix( a, tmp, alpha );
			}

			vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );
				return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );
			}

			vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {
				if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );
				return vec3( 1.0 );
			}
			`,"#include <packing>","#include <common>"].join(`
`),this.parsCode={vertex:["float neighbor_offset = 0.0001;",""].join(`
`),fragment:["float accumAlpha = 0.0;",`void accumulateAlpha(float alpha) {
					accumAlpha += (1.0 - accumAlpha) * alpha;
				}`,""].join(`
`)},this.code={vertex:"",fragment:""},this.nodeCode={vertex:"",fragment:""},this.resultCode={vertex:"",fragment:""},this.finalCode={vertex:"",fragment:""},this.inputs={uniforms:{list:[],vertex:[],fragment:[]},arrayUniforms:{list:[],vertex:[],fragment:[]},vars:{varying:[],vertex:[],fragment:[]}},this.defines={},this.uniforms={},this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.updaters=[],this.nodes=[],this.analyzing=!1}build(e,t){this.buildShader("vertex",e),this.buildShader("fragment",t);for(let n=0;n<this.requires.uv.length;n++)if(this.requires.uv[n]){let s=n>0?n+1:"";this.addVaryCode("varying vec2 vUv"+s+";"),n>0&&this.addVertexParsCode("attribute vec2 uv"+s+";"),this.addVertexFinalCode("vUv"+s+" = uv"+s+";")}return this.requires.color[0]&&(this.addVaryCode("varying vec4 vColor;"),this.addVertexParsCode("attribute vec4 color;"),this.addVertexFinalCode("vColor = color;")),this.requires.color[1]&&(this.addVaryCode("varying vec4 vColor2;"),this.addVertexParsCode("attribute vec4 color2;"),this.addVertexFinalCode("vColor2 = color2;")),this.requires.position&&(this.addVaryCode("varying vec3 vPosition;"),this.addVertexFinalCode("vPosition = transformed;")),this.requires.worldPosition,this.requires.normal&&(this.addVaryCode("varying vec3 vObjectNormal;"),this.addVertexFinalCode("vObjectNormal = normal;")),this.requires.modelMatrix&&this.addFragmentParsCode("uniform mat4 modelMatrix;"),this.requires.viewMatrix&&this.addFragmentParsCode("uniform mat4 viewMatrix;"),this.requires.projectionMatrix&&this.addFragmentParsCode("uniform mat4 projectionMatrix;"),this.requires.worldNormal&&(this.addVaryCode("varying vec3 vWNormal;"),this.addVertexFinalCode("vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;")),this.requires.vWorldViewDir&&(this.addVaryCode("varying vec3 vWorldViewDir;"),this.addVertexFinalCode("vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );")),this}buildShader(e,t){this.resultCode[e]=t.build(this.setShader(e),"v4")}setMaterial(e,t){return this.defines={},this}addFlow(e,t,n){return this.addSlot(e).addCache(t).addContext(n)}removeFlow(){return this.removeSlot().removeCache().removeContext()}addCache(e){return this.cache=e!=null?e:"",this.caches.push(this.cache),this}removeCache(){return this.caches.pop(),this.cache=this.caches[this.caches.length-1]||"",this}addContext(e){return this.context=Object.assign({},this.context,e),this.context.extra=this.context.extra||{},this.contexts.push(this.context),this}removeContext(){return this.contexts.pop(),this.context=this.contexts[this.contexts.length-1]||{},this}addSlot(e){return this.slot=e||"",this.slots.push(this.slot),this}removeSlot(){return this.slots.pop(),this.slot=this.slots[this.slots.length-1]||"",this}addFragmentVariable(e,t){this.fragmentVariables[e]===void 0&&(this.addFragmentCode(`${t} ${e};`),this.fragmentVariables[e]="")}addFragmentParsVariable(e,t){this.fragmentParsVariables[e]===void 0&&(this.addFragmentParsCode(`${t} ${e};`),this.fragmentParsVariables[e]="")}addVertexParsVariable(e,t){this.vertexParsVariables[e]===void 0&&(this.addVertexParsCode(`${t} ${e};`),this.vertexParsVariables[e]="")}addVertexCode(e){this.addCode(e,"vertex")}addFragmentCode(e){this.addCode(e,"fragment")}addCode(e,t){this.code[t!=null?t:this.shader]+=e+`
`}addVertexNodeCode(e){this.addNodeCode(e,"vertex")}addFragmentNodeCode(e){this.addNodeCode(e,"fragment")}addNodeCode(e,t){this.nodeCode[t!=null?t:this.shader]+=e+`
`}clearNodeCode(e){e=e!=null?e:this.shader;let t=this.nodeCode[e];return this.nodeCode[e]="",t}clearVertexNodeCode(){return this.clearNodeCode("vertex")}clearFragmentNodeCode(){return this.clearNodeCode("fragment")}addVertexFinalCode(e){this.addFinalCode(e,"vertex")}addFragmentFinalCode(e){this.addFinalCode(e,"fragment")}addFinalCode(e,t){this.finalCode[t!=null?t:this.shader]+=e+`
`}addVertexParsCode(e){this.addParsCode(e,"vertex")}addFragmentParsCode(e){this.addParsCode(e,"fragment")}addParsCode(e,t){this.parsCode[t!=null?t:this.shader]+=e+`
`}addVaryCode(e){this.addVertexParsCode(e),this.addFragmentParsCode(e)}isCache(e){return this.caches.indexOf(e)!==-1}isSlot(e){return this.slots.indexOf(e)!==-1}define(e,t){this.defines[e]=t===void 0?1:t}require(e){this.requires[e]=!0}isDefined(e){return this.defines[e]!==void 0}getVar(e,t,n,s="varying",r="V",i=""){let o=this.getVars(s),a=o[e];if(!a){let l=o.length;a={name:n||"node"+r+l+(i?"_"+i:""),type:t},o.push(a),o[e]=a}return a}getTempVar(e,t,n,s){return this.getVar(e,t,n,this.shader,"T",s)}getAttribute(e,t){if(!this.attributes[e]){let n=this.getVar(e,t);this.addVertexParsCode("attribute "+t+" "+e+";"),this.addVertexFinalCode(n.name+" = "+e+";"),this.attributes[e]={varying:n,name:e,type:t}}return this.attributes[e]}getCode(e){return[this.prefixCode,this.parsCode[e],this.getVarListCode(this.getVars("varying"),"varying"),this.getVarListCode(this.inputs.uniforms[e],"uniform"),this.getVarListCode(this.inputs.arrayUniforms[e],"uniform"),this.getIncludesCode("consts",e),this.getIncludesCode("structs",e),this.getIncludesCode("functions",e),"void main() {",this.getVarListCode(this.getVars(e)),this.code[e],this.resultCode[e],this.finalCode[e],"}"].join(`
`)}getVarListCode(e,t){t=t!=null?t:"";let n="";for(let s=0,r=e.length;s<r;++s){let i=e[s],o=i.type,a=i.name,l=i.size,c=this.getFormatByType(o);if(c===void 0)throw new Error("Node pars "+c+" not found.");c.includes("[]")?n+=t+" "+c.substring(0,c.length-2)+" "+a+`[${l}];
`:n+=t+" "+c+" "+a+`;
`}return n}getVars(e){return this.inputs.vars[e!=null?e:this.shader]}getNodeData(e){let t=e instanceof yc?e.uuid:e;return this.nodeData[t]=this.nodeData[t]||{}}createUniform(e,t,n,s,r,i){if(t.includes("[]")){let o=this.inputs.arrayUniforms,a=o.list.length,l=new vR({type:t,size:n.size,name:s||"nodeUA"+a+(i?"_"+i:""),node:n,needsUpdate:r});return o.list.push(l),o[e].push(l),o[e][l.name]=l,this.uniforms[l.name]=l,l}else{let o=this.inputs.uniforms,a=o.list.length,l=new vR({type:t,name:s||"nodeU"+a+(i?"_"+i:""),node:n,needsUpdate:r});return o.list.push(l),o[e].push(l),o[e][l.name]=l,this.uniforms[l.name]=l,l}}createVertexUniform(e,t,n,s,r){return this.createUniform("vertex",e,t,n,s,r)}createFragmentUniform(e,t,n,s,r){return this.createUniform("fragment",e,t,n,s,r)}include(e,t,n){var i;let s;if(e=typeof e=="string"?ni.get(e):e,this.context.include===!1)return e.name;e instanceof ft?s=this.includes.functions:e instanceof Sn?s=this.includes.consts:e instanceof wR&&(s=this.includes.structs);let r=s[this.shader]=s[this.shader]||[];if(e){let o=r[e.name];if(o||(o=r[e.name]={node:e,deps:[]},r.push(o),o.src=e.build(this,"source")),e instanceof ft&&t&&r[t.name]&&r[t.name].deps.indexOf(e)===-1&&(r[t.name].deps.push(e),(i=e.includes)==null?void 0:i.length)){let a=0;do this.include(e.includes[a++],t);while(a<e.includes.length)}return n&&(o.src=n),e.name}else throw new Error("Include not found.")}colorToVectorProperties(e){return e.replace("r","x").replace("g","y").replace("b","z").replace("a","w")}colorToVector(e){return e.replace(/c/g,"v3")}getIncludes(e,t){return this.includes[e][t||this.shader]}getConstructorFromLength(e){return tle[e-1]}isTypeMatrix(e){return/^m/.test(e)}getTypeLength(e){return e==="f"?1:parseInt(this.colorToVector(e).substr(1))}getTypeFromLength(e){return e===1?"f":"v"+e}findNode(...e){for(let t=0;t<arguments.length;t++){let n=e[t];if(n==null?void 0:n.isNode)return n}}resolve(...e){for(let t=0;t<arguments.length;t++){let n=e[t];if(n!==void 0){if(n.isNode)return n;if(n.isTexture)switch(n.mapping){case hu:case du:return new ele(n);case Tf:return new Jae(new vc(n));default:return new vc(n)}else{if(n.isVector2)return new Ji(n);if(n.isVector3)return new eo(n);if(n.isVector4)return new zu(n)}}}}format(e,t,n){switch(this.colorToVector(n+" <- "+t)){case"f <- v2":return e+".x";case"f <- v3":return e+".x";case"f <- v4":return e+".x";case"f <- i":case"f <- b":return"float( "+e+" )";case"v2 <- f":return"vec2( "+e+" )";case"v2 <- v3":return e+".xy";case"v2 <- v4":return e+".xy";case"v2 <- i":case"v2 <- b":return"vec2( float( "+e+" ) )";case"v3 <- f":return"vec3( "+e+" )";case"v3 <- v2":return"vec3( "+e+", 0.0 )";case"v3 <- v4":return e+".xyz";case"v3 <- i":case"v3 <- b":return"vec2( float( "+e+" ) )";case"v4 <- f":return"vec4( "+e+" )";case"v4 <- v2":return"vec4( "+e+", 0.0, 1.0 )";case"v4 <- v3":return"vec4( "+e+", 1.0 )";case"v4 <- i":case"v4 <- b":return"vec4( float( "+e+" ) )";case"i <- f":case"i <- b":return"int( "+e+" )";case"i <- v2":return"int( "+e+".x )";case"i <- v3":return"int( "+e+".x )";case"i <- v4":return"int( "+e+".x )";case"b <- f":return"( "+e+" != 0.0 )";case"b <- v2":return"( "+e+" != vec2( 0.0 ) )";case"b <- v3":return"( "+e+" != vec3( 0.0 ) )";case"b <- v4":return"( "+e+" != vec4( 0.0 ) )";case"b <- i":return"( "+e+" != 0 )"}return e}getTypeByFormat(e){return nle[e]||e}getFormatByType(e){return sle[e]||e}getUUID(e,t){return t=t!==void 0?t:!0,t&&this.cache&&(e=this.cache+"-"+e),e}getElementByIndex(e){return CR[e]}getIndexByElement(e){return CR.indexOf(e)}isShader(e){return this.shader===e}setShader(e){return this.shader=e,this}mergeDefines(e){for(let t in e)this.defines[t]=e[t];return this.defines}mergeUniform(e){for(let t in e)this.uniforms[t]=e[t];return this.uniforms}getTextureEncodingFromMap(e){let t;return e?e.isTexture&&(t=e.encoding):t=ha,t===ha&&this.context.gamma&&(t=Gt),t}},os=class extends Ii{constructor(e=0,t,n,s){super("c");this.nodeType="Color",this.value=e instanceof Ni?e:new Ni(e||0,t,n,s)}setRGBA(e){this.value.setRGBA(e.r,e.g,e.b,e.a)}generate(e,t,n,s,r,i){n=e.getUUID(n!=null?n:this.getUUID()),s=s!=null?s:this.getType(e);let o=e.getNodeData(n),a=this.getReadonly()&&this.generateReadonly!==void 0;if(this.alpha){let l=this.alpha.build(e,"f");e.addFragmentNodeCode(`accumAlpha += ( 1.0 - accumAlpha ) * ${l};`)}return a?this.generateReadonly(e,t,n,s,r,i):e.isShader("vertex")?(o.vertex||(o.vertex=e.createVertexUniform(s,this,r,i,this.getLabel())),e.format(o.vertex.name,s,t)):(o.fragment||(o.fragment=e.createFragmentUniform(s,this,r,i,this.getLabel())),e.format(o.fragment.name,s,t))}generateReadonly(e,t,n,s,r,i){return e.format("vec3("+this.value.r+", "+this.value.g+", "+this.value.b+")",s,t)}},En=class extends Ii{constructor(e){super("i");this.nodeType="Int",this.value=Math.floor(e!=null?e:0)}generateReadonly(e,t,n,s,r,i){return e.format(this.value.toString(),s,t)}},TR=class extends yc{constructor(){super("basic");this.nodeType="Basic",this.color=new os(5855577),this.shadingAlpha=new lt(1),this.shadingBlend=new En(0)}get category(){return"phong"}generate(e){let t;if(e.isShader("vertex")){let n=this.position?this.position.analyzeAndFlow(e,"v3",{cache:"position"}):void 0;e.mergeUniform(cd.merge([Ye.fog])),e.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","#include <fog_pars_vertex>","#include <normal_pars_vertex>"].join(`
`));let s=["#include <beginnormal_vertex>",`
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,"#include <normal_vertex>",`
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`];n&&s.push(n.code,n.result?"displaced_position = "+n.result+";":""),s.push("transformed = displaced_position;","transformedNormal = normalMatrix * displaced_normal;","#ifndef FLAT_SHADED","	vNormal = transformedNormal;","#endif"),s.push("#include <project_vertex>","#include <fog_vertex>","#include <clipping_planes_vertex>","	vViewPosition = - mvPosition.xyz;","#include <worldpos_vertex>"),s.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"),t=s.join(`
`)}else{this.color===void 0&&(this.color=new os(5855577)),this.color.analyze(e,{slot:"color"}),this.alpha&&this.alpha.analyze(e),this.afterColor&&this.afterColor.analyze(e,{slot:"afterColor"});let n=this.color.flow(e,"c",{slot:"color"}),s=this.alpha?this.alpha.flow(e,"f"):void 0,r=this.afterColor?this.afterColor.flow(e,"c",{slot:"afterColor"}):void 0;e.requires.transparent=s!==void 0,e.addParsCode(["varying vec3 vWPosition;","#include <fog_pars_fragment>","#include <dithering_pars_fragment>","varying vec3 vViewPosition;","#include <normal_pars_fragment>"].join(`
`));let i=["#include <normal_fragment_begin>",n.code];s&&i.push(s.code,"#ifdef ALPHATEST"," if ( "+s.result+" <= ALPHATEST ) discard;","#endif"),r?i.push(r.code,`vec3 outgoingLight = ${n.result};`,`vec3 finalColor = spe_blend(outgoingLight, ${r.result}, 1.0, SPE_BLENDING_NORMAL);`):i.push(`vec3 finalColor = ${n.result};`),s?i.push(`gl_FragColor = vec4( finalColor, accumAlpha * ${s.result} );`):i.push("gl_FragColor = vec4("+n.result+", 1.0 );"),i.push("#include <fog_fragment>","#include <dithering_fragment>"),t=i.join(`
`)}return t}},Uu=class extends Ii{constructor(e=1,t){super("f[]");this.nodeType="FloatArray",this.size=e,this.value=Array.isArray(t)?t:typeof t=="number"?new Array(e).fill(t):new Array(e).fill(0)}},Kn={normalRenderTarget:new vc,normalRenderTargetDepth:new vc,transmissionRenderTarget:new vc,transmissionSize:new Ji(2048,2048),transmissionRenderTargetDepth:new vc,pixelRatioNode:new lt(1),resolution:new Ji,penumbraSize:new Uu(5,.5)};for(let e of Object.values(Kn))e.isRenderGlobal=!0;var ile=class extends yc{constructor(){super("lambert");this.nodeType="Lambert",this.color=new os(5855577),this.emissive=new os(0),this.emissiveIntensity=new lt(1),this.shadingAlpha=new lt(1),this.shadingBlend=new En(0)}get category(){return"lambert"}build(e){let t;if(e.define("LAMBERT"),e.requires.lights=!0,e.extensions.derivatives=!0,e.isShader("vertex")){let n=this.position?this.position.analyzeAndFlow(e,"v3",{cache:"position"}):void 0;e.mergeUniform(cd.merge([Ye.fog,Ye.lights])),e.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","varying vec3 vLightFront;","varying vec3 vIndirectFront;","#ifndef DOUBLE_SIDED","   #define DOUBLE_SIDED","#endif","#ifdef DOUBLE_SIDED","	varying vec3 vLightBack;","	varying vec3 vIndirectBack;","#endif","#include <bsdfs>","#include <lights_pars_begin>","#include <color_pars_vertex>","#include <fog_pars_vertex>","#include <normal_pars_vertex>","#include <shadowmap_pars_vertex>","#include <clipping_planes_pars_vertex>"].join(`
`));let s=["#include <beginnormal_vertex>",`
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,"#include <normal_vertex>",`
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];n&&s.push(n.code,n.result?"displaced_position = "+n.result+";":""),s.push("transformed = displaced_position;","transformedNormal = normalMatrix * displaced_normal;","#ifndef FLAT_SHADED","    vNormal = transformedNormal;","#endif"),s.push("	#include <project_vertex>","	#include <clipping_planes_vertex>","	vViewPosition = - mvPosition.xyz;","	#include <worldpos_vertex>",`
					vec3 diffuse = vec3( 1.0 );
					GeometricContext geometry;
					geometry.position = mvPosition.xyz;
					geometry.normal = normalize( transformedNormal );
					geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
					GeometricContext backGeometry;
					backGeometry.position = geometry.position;
					backGeometry.normal = -geometry.normal;
					backGeometry.viewDir = geometry.viewDir;
					vLightFront = vec3( 0.0 );
					vIndirectFront = vec3( 0.0 );
					#ifdef DOUBLE_SIDED
						vLightBack = vec3( 0.0 );
						vIndirectBack = vec3( 0.0 );
					#endif
					IncidentLight directLight;
					float dotNL;
					vec3 directLightColor_Diffuse;
					vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
					vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
					#ifdef DOUBLE_SIDED
						vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
						vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
					#endif
					#if NUM_POINT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
							getPointLightInfo( pointLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_SPOT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
							getSpotLightInfo( spotLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_DIR_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
							getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_HEMI_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
							vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
							#ifdef DOUBLE_SIDED
								vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
							#endif
						}
						#pragma unroll_loop_end
					#endif
				`,"	#include <shadowmap_vertex>","	#include <fog_vertex>"),s.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"),t=s.join(`
`)}else{e.mergeUniform({penumbraSize:Kn.penumbraSize}),this.color===void 0&&(this.color=new os(5855577)),this.color.analyze(e,{slot:"color"}),this.shadingAlpha.analyze(e),this.shadingBlend.analyze(e),this.afterColor&&this.afterColor.analyze(e,{slot:"afterColor"}),this.alpha&&this.alpha.analyze(e);let n=this.color.flow(e,"c",{slot:"color"}),s=this.emissive.flow(e,"c",{slot:"emissive"}),r=this.emissiveIntensity.flow(e,"f",{slot:"emissive"}),i=this.shadingAlpha.flow(e,"f"),o=this.shadingBlend.flow(e,"i"),a=this.afterColor?this.afterColor.flow(e,"c",{slot:"afterColor"}):void 0,l=this.alpha?this.alpha.flow(e,"f"):void 0;e.requires.transparent=l!==void 0,e.addParsCode([`uniform float penumbraSize[${5}];`,"varying vec3 vViewPosition;","varying vec3 vWPosition;","varying vec3 vLightFront;","varying vec3 vIndirectFront;","#ifndef DOUBLE_SIDED","   #define DOUBLE_SIDED","#endif","#include <normal_pars_fragment>","#ifdef DOUBLE_SIDED","	varying vec3 vLightBack;","	varying vec3 vIndirectBack;","#endif","#include <bsdfs>","#include <lights_pars_begin>","#include <fog_pars_fragment>","#include <shadowmap_pars_fragment>","#include <shadowmask_pars_fragment>","#include <clipping_planes_pars_fragment>","#include <dithering_pars_fragment>"].join(`
`));let c=["#include <normal_fragment_begin>",`
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx, viewdy));
				bool isFrontFacing = (dot(normal, faceNormal) >= 0.0);
				`,"#include <clipping_planes_fragment>"];c.push(n.code,"vec3 diffuseColor = "+n.result+";","ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );"),l&&c.push(l.code,"#ifdef ALPHATEST","if ( "+l.result+" <= ALPHATEST ) discard;","#endif"),c.push("#ifdef DOUBLE_SIDED","	reflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;","#else","	reflectedLight.indirectDiffuse += vIndirectFront;","#endif","#include <lightmap_fragment>","reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );","#ifdef DOUBLE_SIDED","	reflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;","#else","	reflectedLight.directDiffuse = vLightFront;","#endif","reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();"),s&&c.push(s.code,"reflectedLight.directDiffuse += "+s.result+" * "+r.result+";"),c.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;"),c.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${i.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${i.result}, ${o.result} );
				}
				`),a&&c.push(a.code,`outgoingLight = spe_blend(outgoingLight, ${a.result}, 1.0, SPE_BLENDING_NORMAL);`),l?c.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${l.result} );`):c.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),c.push("#include <encodings_fragment>","#include <fog_fragment>","#include <dithering_fragment>"),t=c.join(`
`)}return t}},ole=class extends yc{constructor(){super("phong");this.nodeType="Phong",this.color=new os(5855577),this.specular=new os(1118481),this.shininess=new lt(30),this.shadingAlpha=new lt(1),this.shadingBlend=new En(0)}get category(){return"phong"}build(e){let t;if(e.define("PHONG"),e.requires.lights=!0,e.extensions.derivatives=!0,e.isShader("vertex")){let n=this.position?this.position.analyzeAndFlow(e,"v3",{cache:"position"}):void 0;e.mergeUniform(cd.merge([Ye.fog,Ye.lights])),e.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","#include <fog_pars_vertex>","#include <normal_pars_vertex>","#include <shadowmap_pars_vertex>","#include <clipping_planes_pars_vertex>"].join(`
`));let s=["#include <beginnormal_vertex>",`
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif


				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,"#include <normal_vertex>",`
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];n&&s.push(n.code,n.result?"displaced_position = "+n.result+";":""),s.push("transformed = displaced_position;","transformedNormal = normalMatrix * displaced_normal;","#ifndef FLAT_SHADED","    vNormal = transformedNormal;","#endif"),s.push("	#include <project_vertex>","	#include <clipping_planes_vertex>","	vViewPosition = - mvPosition.xyz;","	#include <worldpos_vertex>","	#include <shadowmap_vertex>","	#include <fog_vertex>"),s.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"),t=s.join(`
`)}else{e.mergeUniform({penumbraSize:Kn.penumbraSize}),this.color===void 0&&(this.color=new os(5855577)),this.color.analyze(e,{slot:"color"}),this.specular.analyze(e),this.shininess.analyze(e),this.shadingAlpha.analyze(e),this.shadingBlend.analyze(e),this.afterColor&&this.afterColor.analyze(e,{slot:"afterColor"}),this.alpha&&this.alpha.analyze(e);let n=this.color.flow(e,"c",{slot:"color"}),s=this.specular.flow(e,"c"),r=this.shininess.flow(e,"f"),i=this.shadingAlpha.flow(e,"f"),o=this.shadingBlend.flow(e,"i"),a=this.afterColor?this.afterColor.flow(e,"c",{slot:"afterColor"}):void 0,l=this.alpha?this.alpha.flow(e,"f"):void 0;e.requires.transparent=l!==void 0,e.addParsCode(["varying vec3 vWPosition;","uniform vec3 emissive;",`uniform float penumbraSize[${5}];`,"#include <normal_pars_fragment>","#include <fog_pars_fragment>","#include <bsdfs>","#include <lights_pars_begin>","#include <lights_phong_pars_fragment>","#include <shadowmap_pars_fragment>","#include <dithering_pars_fragment>"].join(`
`));let c=["#include <normal_fragment_begin>",`
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,"	BlinnPhongMaterial material;"];c.push(n.code,"	vec3 diffuseColor = "+n.result+";","	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );","	vec3 totalEmissiveRadiance = emissive;",s.code,"	vec3 specular = "+s.result+";",r.code,"	float shininess = max( 0.0001, "+r.result+" );","	float specularStrength = 1.0;"),l&&c.push(l.code,"#ifdef ALPHATEST","if ( "+l.result+" <= ALPHATEST ) discard;","#endif"),c.push("material.diffuseColor = diffuseColor;"),c.push("material.specularColor = specular;","material.specularShininess = shininess;","material.specularStrength = specularStrength;","#include <lights_fragment_begin>","#include <lights_fragment_end>"),c.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;"),c.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${i.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${i.result}, ${o.result} );
				}
				`),a&&c.push(a.code,`outgoingLight = spe_blend(outgoingLight, ${a.result}, 1.0, SPE_BLENDING_NORMAL);`),l?c.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${l.result} );`):c.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),c.push("#include <encodings_fragment>","#include <fog_fragment>","#include <dithering_fragment>"),t=c.join(`
`)}return t}},ale=class extends yc{constructor(){super("standard");this.nodeType="Standard",this.color=new os(5855577),this.roughness=new lt(.3),this.metalness=new lt(0),this.reflectivity=new lt(.5),this.shadingAlpha=new lt(1),this.shadingBlend=new En(0)}get category(){return"physical"}build(e){let t;if(e.define("STANDARD"),e.requires.lights=!0,e.extensions.derivatives=!0,e.extensions.shaderTextureLOD=!0,e.isShader("vertex")){let n=this.position?this.position.analyzeAndFlow(e,"v3",{cache:"position"}):void 0;e.mergeUniform(cd.merge([Ye.fog,Ye.lights])),e.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","#include <fog_pars_vertex>","#include <normal_pars_vertex>","#include <shadowmap_pars_vertex>","#include <clipping_planes_pars_vertex>"].join(`
`));let s=["#include <beginnormal_vertex>",`
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,"#include <normal_vertex>",`
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`];n&&s.push(n.code,n.result?"displaced_position = "+n.result+";":""),s.push("transformed = displaced_position;","transformedNormal = normalMatrix * displaced_normal;","#ifndef FLAT_SHADED","    vNormal = transformedNormal;","#endif"),s.push("#include <project_vertex>","#include <fog_vertex>","#include <clipping_planes_vertex>","	vViewPosition = - mvPosition.xyz;","#include <worldpos_vertex>","#include <shadowmap_vertex>"),s.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"),t=s.join(`
`)}else{e.mergeUniform({penumbraSize:Kn.penumbraSize});let n={gamma:!0};this.color===void 0&&(this.color=new os(5855577)),this.color.analyze(e,{slot:"color",context:n}),this.roughness.analyze(e),this.metalness.analyze(e),this.shadingAlpha.analyze(e),this.shadingBlend.analyze(e),this.afterColor&&this.afterColor.analyze(e,{slot:"afterColor"}),this.alpha&&this.alpha.analyze(e),this.reflectivity&&this.reflectivity.analyze(e);let s=this.color.flow(e,"c",{slot:"color",context:n}),r=this.roughness.flow(e,"f"),i=this.metalness.flow(e,"f"),o=this.shadingAlpha.flow(e,"f"),a=this.shadingBlend.flow(e,"i"),l=this.afterColor?this.afterColor.flow(e,"c",{slot:"afterColor"}):void 0,c=this.alpha?this.alpha.flow(e,"f"):void 0,h=this.reflectivity?this.reflectivity.flow(e,"f"):void 0;e.requires.transparent=c!==void 0,e.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;",`uniform float penumbraSize[${5}];`,"#include <normal_pars_fragment>","#include <dithering_pars_fragment>","#include <fog_pars_fragment>","#include <bsdfs>","#include <lights_pars_begin>","#include <lights_physical_pars_fragment>","#include <shadowmap_pars_fragment>"].join(`
`));let u=["#include <clipping_planes_fragment>","	#include <normal_fragment_begin>",`
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,"	PhysicalMaterial material;","	material.diffuseColor = vec3( 1.0 );"];u.push(s.code,"	vec3 diffuseColor = "+s.result+";","	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",r.code,"	float roughnessFactor = "+r.result+";",i.code,"	float metalnessFactor = "+i.result+";"),c&&u.push(c.code,"#ifdef ALPHATEST","	if ( "+c.result+" <= ALPHATEST ) discard;","#endif"),u.push("vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );"),u.push("material.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );","material.roughness = max( roughnessFactor, 0.0525 );","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.roughness = clamp( roughnessFactor, 0.04, 1.0 );"),h?u.push(h.code,"material.specularColor = mix( vec3( 0.16 * pow2( "+h.result+" ) ), diffuseColor, metalnessFactor );"):u.push("material.specularColor = mix( vec3( 0.04 ), diffuseColor, metalnessFactor );"),u.push("#include <lights_fragment_begin>"),u.push("#include <lights_fragment_end>"),u.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;"),u.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${o.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${o.result}, ${a.result} );
				}
				`),l&&u.push(l.code,`outgoingLight = spe_blend(outgoingLight, ${l.result}, 1.0, SPE_BLENDING_NORMAL);`),c?u.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${c.result} );`):u.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),u.push("#include <encodings_fragment>","#include <fog_fragment>","#include <dithering_fragment>"),t=u.join(`
`)}return t}},lle=class extends yc{constructor(){super("toon");this.nodeType="Toon",this.color=new os(5855577),this.specular=new os(1118481),this.shininess=new lt(30),this.shadingAlpha=new lt(1),this.shadingBlend=new En(0)}get category(){return"toon"}build(e){let t;if(e.define("TOON"),e.requires.lights=!0,e.extensions.derivatives=!0,e.isShader("vertex")){let n=this.position?this.position.analyzeAndFlow(e,"v3",{cache:"position"}):void 0;e.mergeUniform(cd.merge([Ye.fog,Ye.lights])),e.addParsCode(["varying vec3 vViewPosition;","varying vec3 vWPosition;","#include <fog_pars_vertex>","#include <normal_pars_vertex>","#include <shadowmap_pars_vertex>","#include <clipping_planes_pars_vertex>"].join(`
`));let s=["#include <beginnormal_vertex>",`
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,"#include <normal_vertex>",`
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`];n&&s.push(n.code,n.result?"displaced_position = "+n.result+";":""),s.push("transformed = displaced_position;","transformedNormal = normalMatrix * displaced_normal;","#ifndef FLAT_SHADED","    vNormal = transformedNormal;","#endif"),s.push("	#include <project_vertex>","	#include <fog_vertex>","	#include <clipping_planes_vertex>","	vViewPosition = - mvPosition.xyz;","	#include <worldpos_vertex>","	#include <shadowmap_vertex>","	#include <fog_vertex>"),s.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"),t=s.join(`
`)}else{e.mergeUniform({penumbraSize:Kn.penumbraSize}),this.color===void 0&&(this.color=new os(5855577)),this.color.analyze(e,{slot:"color"}),this.specular.analyze(e),this.shininess.analyze(e),this.shadingAlpha.analyze(e),this.shadingBlend.analyze(e),this.afterColor&&this.afterColor.analyze(e,{slot:"afterColor"}),this.alpha&&this.alpha.analyze(e);let n=this.color.flow(e,"c",{slot:"color"}),s=this.specular.flow(e,"c"),r=this.shininess.flow(e,"f"),i=this.shadingAlpha.flow(e,"f"),o=this.shadingBlend.flow(e,"i"),a=this.afterColor?this.afterColor.flow(e,"c",{slot:"afterColor"}):void 0,l=this.alpha?this.alpha.flow(e,"f"):void 0;e.requires.transparent=l!==void 0,e.addParsCode([`uniform float penumbraSize[${5}];`,"varying vec3 vWPosition;","#include <normal_pars_fragment>","#include <gradientmap_pars_fragment>","#include <fog_pars_fragment>","#include <bsdfs>","#include <lights_pars_begin>","#include <dithering_pars_fragment>",`
					varying vec3 vViewPosition;
					struct ToonMaterial {
						vec3	diffuseColor;
						vec3	specularColor;
						float	specularShininess;
						float	specularStrength;
					};
					void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
			
						reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
						reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
					}
					void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
					}
					#define RE_Direct				RE_Direct_Toon
					#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
					#define Material_LightProbeLOD( material )	(0)
					`,"#include <shadowmap_pars_fragment>","#include <bumpmap_pars_fragment>","#include <normalmap_pars_fragment>"].join(`
`));let c=["#include <normal_fragment_begin>",`
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,"	ToonMaterial material;"];c.push(n.code,"	vec3 diffuseColor = "+n.result+";","	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",s.code,"	vec3 specular = "+s.result+";",r.code,"	float shininess = max( 0.0001, "+r.result+" );","	float specularStrength = 1.0;"),l&&c.push(l.code,"#ifdef ALPHATEST","if ( "+l.result+" <= ALPHATEST ) discard;","#endif"),c.push("material.diffuseColor = diffuseColor;"),c.push("material.specularColor = specular;","material.specularShininess = shininess;","material.specularStrength = specularStrength;","#include <lights_fragment_begin>","#include <lights_fragment_end>"),c.push("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;"),c.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${i.result} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${i.result}, ${o.result} );
				}
				`),a&&c.push(a.code,`outgoingLight = spe_blend(outgoingLight, ${a.result}, 1.0, SPE_BLENDING_NORMAL);`),l?c.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${l.result} );`):c.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),c.push("#include <encodings_fragment>","#include <fog_fragment>","#include <dithering_fragment>"),t=c.join(`
`)}return t}},Tm=class extends Ii{constructor(e){super("b");this.nodeType="Bool",this.value=e!=null?e:!1}generateReadonly(e,t,n,s){return e.format(this.value?"true":"false",s,t)}},ER=class extends Ii{constructor(e){super("m3");this.nodeType="Matrix3",this.value=e!=null?e:new Or}generateReadonly(e,t,n,s,r,i){return e.format("mat3("+this.value.elements.join(", ")+")",s,t)}get elements(){return this.value.elements}set elements(e){this.value.fromArray(e)}},Vu=class extends Ii{constructor(e=1,t){super("v4[]");this.nodeType="Vector4Array",this.size=e,this.value=Array.isArray(t)?t:t instanceof Bt?new Array(e).fill(t):new Array(e).fill(new Bt(0))}},Q2=(e=>(e.SIMPLEX="simplex3d",e.SIMPLEX_FRACTAL="simplex3dFractal",e.ASHIMA="simplexAshima",e.FBM="fbm",e.PERLIN="perlin",e))(Q2||{}),to=function(){let e=new ft(`vec3 random3(vec3 c) {
			float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
			vec3 r;
			r.z = fract(512.0*j);
			j *= .125;
			r.x = fract(512.0*j);
			j *= .125;
			r.y = fract(512.0*j);
			return r-0.5;
		}`),t=new ft(`float simplex3d(vec3 p) {
			 vec3 s = floor(p + dot(p, vec3(F3)));
			 vec3 x = p - s + dot(s, vec3(G3));
			 
			 vec3 e = step(vec3(0.0), x - x.yzx);
			 vec3 i1 = e*(1.0 - e.zxy);
			 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
				
			 vec3 x1 = x - i1 + G3;
			 vec3 x2 = x - i2 + 2.0*G3;
			 vec3 x3 = x - 1.0 + 3.0*G3;
			 
			 vec4 w, d;
			 
			 w.x = dot(x, x);
			 w.y = dot(x1, x1);
			 w.z = dot(x2, x2);
			 w.w = dot(x3, x3);
			 
			 w = max(0.6 - w, 0.0);
			 
			 d.x = dot(random3(s), x);
			 d.y = dot(random3(s + i1), x1);
			 d.z = dot(random3(s + i2), x2);
			 d.w = dot(random3(s + 1.0), x3);
			 
			 w *= w;
			 w *= w;
			 d *= w;
			 
			 return dot(d, vec4(52.0));
		}`,[e]);t.keywords.F3=new Sn("float F3 0.3333333"),t.keywords.G3=new Sn("float G3 0.1666667");let n=new ft(`float simplex3dFractal(vec3 m) {
			mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);
			mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);
			mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);
			return 0.5333333 * simplex3d(m * rot1)
				 + 0.2666667 * simplex3d(2.0 * m * rot2)
				 + 0.1333333 * simplex3d(4.0 * m * rot3)
				 + 0.0666667 * simplex3d(8.0 * m);
		}`,[t]),s=new ft("vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}"),r=new ft("vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}"),i=new ft(`float simplexAshima(vec3 v) {
		  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
		  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
		  vec3 i  = floor(v + dot(v, C.yyy) );
		  vec3 x0 =   v - i + dot(i, C.xxx) ;
		  vec3 g = step(x0.yzx, x0.xyz);
		  vec3 l = 1.0 - g;
		  vec3 i1 = min( g.xyz, l.zxy );
		  vec3 i2 = max( g.xyz, l.zxy );
		  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		  vec3 x3 = x0 - 1. + 3.0 * C.xxx;
		  i = mod(i, 289.0 ); 
		  vec4 p = permute( permute( permute( 
					 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
				   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
		  float n_ = 1.0/7.0; // N=7
		  vec3  ns = n_ * D.wyz - D.xzx;
		  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
		  vec4 x_ = floor(j * ns.z);
		  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
		  vec4 x = x_ *ns.x + ns.yyyy;
		  vec4 y = y_ *ns.x + ns.yyyy;
		  vec4 h = 1.0 - abs(x) - abs(y);
		  vec4 b0 = vec4( x.xy, y.xy );
		  vec4 b1 = vec4( x.zw, y.zw );
		  vec4 s0 = floor(b0)*2.0 + 1.0;
		  vec4 s1 = floor(b1)*2.0 + 1.0;
		  vec4 sh = -step(h, vec4(0.0));
		  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
		  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
		  vec3 p0 = vec3(a0.xy,h.x);
		  vec3 p1 = vec3(a0.zw,h.y);
		  vec3 p2 = vec3(a1.xy,h.z);
		  vec3 p3 = vec3(a1.zw,h.w);
		  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
		  p0 *= norm.x;
		  p1 *= norm.y;
		  p2 *= norm.z;
		  p3 *= norm.w;
		  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
		  m = m * m;
		  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
										dot(p2,x2), dot(p3,x3) ) );
		}`,[s,r]),o=new ft("vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}"),a=new ft("vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}",[o]),l=new ft(`float noise(vec3 p){
			vec3 a = floor(p);
			vec3 d = p - a;
			d = d * d * (3.0 - 2.0 * d);
			vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
			vec4 k1 = perm(b.xyxy);
			vec4 k2 = perm(k1.xyxy + b.zzww);
			vec4 c = k2 + a.zzzz;
			vec4 k3 = perm(c);
			vec4 k4 = perm(c + 1.0);
			vec4 o1 = fract(k3 * (1.0 / 41.0));
			vec4 o2 = fract(k4 * (1.0 / 41.0));
			vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
			vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
			return o4.y * d.y + o4.x * (1.0 - d.y);
		}`,[a]),c=new ft(`float fbm(vec3 x) {
			float v = 0.0;
			float a = 0.5;
			vec3 shift = vec3(100);
			for (int i = 0; i < NUM_OCTAVES; ++i) {
				v += a * noise(x);
				x = x * 2.0 + shift;
				a *= 0.5;
			}
			return v;
		}`,[l]);c.keywords.NUM_OCTAVES=new Sn(`int NUM_OCTAVES ${5}`);let h=new ft("vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}"),u=new ft(`float perlin(vec3 P){
		  vec3 Pi0 = floor(P);
		  vec3 Pi1 = Pi0 + vec3(1.0);
		  Pi0 = mod(Pi0, 289.0);
		  Pi1 = mod(Pi1, 289.0);
		  vec3 Pf0 = fract(P);
		  vec3 Pf1 = Pf0 - vec3(1.0);
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;
		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);
		  vec4 gx0 = ixy0 / 7.0;
		  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		  vec4 gx1 = ixy1 / 7.0;
		  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;
		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);
		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}`,[s,r,h]);return{simplex:t,simplexFractal:n,simplexAshima:i,fbm:c,perlin:u}}(),AR=class extends In{constructor(e,t,n,s,r,i,o,a,l,c,h,u){super("v3");this.nodeType="Noise",this.scale=e,this.size=t,this.move=n,this.fA=s,this.fB=r,this.distortion=i,this.colorA=o,this.colorB=a,this.colorC=l,this.colorD=c,this.alpha=h,this.noiseType=u,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t,n,s,r){e.require("uv"),e.requires.uv=[!0],e.addFragmentVariable(this.calpha,"float");let i=Object.values(Q2)[this.noiseType.value],o=new ft(`vec3 ${i}customNoise(float scale, vec3 size, float move, vec2 fA, vec2 fB, vec2 distortion, vec4 colorA, vec4 colorB, vec4 colorC, vec4 colorD, float alpha, out float calpha) {
                vec3 st = position / size;
				st /= scale;
				vec3 q = vec3(${i}(st),
							  ${i}(st + vec3(1.0)),
							  ${i}(st + vec3(1.0)));
				vec3 r = vec3(${i}(st + vec3(distortion, 1.0) * q + vec3(fA, 1.0) + move),
							  ${i}(st + vec3(distortion, 1.0) * q + vec3(fB, 1.0) + move), 
							  ${i}(st * q));
				float f = ${i}(st + r);
				vec4 color;
				color = mix(colorA, colorB, clamp((f * f) * 4.0, 0.0, 1.0));
				color = mix(color, colorC, clamp(length(q), 0.0, 1.0));
				color = mix(color, colorD, clamp(length(r.x), 0.0, 1.0));

                float lalpha = alpha * color.a;
                calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );

			    accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return clamp(color, 0.0, 1.0).rgb;
			}`,[to.simplex,to.simplexFractal,to.simplexAshima,to.fbm,to.perlin]),a=e.include(o),l=[];return l.push(this.scale.build(e,"f")),l.push(this.size.build(e,"v3")),l.push(this.move.build(e,"f")),l.push(this.fA.build(e,"v2")),l.push(this.fB.build(e,"v2")),l.push(this.distortion.build(e,"v2")),l.push(this.colorA.build(e,"v4")),l.push(this.colorB.build(e,"v4")),l.push(this.colorC.build(e,"v4")),l.push(this.colorD.build(e,"v4")),l.push(this.alpha.build(e,"f")),l.push(this.calpha),e.format(a+"("+l.join(",")+")",this.getType(e),t)}};AR.numOctaves=5;var IR=class extends In{constructor(e,t,n,s,r,i,o){super("v3");this.nodeType="Fresnel",this.color=e,this.bias=t,this.scale=n,this.intensity=s,this.factor=r,this.alpha=i,this.mode=o,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){if(e.require("vWorldViewDir"),e.require("worldNormal"),e.isShader("fragment")){e.addFragmentVariable(this.calpha,"float");let n=e.include(IR.Nodes.fresnel),s=[];return s.push(this.color.build(e,"c")),s.push(this.bias.build(e,"f")),s.push(this.scale.build(e,"f")),s.push(this.intensity.build(e,"f")),s.push(this.factor.build(e,"f")),s.push(this.alpha.build(e,"f")),s.push(this.mode.build(e,"i")),s.push(this.calpha),e.format(n+"("+s.join(",")+")",this.getType(e),t)}else return console.warn("FresnelNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},NR=IR;NR.Nodes=function(){return{fresnel:new ft(`vec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, float alpha, int mode, out float calpha) {
				float fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );

				float lalpha = clamp( fresnel, 0.0, 1.0 ) * alpha;
				calpha = lalpha / clamp(lalpha + accumAlpha, 0.001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;
				return color;
			}`)}}();var kR=class extends In{constructor(e,t,n,s,r,i,o){super("v3");this.nodeType="Rainbow",this.filmThickness=e,this.movement=t,this.wavelengths=n,this.noiseStrength=s,this.noiseScale=r,this.offset=i,this.alpha=o,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){if(e.require("vWorldViewDir"),e.require("worldNormal"),e.isShader("fragment")){e.require("uv"),e.requires.uv=[!0],e.addFragmentVariable(this.calpha,"float");let n=e.include(kR.Nodes.rainbow),s=[];return s.push(this.filmThickness.build(e,"f")),s.push(this.movement.build(e,"f")),s.push(this.wavelengths.build(e,"v3")),s.push(this.noiseStrength.build(e,"f")),s.push(this.noiseScale.build(e,"f")),s.push(this.offset.build(e,"v3")),s.push(this.alpha.build(e,"f")),s.push(this.calpha),e.format(n+"("+s.join(",")+")",this.getType(e),t)}else return console.warn("RainbowNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},DR=kR;DR.Nodes=function(){let e=new ft(`vec3 attenuation(vec3 wavelengths, float filmThickness, float movement, float noiseStrength, float noiseScale, vec3 offset) {
                 vec3 st = position / noiseScale;
				 vec3 q = vec3(simplex3d(st),
							  simplex3d(st + vec3(1.0)),
							  simplex3d(st + vec3(1.0)));

				 vec3 r = vec3(simplex3d(st + vec3(1.4, 1.3, 1.0) * q + vec3(1.7, 9.2, 1.0)),
							  simplex3d(st + vec3(2.0, 1.2, 1.0) * q + vec3(8.3, 2.8, 1.0)),
							  simplex3d(st * q));

                 float noise = simplex3d(st + r);

                 return .5 + .5 * cos((((filmThickness + (noise * noiseStrength)) / (vec3(wavelengths.r * 1.0, wavelengths.g * 0.8, wavelengths.b * 0.6) + 1.0)) * dot(normalize(vWorldViewDir + (offset * -0.001)), normalize(vWNormal))) + movement);
             }`,[to.simplex]);return{rainbow:new ft(`vec3 rainbow(float filmThickness, float movement, vec3 wavelengths, float noiseStrength, float noiseScale, vec3 offset, float alpha, out float calpha) {
                 vec3 res = clamp(attenuation(wavelengths, filmThickness, movement, noiseStrength, noiseScale, offset), 0.0, 2.0);

                 float rainbowContribution = clamp(res.r + res.g + res.b, 0.0, 1.0);
                 float lalpha = alpha * rainbowContribution;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

                 return res;
             }`,[e])}}();var MR=class extends In{constructor(e,t,n,s,r,i,o,a,l,c,h,u,d,p,f,g){super("v3");this.nodeType="Outline",this.firstTime=!0,this.outlineColor=e,this.contourColor=t,this.outlineWidth=n,this.contourWidth=s,this.contourThreshold=r,this.outlineThreshold=i,this.contourFrequency=o,this.outlineSmoothing=a,this.contourDirection=l,this.positionalLines=c,this.compensation=h,this.resolution=u,this.normalMap=d,this.depthMap=p,this.pixelRatio=f,this.alpha=g,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){if(e.require("vWorldViewDir"),e.require("worldNormal"),e.extensions.derivatives=!0,this.firstTime){let n=this.outlineWidth.build(e,"f"),s=this.resolution.build(e,"v2"),r=this.compensation.build(e,"b"),i=this.pixelRatio.build(e,"f");e.addVertexParsVariable("randomColor","attribute vec3"),e.addVertexParsVariable("extrudeNormal","attribute vec3"),e.addVertexParsVariable(n,"uniform float"),e.addVertexParsVariable(s,"uniform vec2"),e.addVertexParsVariable(r,"uniform bool"),e.addVertexParsVariable(i,"uniform float"),e.addVertexParsVariable("vID","flat out float"),e.addFragmentParsVariable("vID","flat in float");let o=`g${this.uuid.toString().replace(/-/g,"")}`;e.addVertexFinalCode(`
                vID = randomColor.r;
                if (${r}) {
                    vec4 ${o}_clipPosition = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
                    // NOTE: For certain shapes, like spheres, we get incorrect extrusion when the
                    // normals face the camera directly. So we hackily fix this by offsetting the normal
                    // by a tiny amount.
                    vec3 ${o}_clipNormal = mat3(projectionMatrix) * (mat3(modelViewMatrix) * extrudeNormal) + 0.0000001;
                    vec2 ${o}_offset = normalize(${o}_clipNormal.xy) / ${s} * (${n} / 2.0) * ${o}_clipPosition.w * 2.0 * ${i};
                    ${o}_clipPosition.xy += ${o}_offset;
                    // TODO(MAX): To handle multiple outline layers, we only want to extrude
                    // if this offset is the biggest of all the potential offsets
                    gl_Position = ${o}_clipPosition;
                }
            `)}if(e.isShader("fragment")){e.require("uv"),e.requires.uv=[!0],e.addFragmentVariable(this.calpha,"float");let n=e.include(MR.Nodes.outline),s=[];return s.push(this.outlineColor.build(e,"c")),s.push(this.contourColor.build(e,"c")),s.push(this.outlineWidth.build(e,"f")),s.push(this.contourWidth.build(e,"f")),s.push(this.contourThreshold.build(e,"f")),s.push(this.outlineThreshold.build(e,"f")),s.push(this.contourFrequency.build(e,"f")),s.push(this.outlineSmoothing.build(e,"f")),s.push(this.contourDirection.build(e,"v3")),s.push(this.positionalLines.build(e,"b")),s.push(this.resolution.build(e,"v2")),s.push(this.normalMap.getTexture(e,"t")),s.push(this.depthMap.getTexture(e,"t")),s.push(this.pixelRatio.build(e,"f")),s.push(this.compensation.build(e,"b")),s.push(this.alpha.build(e,"f")),s.push(this.calpha),this.firstTime=!this.firstTime,e.format(n+"("+s.join(",")+")",this.getType(e),t)}else return console.warn("OutlineNode is not compatible with "+e.shader+" shader."),""}},PR=MR;PR.Nodes=function(){let e=new ft(`
float sobelSample(sampler2D t, sampler2D d, vec2 uv, vec2 resolution, float outlineWidth, float pixelRatio)
{
    vec2 texelSize = (vec2(1.0) / resolution) * outlineWidth * pixelRatio;

    vec2 uvSamples[9];
    vec4 normalSamples[9];

	uvSamples[0] = uv + vec2( -texelSize.x, -texelSize.y);
	uvSamples[1] = uv + vec2(0.0, -texelSize.y);
	uvSamples[2] = uv + vec2(  texelSize.x, -texelSize.y);
	uvSamples[3] = uv + vec2( -texelSize.x, 0.0);
	uvSamples[4] = uv;
	uvSamples[5] = uv + vec2(  texelSize.x, 0.0);
	uvSamples[6] = uv + vec2( -texelSize.x, texelSize.y);
	uvSamples[7] = uv + vec2(0.0, texelSize.y);
	uvSamples[8] = uv + vec2(  texelSize.x, texelSize.y);


    normalSamples[0] = texture2D(t, uvSamples[0]);
    normalSamples[1] = texture2D(t, uvSamples[1]);
    normalSamples[2] = texture2D(t, uvSamples[2]);
    normalSamples[3] = texture2D(t, uvSamples[3]);
    normalSamples[4] = texture2D(t, uvSamples[4]);
    normalSamples[5] = texture2D(t, uvSamples[5]);
    normalSamples[6] = texture2D(t, uvSamples[6]);
    normalSamples[7] = texture2D(t, uvSamples[7]);
    normalSamples[8] = texture2D(t, uvSamples[8]);

    float depthBias = 0.0001;
    // TODO(MAX): Can we somehow reduce the number of conditionals here with MATH?!
    if (normalSamples[0].a != vID && normalSamples[0].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[0]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[1].a != vID && normalSamples[1].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[1]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[2].a != vID && normalSamples[2].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[2]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[3].a != vID && normalSamples[3].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[3]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }


    if (normalSamples[4].a != vID && normalSamples[4].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[4]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[5].a != vID && normalSamples[5].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[5]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[6].a != vID && normalSamples[6].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[6]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[7].a != vID && normalSamples[7].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[7]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[8].a != vID && normalSamples[8].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[8]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    vec4 sobel_edge_h = normalSamples[2] + (2.0*normalSamples[5]) + normalSamples[8] - (normalSamples[0] + (2.0*normalSamples[3]) + normalSamples[6]);
  	vec4 sobel_edge_v = normalSamples[0] + (2.0*normalSamples[1]) + normalSamples[2] - (normalSamples[6] + (2.0*normalSamples[7]) + normalSamples[8]);

    float edgeNormal = sqrt(dot(sobel_edge_h, sobel_edge_h) + dot(sobel_edge_v, sobel_edge_v));
    return edgeNormal;
}
`);return{outline:new ft(`vec3 outline(vec3 outlineColor, vec3 contourColor, float outlineWidth, float contourWidth, float outlineThreshold, float contourThreshold, float outlineSmoothing, float contourFrequency, vec3 contourDirection, bool positionalLines, vec2 resolution, sampler2D normalMap, sampler2D depthMap, float pixelRatio, bool compensation, float alpha, out float calpha) {
                vec3 result = outlineColor;
                float resultAlpha = 0.0;

                vec3 N = normalize(vWNormal);
                vec2 nuv = (gl_FragCoord.xy / resolution);
                float sobelSample = compensation ? sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth / 2., pixelRatio) : sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth, pixelRatio);
                resultAlpha = smoothstep(outlineThreshold - outlineSmoothing, outlineThreshold + outlineSmoothing, sobelSample);

                float t = 1.0 - contourThreshold;
                if(positionalLines) {
                    vec3 NDir = position * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float f  = fract(NT * contourFrequency * 0.01);
                    float df = fwidth(NT * contourFrequency);

                    float g = smoothstep(df * (contourWidth * 0.01), df * (contourWidth * 0.01 * 2.0), f);
                    if (g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0;
                    }
                 }
                 else {
                    vec3 NDir = N * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float df = fwidth(NT * contourThreshold);
                    float f = sin(NT * 1.0 * contourFrequency);
                    float g = smoothstep(0.0, df * contourWidth, 1.0 - f);

                    if (df > (t * 0.5) && g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0 - g;
                    }
                 }

                 float lalpha = alpha * resultAlpha;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
                 return result;
             }`,[e])}}();var OR=class extends In{constructor(e,t,n,s,r,i,o,a){super("v3");this.nodeType="Transmission",this.thickness=e,this.ior=t,this.roughness=n,this.transmissionSamplerSize=s,this.transmissionSamplerMap=r,this.transmissionDepthMap=i,this.aspectRatio=o,this.alpha=a,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){if(e.extensions.shaderTextureLOD=!0,e.extensions.derivatives=!0,e.isShader("fragment")){e.define("NUM_SAMPLES",30),e.require("worldPosition"),e.requires.worldNormal=!0,e.requires.modelMatrix=!0,e.requires.projectionMatrix=!0,e.addFragmentVariable(this.calpha,"float");let n=e.include(OR.Nodes.transmission),s=[];return s.push(this.thickness.build(e,"f")),s.push(this.ior.build(e,"f")),s.push(this.roughness.build(e,"f")),s.push(this.transmissionSamplerSize.build(e,"v2")),s.push(this.transmissionSamplerMap.getTexture(e,"t")),s.push(this.transmissionDepthMap.getTexture(e,"t")),s.push(this.aspectRatio.build(e,"v2")),s.push("normal"),s.push(this.alpha.build(e,"f")),s.push(this.calpha),e.format(n+"("+s.join(",")+")",this.getType(e),t)}else return console.warn("TransmissionNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},RR=OR;RR.Nodes=function(){let e=new ft(`
            float gaussian(vec2 i) {
                const float sigma = float(NUM_SAMPLES) * .25;
                return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );
            }`),t=new ft(`
            vec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {
                // Slightly modified version of this:
                // https://www.shadertoy.com/view/ltScRG

                const int LOD = 2;
                const int sLOD = 4; // tile size = 2^LOD

                vec3 O = vec3(0);
                float a = 0.0;
                const int s = NUM_SAMPLES/sLOD;
                for ( int i = 0; i < s*s; i++ ) {
                    int modulo = (i)-((i)/(s))*(s);
                    vec2 d = vec2(float(modulo), float(i/s))*float(sLOD) - float(NUM_SAMPLES)/2.;
                    vec2 uv = U + (scale * aspectRatio) * d;
                    // What is the depth of the opaque object we're trying to sample
                    float opaqueDepth = unpackRGBAToDepth(texture2D(dm, uv));
                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {
                        uv = unrefractedU + ((scale * min(lod / 2., 1.)) * aspectRatio) * d;
                        lod = lod > 4.0 ? lod : lod / 2.0;
                    }
                    float gaussian = gaussian(d);
		            #ifdef TEXTURE_LOD_EXT
                    O += gaussian * texture2DLodEXT( sp, uv, lod).rgb;
                    #else
                    O += gaussian * textureLod( sp, uv, lod).rgb;
                    #endif
                    a += gaussian;
                }
                return O / a;
            }`,[e]),n=new ft(`
            vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		        // Direction of refracted light.
		        vec3 refractionVector = refract( -v,  n, 1.0 / ior );
		        // Compute rotation-independant scaling of the model matrix.
		        vec3 modelScale;
		        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		        // The thickness is specified in local space.
		        return normalize( refractionVector ) * thickness * modelScale;
	        }`),s=new ft(`
float applyIorToRoughness( float roughness, float ior ) {
		// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
		// an IOR of 1.5 results in the default amount of microfacet refraction.
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	} `),r=new ft(`
vec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
        float lod = applyIorToRoughness(roughness, ior);

        return blur(transmissionSamplerMap, fragCoord, vec2(lod / (transmissionSamplerSize.x / 2.)), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);
	}`,[s,t]),i=new ft(`
vec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {
        vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
        vec3 refractedRayExit = position + transmissionRay;

        // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
        vec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );
        vec2 refractionCoords = ndcPos.xy / ndcPos.w;
        refractionCoords += 1.0;
        refractionCoords /= 2.0;

        vec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );
        vec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;
        unrefractedCoords += 1.0;
        unrefractedCoords /= 2.0;

        // Sample framebuffer to get pixel the refracted ray hits.
        return getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );
    }`,[r,n]);return{transmission:new ft(`
            vec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float alpha, out float calpha) {
                vec3 v = vec3(0.);
                if (isOrthographic) {
                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
                } else {
                    v = normalize(vWPosition - cameraPosition);
                }
                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );
                float lalpha = alpha;

                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
                 return transmission;
            }`,[i])}}();var Em=class extends In{constructor(e,t,n,s,r,i,o,a,l,c,h){super("v3");this.nodeType="Depth",this.gradientType=e,this.smooth=t,this.near=n,this.far=s,this.isVector=r,this.isWorldSpace=i,this.origin=o,this.direction=a,this.colors=l,this.steps=c,this.alpha=h,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){let n=`g${this.uuid.toString().replace(/-/g,"")}`,s=new ft(`vec3 ${n}_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[${n}_MAX_COLORS], float steps[${n}_MAX_COLORS], float alpha, out float calpha) {
               vec4 color = colors[0];
               #ifdef ${n}_IS_VECTOR
                   #ifdef ${n}_LINEAR
                       #ifdef ${n}_WORLDSPACE
                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);
                       #else
                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);
                       #endif
                   #else
                       #ifdef ${n}_WORLDSPACE
                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);
                       #else
                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);
                       #endif
                   #endif
               #else
                   float dist = length(vWPosition - cameraPosition);
			       float depth = ( dist - near ) / ( far - near );
               #endif


              float p;
              #ifdef ${n}_SMOOTH
				for ( int i = 1; i < ${n}_MAX_COLORS; i++ ) {
						p = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}
              #else
                for ( int i = 1; i < ${n}_MAX_COLORS; i++ ) {
                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);
                   color = mix(color, colors[i], p);
                 }
              #endif

               float lalpha = alpha * color.a;
               calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );

			   accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
               return color.rgb;
			}`,[Em.Nodes.vectorLinearWorldSpaceDepth,Em.Nodes.vectorLinearObjectSpaceDepth,Em.Nodes.vectorSphericalObjectSpaceDepth,Em.Nodes.vectorSphericalWorldSpaceDepth]);if(e.isShader("fragment")){e.define(`${n}_MAX_COLORS`,this.colors.value.length),this.smooth.value&&e.define(`${n}_SMOOTH`),this.isVector.value>.5&&e.define(`${n}_IS_VECTOR`),this.gradientType.value===0&&e.define(`${n}_LINEAR`),this.isWorldSpace.value>.5&&e.define(`${n}_WORLDSPACE`),e.require("worldPosition"),e.addFragmentVariable(this.calpha,"float");let r=e.include(s),i=[];return i.push(this.near.build(e,"f")),i.push(this.far.build(e,"f")),i.push(this.origin.build(e,"v3")),i.push(this.direction.build(e,"v3")),i.push(this.colors.build(e,"v4[]")),i.push(this.steps.build(e,"f[]")),i.push(this.alpha.build(e,"f")),i.push(this.calpha),e.format(r+"("+i.join(",")+")",this.getType(e),t)}else return console.warn("DepthNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},LR=Em;LR.Nodes=function(){let e=new ft(`float vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`),t=new ft(`float vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(position.x - origin.x) + n.y*(position.y - origin.y) + n.z*(position.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`),n=new ft(`float vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(vWPosition - origin);
               return ( dist - near ) / ( far - near );
            }`),s=new ft(`float vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(position - origin);
               return ( dist - near ) / ( far - near );
            }`);return{vectorLinearWorldSpaceDepth:e,vectorLinearObjectSpaceDepth:t,vectorSphericalWorldSpaceDepth:n,vectorSphericalObjectSpaceDepth:s}}();var FR=class extends In{constructor(e,t,n,s){super("v3");this.nodeType="Blend",this.a=e,this.b=t,this.alpha=n,this.mode=s}generate(e,t){if(e.isShader("fragment")){let n=[];return n.push(this.a.build(e,"c")),n.push(this.b.build(e,"c")),n.push(this.alpha.build(e,"f")),n.push(this.mode.build(e,"i")),e.format("spe_blend("+n.join(",")+")",this.getType(e),t)}else return console.warn("BlendNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},Z2=(e=>(e.NOISE="noise",e.MAP="map",e))(Z2||{}),$R=class extends In{constructor(e,t,n,s,r){super("v3");this.displacementTypeIndex=new En(0),this.nodeType="VertexDisplacement",this.intensity=e,this.movementOrTexture=t,Object.values(Z2)[this.displacementTypeIndex.value]==="map"&&(this.mat=new ER(this.movementOrTexture.value.matrix)),this.cropOrOffset=n,this.scale=s,this.noiseFunctionIndex=r}generate(e,t){if(e.isShader("vertex")){e.define("USE_LAYER_DISPLACE");let n,s=[];switch(s.push("displaced_position"),s.push("displaced_normal"),Object.values(Z2)[this.displacementTypeIndex.value]){case"map":{n=e.include($R.Nodes.map),s.push(this.movementOrTexture.getTexture(e,"t")),s.push("uv"),s.push(this.cropOrOffset.build(e,"f")),this.mat&&s.push(this.mat.build(e,"mat3"));break}case"noise":{let r=Object.values(Q2)[this.noiseFunctionIndex.value],i=new ft(`vec3 orthogonal(vec3 v) {
							return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
						}`),o=new ft(`vec3 distorted(vec3 p, vec3 n, float scale, float intensity, vec3 offset, float neighbour_offset, float movement) {
							return p + n * ${r}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1)) * intensity;
						}`,[to.simplex,to.simplexFractal,to.simplexAshima,to.fbm,to.perlin]),a=new ft(`vec3 vertexDisplacementNoise(vec3 position, vec3 normal, float scale, vec3 offset, float movement, float intensity, out vec3 displaced_normal) {
							vec3 displaced_position = distorted(position, normal, scale, intensity, offset, neighbor_offset, movement);
							vec3 tangent1 = orthogonal(normal);
							vec3 tangent2 = normalize(cross(normal, tangent1));

                            // TODO(Max): The distance to the neighbors was originally scaled by 0.1.
                            // This caused some small oval/circular visual artifacts in the lighting.
                            // For now, simply using neighbors further away betters the problem,
                            // but we should figure out the underlying cause when we have some time.
                            // Maybe its related to how we calculate the tangent and bitangent?
							vec3 nearby1 = position + tangent1;
							vec3 nearby2 = position + tangent2;
							vec3 distorted1 = distorted(nearby1, normal, scale, intensity, offset, neighbor_offset, movement);
							vec3 distorted2 = distorted(nearby2, normal, scale, intensity, offset, neighbor_offset, movement);
							displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
							return displaced_position;
						}`,[o,i]);n=e.include(a),s.push(this.scale.build(e,"f")),s.push(this.cropOrOffset.build(e,"v3")),s.push(this.movementOrTexture.build(e,"f"));break}}return s.push(this.intensity.build(e,"f")),s.push("displaced_normal"),e.format(n+"("+s.join(",")+")",this.getType(e),t)}else return console.warn("VertexDisplacementNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},BR=$R;BR.Nodes=function(){let e=new ft(`vec3 orthogonal(vec3 v) {
				return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
			}`),t=new ft(`float displacementMapTexture(sampler2D tex, float crop, vec2 uv, mat3 mat, vec2 offset) {
				vec2 uvs = (mat * vec3(uv * 2.0 - 1.0, 1.0) / 2.0 + 0.5).xy + offset;
				vec4 tmp = texture2D(tex, uvs);
				vec3 col = tmp.rgb;
				if (crop > 0.5) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						return 0.0;
					}
				}
				return col.r;
			}`);return{map:new ft(`vec3 vertexDisplacementMap(vec3 position, vec3 normal, sampler2D tex, vec2 uv, float crop, mat3 mat, float intensity, out vec3 displaced_normal) {
				vec3 displaced_position = position + normal * displacementMapTexture(tex, crop, uv, mat, vec2(0.0)) * intensity;
				vec3 tangent1 = normalize(orthogonal(normal));
				vec3 tangent2 = normalize(cross(normal, tangent1));
				vec3 nearby1 = position + tangent1 * 0.1;
				vec3 nearby2 = position + tangent2 * 0.1;
				vec3 distorted1 = nearby1 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				vec3 distorted2 = nearby2 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
				return displaced_position;
			}`,[e,t])}}();var zR=class extends In{constructor(e,t,n,s,r,i,o,a){super("v3");this.nodeType="Gradient",this.gradientType=e,this.smooth=t,this.colors=n,this.steps=s,this.offset=r,this.morph=i,this.angle=o,this.alpha=a,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){if(e.isShader("fragment")){e.define("GRAD_MAX",10),e.require("uv"),e.requires.uv=[!0],e.addFragmentVariable(this.calpha,"float");let n=e.include(zR.Nodes.gradient),s=[];return s.push(this.gradientType.build(e,"i")),s.push(this.smooth.build(e,"b")),s.push(this.colors.build(e,"v4[]")),s.push(this.steps.build(e,"f[]")),s.push(this.offset.build(e,"v2")),s.push(this.morph.build(e,"v2")),s.push(this.angle.build(e,"f")),s.push(this.alpha.build(e,"f")),s.push(this.calpha),e.format(n+"("+s.join(",")+")",this.getType(e),t)}else return console.warn("GradientNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},UR=zR;UR.Nodes=function(){return{gradient:new ft(`vec3 gradient(int gradientType, bool smoothed, vec4 colors[GRAD_MAX], float steps[GRAD_MAX], vec2 offset, vec2 morph, float angle, float alpha, out float calpha) {
				vec4 color = colors[0];
				vec2 m = morph / vUv.xy;
				vec2 rot = vec2( 0.5 + m.x, m.y );
				vec2 dt = vec2(
					cos( angle ) * rot.x - sin( angle ) * rot.y,
					sin( angle ) * rot.x + cos( angle ) * rot.y
				);
				vec2 pt = ( vUv - 0.5 + offset ) / 2.0 + dt / 2.0;
				float t = dot( pt, dt ) / dot( dt, dt );
				if ( gradientType == 1 ) {
					t = distance (
						( vUv + morph ) * 3.0,
						( vUv + offset ) + 1.0
					) + angle;
				} else if ( gradientType == 2 ) {
					float polar = atan(
						vUv.x + morph.x - 0.5 + offset.x,
						vUv.y + morph.y - 0.5 + offset.y
					) * -1.0;
					t = fract( ( angle / PI / -2.0 ) + 0.5 * ( polar / PI ) );
				}

				float p;
				if (smoothed) {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}

				} else {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], p);
					}
				}

				float lalpha = alpha * color.a;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

				return color.xyz;
			}`)}}();var ox=class extends In{constructor(e,t,n,s,r,i,o,a,l,c){super("v3");this.nodeType="CustomTexture",this.firstTime=!0,this.texture=e,this.textureSize=t,this.crop=n,this.projection=s,this.axis=r,this.side=i,this.size=o,this.mat=a,this.alpha=l,this.mode=c,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){e.require("position"),e.require("normal"),e.require("uv"),e.requires.uv=[!0],e.extensions.shaderTextureLOD=!0,e.extensions.derivatives=!0;let n=`g${this.uuid.toString().replace(/-/g,"")}`,s;switch(this.projection.value){case 3:s=e.include(ox.Nodes.cylindrical);break;case 2:s=e.include(ox.Nodes.spherical);break;case 1:let i=["vec3(1.0, 0.0, 0.0)","vec3(0.0, 1.0, 0.0)","vec3(0.0, 0.0, 1.0)"][this.axis.value],o=new ft(`
		vec3 ${n}_planarTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( (${n}_vCustomUv * 2. - 1.) / (size * .5), 1. ) / 2. + 0.5 ).xy;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				${this.side.value===2?"":`lalpha *= step(0.0, ${this.side.value===1?"-1.0 * ":""}dot(vObjectNormal, mat * ${i}));`}

				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}`);s=e.include(o);break;default:s=e.include(ox.Nodes.uv);break}if(this.projection.value===1&&this.firstTime){e.addVertexParsCode(`varying vec2 ${n}_vCustomUv;`),e.addFragmentParsCode(`varying vec2 ${n}_vCustomUv;`);let i=["zy","xz","xy"][this.axis.value];e.addVertexFinalCode(`${n}_vCustomUv = (1. + (transformed.${i})) / 2.;`)}e.addFragmentVariable(this.calpha,"float");let r=[];return r.push(this.texture.generate(e,"t")),r.push(this.textureSize.build(e,"v2")),r.push(this.crop.build(e,"f")),r.push(this.mat.build(e,"mat3")),r.push(this.size.build(e,"v2")),r.push(this.alpha.build(e,"f")),r.push(this.mode.build(e,"i")),r.push(this.calpha),this.firstTime=!this.firstTime,e.format(s+"("+r.join(",")+")",this.getType(e),t)}},VR=ox;VR.Nodes=function(){let e=new ft(`
vec3 cylindricalTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(position);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float scaledHeight = position.y / (size.y * 0.5);
                float v =  (scaledHeight / 2.) + .5;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;

				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}
`),t=new ft(`
vec3 sphericalTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {
                vec3 posN = normalize(vPosition);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float v = 0.5 + asin(posN.y) / 3.1415;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;
				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}
`),n=new ft(`vec3 uvTexture(sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float alpha, int mode, out float calpha) {

				vec2 uvs = ( mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;

				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				return col;
			}`);return{cylindrical:e,spherical:t,uv:n}}();var GR=class extends In{constructor(e,t){super("v3");this.nodeType="CustomNormal",this.cnormal=e,this.alpha=t}generate(e,t){if(e.isShader("fragment")){let n=e.include(GR.Nodes.customNormal),s=[];return s.push(this.cnormal.build(e,"v3")),s.push("normal"),s.push(this.alpha.build(e,"f")),e.format(n+"("+s.join(",")+")",this.getType(e),t)}else return console.warn("CustomNormalNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},WR=GR;WR.Nodes=function(){return{customNormal:new ft(`vec3 customNormal(vec3 cnormal, vec3 norm, float alpha) {
				vec3 normal = packNormalToRGB( norm ).rgb;
				normal *= step( vec3(0.5), cnormal );

				accumAlpha += ( 1.0 - accumAlpha ) * alpha;

				return normal;
			}`)}}();function ki(e,t){return t.color(e)}function cle(e,t){switch(e.type){case"fresnel":return dle(e,t);case"gradient":return ple(e);case"depth":return fle(e);case"normal":return mle(e);case"noise":return gle(e,t);case"rainbow":return yle(e);case"toon":return vle(e,t);case"outline":return xle(e,t);case"transmission":return ble(e);case"color":return hle(e,t)}}function ule(e){return{type:e.type}}function Pa(e){let{alpha:t,mode:n}=e;return De(ue({},ule(e)),{alpha:t,mode:n})}function hle(e,t){return De(ue({},Pa(e)),{color:ki(e.color,t)})}function dle(e,t){let{bias:n,scale:s,intensity:r,factor:i,color:o}=e;return De(ue({},Pa(e)),{color:ki(o,t),bias:n,scale:s,intensity:r,factor:i})}function ple(e){let{gradientType:t,smooth:n,colors:s,steps:r,angle:i,offset:o,morph:a}=e;return De(ue({},Pa(e)),{gradientType:t,smooth:n,colors:s.map(l=>new Bt(l[0],l[1],l[2],l[3])),num:s.length,steps:r,offset:new se(...o),morph:new se(...a),angle:i})}function fle(e){let{gradientType:t,near:n,far:s,isVector:r,isWorldSpace:i,origin:o,direction:a,colors:l,steps:c,smooth:h}=e;return De(ue({},Pa(e)),{gradientType:t,near:n,far:s,isVector:r,isWorldSpace:i,origin:new I(...o),direction:a?new I(...a):new I(1,0,0),colors:l.map(u=>u!==void 0?new Bt(u[0],u[1],u[2],u[3]):new Bt(0,0,0,0)),steps:c.slice(0,l.length),smooth:h})}function mle(e){let{cnormal:t}=e;return De(ue({},Pa(e)),{cnormal:new I(t[0],t[1],t[2])})}function gle(e,t){return De(ue({},Pa(e)),{scale:e.scale,move:e.move,fA:new se(...e.fA),fB:new se(...e.fB),size:new I(...e.size),distortion:new se(...e.distortion),colorA:ki(e.colorA,t),colorB:ki(e.colorB,t),colorC:ki(e.colorC,t),colorD:ki(e.colorD,t),noiseType:e.noiseType})}function yle(e){return De(ue({},Pa(e)),{filmThickness:e.filmThickness,movement:e.movement,wavelengths:new I(...e.wavelengths),noiseStrength:e.noiseStrength,noiseScale:e.noiseScale,offset:new I(...e.offset)})}function vle(e,t){return De(ue({},Pa(e)),{positioning:e.positioning,colors:e.colors.map(n=>new Bt(n[0],n[1],n[2],n[3])),num:e.colors.length,steps:e.steps,source:new I(...e.source),isWorldSpace:e.isWorldSpace,noiseStrength:e.noiseStrength,noiseScale:e.noiseScale,shadowColor:ki(e.shadowColor,t),offset:new I(...e.offset)})}function xle(e,t){return De(ue({},Pa(e)),{outlineColor:ki(e.outlineColor,t),contourColor:ki(e.contourColor,t),outlineWidth:e.outlineWidth,contourWidth:e.contourWidth,outlineThreshold:e.outlineThreshold,contourThreshold:e.contourThreshold,outlineSmoothing:e.outlineSmoothing,contourFrequency:e.contourFrequency,contourDirection:new I(...e.contourDirection),positionalLines:e.positionalLines,compensation:e.compensation})}function ble(e,t){return De(ue({},Pa(e)),{thickness:e.thickness,ior:e.ior,roughness:e.roughness})}var ax=class extends Ni{},wle=class{constructor(e=1e3*10){this.timeout=e,this.cache=new Map,this.head={data:null,time:0,src:null,next:null,prev:null},this.tail={data:null,time:1/0,src:null,next:null,prev:null},this.hasClean=!1,this.head.next=this.tail,this.tail.prev=this.head}log(...e){}remove(e){let t=this.cache.get(e);t&&(this.dispose(e,t.data),this.cache.delete(e),t.prev.next=t.next,t.next.prev=t.prev)}scheduleCleanup(){this.hasClean||(this.log("scheduled cleanup"),this.hasClean=!0,setTimeout(()=>{this.hasClean=!1,this.log("cleaning");let e=Date.now(),t=this.head.next;for(;t.time<e-this.timeout;)this.dispose(t.src,t.data),this.cache.delete(t.src),t=t.next,t.prev=this.head,this.head.next=t;this.head.next!==this.tail?this.scheduleCleanup():this.log("no more cleanup")},this.timeout+1e3))}has(e){var t;return(t=this.cache.get(e))==null?void 0:t.data}load(e){let t=Date.now(),n=this.cache.get(e);return n===void 0?(n={data:this.create(e),src:e,time:t,next:null,prev:null},this.cache.set(e,n)):(n.time=t,n.prev.next=n.next,n.next.prev=n.prev),n.prev=this.tail.prev,n.next=this.tail,this.tail.prev.next=n,this.tail.prev=n,this.scheduleCleanup(),n.data}},Sle=class extends wle{create(e){return URL.createObjectURL(new Blob([e]))}dispose(e,t){URL.revokeObjectURL(t)}},J2;function _le(e){return typeof e=="string"?e:(J2||(J2=new Sle),J2.load(e))}var Cle=class{constructor(e,t){this.data=e,this.cache=t,this.refCount=0}deref(){this.refCount,this.refCount-=1,this.refCount===0&&(this.cache.remove(this),this.dispose())}dispose(){this.refCount}},Tle=class{constructor(){this.cache=new Map}remove(e){this.cache.delete(e.data)}load(e){let t=this.cache.get(e);return t===void 0&&(t=this.create(e),this.cache.set(e,t)),t.refCount+=1,t}},HR=class extends Cle{constructor(e,t){super(e,t.imageHolderCache);this.data=e,this.shared=t,this.loaded=!1,this.isVideo=!1,this.isVideo=e.type=="video",this.updateSrc(e.data)}async updateSrc(e){if(typeof document>"u")return;this.disposeTextures(),this.loaded=!1;let t=()=>{this.loaded=!0;let s=[1e3,1001,1002];for(let r of s){let i=this[r];i&&(i.image=this.img,i.needsUpdate=!0)}this.shared.requestRender()};if(this.isVideo){if(this.img=document.createElement("video"),this.img.preload="auto",this.img.playsInline=!0,this.img.currentTime=.01,typeof e!="string"){var n=new FileReader;n.readAsDataURL(new Blob([e],{type:"video/mp4"}));let s;await new Promise(r=>{n.onloadend=i=>{var o;s=(o=i.target)==null?void 0:o.result,r(null)}}),this.img.src=s}else this.img.src=e;this.img.onloadeddata=()=>{t()}}else this.img=new Image,this.img.src=_le(e),this.img.onload=t}getTexture(e){let t=this[e];if(t)return t;{let n;return this.isVideo?n=new TK(this.img,void 0,e,e):n=new mr(this.img,void 0,e,e),this.loaded&&(n.needsUpdate=!0),this[e]=n,n}}disposeTextures(){var e,t,n;(e=this[1e3])==null||e.dispose(),this[1e3]=void 0,(t=this[1001])==null||t.dispose(),this[1001]=void 0,(n=this[1002])==null||n.dispose(),this[1002]=void 0}dispose(){super.dispose(),this.disposeTextures()}},Gu=class extends HR{},eC=class extends Ii{},jR={noise:["noiseType"],texture:["projection","axis","side"],video:["projection","axis","side"],displace:["noiseType"],depth:["smooth","isWorldSpace","gradientType","isVector"]},qR={depth:["colors"]};function Ele(e,t,n){var i,o;let s=jR[e.type],r=qR[e.type];if(r!==void 0){let a=e.color;if(r.includes(t)){let l=(o=(i=a[t])==null?void 0:i.value)==null?void 0:o.length;if(l!==void 0&&l!==n.length)return!0}}return s!==void 0?s.includes(t):!1}function XR(e,t,n){let s=n.uniforms[`f${n.id}_texture`];if(!s)return!1;let r=!1,i=e;if("image"in i){let o=i.image,a=t.image(o),l=s;l.image instanceof Gu||l.image.deref(),l.image=a}if("video"in i){let o=i.video,a=t.video(o),l=s;l.image instanceof Gu||l.image.deref(),l.image=a}if("wrapping"in i){let o=s;o.wrap=i.wrapping}if("repeat"in i||"offset"in i){let o="mat",a=n.uniforms[`f${n.id}_${o}`];"repeat"in i&&(a.repeat=i.repeat),"offset"in i&&(a.offset=i.offset),a.updateMatrix()}return r}function Ale(e,t,n,s){let r=!1;for(let[i,o]of Object.entries(e)){if(!i||o===void 0)continue;if(tL(i,n,s)){i==="visible"&&n.type==="light"&&(r=!0);continue}n.visible=s.visible;let a=n.uniforms[`f${n.id}_${i}`];if(!!a&&!(a instanceof eC))switch(r=r||Ele(n,i,o),a.constructor){case os:if(typeof o=="string"){let l=t.getColor(o);l&&(a.value=l);break}else{let l=o;a.value instanceof ax?a.value=new Ni(l.r,l.g,l.b,l.a):a.setRGBA(l);break}case zu:if(typeof o=="string"){let l=t.getColor(o);l&&(a.value=l);break}else{let l=o;a.value instanceof ax?a.value=new Ni(l.r,l.g,l.b,l.a):a.value.setRGBA(l.r,l.g,l.b,l.a);break}case Ji:{let l=o;a.value.setX(l[0]),a.value.setY(l[1]);break}case eo:{let l=o;a.value.setX(l[0]),a.value.setY(l[1]),a.value.setZ(l[2]);break}case vc:{XR(o,t,n);break}case Vu:{a.value=o.map(l=>new Bt(...l));break}default:{a.value=o;break}}}return r}var KR=class extends In{constructor(e,t,n){super("v3");this.nodeType="Matcap",this.texture=e,this.alpha=t,this.mode=n,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){if(e.isShader("fragment")){e.addFragmentVariable(this.calpha,"float");let n=e.include(KR.Nodes.matcap);e.require("normal"),e.requires.normal=!0;let s=[];return s.push(this.texture.generate(e,"t")),s.push("normal"),s.push(this.alpha.build(e,"f")),s.push(this.mode.build(e,"i")),s.push(this.calpha),e.format(n+"("+s.join(",")+")",this.getType(e),t)}else return console.warn("MatcapNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},YR=KR;YR.Nodes=function(){return{matcap:new ft(`vec3 matcap(sampler2D matcapTex, vec3 normal, float alpha, int mode, out float calpha) {
                vec3 viewDir = normalize( vViewPosition );
                vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
                vec3 y = cross( viewDir, x );
                vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks
                vec4 matcapColor = texture2D( matcapTex, uv );

                calpha =  alpha / clamp( alpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * alpha;
                
                return matcapColor.rgb;
            }
            `)}}();var tC=class extends eC{constructor(e,t){super("t");this.image=e,this.wrap=t}get value(){return this.image.getTexture(this.wrap)}},Ile=class extends eC{constructor(e){super("v3");this.image=e,this._value=new I}get value(){var e,t;return this._value.x=this.image.isVideo?(e=this.image.img.videoWidth)!=null?e:0:this.image.img.width,this._value.y=this.image.isVideo?(t=this.image.img.videoHeight)!=null?t:0:this.image.img.height,this._value}},QR=class extends In{constructor(e,t,n,s,r,i,o,a,l,c){super("v3");this.nodeType="Toon",this.positioning=e,this.colors=t,this.steps=n,this.source=s,this.isWorldSpace=r,this.noiseStrength=i,this.noiseScale=o,this.shadowColor=a,this.offset=l,this.alpha=c,this.calpha=`g${this.uuid.toString().replace(/-/g,"")}_calpha`}generate(e,t){if(e.require("worldNormal"),e.require("worldPosition"),e.isShader("fragment")){e.define("COLORS_MAX",10),e.addFragmentVariable(this.calpha,"float");let n=e.include(QR.Nodes.toon),s=[];return s.push(this.positioning.build(e,"i")),s.push(this.colors.build(e,"v4[]")),s.push(this.steps.build(e,"f[]")),s.push(this.source.build(e,"v3")),s.push(this.isWorldSpace.build(e,"b")),s.push(this.noiseStrength.build(e,"f")),s.push(this.noiseScale.build(e,"f")),s.push(this.shadowColor.build(e,"v4")),s.push(this.offset.build(e,"v3")),s.push(this.alpha.build(e,"f")),s.push(this.calpha),e.format(n+"("+s.join(",")+")",this.getType(e),t)}else return console.warn("ToonNode is not compatible with "+e.shader+" shader."),e.format("vec3( 0.0 )",this.getType(e),t)}},ZR=QR;ZR.Nodes=function(){let e=new ft(`float rand(float n) {
				return fract(sin(n) * 43758.5453123);
			}`),t=new ft(`float hash1(float p) { 
				p = fract(p * 0.011); 
				p *= p + 7.5; 
				p *= p + p; 
				return fract(p); 
			}`),n=new ft(`float valueNoise(vec3 x) {
				const vec3 step = vec3(110, 241, 171);
			
				vec3 i = floor(x);
				vec3 f = fract(x);
			 
				// For performance, compute the base input to a 1D hash from the integer part of the argument and the 
				// incremental change to the 1D based on the 3D -> 1D wrapping
				float n = dot(i, step);
			
				vec3 u = f * f * (3.0 - 2.0 * f);
				return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
						   mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
			}`,[t]),s=new ft(`vec3 hash3(vec3 x) {
				x = vec3(dot(x,vec3(127.1, 311.7, 74.7)),
						 dot(x,vec3(269.5, 183.3, 246.1)),
						 dot(x,vec3(113.5, 271.9, 124.6)));
			
				return fract(sin(x)*43758.5453123);
			}`),r=new ft(`vec3 voronoiNoise(in vec3 x)
			{
				vec3 p = floor(x);
				vec3 f = fract(x);

				float id = 0.0;
				vec2 res = vec2(100.0);

				for(int k=-1; k<=1; k++)
				for(int j=-1; j<=1; j++)
				for(int i=-1; i<=1; i++)
				{
					vec3 b = vec3(float(i), float(j), float(k));

					// Comment out the "+ hash(p + b);" part below to get "square" cells
					vec3 r = vec3(b) - f + hash3(p + b);
					float d = dot(r, r);

					if (d < res.x)
					{
						id = dot(p + b, vec3(1.0, 57.0, 113.0));
						res = vec2(d, res.x);			
					}
					else if (d < res.y)
					{
						res.y = d;
					}
				}

				return vec3(sqrt(res), abs(id));
			}
			`,[s]);return{toon:new ft(`vec3 toon(int positioning, vec4 colors[COLORS_MAX], float steps[COLORS_MAX], vec3 source, bool isWorldSpace, float noiseStrength, float noiseScale, vec4 shadowColor, vec3 offset, float alpha, out float calpha) {
				float t = 0.0;
				float shadow = 1.0;

				if (positioning == 0) {

					// Can't do this mode if lighting is "none"
					#if (defined(PHONG) || defined(LAMBERT) || defined(STANDARD))

						// Algorithm from Chapter 10 of Graphics Shaders
						const vec3 weights = vec3(0.2125, 0.7154, 0.0721);
						vec3 lpos;
						vec3 l;
						float dproduct;

						#if (NUM_POINT_LIGHTS > 0)

							#if defined(USE_SHADOWMAP) && (NUM_POINT_LIGHT_SHADOWS > 0)
								PointLightShadow pointLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_POINT_LIGHTS; i++) {
								// Light positions are in view-space for some reason?
								lpos = (inverse(viewMatrix) * vec4(pointLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								
								// TODO: we want to use "intensity" but it isn't available in the shader code
								//dproduct += dot(pointLights[UNROLLED_LOOP_INDEX].color, weights);

								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS)
									pointLightShadow = pointLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getPointShadow( 
											pointShadowMap[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowMapSize, 
											pointLightShadow.shadowBias, 
											pointLightShadow.shadowRadius,
											vPointShadowCoord[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowCameraNear, 
											pointLightShadow.shadowCameraFar);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_DIR_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_DIR_LIGHT_SHADOWS > 0)
								DirectionalLightShadow directionalLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_DIR_LIGHTS; i++) {
								// Use the direction vector for directional lights instead
								l = (inverse(viewMatrix) * vec4(directionalLights[UNROLLED_LOOP_INDEX].direction, 0.0)).xyz;
		
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS)
									directionalLightShadow = directionalLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow( 
										UNROLLED_LOOP_INDEX,
										directionalShadowMap[UNROLLED_LOOP_INDEX], 
										directionalLightShadow.shadowMapSize, 
										directionalLightShadow.shadowBias, 
										directionalLightShadow.shadowRadius, 
										vDirectionalShadowCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_SPOT_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_SPOT_LIGHT_SHADOWS > 0)
								SpotLightShadow spotLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {
								lpos = (inverse(viewMatrix) * vec4(spotLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS)
									spotLightShadow = spotLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow(
										UNROLLED_LOOP_INDEX,
										spotShadowMap[UNROLLED_LOOP_INDEX], 
										spotLightShadow.shadowMapSize, 
										spotLightShadow.shadowBias, 
										spotLightShadow.shadowRadius, 
										vSpotShadowCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						t = clamp(t, 0.0, 1.0);
				
					#endif

				} else if (positioning == 1) {
					
					vec3 origin = mix(position, worldPosition, float(isWorldSpace));
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	

				} else {

					vec3 origin = worldPosition;
					vec3 source = cameraPosition - offset;
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	
					
				}

				if (noiseStrength > 0.0) {
					// Distort with noise
					vec3 st = position / noiseScale;
					
					// Voronoi "smooth" noise
					float noise = 1.0 - voronoiNoise(st).x;

					// Voronoi cellular noise
					//float noise = 1.0 - rand(voronoiNoise(st).z);

					// Position warp noise
					// vec3 offset = vec3(
					// 	simplex3d(st),
					// 	simplex3d(st + vec3(111.1, 143.89, 217.19)),
					// 	simplex3d(st + vec3(171.1, 247.89, 117.23))
					// );
					// st += offset;
					// float noise = valueNoise(st);

					t += noise * noiseStrength;
				}

				t = clamp(t, 0.0, 1.0);

				// Compute ramp color
				float p;
				vec4 color = colors[0];
				for (int i = 1; i < COLORS_MAX; i++) {
					p = clamp((t - steps[i-1]) / (steps[i] - steps[i-1]), 0.0, 1.0);
					color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
				}

				// Incorporate custom shadow color
				if (positioning == 0) {

					vec3 blendedShadow = mix(color.rgb, shadowColor.rgb, shadowColor.a);
					color.rgb = mix(blendedShadow, color.rgb, shadow);
				
				}

				// Accumulate alpha as usual
				float lalpha = alpha * color.a;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color.xyz;

            }`,[to.simplex,e,n,r])}}();function JR(e,t,n){e.setUvTransform(n[0],n[1],t[0],t[1],0,0,0)}var Nle=class extends ER{constructor(e,t){super(new Or);this.repeat=e,this.offset=t,JR(this.value,e,t)}updateMatrix(){JR(this.value,this.repeat,this.offset)}},Wu=class{constructor(e,t,n,s){this.id=e,this.uuid=t,this.data=n,this.uniforms={};for(let r in s)this.uniforms[`f${this.id}_${r}`]=s[r];for(let r in n)tL(r,this,n)}get type(){return this.data.type}static create(e,t,n,s){var r,i,o,a,l,c,h,u,d,p,f;if(n.type==="light")return np.createLigherLayer(e,t,n,s);if(n.type==="texture"||n.type==="video"){let g=n.type==="texture"?s.image(n.texture.image):s.video(n.texture.video),m=new tC(g,n.texture.wrapping),y=new Ile(g),v=new Nle(n.texture.repeat,n.texture.offset),b=new lt(n.crop?1:0),x=new En((r=n.projection)!=null?r:0),w=new En((i=["x","y","z"].indexOf(n.axis))!=null?i:0),S=new En((o=n.side)!=null?o:0),C=new Ji(n.size?new se(n.size[0],n.size[1]):new se(100,100)),_=new lt((a=n.alpha)!=null?a:1),T=new En((l=n.mode)!=null?l:0),E=new VR(m,y,b,x,w,S,C,v,_,T),A=new Hn(E.calpha,"f");return new or(e,t,n,{texture:m,textureSize:y,crop:b,projection:x,axis:w,side:S,size:C,mat:v,alpha:_,mode:T},E,T,A)}else if(n.type==="matcap"){let g=s.image(n.texture.image),m=new tC(g,n.texture.wrapping),y=new lt((c=n.alpha)!=null?c:1),v=new En((h=n.mode)!=null?h:0),b=new YR(m,y,v),x=new Hn(b.calpha,"f");return new or(e,t,n,{texture:m,alpha:y,mode:v},b,v,x)}else if(n.type==="displace")if(n.displacementType==="noise"){let g=new eo(new I(...n.offset)),m=new lt((u=n.scale)!=null?u:10),y=new lt((d=n.intensity)!=null?d:8),v=new lt((p=n.movement)!=null?p:1),b=new En((f=n.noiseType)!=null?f:0),x=new BR(y,v,g,m,b);return new eL(e,t,n,{offset:g,scale:m,intensity:y,movement:v,noiseType:b},x)}else throw new Error;else return Mle(e,t,n,s)}updateByOp(e,t,n){var r;let s=e;if(s.path[0]===void 0){if(s.type===0)return"type"in s.props||"category"in s.props?((r=n.scene)==null||r.markNeedsUpdateRendererDirty(),!0):Ale(s.props,n.shared,this,t)}else if(s.path[0]==="texture")return"texture"in t||"video"in t?XR(s.props,n.shared,this):!0;return!1}dispose(){if(kle(this)){let e=this.uniforms[`f${this.id}_texture`];if(!e)return!1;let t=e;t.image instanceof Gu||t.image.deref()}}hasValueByKey(e){return this.uniforms[e]!==void 0}hasValue(e){return this.hasValueByKey(`f${this.id}_${e}`)}setValue(e,t){let n=`f${this.id}_${e}`;this.hasValueByKey(n)&&t!==void 0&&(this.uniforms[n].value=t)}getNode(e){let t=`f${this.id}_${e}`;if(this.hasValueByKey(t))return this.uniforms[t]}getValue(e){let t=`f${this.id}_${e}`;if(this.hasValueByKey(t))return this.uniforms[t].value}getName(e){let t=/f\d+_(.*)/.exec(e);if(t&&t.length>1)return t[1];console.log(`Layer.getName: error ${e}`)}getNames(){let e=[];for(let t in this.uniforms){let n=this.getName(t);n&&e.push(n)}return e}},or=class extends Wu{constructor(e,t,n,s,r,i,o){super(e,t,n,s);this.params=s,this.color=r,this.mode=i,this.alpha=o}},eL=class extends Wu{constructor(e,t,n,s,r){super(e,t,n,s);this.position=r}},np=class extends Wu{constructor(e,t,n,s,r){super(e,t,n,r);this.node=s}static createLigherLayer(e,t,n,s){var l,c,h,u,d,p,f,g;let r,i=new lt(n.alpha),o=new En(n.mode),a;if(!n.visible)r=new TR,a={};else if(n.category==="lambert"){r=new ile;let m=new os((l=s.color(n.emissive))!=null?l:0);a={emissive:m},r.emissive=m}else if(n.category==="toon"){r=new lle;let m=new lt((c=n.shininess)!=null?c:30),y=new os((h=s.color(n.specular))!=null?h:1118481);a={shininess:m,specular:y},r.shininess=m,r.specular=y}else if(n.category==="physical"){r=new ale;let m=new lt((u=n.roughness)!=null?u:.3),y=new lt((d=n.metalness)!=null?d:0),v=new lt((p=n.reflectivity)!=null?p:.5);a={roughness:m,metalness:y,reflectivity:v},r.roughness=m,r.metalness=y,r.reflectivity=v}else{r=new ole;let m=new lt((f=n.shininess)!=null?f:30),y=new os(n.specular!==void 0&&(g=s.color(n.specular))!=null?g:1118481);a={shininess:m,specular:y},r.shininess=m,r.specular=y}return r.alpha=new lt(1),r.shadingAlpha=i,r.shadingBlend=o,a.alpha=r.shadingAlpha,a.mode=r.shadingBlend,new np(e,t,n,r,a)}get category(){return this.node.category}};function kle(e){let t=e instanceof Wu?e.type:e;return t==="texture"||t==="video"||t==="displace_map"||t==="matcap"}function Dle(e,t,n,s){var r,i,o,a,l,c,h,u,d,p,f,g,m,y,v,b,x,w,S,C,_,T,E,A,D,O,P,L,B,F,M,U,z,$,R,H,K,Y,X,oe,ie,Z,ce,ge,_e,be,Me,Ie,Le,Ue,$e,We,Rt,ct,j,V,we,Pe,Be,je,pt,Te,ut,He,Xe,te,Ke,qe,Et,it,At,Ge,yt;switch(e.type){case"color":{let nt=new os((r=s.color)!=null?r:5855577),Je=new lt((i=s.alpha)!=null?i:1),mt=new Hn("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )","f");mt.keywords.alpha=Je;let Dt=new En((o=s.mode)!=null?o:0);return nt.alpha=Je,new or(t,n,e,{color:nt,alpha:Je,mode:Dt},nt,Dt,mt)}case"fresnel":{let nt=new os((a=s.color)!=null?a:16777215),Je=new lt((l=s.bias)!=null?l:.1),mt=new lt((c=s.scale)!=null?c:1),Dt=new lt((h=s.intensity)!=null?h:2),rn=new lt((u=s.factor)!=null?u:1),Xn=new lt((d=s.alpha)!=null?d:1),gn=new En((p=s.mode)!=null?p:0),On=new NR(nt,Je,mt,Dt,rn,Xn,gn),Tn=new Hn(On.calpha,"f");return new or(t,n,e,{color:nt,bias:Je,scale:mt,intensity:Dt,factor:rn,alpha:Xn,mode:gn},On,gn,Tn)}case"rainbow":{let nt=new lt((f=s.filmThickness)!=null?f:30),Je=new lt((g=s.movement)!=null?g:0),mt=new eo((m=s.wavelengths)!=null?m:new I(0,0,0)),Dt=new lt((y=s.noiseStrength)!=null?y:0),rn=new lt((v=s.noiseScale)!=null?v:1),Xn=new eo((b=s.offset)!=null?b:new I(0,0,0)),gn=new lt((x=s.alpha)!=null?x:1),On=new DR(nt,Je,mt,Dt,rn,Xn,gn),Tn=new Hn(On.calpha,"f"),Rn=new En((w=s.mode)!=null?w:0);return new or(t,n,e,{filmThickness:nt,movement:Je,wavelengths:mt,noiseStrength:Dt,noiseScale:rn,offset:Xn,alpha:gn,mode:Rn},On,Rn,Tn)}case"transmission":{let nt=new lt((S=s.thickness)!=null?S:10),Je=new lt((C=s.ior)!=null?C:1.5),mt=new lt((_=s.roughness)!=null?_:.5),Dt=Kn.transmissionSize,rn=Kn.transmissionRenderTarget,Xn=Kn.transmissionRenderTargetDepth,gn=window.innerWidth,On=window.innerHeight,Tn=gn>=On?new Ji(On/gn,1):new Ji(1,gn/On),Rn=new lt((T=s.alpha)!=null?T:1),Hs=new RR(nt,Je,mt,Dt,rn,Xn,Tn,Rn),gi=new Hn(Hs.calpha,"f"),Mr=new En((E=s.mode)!=null?E:0);return new or(t,n,e,{thickness:nt,ior:Je,roughness:mt,aspectRatio:Tn,alpha:Rn,mode:Mr},Hs,Mr,gi)}case"toon":{let nt=new En((A=s.positioning)!=null?A:0),Je;s.colors?Je=new Vu(s.colors.length,s.colors):(Je=new Vu(10,new Bt(0,0,0,1)),Je.value[1]=new Bt(1,1,1,1));let mt;s.steps?mt=new Uu(s.steps.length,s.steps):(mt=new Uu(10,1),mt.value[0]=0);let Dt=new eo((D=s.source)!=null?D:new I(0,0,0)),rn=new Tm((O=s.isWorldSpace)!=null?O:!0),Xn=new lt((P=s.noiseStrength)!=null?P:0),gn=new lt((L=s.noiseScale)!=null?L:1),On=new zu(s.shadowColor),Tn=new eo((B=s.offset)!=null?B:new I(0,0,0)),Rn=new lt((F=s.alpha)!=null?F:1),Hs=new ZR(nt,Je,mt,Dt,rn,Xn,gn,On,Tn,Rn),gi=new Hn(Hs.calpha,"f"),Mr=new En((M=s.mode)!=null?M:0);return new or(t,n,e,{positioning:nt,colors:Je,steps:mt,source:Dt,isWorldSpace:rn,noiseStrength:Xn,noiseScale:gn,shadowColor:On,offset:Tn,alpha:Rn,mode:Mr},Hs,Mr,gi)}case"outline":{let nt=new os((U=s.outlineColor)!=null?U:16777215),Je=new os((z=s.contourColor)!=null?z:16777215),mt=new lt(($=s.outlineWidth)!=null?$:.1),Dt=new lt((R=s.contourWidth)!=null?R:.1),rn=new lt((H=s.outlineThreshold)!=null?H:.1),Xn=new lt((K=s.contourThreshold)!=null?K:.1),gn=new lt((Y=s.outlineSmoothing)!=null?Y:.1),On=new lt((X=s.contourFrequency)!=null?X:.1),Tn=new eo((oe=s.contourDirection)!=null?oe:new I(0,1,0)),Rn=new Tm((ie=s.positionalLines)!=null?ie:!1),Hs=new Tm((Z=s.compensation)!=null?Z:!0),gi=Kn.normalRenderTarget,Mr=Kn.normalRenderTargetDepth,q=Kn.pixelRatioNode,ve=Kn.resolution,Ne=new lt((ce=s.alpha)!=null?ce:1),Ce=new PR(nt,Je,mt,Dt,rn,Xn,gn,On,Tn,Rn,Hs,ve,gi,Mr,q,Ne),Re=new Hn(Ce.calpha,"f"),bt=new En((ge=s.mode)!=null?ge:0);return new or(t,n,e,{outlineColor:nt,contourColor:Je,outlineWidth:mt,contourWidth:Dt,outlineThreshold:rn,contourThreshold:Xn,outlineSmoothing:gn,contourFrequency:On,contourDirection:Tn,positionalLines:Rn,compensation:Hs,alpha:Ne,mode:bt},Ce,bt,Re)}case"depth":{let nt=new En((_e=s.gradientType)!=null?_e:0),Je=new Tm((be=s.smooth)!=null?be:!1),mt=new lt((Me=s.near)!=null?Me:50),Dt=new lt((Ie=s.far)!=null?Ie:200),rn=new lt((Le=s.isVector)!=null?Le:1),Xn=new lt((Ue=s.isWorldSpace)!=null?Ue:0),gn=new eo(($e=s.origin)!=null?$e:new I),On=new eo((We=s.direction)!=null?We:new I),Tn;s.colors?Tn=new Vu(s.colors.length,s.colors):(Tn=new Vu(2,new Bt(0,0,0,1)),Tn.value[1]=new Bt(1,1,1,1));let Rn;s.steps?Rn=new Uu(s.steps.length,s.steps):(Rn=new Uu(2,1),Rn.value[0]=0);let Hs=new lt((Rt=s.alpha)!=null?Rt:1),gi=new En((ct=s.mode)!=null?ct:0),Mr=new LR(nt,Je,mt,Dt,rn,Xn,gn,On,Tn,Rn,Hs),q=new Hn(Mr.calpha,"f");return new or(t,n,e,{gradientType:nt,smooth:Je,near:mt,far:Dt,isVector:rn,isWorldSpace:Xn,origin:gn,direction:On,colors:Tn,steps:Rn,alpha:Hs,mode:gi},Mr,gi,q)}case"noise":{let nt=new lt((j=s.scale)!=null?j:1),Je=new eo((V=s.size)!=null?V:new I(100,100,100)),mt=new lt((we=s.move)!=null?we:1),Dt=new Ji((Pe=s.fA)!=null?Pe:new se(1.7,9.2)),rn=new Ji((Be=s.fB)!=null?Be:new se(8.3,2.8)),Xn=new Ji((je=s.distortion)!=null?je:new se(1,1)),gn=new zu(s.colorA),On=new zu(s.colorB),Tn=new zu(s.colorC),Rn=new zu(s.colorD),Hs=new lt((pt=s.alpha)!=null?pt:1),gi=new En((Te=s.mode)!=null?Te:0),Mr=new En((ut=s.noiseType)!=null?ut:0),q=new AR(nt,Je,mt,Dt,rn,Xn,gn,On,Tn,Rn,Hs,Mr),ve=new Hn(q.calpha,"f");return new or(t,n,e,{scale:nt,size:Je,move:mt,fA:Dt,fB:rn,distortion:Xn,colorA:gn,colorB:On,colorC:Tn,colorD:Rn,alpha:Hs,mode:gi,noiseType:Mr},q,gi,ve)}case"normal":{let nt=new eo((He=s.cnormal)!=null?He:new I(1,1,1)),Je=new lt((Xe=s.alpha)!=null?Xe:1),mt=new En((te=s.mode)!=null?te:0),Dt=new WR(nt,Je),rn=new Hn("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )","f");return rn.keywords.alpha=Je,new or(t,n,e,{cnormal:nt,alpha:Je,mode:mt},Dt,mt,rn)}case"gradient":{let nt=new En((Ke=s.gradientType)!=null?Ke:0),Je=new Tm((qe=s.smooth)!=null?qe:!1),mt;s.colors?mt=new Vu(s.colors.length,s.colors):(mt=new Vu(10,new Bt(0,0,0,1)),mt.value[1]=new Bt(1,1,1,1));let Dt;s.steps?Dt=new Uu(s.steps.length,s.steps):(Dt=new Uu(10,1),Dt.value[0]=0);let rn=new Ji((Et=s.offset)!=null?Et:new se(0,0)),Xn=new Ji((it=s.morph)!=null?it:new se(0,0)),gn=new lt((At=s.angle)!=null?At:0),On=new lt((Ge=s.alpha)!=null?Ge:1),Tn=new En((yt=s.mode)!=null?yt:0),Rn=new UR(nt,Je,mt,Dt,rn,Xn,gn,On),Hs=new Hn(Rn.calpha,"f");return new or(t,n,e,{gradientType:nt,smooth:Je,colors:mt,steps:Dt,offset:rn,morph:Xn,angle:gn,alpha:On,mode:Tn},Rn,Tn,Hs)}default:{let nt=new os(1,0,0,1),Je=new lt(1),mt=new Hn("alpha / clamp(alpha + accumAlpha, 0.00001, 1.0 )","f");mt.keywords.alpha=Je;let Dt=new En(0);return nt.alpha=Je,new or(t,n,e,{color:nt,alpha:Je,mode:Dt},nt,Dt,mt)}}}function Mle(e,t,n,s){let r=cle(n,s);return Dle(n,e,t,r)}function tL(e,t,n){if(n.type==="displace"&&(e==="intensity"||e==="visible")){let s=t.uniforms[`f${t.id}_intensity`];return s?(s.value=n.intensity*(n.visible?1:0),s):void 0}if(n.type!=="displace"&&(e==="alpha"||e==="visible")){let s=t.uniforms[`f${t.id}_alpha`];if(!s)return;if(s.value=n.alpha*(n.visible?1:0),n.type==="outline"&&e==="visible"){let r=t.uniforms[`f${t.id}_compensation`];r&&(r.value=n.compensation&&n.visible)}return s}}function nL(e,t){let n=0;for(let s of e.layers)if(s.data.type!=="displace"&&"alpha"in s.data&&s.data.type!=="light"&&s.data.type!=="fresnel"&&s.data.type!=="texture"&&s.data.type!=="matcap"&&s.data.type!=="rainbow"&&s.data.type!=="outline"){let r=s.data.visible?s.data.alpha:0;if(r==1&&s.data.type=="depth"||s.data.type=="gradient"){for(let i of s.data.colors)if(i[3]<1){r=i[3];break}}else if(r==1&&s.data.type=="noise"){let i=t.color(s.data.colorA).a,o=t.color(s.data.colorB).a,a=t.color(s.data.colorC).a,l=t.color(s.data.colorD).a,c=Math.min(i,Math.min(o,Math.min(a,l)));c<1&&(r=c)}n+=(1-n)*r}return n<1}var xc=class extends Ms{constructor(){super(void 0);this.flatShading=!1,this.cacheKey="",this.fog=!0,this.dithering=!0,this.vertexColors=!0,this.transparent=!0}customProgramCacheKey(){return this.cacheKey}},Ple=class extends xc{constructor(e,t,n,s){super();this.flatShading=e,this.side=t,this.wireframe=n,this.root=s}updateAfterBuild(){let e=this.root;this.lights=e.lights,this.vertexShader=e.vertexShader,this.fragmentShader=e.fragmentShader,this.defines=e.defines,this.uniforms=e.uniforms,this.extensions=e.extensions,this.transparent=e.transparent,this.cacheKey=e.customProgramCacheKey()+"flat"+this.flatShading+this.side}onBeforeCompile(e,t){this.root.onBeforeCompile(e)}get data(){return this.root.data}get category(){return this.root.category}getFlavor(e,t,n){return this.root.getFlavor(e,t,n)}get layers(){return this.root.layers}get fragment(){return this.root.fragment}getLayersOfType(e){return this.root.getLayersOfType(e)}getLayerByUuid(e){return this.root.getLayerByUuid(e)}updateByOp(e,t,n){this.root.updateByOp(e,t,n)}nodeMaterialDispose(){this.root.nodeMaterialDispose()}},sL=class extends xc{constructor(e,t){super();this.data=e,this.layerIdGen=0,this.flavors=[],this.type="NodeMaterial",this.updaters=[],this.reset0(e,t)}get nodeMaterial(){return this}getFlavor(e,t,n){let s=n?6:(e?3:0)+t;if(s===0)return this;this.flavors===void 0&&(this.flavors=[]),s-=1;let r=this.flavors[s];return r===void 0&&(r=new Ple(e,t,n,this),this.flavors[s]=r,r.flatShading=e,r.side=t,r.updateAfterBuild()),r}get fragment(){return this.lightLayer.node}get category(){return this.lightLayer.category}reset(e,t){this.data!==e&&this.reset0(e,t)}reset0(e,t){var s,r;this.data=e;let n=(s=e.layers)!=null?s:Ci.defaultTwoLayerData("phong").layers;this.layers=n.map(i=>Wu.create(this.layerIdGen++,i.id,i.data,t.shared)),this.layers.reverse(),this.name=(r=e.name)!=null?r:"Untitled Material",this.onUpdate(),this.transparent=nL(e,t.shared)}getLayersOfType(e){return this.layers.filter(t=>t.type===e)}getLayerByUuid(e){return this.layers.find(t=>t.uuid===e)}onUpdate(){this.cacheKey=this.computeCacheKey(),this.lightLayer=this.layers.find(e=>e instanceof np),this.lightLayer===void 0&&(this.lightLayer=new np(0,"",De(ue({},Qi.defaultData("light","phong")),{visible:!1}),new TR,{})),this.dispose(),this.needsUpdate=!0,this.blendColors(),this.blendAfterColors(),this.blendPositions()}updateByOp(e,t,n){var s,r,i;if(this.data=t,this.transparent=nL(t,n.shared),e.path[0]==="layers"){this.data=t;let o=n.shared,a=e.path[1];if(a===void 0){if(this.layers.reverse(),e.type===4){let l=Wu.create(this.layerIdGen++,e.id,e.data,n.shared);this.layers.splice(e.localIndex,0,l),(s=n.scene)==null||s.markNeedsUpdateRendererDirty()}else if(e.type===5)this.layers.splice(e.localIndex,1)[0].dispose(),(r=n.scene)==null||r.markNeedsUpdateRendererDirty();else if(e.type===6){let l=this.layers.findIndex(h=>h.uuid===e.id),c=this.layers[l];this.layers.splice(l,1),this.layers.splice(e.localIndex,0,c),(i=n.scene)==null||i.markNeedsUpdateRendererDirty()}this.layers.reverse(),this.onUpdate()}else{let l=this.layers.find(c=>c.uuid===a);if(l){let c=t.layers.data(a);if(l.updateByOp(De(ue({},e),{path:e.path.slice(2)}),c,n)){let h=Wu.create(this.layerIdGen++,a,c,o);this.layers.splice(this.layers.findIndex(u=>u.uuid===a),1,h),this.onUpdate()}}}}else this.reset(t,n)}blendColors(){let e=this.layers.findIndex(n=>n instanceof or),t=this.layers.findIndex(n=>n instanceof np);if(e!==-1&&e<t){let n=this.layers[e].color;for(let s=e+1;s<t;++s){let r=this.layers[s];r instanceof or&&(n=new FR(n,r.color,r.alpha,r.mode))}this.fragment.color=n}else this.fragment.color=void 0}blendAfterColors(){let e=new Hn("outgoingLight","f"),t=this.layers.findIndex(n=>n instanceof np);if(this.layers.length>t+1){for(let n=t+1;n<this.layers.length;++n){let s=this.layers[n];s instanceof or&&(e=new FR(e,s.color,s.alpha,s.mode))}this.fragment.afterColor=e}else this.fragment.afterColor=void 0}blendPositions(){let e=this.layers.filter(t=>t instanceof eL);if(e.length>0){let t=e[0].position;for(let n=1;n<e.length;++n)e[n]&&(t=new Da(t,e[n].position,Da.ADD),t=new Da(t,new lt(.5).setReadonly(!0),Da.MUL));this.fragment.position=t}else this.fragment.position=void 0}getDefines(){return this.defines}getUniforms(){return this.uniforms}getVertexShader(){return this.vertexShader}getFragmentShader(){return this.fragmentShader}onBeforeCompile(e){this.build(),e.defines=this.defines,e.uniforms=this.uniforms,e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.extensionDerivatives=this.extensions.derivatives===!0,e.extensionFragDepth=this.extensions.fragDepth===!0,e.extensionDrawBuffers=this.extensions.drawBuffers===!0,e.extensionShaderTextureLOD=this.extensions.shaderTextureLOD===!0}clampUniformsForPreview(e,t){let n=(s,r,i)=>Math.min(Math.max(s,r),i);for(let s of this.layers)if(s.type==="displace"){let r=n(s.uniforms[`f${s.id}_intensity`].value,e,t);s.uniforms[`f${s.id}_intensity`].value=r}}computeCacheKey(){var t,n;let e="[";for(let{data:s}of this.data.layers)if(s.type==="light")e+=`"${s.visible?s.category.toUpperCase():"Basic"}"`;else{let r=((t=jR[s.type])!=null?t:[]).map(a=>s[a]),i=((n=qR[s.type])!=null?n:[]).map(a=>{var l,c;return(c=(l=s[a])==null?void 0:l.length)!=null?c:0}),o=[...r,...i];o.length?e+=`["${s.type}", "${o.join('","')}"],`:e+=`"${s.type}",`}return e=e.slice(0,-1)+"]",e}updateFrame(e){for(let t=0;t<this.updaters.length;++t)e.updateNode(this.updaters[t])}build(){let e=new rle;this.lights=this.lightLayer.data.visible,e.build(this.fragment,this.fragment),this.vertexShader=e.getCode("vertex"),this.fragmentShader=e.getCode("fragment"),this.defines=e.defines,this.uniforms=e.uniforms,this.extensions=e.extensions,this.updaters=e.updaters;for(let t of this.flavors)t&&t.updateAfterBuild();return this}nodeMaterialDispose(){this.layers.forEach(e=>e.dispose()),super.dispose();for(let e of this.flavors)e&&e.dispose()}assetsLoaded(){for(let e of this.layers)if(e instanceof or){let t=e.params.texture;if(t instanceof tC&&!t.image.loaded)return!1}return!0}getHash(){let e="{";return e+='"fragment":'+this.fragment.getHash(),e+="}",e}};Object.defineProperties(xc.prototype,{properties:{get:function(){return this.fragment.properties}}});var nC=class extends sL{},Ole=J0(v6()),rL=new Map;function Rle(e){if(typeof e=="string")return e;let t=rL.get(e);return t||(t={url:URL.createObjectURL(new Blob([e]))},rL.set(e,t)),t.url}var Am=class{constructor({src:e,volume:t,delay:n,loop:s}){this._volume=1,this.delay=0,this._loop=1,this.loopsRemaining=0,this._status="stopped",this.onEnd=()=>{this.loopsRemaining===1/0?this.replay():this.loopsRemaining>1?(this.replay(),this.loopsRemaining--):(this._status="stopped",this.loopsRemaining=this._loop)};let r;typeof e=="string"?r={src:e}:r={src:Rle(e),format:"wav"},this.sound=new Ole.Howl(r),this.sound.on("end",this.onEnd),this.src=e,t!==void 0&&(this.volume=t),n!==void 0&&(this.delay=n),s!==void 0&&(this.loop=s)}get status(){return this._status}get volume(){return this._volume}set volume(e){this._volume=e,this.sound.volume(e)}get loop(){return this._loop}set loop(e){this._loop=e,this.loopsRemaining=e}replay(){this.clearDelay(),this.delayTimerId=window.setTimeout(()=>{this.sound.play(),this.clearDelay()},this.delay)}fade(e,t=1e3){e?(this.sound.volume(this._volume),this.clearFade(),this.fadeTimerId=window.setTimeout(()=>{this.sound.fade(this._volume,0,t),this.clearFade()},e)):this.sound.fade(this._volume,0,t)}on(e,t,n){this.sound.on(e,t,n)}off(e,t,n){this.sound.off(e,t,n)}play(){this._status==="playing"||this.sound.playing()||(this._status==="paused"?(this.sound.seek()===0?this.replay():this.sound.play(),this._status="playing"):this._status==="stopped"&&(this.replay(),this._status="playing"))}pause(){this._status==="playing"&&(this.sound.pause(),this.clearFade(),this.clearDelay(),this._status="paused")}stop(){this.sound.stop(),this.loopsRemaining=this._loop,this.clearFade(),this.clearDelay(),this._status="stopped"}clearFade(){this.fadeTimerId&&(clearTimeout(this.fadeTimerId),delete this.fadeTimerId)}clearDelay(){this.delayTimerId&&(clearTimeout(this.delayTimerId),delete this.delayTimerId)}dispose(e=!1){this.off(),this.stop(),this.clearFade(),this.clearDelay()}},Lle=class{constructor(){this.type="ShapePath",this.color=new _t,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new My,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){var n;return(n=this.currentPath)==null||n.lineTo(e,t),this}quadraticCurveTo(e,t,n,s){var r;return(r=this.currentPath)==null||r.quadraticCurveTo(e,t,n,s),this}bezierCurveTo(e,t,n,s,r,i){var o;return(o=this.currentPath)==null||o.bezierCurveTo(e,t,n,s,r,i),this}splineThru(e){var t;return(t=this.currentPath)==null||t.splineThru(e),this}toShapes(){let e={ORIGIN:0,DESTINATION:1,BETWEEN:2,LEFT:3,RIGHT:4,BEHIND:5,BEYOND:6},t={loc:e.ORIGIN,t:0};function n(p,f,g,m){let y=p.x,v=f.x,b=g.x,x=m.x,w=p.y,S=f.y,C=g.y,_=m.y,T=(x-b)*(w-C)-(_-C)*(y-b),E=(v-y)*(w-C)-(S-w)*(y-b),A=(_-C)*(v-y)-(x-b)*(S-w),D=T/A,O=E/A;if(A===0&&T!==0||D<=0||D>=1||O<0||O>1)return null;if(T===0&&A===0){for(let P=0;P<2;P++)if(s(P===0?g:m,p,f),t.loc===e.ORIGIN){let L=P===0?g:m;return{x:L.x,y:L.y,t:t.t}}else if(t.loc===e.BETWEEN){let L=+(y+t.t*(v-y)).toPrecision(10),B=+(w+t.t*(S-w)).toPrecision(10);return{x:L,y:B,t:t.t}}return null}else{for(let B=0;B<2;B++)if(s(B===0?g:m,p,f),t.loc===e.ORIGIN){let F=B===0?g:m;return{x:F.x,y:F.y,t:t.t}}let P=+(y+D*(v-y)).toPrecision(10),L=+(w+D*(S-w)).toPrecision(10);return{x:P,y:L,t:D}}}function s(p,f,g){let m=g.x-f.x,y=g.y-f.y,v=p.x-f.x,b=p.y-f.y,x=m*b-v*y;if(p.x===f.x&&p.y===f.y){t.loc=e.ORIGIN,t.t=0;return}if(p.x===g.x&&p.y===g.y){t.loc=e.DESTINATION,t.t=1;return}if(x<-Number.EPSILON){t.loc=e.LEFT;return}if(x>Number.EPSILON){t.loc=e.RIGHT;return}if(m*v<0||y*b<0){t.loc=e.BEHIND;return}if(Math.sqrt(m*m+y*y)<Math.sqrt(v*v+b*b)){t.loc=e.BEYOND;return}let w;m!==0?w=v/m:w=b/y,t.loc=e.BETWEEN,t.t=w}function r(p,f){let g=[],m=[];for(let y=1;y<p.length;y++){let v=p[y-1],b=p[y];for(let x=1;x<f.length;x++){let w=f[x-1],S=f[x],C=n(v,b,w,S);C!==null&&g.find(_=>_.t<=C.t+Number.EPSILON&&_.t>=C.t-Number.EPSILON)===void 0&&(g.push(C),m.push(new se(C.x,C.y)))}}return m}function i(p,f,g){let m=new se;f.getCenter(m);let y=[];return g.forEach(v=>{v.boundingBox.containsPoint(m)&&r(p,v.points).forEach(b=>{y.push({identifier:v.identifier,isCW:v.isCW,point:b})})}),y.sort((v,b)=>v.point.x-b.point.x),y}function o(p,f,g,m,y){(y==null||y==="")&&(y="nonzero");let v=new se;p.boundingBox.getCenter(v);let b=[new se(g,v.y),new se(m,v.y)],x=i(b,p.boundingBox,f);x.sort((E,A)=>E.point.x-A.point.x);let w=[],S=[];x.forEach(E=>{E.identifier===p.identifier?w.push(E):S.push(E)});let C=w[0].point.x,_=[],T=0;for(;T<S.length&&S[T].point.x<C;)_.length>0&&_[_.length-1]===S[T].identifier?_.pop():_.push(S[T].identifier),T++;if(_.push(p.identifier),y==="evenodd"){let E=_.length%2==0,A=_[_.length-2];return{identifier:p.identifier,isHole:E,for:A}}else if(y==="nonzero"){let E=!0,A=null,D=null;for(let O=0;O<_.length;O++){let P=_[O];f[P]&&(E?(D=f[P].isCW,E=!1,A=P):D!==f[P].isCW&&(D=f[P].isCW,E=!0))}return{identifier:p.identifier,isHole:E,for:A}}else console.warn('fill-rule: "'+y+'" is currently not implemented.')}let a=0,l=999999999,c=-999999999,h=[];this.subPaths.forEach(p=>{let f=p.getPoints(),g=-999999999,m=999999999,y=-999999999,v=999999999;for(let b=0;b<f.length;b++){let x=f[b];x.y>g&&(g=x.y),x.y<m&&(m=x.y),x.x>y&&(y=x.x),x.x<v&&(v=x.x)}c<=y&&(c=y+1),l>=v&&(l=v-1),f.length&&h.push({curves:p.curves,points:f,isCW:cM.isClockWise(f),identifier:a++,boundingBox:new pY(new se(v,m),new se(y,g))})});let u=h.map(p=>{var f;return o(p,h,l,c,(f=this.userData)==null?void 0:f.style.fillRule)}),d=[];return h.forEach(p=>{let f=u[p.identifier];if(f&&!f.isHole){let g=new Py;g.curves=p.curves,u.filter(m=>(m==null?void 0:m.isHole)&&m.for===p.identifier).forEach(m=>{if(m){let y=h[m.identifier],v=new My;v.curves=y.curves,g.holes.push(v)}}),d.push(g)}}),d}},iL,oL=new Promise(e=>{iL=e}),aL=!1;async function Fle(){if(aL)return;let e=await import("./opentype.84f4b5e1.js");iL(e),aL=!0}var $le=class{async load(e,t,n=()=>{}){let{load:s}=await oL;s(e,(r,i)=>{r||!i?n(r!=null?r:"Something went wrong"):t(i)})}async parse(e){let{parse:t,Bidi:n}=await oL;try{let s=t(e),r=new n,i=o=>s.charToGlyphIndex(o.char);return r.registerModifier("glyphIndex",null,i),r.applyFeatures(s,s.defaultRenderOptions.features),{font:s,bidi:r}}catch(s){console.error(s)}}};async function Ble(e){return await(await fetch(e)).arrayBuffer()}var zle=new $le;async function lL(e){let t,n,s=!1;if(e.url?(t=await Ble(e.url),n=e.url,s=e.url.startsWith("/")):e.data&&(t=e.data.buffer),t){let r=await zle.parse(t);if(r)return{font:r.font,url:n,intercepted:s,arr:t,bidi:r.bidi}}}function Ule(e,t){return t.state.glyphIndex===e||t.state.fina===e||t.state.medi===e||t.state.init===e}var Vle=class{constructor(e){var t;this._arrayBuffer=new ArrayBuffer(1),this._isLoaded=!1,this._intercepted=!1,this._isUserFont=(t=e.isUserFont)!=null?t:!1,this._loadingPromise=lL(e).then(n=>{n&&(this._arrayBuffer=n.arr,this._url=n.url,this.font=n.font,this._intercepted=n.intercepted,this._isLoaded=!0,this._bidi=n.bidi)})}update(e){var t;this._isLoaded=!1,this._isUserFont=(t=e.isUserFont)!=null?t:!1,this._loadingPromise=lL(e).then(n=>{n&&(this._arrayBuffer=n.arr,this._url=n.url,this.font=n.font,this._intercepted=n.intercepted,this._isLoaded=!0,this._bidi=n.bidi)})}get url(){return this._url}get intercepted(){return this._intercepted}get isLoaded(){return this._isLoaded}get loadingPromise(){return this._loadingPromise}reverseLigaturesTable(e,t,n){if(!this._bidi)return[];let s=this._bidi;s.getTextGlyphs(t);let r=s.tokenizer.tokens,i=[],o=0,a=n.length===r.length;for(let l=0;l<n.length;l++){let c=n[l].index,h=String.fromCharCode(n[l].unicode),u=r[o];if(Ule(c,u)||a)i.push({char:h,index:c,replacements:[u.state.glyphIndex],replacementChars:[u.char]}),o++;else{let d=u.char,p="",f=[u.state.glyphIndex],g=[],m=!1;for(;!m;)o++,p=t.charAt(o),d+=p,f.push(e.charToGlyphIndex(p)),g=e.stringToGlyphs(d),g.length===1&&g[0].index===c&&(m=!0),o>t.length&&(m=!0);i.push({char:h,index:c,replacements:f,replacementChars:Array.from(d)}),o++}}return i}generateShapes(e,t){if(!this._isLoaded)return;let n=this.font,s=t.fontSize/this.unitsPerEm,r=t.fontSize*t.lineHeight,i=e.map(y=>this.getTextWidth(y,t)),o=t.width,a=this.getCharWidth(`
`,t),l=t.horizontalAlign===1?a:0,c=this.computeSpaceWidthForLine(e,0,t),h=this.getLineInitialOffsetX(i[0],o,t.horizontalAlign,e[0],a),u=this.getLineInitialOffsetY(r,e.length,t.height,s,t.verticalAlign),d=[],p=e.map(y=>[]),f=e.map(y=>[]),g;for(let y=0;y<e.length;y++){let v=e[y],b={features:{liga:!0}},x=[];try{x=n.stringToGlyphs(v,b)}catch(S){console.warn(S)}h=this.getLineInitialOffsetX(i[y],o,t.horizontalAlign,v,a);let w=[];try{w=this.reverseLigaturesTable(n,v,x)}catch(S){console.warn(S)}c=this.computeSpaceWidthForLine(e,y,t);for(let S=0;S<x.length;S++){let C=x[S],_=C.index===0?`
`:C.unicode?String.fromCharCode(C.unicode):void 0,T=w[S],E=0,A=0;S===0&&t.horizontalAlign===2&&C.leftSideBearing!==void 0&&(A=-C.leftSideBearing*s),g&&(E=n.getKerningValue(C,g)*s),h+=A+E;let D=0;if(_===`
`)D=l;else if(_===" ")D=c;else{let O=this.createPath(C,s,h,u,t);O&&(D=O.offsetX-(E+A),d.push(O.path))}if(T.replacements.length===1)f[y].push([h,u]),p[y].push(D);else{let O=T.replacements.map(F=>{var M;return((M=n.glyphs.get(F).advanceWidth)!=null?M:0)*s}),P=O.reduce((F,M)=>F+=M,0),L=O.map(F=>F/P),B=h;for(let F=0;F<L.length;F++){let M=D*L[F];f[y].push([B,u]),p[y].push(M),B+=M}}h+=D,g=C}u-=r}let m=[];for(let y=0,v=d.length;y<v;y++)m.push(...d[y].toShapes());return{shapes:m,charWidths:p,lineWidths:i,charCoords:f}}get isUserFont(){return this._isUserFont}get arrayBuffer(){return this._arrayBuffer}get ascender(){var e,t;return(t=(e=this.font)==null?void 0:e.ascender)!=null?t:0}get descender(){var e,t;return(t=(e=this.font)==null?void 0:e.descender)!=null?t:0}get familyName(){var e,t;return(t=(e=this.font)==null?void 0:e.names.fontFamily)!=null?t:""}get subfamilyName(){var e,t;return(t=(e=this.font)==null?void 0:e.names.fontSubfamily)!=null?t:""}get unitsPerEm(){var e,t;return(t=(e=this.font)==null?void 0:e.unitsPerEm)!=null?t:1}getLineInitialOffsetX(e,t,n,s,r){return(n===3||n===2)&&s.indexOf(`
`)>=0&&(e-=r),n===3?t*.5-e*.5:n===2?t-e:0}getLineInitialOffsetY(e,t,n,s,r){let i=t*e,o=Math.abs(this.ascender-this.descender)*s,a=e-o,l=-this.ascender*s-a/2;return r===3?-(n-i-l):r===2?-(n*.5-i*.5-l):l}createPath(e,t,n,s,r){var l,c;let i=e.getPath(n,-s,r.fontSize,{kerning:!1,letterSpacing:r.letterSpacing});if(!i){console.error('THREE.Font: character "'+e+'" does not exists in font family '+this.familyName+".");return}let o=new Lle,a=((l=e.advanceWidth)!=null?l:1)*t;if(e)for(let h of i.commands){let u=(c=o.currentPath)==null?void 0:c.currentPoint;if(!(u&&h.type!=="Z"&&u.x===h.x&&-u.y===h.y))switch(h.type){case"M":o.moveTo(h.x,-h.y);break;case"L":o.lineTo(h.x,-h.y);break;case"Q":o.quadraticCurveTo(h.x1,-h.y1,h.x,-h.y);break;case"C":o.bezierCurveTo(h.x1,-h.y1,h.x2,-h.y2,h.x,-h.y);break}}return o.subPaths.forEach(h=>{let u=Gle(h.curves);u!==void 0&&h.currentPoint.distanceTo(u)>0&&h.lineTo(u.x,u.y)}),{offsetX:a+r.fontSize*r.letterSpacing,path:o}}getCharWidth(e,t){var n,s;return(s=(n=this.font)==null?void 0:n.getAdvanceWidth(e,t.fontSize,{kerning:!0,letterSpacing:t.letterSpacing}))!=null?s:0}getTextWidth(e,t){var n,s;return(s=(n=this.font)==null?void 0:n.getAdvanceWidth(e,t.fontSize,{kerning:!0,letterSpacing:t.letterSpacing}))!=null?s:0}computeSpaceWidthForLine(e,t,n){let s=this.getCharWidth(" ",n),r=e[t];if(r){let i=this.countSpaces(r.trimEnd());if(n.horizontalAlign===4&&t<e.length-1&&i){let o=n.width,a=this.getTextWidth(r,n);return(o-(a-i*s))/i}}return s}countSpaces(e){return(e.match(/ /g)||[]).length}};function Gle(e){if(e.length){let t=e[0];if(t instanceof Po)return t.v1;if(t instanceof Mo||t instanceof sc)return t.v0}}var Wle=class{constructor(){this.objects=new Map,this.unreachable=new Set}getCached(e){return this.objects.get(e)}get size(){return this.objects.size}get(e,t){let n=this.objects.get(e);return n===void 0?(n=this.createObject(e,t),this.objects.set(e,n)):n.isShared=!0,n}mutateIfUnique(e,t){let n=this.objects.get(e);if(n&&n.isShared!==!0)return this.objects.delete(e),this.objects.set(t,n),n}startGc(){this.unreachable=new Set(this.objects.keys())}markAsReachable(e,t){let n=this.objects.get(e);t===n&&this.unreachable.delete(e)}endGc(){this.unreachable.forEach(e=>{this.disposeObject(this.objects.get(e)),this.objects.delete(e)}),this.unreachable.clear()}dispose(){this.objects.forEach(e=>{this.disposeObject(e)}),this.objects.clear()}},cL=class extends Wle{constructor(e){super();this.flatShading=e}disposeObject(e){e.dispose()}createObject(e,t){let n=nx(e,t,this.flatShading);return n.computeBoundingSphere(),n}},Hle={find(e){},markNeedsUpdateRendererDirty:function(){},markGeometryCacheDirty:function(){},addPendingExpandCloner:function(e){},addPendingUpdateCloner(e){}},jle=class extends Tle{constructor(e){super();this.shared=e}create(e){return new HR(e,this.shared)}},lx=class{constructor(e,t={}){if(this.geometryCache=new cL(!0),this.geometryCache2=new cL(!1),this.imageHolderCache=new jle(this),this.thisContext={scene:Hle,shared:this},this.deletedMaterial=new nC(Ci.defaultTwoLayerData("phong"),this.thisContext),this.deletedImage=new Gu(d2.emptyImage,this),this.deletedVideo=new Gu(bv.defaultVideo,this),this.materials={},this.images={},this.videos={},this.colors={},this.audios={},this.fonts={},this.penumbraSize=[],this.requestRender=()=>{this._requestRender&&this._requestRender()},t.images)for(let[n,s]of Object.entries(t.images))this.addImage(n,s);if(t.videos)for(let[n,s]of Object.entries(t.videos))this.addVideo(n,s);if(t.audios)for(let[n,s]of Object.entries(t.audios))this.addAudio(n,s.data);this.reset(e)}setRequestRender(e){this._requestRender=e}reset(e){for(let[t,n]of Object.entries(e.images))this.addImage(t,n);for(let[t,n]of Object.entries(e.videos))this.addVideo(t,n);for(let[t,n]of Object.entries(e.colors))this.addColor(t,n);for(let[t,n]of Object.entries(e.materials))this.addMaterial(t,new nC(n,this.thisContext));for(let[t,n]of Object.entries(e.audios))this.addAudio(t,n.data);for(let[t,n]of Object.entries(e.fonts))this.addFont(t,n);this.penumbraSize=e.penumbraSize}addMaterial(e,t){t.uuid=e,this.materials[e]=t}deleteMaterial(e){this.materials[e]&&(this.materials[e].nodeMaterialDispose(),delete this.materials[e])}getMaterial(e){return this.materials[e]}getMaterialOrDeletedPlaceholder(e){var t;return(t=this.materials[e])!=null?t:this.deletedMaterial}material(e){return typeof e=="string"?this.getMaterialOrDeletedPlaceholder(e):new sL(e,this.thisContext)}getMaterials(){return this.materials}addImage(e,t){return this.images[e]?(this.onColorOrImageUpdate&&this.onColorOrImageUpdate(),this.images[e].updateSrc(t.data),!0):(this.images[e]=new Gu(t,this),!1)}deleteImage(e){let t=this.images[e];t&&(t.dispose(),delete this.images[e])}getDefaultImage(){return this.images.image_0}getImage(e){var t;return(t=this.images[e])!=null?t:this.deletedImage}image(e){return typeof e=="string"?this.getImage(e):this.imageHolderCache.load(e)}addVideo(e,t){return this.videos[e]?(this.videos[e].updateSrc(t.data),!0):(this.videos[e]=new Gu(t,this),!1)}deleteVideo(e){let t=this.videos[e];t&&(t.dispose(),delete this.videos[e])}getVideo(e){var t;return(t=this.videos[e])!=null?t:this.deletedVideo}video(e){return typeof e=="string"?this.getVideo(e):this.imageHolderCache.load(e)}addColor(e,t){return this.colors[e]?(this.onColorOrImageUpdate&&this.onColorOrImageUpdate(),"a"in t?this.colors[e].setRGBA(t.r,t.g,t.b,t.a):this.colors[e].setRGBA(t.r,t.g,t.b,1),!0):("a"in t?this.colors[e]=new ax(t.r,t.g,t.b,t.a):this.colors[e]=new ax(t.r,t.g,t.b,1),!1)}updateColor(e,t){var n,s,r,i;if(this.colors[e]){this.onColorOrImageUpdate&&this.onColorOrImageUpdate();let o=this.colors[e];return this.colors[e].r=(n=t.r)!=null?n:o.r,this.colors[e].g=(s=t.g)!=null?s:o.g,this.colors[e].b=(r=t.b)!=null?r:o.b,this.colors[e].a=(i=t.a)!=null?i:o.a,!0}return!1}deleteColor(e){this.colors[e]&&delete this.colors[e]}getColor(e){return this.colors[e]}color(e){let t;if(typeof e=="string"){let n=this.getColor(e);n?t=n:(console.warn("Tried to create color layer params with a color key that does not exist in the assets manager"),t=new Ni(0,0,0,0))}else return"a"in e?new Ni(e.r,e.g,e.b,e.a):new Ni(e.r,e.g,e.b,1);return t}addAudio(e,t){this.audios[e]=t}getAudio(e){let t=this.audios[e];if(t instanceof Am)return t;{let n=new Am({src:t});return this.audios[e]=n,n}}deleteAudio(e){let t=this.audios[e];t&&(t instanceof Am&&t.dispose(),delete this.audios[e])}addFont(e,t){this.fonts[e]=new Vle(t),this.fonts[e].loadingPromise.then(()=>this.requestRender())}getFont(e){return this.fonts[e]}deleteFont(e){this.fonts[e]&&delete this.fonts[e]}dispose(){Object.keys(this.materials).forEach(e=>this.deleteMaterial(e)),this._requestRender=void 0,Object.values(this.audios).forEach(e=>{e instanceof Am&&e.dispose()}),this.audios={},this.geometryCache.dispose(),this.geometryCache2.dispose()}};new lx(Ov.emptyData());var cx=class extends Ai{updateByPatchedOp(e,t,n){if(super.updateByPatchedOp(e,t,n),Gre(e.path,["materials"])!==null&&e.type===0&&Array.isArray(this.material))for(let[s,r]of Object.entries(e.props)){let i=n.shared.material(r);this.material[Number(s)]=i}else if(Nu(e.path,["material"])&&this.material instanceof xc)"material"in t&&typeof t.material!="string"&&this.material.updateByOp(wi.drop(e,1),t.material,n);else if(Nu(e.path,["materials","*"])&&Array.isArray(this.material)){let s=e.path[1];if("materials"in t&&s<this.material.length){let r=t.materials[s];typeof r!="string"&&this.material[s].updateByOp(wi.drop(e,2),r,n)}}}updateState(e,t){var s,r,i,o,a;super.updateState(e,t),e.castShadow!==void 0&&(this.castShadow=e.castShadow),e.receiveShadow!==void 0&&(this.receiveShadow=e.receiveShadow);let n=this.dataPatched;if(((s=e.geometry)==null?void 0:s.type)!=="NonParametricGeometry"&&"material"in e&&e.material!==void 0&&(this.disposeMaterial(),this.material=t.shared.material(e.material).getFlavor(n.flatShading,n.side,n.wireframe),(r=t.scene)==null||r.markNeedsUpdateRendererDirty()),((i=e.geometry)==null?void 0:i.type)==="NonParametricGeometry"&&("materials"in e&&e.materials!==void 0?(this.disposeMaterial(),this.material=e.materials.map(l=>t.shared.material(l).getFlavor(n.flatShading,n.side,n.wireframe)),(o=t.scene)==null||o.markNeedsUpdateRendererDirty()):"material"in e&&e.material!==void 0&&(this.disposeMaterial(),this.material=[t.shared.material(e.material).getFlavor(n.flatShading,n.side,n.wireframe)],(a=t.scene)==null||a.markNeedsUpdateRendererDirty())),e.flatShading!==void 0||e.wireframe!==void 0||e.side!==void 0)if(Array.isArray(this.material))for(let l=0;l<this.material.length;l++)this.material[l]=this.material[l].getFlavor(n.flatShading,n.side,n.wireframe);else this.material=this.material.getFlavor(n.flatShading,n.side,n.wireframe)}disposeMaterial(){this.material&&ZP(this.material).forEach(e=>{e instanceof xc&&(e instanceof nC||e.nodeMaterialDispose())})}dispose(){this.disposeMaterial(),super.dispose()}},$o=class extends cx{constructor(e,t,n){super(e,t);this.data=t,this.localGeometry=void 0}chooseGeoemtryCache(e){return e.geometryCache}markGeometryAsReachable(e){this.geometryCreateDeleyed instanceof It&&this.chooseGeoemtryCache(e).markAsReachable(this.dataPatched.geometry,this.geometryCreateDeleyed)}get geometry(){if(this.localGeometry!==void 0)return this.localGeometry;if(this.geometryCreateDeleyed instanceof lx){let e=this.geometryCreateDeleyed,t=this.chooseGeoemtryCache(e);this.geometryCreateDeleyed=t.get(this.dataPatched.geometry,e)}return this.geometryCreateDeleyed}set geometry(e){this.localGeometry=e}get is2DAndNoDepth(){let e=this.dataPatched.geometry;return Sv.is2DParametricMesh(e.type)&&e.depth===0}get is2DType(){return Sv.is2DParametricMesh(this.geometry.userData.type)}updateByPatchedOp(e,t,n){super.updateByPatchedOp(e,t,n),Nu(e.path,["geometry"])&&this.updateByPatchedOpGeometry(wi.drop(e,1),t.geometry,n)}removeInteractionGeometry(){var e;(e=this.localGeometry)==null||e.dispose(),this.localGeometry=void 0}updateGeometryInteractions(e,t){var s;this.invalidateDownstreamBooleanData();let n=this.data.geometry.type;if(n==="NonParametricGeometry"||n==="SubdivGeometry"){let r=e;if(this.localGeometry===void 0){let c=ue(ue({},this.data.geometry),r);this.localGeometry=nx(c,t,this.data.flatShading)}let i,o,a;r.scaleBaked?[i,o,a]=r.scaleBaked:{width:i,height:o,depth:a}=r;let l=this.localGeometry.userData;l.sxPrev!==void 0&&W2(this.localGeometry.attributes,i/l.sxPrev,o/l.syPrev,a/l.szPrev),l.sxPrev=i,l.syPrev=o,l.szPrev=a}else{let r=ue(ue({},this.data.geometry),e);(s=this.localGeometry)==null||s.dispose(),this.localGeometry=nx(r,t,this.data.flatShading)}}refreshAttachedCloners(e){for(let t of this.attachedSurfaceCloners)e.scene.addPendingUpdateCloner(t.object)}createGeometryDelayed(e){this.geometryCreateDeleyed=e.shared,this.refreshAttachedCloners(e)}updateByPatchedOpGeometry(e,t,n){var r;let s=!1;e.type===0&&e.path.length===0&&A_(["scaleBaked"],Object.keys(e.props))&&this.geometryCreateDeleyed instanceof zr&&this.chooseGeoemtryCache(n.shared).mutateIfUnique(this.geometryCreateDeleyed.data,t)===this.geometryCreateDeleyed&&(s=!0,this.geometryCreateDeleyed.mutateDirectlyScaleBaked(t,e.props.scaleBaked),this.refreshAttachedCloners(n)),s||((r=n.scene)==null||r.markGeometryCacheDirty(),this.createGeometryDelayed(n)),this.resetBBoxNeedsUpdate(),this.invalidateDownstreamBooleanData()}updateGeometryOnStateUpdate(e,t){this.createGeometryDelayed(t)}updateState(e,t){e.geometry!==void 0&&this.updateGeometryOnStateUpdate(e.geometry,t),super.updateState(e,t)}updateGeometryGroupsIfNeeded(){var e,t;Array.isArray(this.material)&&this.geometry.groups.length===0&&this.geometry.addGroup(0,Math.max((t=(e=this.geometry.getIndex())==null?void 0:e.count)!=null?t:0,this.geometry.getAttribute("position").count),0)}updateEntityBoxSize(e,t){var s;let n=this.geometry.userData.parameters;this.is2DType?e.set(0,0,n.depth*.5):e.setScalar(0),t.set(n.width,n.height,(s=n.depth)!=null?s:0).multiplyScalar(.5)}};function qle(e){var i,o;if(e.geometry.attributes.extrudeNormal||!e.geometry.attributes.position||!e.geometry.attributes.normal)return;let t=new Map,n=e.geometry.attributes.position.array,s=e.geometry.attributes.normal.array,r=new Float32Array(n.length);for(let a=0;a<n.length;a+=3){let l=`${n[a]}_${n[a+1]}_${n[a+2]}`,c=new I(s[a],s[a+1],s[a+2]);t.has(l)?(i=t.get(l))==null||i.normals.push(c):t.set(l,{normals:[c],result:new I})}t.forEach((a,l)=>{for(let c of a.normals)a.result.add(c);a.result.divideScalar(a.normals.length)});for(let a=0;a<n.length;a+=3){let l=`${n[a]}_${n[a+1]}_${n[a+2]}`,c=(o=t.get(l))==null?void 0:o.result;c&&(r[a]=c.x,r[a+1]=c.y,r[a+2]=c.z)}e.geometry.setAttribute("extrudeNormal",new ot(r,3))}function Xle(e){if(e.geometry.attributes.extrudeNormals||!e.geometry.attributes.position)return;let t=e.geometry.attributes.position.array,n=new Float32Array(t.length),s=new I;for(let r=0;r<t.length;r+=3)s.set(t[r],t[r+1],t[r+2]).normalize(),n[r]=s.x,n[r+1]=s.y,n[r+2]=s.z;e.geometry.setAttribute("extrudeNormal",new ot(n,3))}function sC(e){if(Array.isArray(e.material)){for(let t of e.material)if(t.getLayersOfType("outline").length===0)return}else if(!(e.material instanceof xc)||e.material.getLayersOfType("outline").length===0)return;e instanceof $o&&e.is2DAndNoDepth?Xle(e):qle(e)}function rC(e){if(!e.geometry.attributes.position)return;let t=e.geometry.attributes.position.array,n=new Float32Array(t.length),s=parseInt(e.uuid.replace(/\D/g,"")),r=[Kt.seededRandom(s),Kt.seededRandom(s+1e4),Kt.seededRandom(s+2e4)];for(let i=0;i<t.length;i++)n[i]=r[i%3];e.geometry.setAttribute("randomColor",new Lt(n,3))}G2.then(e=>{});var Oa=new Ss,Im=new I;function Kle(e){let t=!1;return e.scene.objects.traverse((n,s)=>{s.type==="Mesh"&&s.geometry.type==="SubdivGeometry"&&(t=!0)}),t}var Nm=class extends $o{constructor(e,t,n){super(e,t,n);this.data=t,this.hiddenMatrixOld=new et,this.smoothShading=!0,this.skipReactionUpdate=!1}chooseGeoemtryCache(e){return this.dataPatched.flatShading?e.geometryCache:e.geometryCache2}get subdivPointerNew(){return this.localGeometry!==void 0?this.subdivPointer:this.geometry.ensureSubdivPointer()}get originalGeometryNew(){return this.localGeometry!==void 0?this.originalGeometry:this.geometry.originalGeometry}get phongAngle(){var e;return(e=this.data.geometry.phongAngle)!=null?e:45}updateEntityBoxSize(e,t){var s;let n=this.geometry.userData.parameters;e.copy(this.originalGeometryNew.boundingSphere.center),t.set(n.width,n.height,(s=n.depth)!=null?s:0).multiplyScalar(.5)}createGeometryByControls(e){var i,o,a,l;if(this.skipReactionUpdate===!0)return;let t=(i=this.localGeometry)==null?void 0:i.uuid,{originalGeometry:n,subdividedGeometry:s,subdivPointer:r}=zr.build(e,this.subdivPointer,this.smoothShading,this.hasNonUniformScale?this.shearScale:void 0);this.subdivPointer=r,n!==void 0&&((o=this.originalGeometry)==null||o.dispose(),this.originalGeometry=n),s!==void 0&&((a=this.subdividedGeometry)==null||a.dispose(),this.subdividedGeometry=s!=null?s:void 0),this.localGeometry=(l=this.subdividedGeometry)!=null?l:this.originalGeometry,sC(this),rC(this),this.calcBoundingBox(),t&&(this.localGeometry.uuid=t)}updateState(e,t){if(super.updateState(e,t),e.flatShading!==void 0){let n=this.material;this.material=n.getFlavor(!1,n.side,n.wireframe),this.smoothShading=!e.flatShading,this.createGeometryDelayed(t)}}updateMesh(e=!1){zr.buildLevel(this.subdivPointer,!0,this.smoothShading?this.phongAngle:-1,this.originalGeometry,e&&this.hasNonUniformScale?this.shearScaleInv:void 0),this.subdividedGeometry&&zr.buildLevel(this.subdivPointer,!1,this.smoothShading?this.phongAngle:-1,this.subdividedGeometry,e&&this.hasNonUniformScale?this.shearScaleInv:void 0)}updateTopology(){var e;this.originalGeometry.dispose(),this.originalGeometry=zr.buildLevel(this.subdivPointer,!0,this.smoothShading?this.phongAngle:-1),this.subdividedGeometry&&(this.subdividedGeometry.dispose(),this.subdividedGeometry=zr.buildLevel(this.subdivPointer,!1,this.smoothShading?this.phongAngle:-1)),this.localGeometry=(e=this.subdividedGeometry)!=null?e:this.originalGeometry}raycast(e,t){let n=this.localGeometry;this.localGeometry=this.originalGeometryNew,Ai.prototype.raycast.call(this,e,t),this.localGeometry=n}activateSVDCompensation(){!this.hasNonUniformScale||(this.matrix.copy(this.matrixWorldRigid),this.hiddenMatrixOld.copy(this.hiddenMatrix),this.hiddenMatrix.copy(this.parent.matrixWorld).invert())}deactivateSVDCompensation(){!this.hasNonUniformScale||(this.updateMatrix(),this.hasNonUniformScale=void 0,this.hiddenMatrix.copy(this.hiddenMatrixOld))}calcBoundingBox(){let e=this.originalGeometry;e.boundingSphere===null&&(e.boundingSphere=new Wi,this.subdividedGeometry&&(this.subdividedGeometry.boundingSphere=e.boundingSphere));let t=e.attributes.position,n=e.boundingSphere.center;Oa.setFromBufferAttribute(t),Oa.getCenter(n),e.boundingSphere.radius=n.distanceTo(Oa.max),isNaN(e.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this),Oa.getSize(Im),this.hasNonUniformScale&&Im.divide(this.scale);let s={width:Im.x,height:Im.y,depth:Im.z};return this.geometry.userData.parameters=s,s}updateBoundingSphere(e){let t=this.originalGeometry;Oa.min.set(e[0],e[2],e[4]),Oa.max.set(e[1],e[3],e[5]),this.hasNonUniformScale&&(Oa.min.applyMatrix4(this.shearScaleInv),Oa.max.applyMatrix4(this.shearScaleInv)),t.boundingSphere===null&&(t.boundingSphere=new Wi);let n=t.boundingSphere.center;Oa.getCenter(n),t.boundingSphere.radius=n.distanceTo(Oa.max)}freeSubdivPointer(){var e,t;this.subdivPointer&&(zr.freeSubdivPointer(this.subdivPointer),this.subdivPointer=0),this.localGeometry=void 0,(e=this.originalGeometry)==null||e.dispose(),(t=this.subdividedGeometry)==null||t.dispose()}dispose(){super.dispose(),this.freeSubdivPointer()}updateByPatchedOpGeometry(e,t,n){super.updateByPatchedOpGeometry(e,t,n),this.localGeometry&&this.createGeometryByControls(t)}},uL=-1,Yle=1,Qle={x:[1,0,0],"-x":[-1,0,0],y:[0,1,0],"-y":[0,-1,0],z:[0,0,1],"-z":[0,0,-1]},Zle={polygon_center:0,edge:1,vertex:2},ux=(e,t)=>(n,s)=>!t||n===0||e===0?0:e*s/100,Ot=(e,t)=>{let n=Math.abs(t),s=n*-1;return(e-uL)*(n-s)/(Yle-uL)+s};function Jle(e){let t=[],n={};for(var s=0,r=e.length;s<r;s++){var i=JSON.stringify(e[s].pos.map(o=>Math.round(o*1e4)/1e4));n[i]||(t.push(e[s]),n[i]=!0)}return t}var ece=new I,hx=new I,tce=new I,nce=new I;function sp(e,t){let n=tce.fromArray(e),s=nce.fromArray(t);hx.copy(s).sub(n);let r=hx.length();return hx.normalize().multiplyScalar(r*.5),ece.copy(n).add(hx).toArray()}var no=new Jr,dx=new I,px=new I,Hu=new I;function sce(e){let t=[];for(let n=0;n<=e.index.count;n++)if(dx.fromArray(e.index.array,n*3),no.setFromAttributeAndIndices(e.attributes.position,dx.x,dx.y,dx.z),no.getNormal(px),no.getMidpoint(Hu),!(isNaN(Hu.x)||isNaN(Hu.y)||isNaN(Hu.z))){let{a:s,b:r,c:i}=no,o=s.toArray(),a=r.toArray(),l=i.toArray(),c=s.distanceTo(r),h=r.distanceTo(i),u=i.distanceTo(s),d=sp(o,a),p=sp(a,l),f=sp(l,o),g=[c,h,u],m=Math.max(...g),y=g.filter(x=>Math.round(x)===Math.round(m)).length>1,v=[],b=no.getMidpoint(Hu).toArray();m===c&&!y&&(v=[p,f,f],b=d),m===h&&!y&&(v=[d,f,f],b=p),m===u&&!y&&(v=[d,p,p],b=f),y&&(v=[d,p,f]),t.push({vertices:[o,a,l],faceCenters:v,midpoint:b,norm:no.getNormal(px).toArray()})}return t}function rce(e){let t=[],{position:n}=e.attributes;for(let s=0;s<n.count;s++){no.setFromAttributeAndIndices(n,s*3,s*3+1,s*3+2),no.getNormal(px),no.getMidpoint(Hu);let r=no.a.toArray(),i=no.b.toArray(),o=no.c.toArray();t.push({vertices:[r,i,o],faceCenters:[sp(r,i),sp(i,o),sp(o,r)],midpoint:Hu.toArray(),norm:px.toArray()})}return t}var ice=4,oce=.5,iC=e=>.5*(1-Math.cos(e*Math.PI)),ace=class{constructor(){this.perlin=new Array(4095+1)}noise(e,t=0,n=0){if(this.perlin==null){this.perlin=new Array(4095+1);for(let m=0;m<4095+1;m++)this.perlin[m]=Math.random()}e<0&&(e=-e),t<0&&(t=-t),n<0&&(n=-n);let s=Math.floor(e),r=Math.floor(t),i=Math.floor(n),o=e-s,a=t-r,l=n-i,c,h,u=0,d=.5,p,f,g;for(let m=0;m<ice;m++){let y=s+(r<<4)+(i<<8);c=iC(o),h=iC(a),p=this.perlin[y&4095],p+=c*(this.perlin[y+1&4095]-p),f=this.perlin[y+16&4095],f+=c*(this.perlin[y+16+1&4095]-f),p+=h*(f-p),y+=256,f=this.perlin[y&4095],f+=c*(this.perlin[y+1&4095]-f),g=this.perlin[y+16&4095],g+=c*(this.perlin[y+16+1&4095]-g),f+=h*(g-f),p+=iC(l)*(f-p),u+=p*d,d*=oce,s<<=1,o*=2,r<<=1,a*=2,i<<=1,l*=2,o>=1&&(s++,o--),a>=1&&(r++,a--),l>=1&&(i++,l--)}return u}noiseSeed(e){let t=(()=>{let n,s;return{setSeed(r){s=n=(r!=null?r:Math.random()*4294967296)>>>0},getSeed(){return n},rand(){return s=(1664525*s+1013904223)%4294967296,s/4294967296}}})();t.setSeed(e),this.perlin=new Array(4095+1);for(let n=0;n<4095+1;n++)this.perlin[n]=t.rand()}},lce=ace,hL=new I,dL=new et,pL=new td;function fL(e){let t=!1;return e.scene.objects.traverse((n,s)=>{s.type==="Mesh"&&s.geometry.type==="TextGeometry"&&(t=!0)}),t}var mL=class extends $o{constructor(e,t,n){super(e,t,n);this.data=t}get textGeometry(){return this.geometry}get charWidths(){return this.textGeometry.charWidths}get charCoords(){return this.textGeometry.charCoords}get wrappedText(){return this.textGeometry.wrappedText}get font(){return this.textGeometry.font}get initialOffsetY(){var t,n;let e=this.dataPatched;return(n=(t=this.font)==null?void 0:t.getLineInitialOffsetY(this.lineHeight,this.wrappedText.length,e.geometry.height,this.fontScale,e.geometry.verticalAlign))!=null?n:0}get fontScale(){let e=this.dataPatched;return this.font?e.geometry.fontSize/this.font.unitsPerEm:1}get AD(){return Math.abs(this.ascender-this.descender)}get ascender(){var e,t;return((t=(e=this.font)==null?void 0:e.ascender)!=null?t:1)*this.fontScale}get descender(){var e,t;return((t=(e=this.font)==null?void 0:e.descender)!=null?t:1)*this.fontScale}get lineHeight(){let e=this.dataPatched;return e.geometry.fontSize*e.geometry.lineHeight}raycast(e,t){let{matrixWorld:n}=this;if(!isNaN(e.ray.origin.x)&&(dL.copy(n).invert(),pL.copy(e.ray).applyMatrix4(dL),pL.intersectBox(this.singleBBox,hL))){let s=hL.applyMatrix4(n),r=e.ray.origin.distanceTo(s);t.push({distance:r,point:s.clone(),object:this})}}},Ur=1e-4,Ra,gL,yL,vL,xL=new I,bL=new I;G2.then(e=>{Ra=e,gL=[Ra.get_face_center,Ra.get_edge_midpoint,Ra.get_vertex_position],yL=[Ra.get_face_normal,Ra.get_edge_normal,Ra.get_vertex_normal],vL=[Ra.face_count,Ra.edge_count,Ra.vertex_count]});var cce=new et,uce=new et,bc=new I,ju=new I,km=new I,oC=new I,hce=new I,dce=new I,Sl=new lce,fx=class extends C2(Ln){constructor(e,t){super();this.parameters=t,this.objectForSample=void 0,this._pendingMediaLoad=!1,this.object=e}resetOnMove(){this.removeFromParent(),this.parent=null}expandClones(e){if(this.parent===null)this.updateState(this.parameters,e);else for(let t of this.children)t instanceof Ru&&t.expand()}invalidateTransform(e){this.matrixWorldNeedsUpdate=!0,this.traverse(t=>{t instanceof Ru&&t.object===e&&(t.matrixWorldNeedsUpdate=!0)})}onObjUpdateMatrix(){this.parameters.type!=="toObject"&&(this.matrixWorldNeedsUpdate=!0)}update(){switch(this._updateCount(),this.parameters.type){case"radial":this._updateRadial(this.parameters);break;case"linear":this._updateLinear(this.parameters);break;case"grid":this._updateGrid(this.parameters);break;case"toObject":this._updateToObject(this.parameters)}for(let e of this.children)e.updateMatrix(),e.hasNonUniformScale&&(e.updateMatrixWorld(),e.updateMatrixWorldSVD())}_updateCount(e){let t;if(e!==void 0?t=e:t=this.parameters.type==="grid"?this.parameters.grid.count[0]*this.parameters.grid.count[1]*this.parameters.grid.count[2]:this.parameters.count,this.parameters.type==="toObject"&&!this.parameters.toObject.object&&(t=0),this.parameters.type==="toObject"&&this.objectForSample){for(let s=0,r=this.children.length;s<r;++s)this.remove(this.children[0]);let n=this.children;if(n.length===t)return;if(n.length<t)for(let s=0,r=t-n.length;s<r;++s){let i=new Ru(this.object);i.expand(),this.add(i)}else for(let s=0,r=n.length-t;s<r;++s)this.remove(n[s])}else{if(this.children.length===t)return;if(this.children.length<t)for(let n=0,s=t-this.children.length;n<s;++n){let r=new Ru(this.object);r.expand(),this.add(r)}else for(let n=0,s=this.children.length-t;n<s;++n)this.remove(this.children[0])}}_updateRadial(e){var u;let t=e.radial,n=t.start*Kt.DEG2RAD,s=t.end*Kt.DEG2RAD,r=n-s,i=new gr(t.rotation[0],t.rotation[1],t.rotation[2]),o;switch(t.axis){case"z":o=new I(0,0,1);break;case"y":o=new I(0,1,0);break;default:case"x":o=new I(1,0,0);break}let a=(u=e.randomnessObject)!=null?u:cc.defaultData([1,1,1]).randomnessObject,l=a.noiseType==="perlin";Sl.noiseSeed(a.seed);let c=_2((0,mm.default)(a.seed)),h=ux(a.strength,this.parameters.randomness);for(let[d,p]of this.children.entries()){let f=d*(a.freqScale/10)+a.movement,g=l?Sl.noise(f):c(f,f);p.scale.x=t.scale[0]+h(d,Ot(g,a.scale[0]))||Ur,p.scale.y=t.scale[1]+h(d,Ot(g,a.scale[1]))||Ur,p.scale.z=t.scale[2]+h(d,Ot(g,a.scale[2]))||Ur,p.position.setScalar(0);let m=r/e.count*d-n;switch(t.axis){case"x":p.rotation.set(0,m,0);break;case"y":p.rotation.set(0,0,m);break;case"z":p.rotation.set(m,0,0);break}p.translateOnAxis(o,t.radius),p.position.x+=t.position[0]+h(d,Ot(g,a.position[0])),p.position.y+=t.position[1]+h(d,Ot(g,a.position[1])),p.position.z+=t.position[2]+h(d,Ot(g,a.position[2]));let y=h(d,Ot(g,a.rotation[0])),v=h(d,Ot(g,a.rotation[1])),b=h(d,Ot(g,a.rotation[2]));t.alignment===!0?(p.rotation.x+=i.x+y,p.rotation.y+=i.y+v,p.rotation.z+=i.z+b):p.rotation.set(i.x+y,i.y+v,i.z+b)}}_updateLinear(e){var a;if(e.type!=="linear")throw new Error;let t=e.linear,n=new gr(t.rotation[0],t.rotation[1],t.rotation[2]),s=(a=e.randomnessObject)!=null?a:cc.defaultData([1,1,1]).randomnessObject,r=s.noiseType==="perlin";Sl.noiseSeed(s.seed);let i=_2((0,mm.default)(s.seed)),o=ux(s.strength,this.parameters.randomness);for(let[l,c]of this.children.entries()){let h=l*(s.freqScale/10)+s.movement,u=r?Sl.noise(h):i(h,h),d=o(l,Ot(u,s.rotation[0])),p=o(l,Ot(u,s.rotation[1])),f=o(l,Ot(u,s.rotation[2]));c.scale.x=1+(t.scale[0]-1)*l+o(l,Ot(u,s.scale[0]))||Ur,c.scale.y=1+(t.scale[1]-1)*l+o(l,Ot(u,s.scale[1]))||Ur,c.scale.z=1+(t.scale[2]-1)*l+o(l,Ot(u,s.scale[2]))||Ur,c.rotation.x=n.x*l+d,c.rotation.y=n.y*l+p,c.rotation.z=n.z*l+f,c.position.x=t.position[0]*l+o(l,Ot(u,s.position[0])),c.position.y=t.position[1]*l+o(l,Ot(u,s.position[1])),c.position.z=t.position[2]*l+o(l,Ot(u,s.position[2]))}}_updateGrid(e){var a;let t=0,n=e.grid,s=(a=e.randomnessObject)!=null?a:cc.defaultData([1,1,1]).randomnessObject,r=ux(s.strength,this.parameters.randomness),i=s.noiseType==="perlin";Sl.noiseSeed(s.seed);let o=moe((0,mm.default)(s.seed));if(n.useCenter===!0){let l={x:n.count[0]%2==0?2:1,y:n.count[1]%2==0?2:1,z:n.count[2]%2==0?2:1},c=new I(n.size[0]*(n.count[0]-l.x)*.5,n.size[1]*(n.count[1]-l.y)*.5,n.size[2]*(n.count[2]-l.z)*.5);for(let h=0;h<n.count[0];h++)for(let u=0;u<n.count[1];u++)for(let d=0;d<n.count[2];d++){let p=[(h+1)*(s.freqScale/10)+s.movement,(u+1)*(s.freqScale/10)+s.movement,(d+1)*(s.freqScale/10)+s.movement],f=i?Sl.noise(...p):o(...p),g=this.children[t++];g.scale.x=1+r(t,Ot(f,s.scale[0]))||Ur,g.scale.y=1+r(t,Ot(f,s.scale[1]))||Ur,g.scale.z=1+r(t,Ot(f,s.scale[2]))||Ur;let m=r(t,Ot(f,s.rotation[0])),y=r(t,Ot(f,s.rotation[1])),v=r(t,Ot(f,s.rotation[2]));g.rotation.set(m,y,v),g.position.x=n.size[0]*h-c.x+r(t,Ot(f,s.position[0])),g.position.y=n.size[1]*u-c.y+r(t,Ot(f,s.position[1])),g.position.z=n.size[2]*d-c.z+r(t,Ot(f,s.position[2]))}}else for(let l=0;l<n.count[0];l++)for(let c=0;c<n.count[1];c++)for(let h=0;h<n.count[2];h++){let u=[(l+1)*(s.freqScale/10)+s.movement,(c+1)*(s.freqScale/10)+s.movement,(h+1)*(s.freqScale/10)+s.movement],d=i?Sl.noise(...u):o(...u),p=this.children[t++];p.scale.x=1+r(t,Ot(d,s.scale[0]))||Ur,p.scale.y=1+r(t,Ot(d,s.scale[1]))||Ur,p.scale.z=1+r(t,Ot(d,s.scale[2]))||Ur;let f=r(t,Ot(d,s.rotation[0])),g=r(t,Ot(d,s.rotation[1])),m=r(t,Ot(d,s.rotation[2]));p.rotation.set(f,g,m),p.position.x=n.size[0]*l+r(t,Ot(d,s.position[0])),p.position.y=-n.size[1]*c+r(t,Ot(d,s.position[1])),p.position.z=-n.size[2]*h+r(t,Ot(d,s.position[2]))}}_updateToObject(e){var g,m;if(e.type!=="toObject")throw new Error;let{toObject:t}=e,n=new gr(t.rotation[0],t.rotation[1],t.rotation[2]),s=(g=e.randomnessObject)!=null?g:cc.defaultData([1,1,1]).randomnessObject,r=s.noiseType==="perlin";Sl.noiseSeed(s.seed);let i=_2((0,mm.default)(s.seed)),o=ux(s.strength,this.parameters.randomness);if(!t.object){for(let[,y]of this.children.entries())y.position.set(0,0,0),y.scale.setScalar(1),y.rotation.set(0,0,0);this.objectForSample=void 0;return}if(!this.objectForSample)return;if(this.objectForSample instanceof mL)if(!((m=this.objectForSample.font)==null?void 0:m.isLoaded)||this.objectForSample.geometry.attributes.position===void 0){this._pendingMediaLoad=!0;return}else this._pendingMediaLoad=!1;if(this.objectForSample.geometry===void 0&&this.object.parent===this.objectForSample){console.warn(`Oh no! The object "${this.object.name}" (${this.object.uuid}) seem to be a child of the object it's being cloned to. Please re-parent it so that they are siblings instead.`);return}let a=this.getSubdivData(),l=[],c=y=>{let v=y.length,b=y.map(S=>S[0]).reduce((S,C)=>S+C,0),x=y.map(S=>S[1]).reduce((S,C)=>S+C,0),w=y.map(S=>S[2]).reduce((S,C)=>S+C,0);return[b/v,x/v,w/v]},h=y=>Math.round(y*1e6)/1e6;a.forEach(y=>{let v=a.filter(b=>h(y.pos[0])===h(b.pos[0])&&h(y.pos[1])===h(b.pos[1])&&h(y.pos[2])===h(b.pos[2]));v.length>1?l.push({pos:y.pos,norm:c(v.map(b=>b.norm))}):l.push(y)});let u=Jle(l);if(a.length>0){let y=Math.round(u.length*t.count/100);this._updateCount(y)}this.objectForSample.updateMatrixWorld();let d=new goe(this.objectForSample).build(),p=Qle[t.axis],f=this.children;d.setRandomGenerator((0,mm.default)(this.object.uuid+t.seed));for(let[y,v]of f.entries()){let b=y*(s.freqScale/10)+s.movement,x=r?Sl.noise(b):i(b,b),w=o(y,Ot(x,s.rotation[0])),S=o(y,Ot(x,s.rotation[1])),C=o(y,Ot(x,s.rotation[2]));t.spreadType==="random"?d.sample(km,oC):(u.length&&(km.fromArray(u[y].pos),oC.fromArray(u[y].norm)),this.objectForSample instanceof Nm&&km.applyMatrix4(cce.copy(this.objectForSample.matrixWorld).invert())),km.applyMatrix4(this.object.hiddenMatrix.clone().invert()),v.position.copy(km),bc.fromArray(p);let _=t.align==="normal"?oC:this.object.getWorldDirection(dce),T=ju.fromArray(t.position);ju.x+=ju.x+o(y,Ot(x,s.position[0])),ju.y+=ju.y+o(y,Ot(x,s.position[1])),ju.z+=ju.z+o(y,Ot(x,s.position[2]));let E=Math.acos(_.dot(bc)),A=hce.crossVectors(bc,_).normalize(),D=uce.makeRotationAxis(A,E),O=_.clone().cross(this.object.up).normalize(),P=O.clone().cross(_).normalize(),L=new et().makeBasis(O,_,P),B=new I(bc.y,bc.z,bc.x).normalize(),F=B.clone().cross(bc).normalize(),M=new et().makeBasis(B,bc,F).invert(),U=new et().multiplyMatrices(L,M);v.rotation.setFromRotationMatrix(U),T.applyMatrix4(D),v.position.add(T),v.rotation.x=v.rotation.x+n.x+w,v.rotation.y=v.rotation.y+n.y+S,v.rotation.z=v.rotation.z+n.z+C,v.scale.setScalar(1),v.scale.x=v.scale.x+t.scale[0]+o(y,Ot(x,s.scale[0]))||Ur,v.scale.y=v.scale.y+t.scale[1]+o(y,Ot(x,s.scale[1]))||Ur,v.scale.z=v.scale.z+t.scale[2]+o(y,Ot(x,s.scale[2]))||Ur,v.scale.multiply(this.object.scale),v.hiddenMatrix=this.object.hiddenMatrix}}getSubdivData(){if(!this.objectForSample)return[];let e=this.parameters.toObject.spreadType;if(e==="random")return[];if(this.objectForSample instanceof Nm){let t=this.objectForSample,n=Zle[e],s=vL[n],r=gL[n],i=yL[n],o=[],a=s(t.subdivPointerNew);for(let l=0;l<=a-1;l++){let c=r(t.subdivPointerNew,l),h=i(t.subdivPointerNew,l);xL.fromArray(c).applyMatrix4(t.matrixWorld),bL.fromArray(h),o.push({pos:xL.toArray(),norm:bL.toArray()})}return o}else return(this.objectForSample.geometry.index?sce(this.objectForSample.geometry):rce(this.objectForSample.geometry)).map((t,n)=>e==="polygon_center"?{pos:t.midpoint,norm:t.norm}:e==="vertex"?[{pos:t.vertices[0],norm:t.norm},{pos:t.vertices[1],norm:t.norm},{pos:t.vertices[2],norm:t.norm}]:e==="edge"?[{pos:t.faceCenters[0],norm:t.norm},{pos:t.faceCenters[1],norm:t.norm},{pos:t.faceCenters[2],norm:t.norm}]:[]).flat()}updateState(e,t){var n;if(this.parameters=C_(e),this.parameters.type!=="toObject")(this.parent===null||this.parent!==this.object)&&(this.removeFromParent(),(n=this.object.parent)==null||n.add(this),this.matrix=this.object.matrix,this.hiddenMatrix=this.object.hiddenMatrix,this.matrixWorldNeedsUpdate=!0,this.matrixAutoUpdate=!1);else if(this.parent===null||this.parent.uuid!==this.parameters.toObject.object){this.removeFromParent();let s=t.find(this.parameters.toObject.object);s instanceof Ai?this.objectForSample=s:this.objectForSample=void 0,this.matrix=new et,this.hiddenMatrix=new et,this.matrixWorldNeedsUpdate=!0,this.matrixAutoUpdate=!1,s&&s.add(this)}this.update()}get pendingMediaLoad(){return this._pendingMediaLoad}},Dm=e=>{var t;return t=class extends e{},t.geometryHelper=new pa(30,30,30),t},mx=new td,aC=new Wi,wL=new et,Mm=(e,t,n,s,r=!1)=>{let i=t,o=e.matrixWorld;if(i.boundingSphere===null&&i.computeBoundingSphere(),aC.copy(i.boundingSphere),aC.applyMatrix4(o),n.ray.intersectsSphere(aC)===!1||(wL.copy(o).invert(),mx.copy(n.ray).applyMatrix4(wL),i.boundingBox!==null&&mx.intersectsBox(i.boundingBox)===!1))return;let a,l,c,h,u=i.index,d=i.attributes.position,p=i.drawRange,f,g;if(r===!1){let y=Math.max(0,p.start),v=Math.min(u.count,p.start+p.count);for(f=y,g=v;f<g;f+=3)if(l=u.getX(f),c=u.getX(f+1),h=u.getX(f+2),a=m(e,n,mx,d,l,c,h),a){a.faceIndex=Math.floor(f/3),s.push(a);return}}else{let y=i.attributes.position,v=new I,b=new I,x=new I,w=new I,S=2,C=1/((e.scale.x+e.scale.y+e.scale.z)/3),_=C*C,T=Math.max(0,p.start),E=Math.min(y.count,p.start+p.count);for(let A=T,D=E-1;A<D;A+=S){if(v.fromBufferAttribute(y,A),b.fromBufferAttribute(y,A+1),mx.distanceSqToSegment(v,b,w,x)>_)continue;w.applyMatrix4(e.matrixWorld);let O=n.ray.origin.distanceTo(w);O<n.near||O>n.far||s.push({distance:O,point:x.clone().applyMatrix4(e.matrixWorld),object:e})}}function m(y,v,b,x,w,S,C){let _=new I,T=new I,E=new I,A=new I,D=new I;if(_.fromBufferAttribute(x,w),T.fromBufferAttribute(x,S),E.fromBufferAttribute(x,C),b.intersectTriangle(_,T,E,!1,A)===null)return null;D.copy(A),D.applyMatrix4(y.matrixWorld);let O=v.ray.origin.distanceTo(D);return O<v.near||O>v.far?null:{faceIndex:1,distance:O,point:D.clone(),object:y}}},gx=new I,so=new ud,pce=class extends Bf{constructor(e){let t=new It,n=new nc({color:16777215,vertexColors:!0,toneMapped:!1}),s=[],r=[],i={},o=new _t(15711266),a=new _t(15711266),l=new _t(2857471);c("n1","n2",o),c("n2","n4",o),c("n4","n3",o),c("n3","n1",o),c("f1","f2",o),c("f2","f4",o),c("f4","f3",o),c("f3","f1",o),c("n1","f1",o),c("n2","f2",o),c("n3","f3",o),c("n4","f4",o),c("p","n1",a),c("p","n2",a),c("p","n3",a),c("p","n4",a),c("u1","u2",l),c("u2","u3",l),c("u3","u1",l);function c(u,d,p){h(u,p),h(d,p)}function h(u,d){s.push(0,0,0),r.push(d.r,d.g,d.b),i[u]===void 0&&(i[u]=[]),i[u].push(s.length/3-1)}t.setAttribute("position",new ot(s,3)),t.setAttribute("color",new ot(r,3));super(t,n);this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=i,this.update()}update(){let e=this.geometry,t=this.pointMap;so.projectionMatrixInverse.elements=[.5112609807824982,-0,-0,-0,-0,.41421356237309503,-0,-0,-0,-0,-0,-.099999,-0,-0,-1.0000000000000002,.100001];let n=1,s=1,r=.8;Bo("n1",t,e,so,-n,-s,r),Bo("n2",t,e,so,n,-s,r),Bo("n3",t,e,so,-n,s,r),Bo("n4",t,e,so,n,s,r);let i=r;Bo("f1",t,e,so,-n,-s,i),Bo("f2",t,e,so,n,-s,i),Bo("f3",t,e,so,-n,s,i),Bo("f4",t,e,so,n,s,i);let o=i,a=.5;Bo("u1",t,e,so,n*.7*a,s*1.1,o),Bo("u2",t,e,so,-n*.7*a,s*1.1,o),Bo("u3",t,e,so,0,s*(1.1+.9*a),o),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}};function Bo(e,t,n,s,r,i,o){gx.set(r,i,o).unproject(s);let a=t[e];if(a!==void 0){let l=n.getAttribute("position");for(let c=0,h=a.length;c<h;c++)l.setXYZ(a[c],gx.x,gx.y,gx.z)}}var fce=class extends Dm(pce){constructor(e){super(e);this.object=e,this.object=e,this.name=`CombinedCameraHelper: ${e.uuid}`}updateMatrixWorld(e){super.updateMatrixWorld(e),this.updateTarget()}updateTarget(){let e=this.object.getTarget();this.updateWorldMatrix(!0,!1),this.worldToLocal(e)}raycast(e,t){Mm(this.object,this.geometry,e,t,!0)}},lC;(e=>e.is=t=>"objectHelper"in t)(lC||(lC={}));var yx=(e,t)=>class extends MO(e){constructor(){super(...arguments);this.objectHelper=new t(this),this.gizmos={}}get geometryHelper(){return t.geometryHelper}raycast(n,s){this.objectHelper.raycast(n,s)}showGizmos(){for(let n in this.gizmos){let s=this.gizmos[n];s instanceof Uy&&(s.visible=!0)}}updateEntityBoxSize(n,s){this.objectHelper.visible&&this.geometryHelper instanceof pa?(n.setScalar(0),s.set(this.geometryHelper.parameters.width,this.geometryHelper.parameters.height,this.geometryHelper.parameters.height).multiplyScalar(.5)):super.updateEntityBoxSize(n,s)}hideGizmos(){for(let n in this.gizmos){let s=this.gizmos[n];s instanceof Uy&&(s.visible=!1)}}},cC=790,rp=new I,uC=new I,_l=class extends yx(ud,fce){constructor(e="",t=De(ue({},_v.defaultData),{name:""})){super();var r;this._cameraType="OrthographicCamera",this.targetOffset=im.DefaultTargetOffset,this.isUpVectorFlipped=!1,this.angleOffsetFromUp=0,this.super_Entity(e,t),this.matrixAutoUpdate=!0,this.width=window.innerWidth,this.height=window.innerHeight;let n=this.width,s=this.height;if(t.orthographic.autoZoom){let i=(r=t.orthographic.autoZoomFrustumSize)!=null?r:cC,o=n/s,a=n>s?o:1,l=n>s?1:o;this.orthoCamera=new Cy(-i*.5*a,i*.5*a,i*.5*(1/l),-i*.5*(1/l),-5e4,1e4)}else this.orthoCamera=new Cy(n*-.5,n*.5,s*.5,s*-.5,-5e4,1e4);this.perspCamera=new vr(45,n/s,50,1e4),this.left=this.orthoCamera.left,this.right=this.orthoCamera.right,this.top=this.orthoCamera.top,this.bottom=this.orthoCamera.bottom,this.far=this.orthoCamera.far,this.view=this.orthoCamera.view,this.aspect=this.perspCamera.aspect,this.focus=this.perspCamera.focus,this.filmGauge=this.perspCamera.filmGauge,this.filmOffset=this.perspCamera.filmOffset,this.objectHelper.update()}get isPerspectiveCamera(){return this.cameraType==="PerspectiveCamera"}get isOrthographicCamera(){return!this.isPerspectiveCamera}get cameraType(){return this._cameraType}set fov(e){this.perspCamera.fov=e}get fov(){return this.perspCamera.fov}setNear(e,t){e==="PerspectiveCamera"?this.perspCamera.near=t:this.orthoCamera.near=t}setZoom(e,t){t>=0&&(e==="PerspectiveCamera"?this.perspCamera.zoom=t:this.orthoCamera.zoom=t)}set cameraType(e){e==="PerspectiveCamera"?this.toPerspective():e==="OrthographicCamera"&&this.toOrthographic()}get near(){return this._cameraType==="PerspectiveCamera"?this.perspCamera.near:this.orthoCamera.near}set near(e){this._cameraType==="PerspectiveCamera"?this.perspCamera.near=e:this.orthoCamera.near=e}get zoom(){return this._cameraType==="PerspectiveCamera"?this.perspCamera.zoom:this.orthoCamera.zoom}set zoom(e){e>=0&&(this._cameraType==="PerspectiveCamera"?this.perspCamera.zoom=e:this.orthoCamera.zoom=e)}lookAt(e){super.lookAt(e),this.getWorldPosition(rp),this.targetOffset=rp.distanceTo(e)}getTarget(e=new I){return this.getWorldDirection(uC),this.getWorldPosition(rp),uC.multiplyScalar(this.targetOffset),e.copy(rp).add(uC),e}getDistanceToTarget(){let e=this.getTarget();return this.getWorldPosition(rp),rp.distanceTo(e)}updateUp(){let e=this.getWorldQuaternion(new un),t=new I(0,0,1).applyQuaternion(e),n=new I().copy(Ln.DefaultUp);this.isUpVectorFlipped&&n.negate(),n.applyQuaternion(e);let s=new I().copy(Ln.DefaultUp).projectOnPlane(t),r=new I().crossVectors(s,n).dot(t)>=0?1:-1;this.angleOffsetFromUp=s.angleTo(n)*r}updateTransformState(e){let t=super.updateTransformState(e);return e.isUpVectorFlipped!==void 0&&(this.isUpVectorFlipped=e.isUpVectorFlipped),this.updateUp(),t}getViewFrontToObject(e){let t=e.getWorldPosition(new I),n=e.getWorldDirection(new I).multiplyScalar(this.targetOffset);return{position:t.clone().add(n),target:t}}getViewToObject(e){let t=e.getWorldPosition(new I),n=this.getWorldDirection(new I).multiplyScalar(this.targetOffset);return{position:t.clone().sub(n),target:t}}setViewplaneSize(e,t){var n;if(this.aspect=e/t,this.data.type==="OrthographicCamera"&&this.data.orthographic.autoZoom){let s=(n=this.data.orthographic.autoZoomFrustumSize)!=null?n:cC,r=e>t?this.aspect:1,i=e>t?1:this.aspect;this.left=-s*.5*r,this.right=s*.5*r,this.top=s*.5*(1/i),this.bottom=-s*.5*(1/i)}else this.left=-e*.5,this.right=e*.5,this.top=t*.5,this.bottom=-t*.5;this.updateProjectionMatrix()}toOrthographic(){this.orthoCamera.left=this.left,this.orthoCamera.right=this.right,this.orthoCamera.top=this.top,this.orthoCamera.bottom=this.bottom,this.orthoCamera.view=this.view,this.orthoCamera.far=this.far,this.orthoCamera.updateProjectionMatrix(),this.projectionMatrix=this.orthoCamera.projectionMatrix,this.projectionMatrixInverse=this.orthoCamera.projectionMatrixInverse,this._cameraType="OrthographicCamera",this.objectHelper&&this.objectHelper.update()}toPerspective(){this.perspCamera.aspect=this.aspect,this.perspCamera.fov=this.fov,this.perspCamera.view=this.view,this.perspCamera.far=this.far,this.perspCamera.updateProjectionMatrix(),this.projectionMatrix=this.perspCamera.projectionMatrix,this.projectionMatrixInverse=this.perspCamera.projectionMatrixInverse,this._cameraType="PerspectiveCamera",this.objectHelper&&this.objectHelper.update()}setFocalLength(e){this.perspCamera.setFocalLength(e),this.toPerspective()}getFocalLength(){return this.perspCamera.getFocalLength()}getEffectiveFOV(){return this.perspCamera.getEffectiveFOV()}getFilmWidth(){return this.perspCamera.getFilmWidth()}getFilmHeight(){return this.perspCamera.getFilmHeight()}setViewOffset(e,t,n,s,r,i){this._cameraType==="PerspectiveCamera"?this.perspCamera.setViewOffset(e,t,n,s,r,i):this.orthoCamera.setViewOffset(e,t,n,s,r,i)}clearViewOffset(){this._cameraType==="PerspectiveCamera"?(this.perspCamera.clearViewOffset(),this.toPerspective()):(this.orthoCamera.clearViewOffset(),this.toOrthographic())}updateProjectionMatrix(){this._cameraType==="PerspectiveCamera"?this.toPerspective():this._cameraType==="OrthographicCamera"&&this.toOrthographic()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}copy(e,t){return super.copy(e,t),this.orthoCamera.copy(e.orthoCamera),this.perspCamera.copy(e.perspCamera),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.far=e.far,this.view=e.view===null?null:Object.assign({},e.view),this._cameraType=e._cameraType,this.aspect=e.aspect,this.fov=e.fov,this.focus=e.focus,this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this.targetOffset=e.targetOffset,this.updateProjectionMatrix(),this}toCameraState(e=[]){let t={type:this.cameraType,far:this.far,orthographic:{near:this.orthoCamera.near,zoom:this.orthoCamera.zoom,autoZoom:!0,autoZoomFrustumSize:cC},perspective:{near:this.perspCamera.near,fov:this.perspCamera.fov,zoom:this.perspCamera.zoom},up:this.up.toArray(),targetOffset:this.targetOffset,isUpVectorFlipped:this.isUpVectorFlipped};return I_(t,e)}updateCameraSubtype(e,t){let n=e==="perspective"?"PerspectiveCamera":"OrthographicCamera";t.zoom!==void 0&&this.setZoom(n,t.zoom),t.near!==void 0&&this.setNear(n,t.near),t.fov!==void 0&&n==="PerspectiveCamera"&&(this.fov=t.fov)}updateState(e){this.updateCameraState(e)}updateCameraState(e){this.updateState_Entity(e,{}),e.far!==void 0&&(this.far=e.far),e.orthographic!==void 0&&this.updateCameraSubtype("orthographic",e.orthographic),e.perspective!==void 0&&this.updateCameraSubtype("perspective",e.perspective),e.type!==void 0&&(this.cameraType=e.type),e.up!==void 0&&this.up.fromArray(e.up),e.targetOffset!==void 0&&(this.targetOffset=e.targetOffset),e.isUpVectorFlipped!==void 0&&(this.isUpVectorFlipped=e.isUpVectorFlipped),this.updateProjectionMatrix()}updateByPatchedOp(e,t,n){super.updateByPatchedOp(e,t,n),e.path.length===1&&e.type===0&&this.updateCameraSubtype(e.path[0],e.props)}toState(e){return De(ue(ue({},super.toState(e)),this.toCameraState(e)),{type:this.cameraType})}},SL=new et;function _L(e){let t=!1;return e.scene.objects.traverse((n,s)=>{var r;((r=s.geometry)==null?void 0:r.type)==="BooleanGeometry"&&(t=!0)}),t}var ip=class extends cx{constructor(e,t,n){super(e,t);this.data=t,this.meshSetAddresses=[],this.needsTransformForDownstream=!1,this.geometry=new It,this.geometry.userData.parameters={width:0,height:0,depth:0}}get booleanOp(){return this.data.geometry.operation}get phongAngle(){var e;return(e=this.data.geometry.phongAngle)!=null?e:45}get isLOD(){return this.recomputeBoolean(),!1}updateByPatchedOp(e,t,n){super.updateByPatchedOp(e,t,n),e.path.length===1&&e.path[0]==="geometry"&&e.type===0&&e.props.operation!==void 0&&(this.freeBooleanPointer(),this.resetBBoxNeedsUpdate())}freeBooleanPointer(){super.freeBooleanPointer(),this.geometry.dispose()}recomputeBoolean(e,t=!0){var s,r;if(this.booleanMeshSetAddress!==-1&&!e)return;for(let i=0;i<this.children.length;i++){let o=this.children[i];o instanceof ip&&o.recomputeBoolean(e===!0,t)}this.meshSetAddresses=[];for(let i=0;i<this.children.length;i++){let o=this.children[i];if(o instanceof Ai&&o.dataPatched.visible===!0&&((s=o.geometry.attributes.position)==null?void 0:s.count)>0&&o.geometry.drawRange.count>0){if(o.booleanMeshSetAddress===-1){if(((r=o.geometry.index)!=null?r:o.geometry.getAttribute("position")).count/3<15e5&&(o.booleanMeshSetAddress=gc.getMeshSet(o.geometry,e===!0,t)),o.booleanMeshSetAddress===-1)return;gc.transformMeshSet(o.booleanMeshSetAddress,o.matrix),o.booleanMatrixInvOld.copy(o.matrix).invert(),o.booleanWasTransformed=!1}else o instanceof ip&&o.needsTransformForDownstream===!0?(gc.transformMeshSet(o.booleanMeshSetAddress,o.matrix),o.needsTransformForDownstream=!1):o.booleanWasTransformed===!0&&(SL.multiplyMatrices(o.matrix,o.booleanMatrixInvOld),gc.transformMeshSet(o.booleanMeshSetAddress,SL),o.booleanMatrixInvOld.copy(o.matrix).invert(),o.booleanWasTransformed=!1);this.meshSetAddresses.push(o.booleanMeshSetAddress)}}if(this.meshSetAddresses.length===0){this.geometry.setAttribute("position",new z8([],0)),this.geometry.setDrawRange(0,0);return}if(e===!0)return gc.calcBooleanTopological(this.meshSetAddresses,this.booleanOp);let n=this.geometry;n.dispose(),this.geometry=new It,this.geometry.userData=n.userData,this.geometry.boundingSphere=n.boundingSphere;try{this.booleanMeshSetAddress=gc.calcBoolean(this.meshSetAddresses,this.booleanOp,this.geometry,this.phongAngle)}catch(i){this.booleanMeshSetAddress=0,console.error(i)}this.booleanMatrixInvOld.copy(this.matrix).invert(),this.needsTransformForDownstream=!0,sC(this),rC(this)}dispose(){super.dispose(),this.geometry.dispose()}},hC;(e=>{function t(n){return fs.is(n)&&n instanceof Hf}e.is=t})(hC||(hC={}));var dC=(e,t)=>class extends yx(e,t){updateState_Light(n,s){this.updateState_Entity(n,s),n.color!==void 0&&(this.color=s.shared.color(n.color)),n.intensity!==void 0&&(this.intensity=n.intensity),n.depth!==void 0&&(this.shadow.camera.far=n.depth,this.shadow.needsUpdate=!0),n.shadows!==void 0&&(this.castShadow=n.shadows)}},Cl=e=>e instanceof Ai,wc=e=>e!==null&&e instanceof ip,mce=e=>e instanceof _l,gce=e=>hC.is(e),yce=e=>lC.is(e),pC=class extends Dm(yY){constructor(e,t=15){super(t);this.object=e,this.object.updateMatrixWorld(),this.name=`EmptyObjectHelper: ${e.uuid}`,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}raycast(e,t){Mm(this.object,pC.geometryHelper,e,t)}update(){}},fC=class extends yx(yd,pC){constructor(e,t){super(),this.super_Entity(e,t),this.objectHelper.update()}updateState(e,t){this.updateState_Entity(e,t)}},CL=class extends Dm(gY){constructor(e,t=15,n=10066329){super(e,t,n);this.object=e,this.added=!1,this.name=`DirectionalLightHelper: ${e.uuid}`}raycast(e,t){Mm(this.object,CL.geometryHelper,e,t)}},TL=class extends Dm(mY){constructor(e,t=15,n=6710886){super(e,t,n);this.object=e,this.name=`PointLightHelper: ${e.uuid}`}raycast(e,t){Mm(this.object,TL.geometryHelper,e,t)}},mC=class extends Dm(fY){constructor(e,t=6710886){super(e,t);this.object=e,this.name=`SpotLightHelper: ${e.uuid}`}raycast(e,t){Mm(this.object,mC.geometryHelper,e,t)}update(){if(this.object!==void 0){let e=mC._vector,t=this.object.distance?this.object.distance:1e3,n=t*Math.tan(this.object.angle);this.cone.scale.set(n,n,t),e.setFromMatrixPosition(this.object.target.matrixWorld),this.cone.lookAt(e);let s=this.color!==void 0?this.color:this.light.color;if(this.cone.material instanceof Array)for(let r=0,i=this.cone.material.length;r<i;r++)this.cone.material[r].color.set(s);else this.cone.material.color.set(s)}}},EL=mC;EL._vector=new I;function vce(e,t){e.shadow.camera.right=t/2,e.shadow.camera.left=-t/2,e.shadow.camera.top=t/2,e.shadow.camera.bottom=-t/2,e.shadow.needsUpdate=!0}var xce=class extends dC(cY,CL){constructor(e,t,n){super(),this.super_Entity(e,t),this.castShadow=!0,this.shadow.mapSize.width=2048,this.shadow.mapSize.height=2048,this.shadow.normalBias=1,this.layers.enable(3);let s=this.shadow.camera;s.top=1250,s.bottom=-1250,s.right=1250,s.left=-1250,s.near=-1e4,s.far=2500;let r=new zy(this.shadow.camera);r.visible=!1,this.gizmos.shadowmap=r}update(){this.shadow.camera.updateProjectionMatrix();for(let e in this.gizmos){let t=this.gizmos[e];t instanceof zy&&t.update()}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.objectHelper&&this.objectHelper.update()}updateState(e,t){this.updateState_Light(e,t);let n=e.depth!==void 0&&e.depth!==this.shadow.camera.far||e.size!==void 0&&e.size/2!==this.shadow.camera.right;e.size!==void 0&&vce(this,e.size),e.shadowRadius!==void 0&&(this.shadow.radius=e.shadowRadius),e.shadowResolution!==void 0&&(this.shadow.mapSize.set(e.shadowResolution,e.shadowResolution),this.shadow.map&&(this.shadow.map.dispose(),this.shadow.map=null)),n&&this.update()}},bce=class extends dC(aY,TL){constructor(e,t,n){super(),this.super_Entity(e,t),this.castShadow=!0,this.shadow.mapSize.width=1024,this.shadow.mapSize.height=1024,this.shadow.normalBias=1,this.layers.enable(3);let s=this.shadow.camera;s.fov=90,s.aspect=1,s.near=100,s.far=2500;let r=new I(-s.far+this.position.x,-s.far+this.position.y,-s.far+this.position.z),i=new I(s.far+this.position.x,s.far+this.position.y,s.far+this.position.z),o=new Ss(r,i),a=new Uy(o,new _t(16755200));a.visible=!1,this.gizmos.shadowmap=a,this.update()}update(){if(this.shadow&&(this.shadow.camera.updateProjectionMatrix(),this.gizmos))for(let e in this.gizmos){let t=this.gizmos[e];if(t instanceof Uy){let n=this.shadow.camera,s=new I(-n.far+this.position.x,-n.far+this.position.y,-n.far+this.position.z),r=new I(n.far+this.position.x,n.far+this.position.y,n.far+this.position.z);t.box.set(s,r),t.updateMatrixWorld(!0)}}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.objectHelper&&this.objectHelper.update()}updateState(e,t){this.updateState_Light(e,t),e.distance!==void 0&&(this.distance=e.distance),e.decay!==void 0&&(this.decay=e.decay),e.shadowRadius!==void 0&&(this.shadow.radius=e.shadowRadius),e.shadowResolution!==void 0&&(this.shadow.mapSize.set(e.shadowResolution,e.shadowResolution),this.shadow.map&&(this.shadow.map.dispose(),this.shadow.map=null))}},AL=new I,IL=new I,NL=new un,wce=class extends dC(iY,EL){constructor(e,t,n){super(),this.super_Entity(e,t),this.castShadow=!0,this.shadow.mapSize.width=1024,this.shadow.mapSize.height=1024,this.shadow.normalBias=1,this.layers.enable(3);let s=this.shadow.camera;s.fov=Kt.RAD2DEG*2*this.angle,s.aspect=1,s.near=100,s.far=2500;let r=new zy(this.shadow.camera);r.visible=!1,this.gizmos.shadowmap=r,this.update()}update(){this.shadow.camera.updateProjectionMatrix();for(let e in this.gizmos){let t=this.gizmos[e];t instanceof zy&&t.update()}}updateMatrixWorld(e){super.updateMatrixWorld(e),IL.setFromMatrixPosition(this.matrixWorld),NL.setFromRotationMatrix(this.matrixWorld),AL.copy(this.up).applyQuaternion(NL).negate().multiplyScalar(this.distance),this.target.position.copy(IL).add(AL),this.target.updateMatrixWorld(),this.objectHelper&&this.objectHelper.update()}updateState(e,t){this.updateState_Light(e,t),e.distance!==void 0&&(this.distance=e.distance),e.decay!==void 0&&(this.decay=e.decay),e.angle!==void 0&&(this.angle=e.angle),e.penumbra!==void 0&&(this.penumbra=e.penumbra),e.shadowRadius!==void 0&&(this.shadow.radius=e.shadowRadius),e.shadowResolution!==void 0&&(this.shadow.mapSize.set(e.shadowResolution,e.shadowResolution),this.shadow.map&&(this.shadow.map.dispose(),this.shadow.map=null))}},Sce=class extends $o{get forceComputeSize(){return!0}get shape(){return this.geometry.userData.shape}constructor(e,t,n){super(e,t,n)}updateEntityBoxSize(e,t){let n=this.geometry.getAttribute("position");n!==void 0?yR(n,this.geometry.drawRange.start,this.geometry.drawRange.count<1/0?this.geometry.drawRange.count:n.count,e,t):super.updateEntityBoxSize(e,t)}},op=class extends yx(yd,pC){constructor(e,t,n){super();t.type==="Instance"&&typeof e=="string"&&(t=this.transformAssignData(t,n)),this.super_Entity(e,t),this.objectHelper.update()}get isComponentRoot(){return this.data.type==="Component"&&typeof this.identity=="string"}get isInstanceRoot(){return this.data.type==="Instance"&&typeof this.identity=="string"}transformAssignData(e,t){let n=t.scene.data.objects.get(e.component);if(n){let s,r;for(let i of Rd.rootOverrideProps)e[i]===void 0?(s===void 0&&(s=ue({},e)),s[i]=n.data[i]):(r===void 0&&(r={}),r[i]=e[i]);return this.overrideData=r,s!=null?s:e}return e}updateByOp(e,t,n,s){let r;if(this.isInstanceRoot&&!s&&(t=this.transformAssignData(t,n),e.type===0&&e.path.length===0&&this.component))for(let i of Rd.rootOverrideProps)i in e.props&&e.props[i]===void 0&&(r===void 0&&(r=De(ue({},e),{props:ue({},e.props)})),r.props[i]=this.component.data[i]);super.updateByOp(r!=null?r:e,t,n,s)}updateState(e,t){this.updateState_Entity(e,t)}expandInstanceChildren(e){var n;let t=this.data;if(this.component===void 0){this.component=(n=e.scene.find(t.component))!=null?n:null;let s=!1;if(this.component!==this.oldComponent){if(this.oldComponent){let r=0;for(let i of this.children)if(fs.is(i))e.scene.disposeAndUnregisterEntityRecursivelyIfNotReregistered(i),gC(i),r+=1;else break;this.children.splice(0,r)}s=!0}this.component&&DL(e,[this.uuid],t.overrides,this,this.component,this.component,0,s),this.oldComponent=this.component}}};function gC(e){if(e.component){let t=e.component.instances.indexOf(e);t>=0&&e.component.instances.splice(t,1);for(let n of e.children)fs.is(n)&&gC(n)}}function kL(e,t,n,s){return e.component===t&&A_(e.identity,s)?e.overrideData===n?2:1:0}function DL(e,t,n,s,r,i,o,a){var c;if(o>50)return!1;if(s.component!==r){if(s.component){let h=s.component.instances.indexOf(s);h>=0&&s.component.instances.splice(h,1)}r.instances.push(s),s.component=r}r instanceof op&&r.isInstanceRoot&&r.expandInstanceChildren(e);let l=0;for(let h of r.children)if(fs.is(h)){let u=[...t,...typeof h.identity=="string"?[h.identity]:h.identity],d=Cv.resolve(n,u,1),p=null,f;if(!a){let g=s.children[l];if(p=fs.is(g)?g:null,p!==null){let m=kL(p,h,d,u);f=m>=1?p.stateSelection:void 0,m!==2&&(p=null)}if(p===null&&(p=(c=e.scene.findInstance(u))!=null?c:null,p!==null)){let m=kL(p,h,d,u);if(f=m>=1?p.stateSelection:void 0,m!==2)p=null;else{let y=p.parent.children.indexOf(p);p.parent.children.splice(y,1),s.children.splice(l,0,p),p.parent===s?y<=l&&console.error("not possible"):(p.parent=s,p.matrixWorldNeedsUpdate=!0,p.resetBBoxNeedsUpdate(),p.updateVisible(),e.pendingDeletes.delete(p))}}}if(p===null){let g=d?Iu.apply(h.data,d):h.data;Mu.is(g.type)&&(g=De(ue({},g),{type:"Empty"})),p=fc.createEntity(u,g,e),p.overrideData=d,s.add(p),s.children.splice(s.children.length-1,1),s.children.splice(l,0,p),p.updateState(p.data,e),f&&p.changeSelectedState(f,e),e.scene.registerInstanceAndSetUuid(p)}l+=1,DL(e,t,n,p,h,i,o+1,a)}if(!a){let h=l;for(;;){let u=s.children[l];if(fs.is(u))e.pendingDeletes.add(u);else break;l+=1}s.children.splice(h,l-h)}return!0}function _ce(e,t,n){let s;return t.geometry.type==="TextGeometry"?new mL(e,t,n):(t.geometry.type==="SubdivGeometry"?s=new Nm(e,t,n):t.geometry.type==="VectorGeometry"?s=new Sce(e,t,n):t.geometry.type==="BooleanGeometry"?s=new ip(e,t,n):s=new $o(e,t,n),s)}function yC(e,t,n){return t.type==="Mesh"?_ce(e,t,n):t.type==="Empty"?new fC(e,t):t.type==="PointLight"?new bce(e,t,n):t.type==="SpotLight"?new wce(e,t,n):t.type==="DirectionalLight"?new xce(e,t,n):t.type==="Component"||t.type==="Instance"?new op(e,t,n):Mu.is(t.type)?new _l(e,t):(console.error(t),new fC(e,t))}fc.createEntity=yC;function Cce(e,t,n){let s=yC(e.identity,t,n),r=e.children,i=e.parent,o=e.component,a=e.instances,l=e.overrideData,c=e.uuid,h=e.stateSelection;e.dispose();for(let u of Object.keys(e))delete e[u];Object.setPrototypeOf(e,Object.getPrototypeOf(s));for(let u of Object.keys(s))e[u]=s[u];e.children=[...e.children,...r],e.parent=i,e.component=o,e.instances=a,e.uuid=c,e.overrideData=l,e.updateState(e.data,n),h&&e.changeSelectedState(h,n),e.resetBBoxNeedsUpdate()}fc.changeEntityProptotype=Cce;fc.Cloner=fx;function Tce(e,t,n,s){e.updateByOp(t,n,s,!1)}function ML(e,t){let n=!1,s=t.getLayersOfType("transmission"),r=t.getLayersOfType("outline");return r.length>0&&(e.layers.set(8),s.length>0&&e.layers.enable(3),n=!0,rC(e),sC(e)),s.length===0&&r.length===0&&e.layers.set(0),n}function PL(e,t){if(!t.layers)return!1;let n=!1,s=t.getLayersOfType("transmission"),r=t.getLayersOfType("outline");return s.length>0&&(e.layers.set(3),r.length>0&&e.layers.enable(8),n=!0),s.length===0&&r.length===0&&e.layers.set(0),n}function Ece(e){let t=!1;return e.traverseEntity(n=>{if(n instanceof cx)if(Array.isArray(n.material))for(let s=0;s<n.material.length;s++)ML(n,n.material[s])&&(t=!0);else ML(n,n.material)&&(t=!0)}),t}function Ace(e){let t=!1;return e.traverseEntity(n=>{if(n instanceof cx)if(Array.isArray(n.material))for(let s=0;s<n.material.length;s++)PL(n,n.material[s])&&(t=!0);else PL(n,n.material)&&(t=!0)}),t}var Ice=new _M,Nce=new et,kce=new td;function Dce(e,t,n){let s=e.cloner;if(s)for(let r of s.children){let i=Nce.copy(r.matrixWorld).invert(),o=kce.copy(t.ray).applyMatrix4(i),a=e.matrixWorld;o.applyMatrix4(a);let l=Ice;l.set(o.origin,o.direction),l.near=t.near,l.far=t.far,l.intersectObject(e,!1).length>0&&n.push({object:e})}}var Mce=e=>`

// PCSS implementation based on:
// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/
// NOTE: This number affects how big the shadow blur can
// possibly get. Bigger number == bigger blur, but less precise results

const float  gPenumbraFilterSize = 80.0;
const int   gPenumbraSamples = ${e};
const int gShadowSamples = ${e};
const float gShadowSamplesRpc = 1.0f / float(gShadowSamples);

vec2 vogelDiskSample(int sample_index, int sample_count, float angle)
{
  const float goldenAngle = 2.399963f; // radians
  float r = sqrt(float(sample_index) + 0.5f) / sqrt(float(sample_count));
  float theta = float(sample_index) * goldenAngle + angle;
  float sine = sin(theta);
  float cosine = cos(theta);
  return vec2(cosine, sine) * r;
}

// NOTE: For now we aren't using this screen-space noise. But we should enable
// it again once we do some sort of temporal AA. Then we could potentially lower
// the number of samples needed and still get a pretty smooth result.
// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso
float getNoiseInterleavedGradient(vec2 screenPos)
{
    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);
    return fract(magic.z * fract(dot(screenPos, magic.xy)));
}

#ifdef USE_SHADOWMAP
    #if NUM_DIR_LIGHT_SHADOWS > 0

        uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
        varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

        struct DirectionalLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

    #endif

    #if NUM_SPOT_LIGHT_SHADOWS > 0

        uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
        varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

        struct SpotLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

    #endif

    #if NUM_POINT_LIGHT_SHADOWS > 0

        uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
        varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

        struct PointLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
            float shadowCameraNear;
            float shadowCameraFar;
        };

        uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

    #endif

    /*
    #if NUM_RECT_AREA_LIGHTS > 0

        // TODO (abelnation): create uniforms for area light shadows

    #endif
    */

float computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)
{
    float penumbra = 1.0;
    float blockerDepthAvg = 0.0;
    float blockerCount = 0.0;

    #pragma unroll_loop_start
    for(int i = 0; i < gPenumbraSamples; i ++)
    {
        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;
        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );

        if(depth < compare + 0.0001)
        {
            blockerDepthAvg += depth;
            blockerCount++;
        }
    }
    #pragma unroll_loop_end

    if (blockerCount > 0.0)
    {
        blockerDepthAvg /= blockerCount;

        // Compute penumbra
        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);
        penumbra *= penumbra;
        penumbra *= 200.0 * penumbraSize[min(index, ${5} - 1)]; // Magic number that affects how quickly the penumbra grows

        return clamp(penumbra, 0.00, 1.0);
    }
    return 0.0;
}

vec4 shadowmod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 shadowperm(vec4 x){return shadowmod289(((x * 34.0) + 1.0) * x);}
float shadowNoise(vec3 p){
            vec3 a = floor(p);
            vec3 d = p - a;
            d = d * d * (3.0 - 2.0 * d);
            vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
            vec4 k1 = shadowperm(b.xyxy);
            vec4 k2 = shadowperm(k1.xyxy + b.zzww);
            vec4 c = k2 + a.zzzz;
            vec4 k3 = shadowperm(c);
            vec4 k4 = shadowperm(c + 1.0);
            vec4 o1 = fract(k3 * (1.0 / 41.0));
            vec4 o2 = fract(k4 * (1.0 / 41.0));
            vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
            vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
            return o4.y * d.y + o4.x * (1.0 - d.y);
        }

float vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)
{
    float shadow         = 0.0f;
    float temporalOffset = shadowNoise(floor(vWPosition * 10.));

    // NOTE: When using TAA, we should use screen space interleaved gradient noise
    //float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy);
    float temporalAngle  = temporalOffset * PI2;

    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);
    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);
    if (penumbra == -1.0) {
        return 1.0;
    }

    #pragma unroll_loop_start
    for (int i = 0; i < gShadowSamples; i++)
    {
        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;
        // Overall blurring offset
        vec2 offset = vogelSample * (shadowRadius * 2.);

        // Penumbra offset
        offset += vogelSample * (penumbra * texelScalar);

        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
    }
    #pragma unroll_loop_end

    return shadow * gShadowSamplesRpc;
}


    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

    }

    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

        return unpackRGBATo2Half( texture2D( shadow, uv ) );

    }

    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

        float occlusion = 1.0;

        vec2 distribution = texture2DDistribution( shadow, uv );

        float hard_shadow = step( compare , distribution.x ); // Hard Shadow

        if (hard_shadow != 1.0 ) {

            float distance = compare - distribution.x ;
            float variance = max( 0.00000, distribution.y * distribution.y );
            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

        }
        return occlusion;

    }

    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

        float shadow = 1.0;

        shadowCoord.xyz /= shadowCoord.w;
        shadowCoord.z += shadowBias;

        // if ( something && something ) breaks ATI OpenGL shader compiler
        // if ( all( something, something ) ) using this instead

        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
        bool inFrustum = all( inFrustumVec );

        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

        bool frustumTest = all( frustumTestVec );

        if ( frustumTest ) {

        #if defined( SHADOWMAP_TYPE_PCF )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );

        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            float dx = texelSize.x;
            float dy = texelSize.y;

            vec2 uv = shadowCoord.xy;
            vec2 f = fract( uv * shadowMapSize + 0.5 );
            uv -= f * texelSize;

            shadow = (
                texture2DCompare( shadowMap, uv, shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
                          f.x ),
                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
                          f.x ),
                     f.y )
            ) * ( 1.0 / 9.0 );

        #elif defined( SHADOWMAP_TYPE_VSM )

            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

        #else // no percentage-closer filtering:

            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

        #endif

        }

        return shadow;

    }

    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
    // vector suitable for 2D texture mapping. This code uses the following layout for the
    // 2D texture:
    //
    // xzXZ
    //  y Y
    //
    // Y - Positive y direction
    // y - Negative y direction
    // X - Positive x direction
    // x - Negative x direction
    // Z - Positive z direction
    // z - Negative z direction
    //
    // Source and test bed:
    // https://gist.github.com/tschw/da10c43c467ce8afd0c4

    vec2 cubeToUV( vec3 v, float texelSizeY ) {

        // Number of texels to avoid at the edge of each square

        vec3 absV = abs( v );

        // Intersect unit cube

        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
        absV *= scaleToCube;

        // Apply scale to avoid seams

        // two texels less per square (one texel will do for NEAREST)
        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

        // Unwrap

        // space: -1 ... 1 range for each square
        //
        // #X##         dim    := ( 4 , 2 )
        //  # #         center := ( 1 , 1 )

        vec2 planar = v.xy;

        float almostATexel = 1.5 * texelSizeY;
        float almostOne = 1.0 - almostATexel;

        if ( absV.z >= almostOne ) {

            if ( v.z > 0.0 )
                planar.x = 4.0 - v.x;

        } else if ( absV.x >= almostOne ) {

            float signX = sign( v.x );
            planar.x = v.z * signX + 2.0 * signX;

        } else if ( absV.y >= almostOne ) {

            float signY = sign( v.y );
            planar.x = v.x + 2.0 * signY + 2.0;
            planar.y = v.z * signY - 2.0;

        }

        // Transform to UV space

        // scale := 0.5 / dim
        // translate := ( center + 0.5 ) / dim
        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

    }

    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

        float shadow = 1.0;
        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

        // for point lights, the uniform @vShadowCoord is re-purposed to hold
        // the vector from the light to the world-space position of the fragment.
        vec3 lightToPosition = shadowCoord.xyz;

        // dp = normalized distance from light to fragment position
        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
        compare += shadowBias;

        // bd3D = base direction 3D
        vec3 bd3D = normalize( lightToPosition );

        float temporalOffset = shadowNoise(floor(vWPosition * 10.));
        float temporalAngle  = temporalOffset * PI2;


        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )
            for (int i = 0; i < gShadowSamples; i++) {
                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;

                // Overall blurring offset
                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);

                // NOTE: Removed for now
                // Penumbra offset
                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);

                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );

            }
            return shadow * gShadowSamplesRpc;

        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )
            for (int i = 0; i < 16; i++) {
                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;

                // Overall blurring offset
                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);

                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );

            }
            return shadow * (1.0 / 16.0);
        #else // no percentage-closer filtering

            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );

        #endif

    }

#endif
`,Pce=zt.lights_fragment_begin,Oce=zt.shadowmask_pars_fragment,OL=!1,Rce=e=>{switch(e){case"low":return 8;case"medium":return 16;case"high":return 32;default:return 16}},Lce=(e="medium")=>{if(OL)return;OL=!0;let t=Rce(e);zt.shadowmap_pars_fragment=Mce(t);let n=Pce.slice();n=n.replace("getShadow( spotShadowMap[ i ]",`getShadow( UNROLLED_LOOP_INDEX + ${3}, spotShadowMap[ i ]`),n=n.replace("getShadow( directionalShadowMap[ i ]","getShadow( UNROLLED_LOOP_INDEX, directionalShadowMap[ i ]"),zt.lights_fragment_begin=n;let s=Oce.slice();s=s.replaceAll("getShadow(","getShadow( UNROLLED_LOOP_INDEX, "),zt.shadowmask_pars_fragment=s},Fce=`
attribute vec3 randomColor;
varying vec3 vNormal;
flat out vec3 vColor;

void main()
{
vNormal = normal;
vColor = randomColor;
gl_Position = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
}
`,$ce=`
uniform float depthContrast;
varying vec3 vNormal;
flat in vec3 vColor;
void main()
{
vec3 normal = (normalize(vNormal)).rgb;

float contrastDepth = (gl_FragCoord.z - 0.5) * depthContrast + 0.5;

vec3 resultColor = mix(mix(vColor, normal, 0.2), vec3(contrastDepth), 0.4);
gl_FragColor = vec4(resultColor, vColor.r);
}
`,vC=new Ms({vertexShader:Fce,fragmentShader:$ce,uniforms:{depthContrast:{value:1}}}),xC=new Rf;xC.wireframe=!0;var RL=new I,LL=class extends _u{constructor(e,t){super();this.data=e,this.backupFog=new XD(16777215,.1,2e3),this.fogUseBGColor=!1,this.enableHelpers=!1,this.wireframeState=!1,this.needsTransmissionDirty=!0,this.needsNormalDirty=!0,this._needsTransmission=!1,this._needsNormal=!1,this.geometryCacheChanged=!1,this.bgColor=new Ni(1,1,1,1),this.entityByUuid={},this.entityIdentityToEntity={},this.toExpandCloner=new Set,this.toUpdateCloner=new Set,this.needsRecomputeInstances=!1,this.ambientLight=new sY(13882323,8553090,.75),this.ambientLight.name="Default Ambient Light",this.ambientLight.layers.enable(3),this.personalCamera=this.createPersonalCamera(),this.activeCamera=this.personalCamera,this.postprocessing=e.postprocessing,this.init(e,t),this.matrixAutoUpdate=!1}markGeometryCacheDirty(){this.geometryCacheChanged=!0}markNeedsUpdateRendererDirty(){this.needsTransmissionDirty=!0,this.needsNormalDirty=!0}needsTransmission(){return this.needsTransmissionDirty&&(this._needsTransmission=Ace(this),this.needsTransmissionDirty=!1),this._needsTransmission}needsNormal(){return this.needsNormalDirty&&(this._needsNormal=Ece(this),this.needsNormalDirty=!1),this._needsNormal}registerInstanceAndSetUuid(e){let t=e.identity.join("-"),n=this.entityIdentityToEntity[t];n&&(e.uuid=n.uuid),this.entityIdentityToEntity[t]=e,this.entityByUuid[e.uuid]=e}findInstance(e){return this.entityIdentityToEntity[e.join("-")]}getWithSortKey(e){let t=this.find(e);if(t===void 0)return;let n=[],s=t;for(;s!==this;){let r=s;s=s.parent;let i=s.children.indexOf(r);n.splice(0,0,i)}return{entity:t,sortKey:n}}getAllSorted(e){let t=[];for(let n of e){let s=this.getWithSortKey(n.id);s!==void 0&&t.push(s)}return t.sort((n,s)=>hie(n.sortKey,s.sortKey)),t.map(n=>n.entity)}nonExistOrDescendantOf(e,t){let n=this.find(e);if(n===void 0)return!0;for(;n;){if(n.uuid===t)return!0;n=n.parent}return!1}find(e){if(e===""||e===void 0)return;let t=this.entityByUuid[e];return t===void 0?this.getObjectByProperty("uuid",e):t}debugEnsureEntity(e){let t=this.find(e);if(t){if(Array.isArray(t.identity)&&this.findInstance(t.identity)===void 0){console.error("not found instance");debugger}}else{console.error("not found");debugger}}addPendingExpandCloner(e){this.toExpandCloner.add(e)}addPendingUpdateCloner(e){this.toUpdateCloner.add(e)}markToExpandCloner(e){this.toExpandCloner.add(e),e.traverseEntityAncestors(t=>{this.toExpandCloner.add(t)})}doPendingExpandCloner(){this.toExpandCloner.forEach(e=>{e.expandCloner(this)}),this.toExpandCloner.clear()}doPendingUpdateCloner(){this.toUpdateCloner.forEach(e=>{var t;(t=e.cloner)==null||t.update()}),this.toUpdateCloner.clear()}doPendingUpdates(){this.doPendingExpandCloner(),this.doPendingUpdateCloner()}updateTreeByOp(e,t){var n;if(e.path.length===0&&e.type===7){let s=e.parent===null?this:this.find(e.parent);if(s===void 0)throw new Error("unexpected");let r=this.createObject(e.id,e.data,e.children,s,e.localIndex,t);r.updateVisible(),r.resetBBoxNeedsUpdate(),Cl(r)&&wc(r.parent)&&(r.invalidateUpstreamBooleanData(),r.parent.invalidateDownstreamBooleanData().recomputeBoolean()),this.markNeedsRecomputeInstancesForAncessors(s),this.markNeedsRecomputeInstancesForChildren(r),this.markToExpandCloner(r)}else if(e.path.length===0&&e.type===8){let s=this.find(e.id);if(s===void 0)throw new Error("unexpected");this.markToExpandCloner(s),s.resetBBoxNeedsUpdate(),this.unregisterObject(s);let r=s.parent;this.markNeedsRecomputeInstancesForAncessors(r),this.markNeedsRecomputeInstancesForChildren(s),s.parent.remove(s),wc(s.parent)&&(s.parent.invalidateUpstreamBooleanData(),s.parent.invalidateDownstreamBooleanData().recomputeBoolean()),Cl(s)&&(s.freeBooleanPointer(),r instanceof ip&&r.invalidateDownstreamBooleanData().recomputeBoolean()),this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(s)}else if(e.path.length===0&&e.type===9){let s=this.find(e.id);if(s===void 0)throw new Error("unexpected");this.markNeedsRecomputeInstancesForChildren(s);let r=s.parent;this.markNeedsRecomputeInstancesForAncessors(r),(n=s.cloner)==null||n.resetOnMove(),this.markToExpandCloner(s);let i=e.parent===null?this:this.find(e.parent);if(i===void 0)throw new Error("unexpected");i.add(s),this.markNeedsRecomputeInstancesForAncessors(i),this.markToExpandCloner(s),s.invalidateClonerTransform(s),s.updateVisible(),s.resetBBoxNeedsUpdate();let o=e.localIndex;i.children.splice(o,0,i.children.pop()),Cl(s)&&(s.invalidateUpstreamBooleanData(),wc(s.parent)?s.parent.invalidateDownstreamBooleanData().recomputeBoolean():r instanceof ip&&r.invalidateDownstreamBooleanData().recomputeBoolean())}this.markNeedsUpdateRendererDirty(),this.markGeometryCacheDirty()}updateEntityByOp(e,t,n,s){if(t.type===0&&(("overrides"in t.props||"component"in t.props)&&this.markNeedsRecomputeInstances(),t.path.includes("overrides")&&"states"in t.props)){let{states:i,rest:o}=t.props;t=De(ue({},t),{props:o}),this.markNeedsRecomputeInstances()}let r=this.find(e);if(r)try{Tce(r,t,n,{scene:this,shared:s}),r instanceof $o&&r.updateGeometryGroupsIfNeeded()}catch(i){console.error(i)}}get enableFog(){return this.fog!==null}set enableFog(e){this.fog=e===!0?this.backupFog:null}init(e,t){if(this.createChildrenObjects(e.objects,this,t),this.personalCamera.removeFromParent(),this.add(this.personalCamera),this.ambientLight.removeFromParent(),this.add(this.ambientLight),this.setBackgroundColor(ki(e.backgroundColor,t)),this.updateFog(e.fog,t),this.updateAmbientLight(e.environment.ambientLight,t),this.activeCamera=this.personalCamera,e.publish.playCamera!==null){let n=this.find(e.publish.playCamera);n instanceof _l&&this.switchActiveCamera(n)}this.expandInstances(t,!0),this.traverseEntity(n=>{wc(n)&&n.recomputeBoolean()}),this.doPendingExpandCloner()}markNeedsRecomputeInstances(){this.needsRecomputeInstances=!0}markNeedsRecomputeInstancesForChildren(e){e.traverseEntity(t=>{(t.data.type==="Component"||t.data.type==="Instance")&&this.markNeedsRecomputeInstances()})}markNeedsRecomputeInstancesForAncessors(e){fs.is(e)&&(e.data.type==="Component"&&this.markNeedsRecomputeInstances(),e.traverseAncestors(t=>{fs.is(t)&&t.data.type==="Component"&&this.markNeedsRecomputeInstances()}))}relativeizeInner(e,t,n,s,r,i,o){e&&e!==s.uuid&&s.find(e)&&r.forInstancesRec(a=>{a.isInstanceRoot||(a.data=uv(a.data,l=>{let c=l.events.data(o.id),h=a.goUp(i);if(h){let u=[...ZP(h.identity),e].join("-"),d=this.entityIdentityToEntity[u];if(d){let p=d.uuid;xa.zoom(c,t)[n]=p}else console.warn("cannot find instance")}}).data)})}rewriteEventsBeforeGoToPlayMode(){this.traverseEntity(e=>{if(e instanceof op&&typeof e.identity=="string"&&e.data.type==="Component")return e.traverseEntity((t,n)=>{t.data.events.forEach(s=>{s.data.type==="GameControl"?t.forInstancesRec(r=>{r.isInstanceRoot||(r.data=uv(r.data,i=>{i.events.delete(s.id)}).data)}):s.data.type==="Conditional"?(s.data.condition.type==="Distance"?(this.relativeizeInner(s.data.condition.fromObject,["condition"],"fromObject",e,t,n,s),this.relativeizeInner(s.data.condition.toObject,["condition"],"toObject",e,t,n,s)):s.data.condition.type==="State"?this.relativeizeInner(s.data.condition.object,["condition"],"object",e,t,n,s):s.data.condition.type==="Comparison"&&(s.data.condition.lOperand.type==="Property"&&this.relativeizeInner(s.data.condition.lOperand.value[0],["condition","lOperand","value"],0,e,t,n,s),s.data.condition.rOperand.type==="Property"&&this.relativeizeInner(s.data.condition.rOperand.value[0],["condition","rOperand","value"],0,e,t,n,s)),s.data.inActions.forEach(r=>{r.data.type==="Transition"&&this.relativeizeInner(r.data.object,["inActions",r.id],"object",e,t,n,s)}),s.data.outActions.forEach(r=>{r.data.type==="Transition"&&this.relativeizeInner(r.data.object,["outActions",r.id],"object",e,t,n,s)})):"actions"in s.data&&s.data.actions.forEach(r=>{r.data.type==="Transition"&&this.relativeizeInner(r.data.object,["actions",r.id],"object",e,t,n,s)})})}),!0})}expandInstances(e,t){let n=new Set;this.traverseEntity(s=>{if(s instanceof op&&s.isInstanceRoot)return s.expandInstanceChildren({scene:this,shared:e,pendingDeletes:n}),t||s.resetBBoxNeedsUpdate(),!0});for(let s of n)this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(s),gC(s)}recomputeInstances(e){this.needsRecomputeInstances&&(this.needsRecomputeInstances=!1,this.traverseEntity(t=>{t instanceof op&&t.isInstanceRoot&&(t.component=void 0)}),this.expandInstances(e,!1))}disposeAndUnregisterEntityRecursivelyIfNotReregistered(e){e.traverseEntity(t=>{let n=typeof t.identity=="string"?t.identity:t.identity.join("-");this.entityIdentityToEntity[n]===t&&(delete this.entityByUuid[t.uuid],delete this.entityIdentityToEntity[n]),t.dispose()})}clearScene(){for(let e of this.children)Ei(e)&&e.disposeRecursively();this.children.length=0}resetAfterClear(e,t){this.init(e,t)}createPersonalCamera(){let e=new _l(LL.PERSONAL_CAMERA_ID,De(ue({},_v.defaultData),{name:"Personal Camera"}));return e.objectHelper.visible=!1,this.registerObjectCreatedInLegacy(e),e}raycast(e){let t=[],n=s=>{for(let r of s.children)Ei(r)&&!r.raycastLock&&r.visible&&((Cl(r)||yce(r)&&this.enableHelpers&&r.objectHelper.visible)&&(e.intersectObject(r,!1,t),Dce(r,e,t)),n(r))};return n(this),t}forEachEntity(e){for(let t of this.children)Ei(t)&&e(t)}traverseEntity(e){for(let t of this.children)Ei(t)&&t.traverseEntity(e)}traverseObject(e){for(let t of this.children)Xv.is(t)&&t.traverseObject(e)}traverseVisibleEntity(e){for(let t of this.children)Ei(t)&&t.visible&&t.traverseVisibleEntity(e)}updateFog(e,t){this.enableFog=e.enabled,this.fogUseBGColor=e.useBackgroundColor,e.useBackgroundColor?this.backupFog.color.set(this.bgColor):this.backupFog.color=ki(e.color,t),this.backupFog.near=e.near,this.backupFog.far=e.far}dispose(){this.clearScene()}updateAmbientLight(e,t){e.color!==void 0&&(this.ambientLight.color=ki(e.color,t)),e.intensity!==void 0&&(this.ambientLight.intensity=e.intensity),e.groundColor!==void 0&&(this.ambientLight.groundColor=ki(e.groundColor,t)),e.enabled!==void 0&&(this.ambientLight.visible=e.enabled)}switchActiveCamera(e){this.activeCamera!==this.personalCamera&&(this.activeCamera.objectHelper.visible=!0),this.activeCamera=e,e.objectHelper.visible=!1}setBackgroundColor(e){this.bgColor=e,this.fogUseBGColor===!0&&(this.backupFog.color=e)}createChildrenObjects(e,t,n){let s=0;for(let r of e)this.createObject(r.id,r.data,r.children,t,s,n),s+=1}registerObjectCreatedInLegacy(e){this.entityByUuid[e.uuid]=e}unregisterObject(e){delete this.entityByUuid[e.uuid];for(let t of e.children)this.unregisterObject(t)}createObject(e,t,n,s,r,i){let o={scene:this,shared:i},a=yC(e,t,o);return a&&(this.entityByUuid[e]=a,s.add(a),s.children.splice(r,0,s.children.pop()),n.length>0&&(a.isInstanceRoot?console.error("instance should not have children!"):this.createChildrenObjects(n,a,i)),a.updateState(t,o),a instanceof $o&&a.updateGeometryGroupsIfNeeded(),a.updateVisible(),a.cloner&&this.toExpandCloner.add(a)),a}getCenter(e){let t=[];for(let s=0,r=e.length;s<r;++s){let{id:i,recursive:o}=e[s],a=this.find(i),l=o?a.recursiveBBox:a.singleBBox;t.push(...l.vertices)}let n=new Ss;return n.setFromPoints(t),n.getCenter(RL),RL}copyMatrixWorld(e,t){if(e===null){t.identity();return}let n=this.find(e);n?t.copy(n.matrixWorld):t.identity()}copyParentMatrixWorld(e,t){var s;if(e===null){t.identity();return}let n=(s=this.find(e))==null?void 0:s.parent;n?t.copy(n.matrixWorld):t.identity()}traverseMaterial(e){this.traverseEntity(t=>{if(t instanceof Ai)if(Array.isArray(t.material))for(let n=0;n<t.material.length;n++)t.material[n]instanceof xc&&e(t.material[n]);else t.material instanceof xc&&e(t.material)})}updateCanvasSize(e,t){this.activeCamera.setViewplaneSize(e,t);let n,s;e>=t?(n=t/e,s=1):(n=1,s=e/t),this.traverseMaterial(r=>{r.getLayersOfType("transmission").forEach(i=>{i.uniforms[`f${i.id}_aspectRatio`].value.x=n,i.uniforms[`f${i.id}_aspectRatio`].value.y=s})})}},vx=LL;vx.PERSONAL_CAMERA_ID="f23858d0-4a3b-4bd8-8173-66ed0af7f6fb-personalCamera";var xx=(e,t)=>{let n=t.x-e.x,s=t.y-e.y;return Math.sqrt(n*n+s*s)},Bce=(e,t)=>{let n=t.x-e.x,s=t.y-e.y;return Uce(Math.atan2(s,n))},zce=(e,t,n)=>{let s={x:0,y:0};return n=bC(n),s.x=e.x-t*Math.cos(n),s.y=e.y-t*Math.sin(n),s},bC=e=>e*(Math.PI/180),Uce=e=>e*(180/Math.PI),Vce=e=>isNaN(e.buttons)?e.pressure!==0:e.buttons!==0,wC=new Map,FL=e=>{wC.has(e)&&clearTimeout(wC.get(e)),wC.set(e,setTimeout(e,100))},bx=(e,t,n)=>{let s=t.split(/[ ,]+/g),r;for(let i=0;i<s.length;i+=1)r=s[i],e.addEventListener?e.addEventListener(r,n,!1):e.attachEvent&&e.attachEvent(r,n)},$L=(e,t,n)=>{let s=t.split(/[ ,]+/g),r;for(let i=0;i<s.length;i+=1)r=s[i],e.removeEventListener?e.removeEventListener(r,n):e.detachEvent&&e.detachEvent(r,n)},BL=e=>(e.preventDefault(),e.type.match(/^touch/)?e.changedTouches:e),zL=()=>{if(typeof window>"u")return;let e=window.pageXOffset!==void 0?window.pageXOffset:(document.documentElement||document.body.parentNode||document.body).scrollLeft,t=window.pageYOffset!==void 0?window.pageYOffset:(document.documentElement||document.body.parentNode||document.body).scrollTop;return{x:e,y:t}},SC=(e,t)=>{t.top||t.right||t.bottom||t.left?(e.style.top=t.top,e.style.right=t.right,e.style.bottom=t.bottom,e.style.left=t.left):(e.style.left=t.x+"px",e.style.top=t.y+"px")},_C=(e,t,n)=>{let s=UL(e);for(let r in s)if(s.hasOwnProperty(r))if(typeof t=="string")s[r]=t+" "+n;else{let i="";for(let o=0,a=t.length;o<a;o+=1)i+=t[o]+" "+n+", ";s[r]=i.slice(0,-2)}return s},Gce=(e,t)=>{let n=UL(e);for(let s in n)n.hasOwnProperty(s)&&(n[s]=t);return n},UL=e=>{let t={};return t[e]="",["webkit","Moz","o"].forEach(function(n){t[n+e.charAt(0).toUpperCase()+e.slice(1)]=""}),t},CC=(e,t)=>{for(let n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);return e},Wce=(e,t)=>{let n={};for(let s in e)e.hasOwnProperty(s)&&t.hasOwnProperty(s)?n[s]=t[s]:e.hasOwnProperty(s)&&(n[s]=e[s]);return n},TC=(e,t)=>{if(e.length)for(let n=0,s=e.length;n<s;n+=1)t(e[n]);else t(e)},Hce=(e,t,n)=>({x:Math.min(Math.max(e.x,t.x-n),t.x+n),y:Math.min(Math.max(e.y,t.y-n),t.y+n)});typeof window<"u"&&(VL="ontouchstart"in window,GL=!!window.PointerEvent,WL=!!window.MSPointerEvent);var VL,GL,WL,Pm={touch:{start:"touchstart",move:"touchmove",end:"touchend, touchcancel"},mouse:{start:"mousedown",move:"mousemove",end:"mouseup"},pointer:{start:"pointerdown",move:"pointermove",end:"pointerup, pointercancel"},MSPointer:{start:"MSPointerDown",move:"MSPointerMove",end:"MSPointerUp"}},ap,Om={};GL?ap=Pm.pointer:WL?ap=Pm.MSPointer:VL?(ap=Pm.touch,Om=Pm.mouse):ap=Pm.mouse;function qu(){}qu.prototype.on=function(e,t){var n=this,s=e.split(/[ ,]+/g),r;n._handlers_=n._handlers_||{};for(var i=0;i<s.length;i+=1)r=s[i],n._handlers_[r]=n._handlers_[r]||[],n._handlers_[r].push(t);return n};qu.prototype.off=function(e,t){var n=this;return n._handlers_=n._handlers_||{},e===void 0?n._handlers_={}:t===void 0?n._handlers_[e]=null:n._handlers_[e]&&n._handlers_[e].indexOf(t)>=0&&n._handlers_[e].splice(n._handlers_[e].indexOf(t),1),n};qu.prototype.trigger=function(e,t){var n=this,s=e.split(/[ ,]+/g),r;n._handlers_=n._handlers_||{};for(var i=0;i<s.length;i+=1)r=s[i],n._handlers_[r]&&n._handlers_[r].length&&n._handlers_[r].forEach(function(o){o.call(n,{type:r,target:n},t)})};qu.prototype.config=function(e){var t=this;t.options=t.defaults||{},e&&(t.options=Wce(t.options,e))};qu.prototype.bindEvt=function(e,t){var n=this;return n._domHandlers_=n._domHandlers_||{},n._domHandlers_[t]=function(){typeof n["on"+t]=="function"?n["on"+t].apply(n,arguments):console.warn('[WARNING] : Missing "on'+t+'" handler.')},bx(e,ap[t],n._domHandlers_[t]),Om[t]&&bx(e,Om[t],n._domHandlers_[t]),n};qu.prototype.unbindEvt=function(e,t){var n=this;return n._domHandlers_=n._domHandlers_||{},$L(e,ap[t],n._domHandlers_[t]),Om[t]&&$L(e,Om[t],n._domHandlers_[t]),delete n._domHandlers_[t],this};var EC=qu;function Rs(e,t){return this.identifier=t.identifier,this.position=t.position,this.frontPosition=t.frontPosition,this.collection=e,this.defaults={size:100,threshold:.1,color:"white",fadeTime:250,dataOnly:!1,restJoystick:!0,restOpacity:1,mode:"dynamic",zone:document.body,lockX:!1,lockY:!1,shape:"circle"},this.config(t),this.options.mode==="dynamic"&&(this.options.restOpacity=0),this.id=Rs.id,Rs.id+=1,this.buildEl().stylize(),this.instance={el:this.ui.el,on:this.on.bind(this),off:this.off.bind(this),show:this.show.bind(this),hide:this.hide.bind(this),add:this.addToDom.bind(this),remove:this.removeFromDom.bind(this),destroy:this.destroy.bind(this),setPosition:this.setPosition.bind(this),resetDirection:this.resetDirection.bind(this),computeDirection:this.computeDirection.bind(this),trigger:this.trigger.bind(this),position:this.position,frontPosition:this.frontPosition,ui:this.ui,identifier:this.identifier,id:this.id,options:this.options},this.instance}Rs.prototype=new EC;Rs.constructor=Rs;Rs.id=0;Rs.prototype.buildEl=function(e){return this.ui={},this.options.dataOnly?this:(this.ui.el=document.createElement("div"),this.ui.back=document.createElement("div"),this.ui.front=document.createElement("div"),this.ui.el.className="nipple collection_"+this.collection.id,this.ui.back.className="back",this.ui.front.className="front",this.ui.el.setAttribute("id","nipple_"+this.collection.id+"_"+this.id),this.ui.el.appendChild(this.ui.back),this.ui.el.appendChild(this.ui.front),this)};Rs.prototype.stylize=function(){if(this.options.dataOnly)return this;var e=this.options.fadeTime+"ms",t=Gce("borderRadius","50%"),n=_C("transition","opacity",e),s={};return s.el={position:"absolute",opacity:this.options.restOpacity,display:"block",zIndex:999},s.back={position:"absolute",display:"block",width:this.options.size+"px",height:this.options.size+"px",marginLeft:-this.options.size/2+"px",marginTop:-this.options.size/2+"px",background:"rgba(255, 255, 255, .4)",border:"solid 2px rgba(0, 0, 0, .1)"},s.front={width:this.options.size/2+"px",height:this.options.size/2+"px",position:"absolute",display:"block",marginLeft:-this.options.size/4+"px",marginTop:-this.options.size/4+"px",background:"rgba(255, 255, 255, .8)",border:"solid 2px rgba(0, 0, 0, .1)"},CC(s.el,n),this.options.shape==="circle"&&CC(s.back,t),CC(s.front,t),this.applyStyles(s),this};Rs.prototype.applyStyles=function(e){for(var t in this.ui)if(this.ui.hasOwnProperty(t))for(var n in e[t])this.ui[t].style[n]=e[t][n];return this};Rs.prototype.addToDom=function(){return this.options.dataOnly||document.body.contains(this.ui.el)?this:(this.options.zone.appendChild(this.ui.el),this)};Rs.prototype.removeFromDom=function(){return this.options.dataOnly||!document.body.contains(this.ui.el)?this:(this.options.zone.removeChild(this.ui.el),this)};Rs.prototype.destroy=function(){clearTimeout(this.removeTimeout),clearTimeout(this.showTimeout),clearTimeout(this.restTimeout),this.trigger("destroyed",this.instance),this.removeFromDom(),this.off()};Rs.prototype.show=function(e){var t=this;return t.options.dataOnly||(clearTimeout(t.removeTimeout),clearTimeout(t.showTimeout),clearTimeout(t.restTimeout),t.addToDom(),t.restCallback(),setTimeout(function(){t.ui.el.style.opacity=1},0),t.showTimeout=setTimeout(function(){t.trigger("shown",t.instance),typeof e=="function"&&e.call(this)},t.options.fadeTime)),t};Rs.prototype.hide=function(e){var t=this;if(t.options.dataOnly)return t;if(t.ui.el.style.opacity=t.options.restOpacity,clearTimeout(t.removeTimeout),clearTimeout(t.showTimeout),clearTimeout(t.restTimeout),t.removeTimeout=setTimeout(function(){var n=t.options.mode==="dynamic"?"none":"block";t.ui.el.style.display=n,typeof e=="function"&&e.call(t),t.trigger("hidden",t.instance)},t.options.fadeTime),t.options.restJoystick){let n=t.options.restJoystick,s={};s.x=n===!0||n.x!==!1?0:t.instance.frontPosition.x,s.y=n===!0||n.y!==!1?0:t.instance.frontPosition.y,t.setPosition(e,s)}return t};Rs.prototype.setPosition=function(e,t){var n=this;n.frontPosition={x:t.x,y:t.y};var s=n.options.fadeTime+"ms",r={};r.front=_C("transition",["top","left"],s);var i={front:{}};i.front={left:n.frontPosition.x+"px",top:n.frontPosition.y+"px"},n.applyStyles(r),n.applyStyles(i),n.restTimeout=setTimeout(function(){typeof e=="function"&&e.call(n),n.restCallback()},n.options.fadeTime)};Rs.prototype.restCallback=function(){var e=this,t={};t.front=_C("transition","none",""),e.applyStyles(t),e.trigger("rested",e.instance)};Rs.prototype.resetDirection=function(){this.direction={x:!1,y:!1,angle:!1}};Rs.prototype.computeDirection=function(e){var t=e.angle.radian,n=Math.PI/4,s=Math.PI/2,r,i,o;if(t>n&&t<n*3&&!e.lockX?r="up":t>-n&&t<=n&&!e.lockY?r="left":t>-n*3&&t<=-n&&!e.lockX?r="down":e.lockY||(r="right"),e.lockY||(t>-s&&t<s?i="left":i="right"),e.lockX||(t>0?o="up":o="down"),e.force>this.options.threshold){var a={},l;for(l in this.direction)this.direction.hasOwnProperty(l)&&(a[l]=this.direction[l]);var c={};this.direction={x:i,y:o,angle:r},e.direction=this.direction;for(l in a)a[l]===this.direction[l]&&(c[l]=!0);if(c.x&&c.y&&c.angle)return e;(!c.x||!c.y)&&this.trigger("plain",e),c.x||this.trigger("plain:"+i,e),c.y||this.trigger("plain:"+o,e),c.angle||this.trigger("dir dir:"+r,e)}else this.resetDirection();return e};var jce=Rs;function ms(e,t){var n=this;n.nipples=[],n.idles=[],n.actives=[],n.ids=[],n.pressureIntervals={},n.manager=e,n.id=ms.id,ms.id+=1,n.defaults={zone:document.body,multitouch:!1,maxNumberOfNipples:10,mode:"dynamic",position:{top:0,left:0},catchDistance:200,size:100,threshold:.1,color:"white",fadeTime:250,dataOnly:!1,restJoystick:!0,restOpacity:1,lockX:!1,lockY:!1,shape:"circle",dynamicPage:!1,follow:!1},n.config(t),(n.options.mode==="static"||n.options.mode==="semi")&&(n.options.multitouch=!1),n.options.multitouch||(n.options.maxNumberOfNipples=1);let s=getComputedStyle(n.options.zone.parentElement);return s&&s.display==="flex"&&(n.parentIsFlex=!0),n.updateBox(),n.prepareNipples(),n.bindings(),n.begin(),n.nipples}ms.prototype=new EC;ms.constructor=ms;ms.id=0;ms.prototype.prepareNipples=function(){var e=this,t=e.nipples;t.on=e.on.bind(e),t.off=e.off.bind(e),t.options=e.options,t.destroy=e.destroy.bind(e),t.ids=e.ids,t.id=e.id,t.processOnMove=e.processOnMove.bind(e),t.processOnEnd=e.processOnEnd.bind(e),t.get=function(n){if(n===void 0)return t[0];for(var s=0,r=t.length;s<r;s+=1)if(t[s].identifier===n)return t[s];return!1}};ms.prototype.bindings=function(){var e=this;e.bindEvt(e.options.zone,"start"),e.options.zone.style.touchAction="none",e.options.zone.style.msTouchAction="none"};ms.prototype.begin=function(){var e=this,t=e.options;if(t.mode==="static"){var n=e.createNipple(t.position,e.manager.getIdentifier());n.add(),e.idles.push(n)}};ms.prototype.createNipple=function(e,t){var n=this,s=n.manager.scroll,r={},i=n.options,o={x:n.parentIsFlex?s.x:s.x+n.box.left,y:n.parentIsFlex?s.y:s.y+n.box.top};if(e.x&&e.y)r={x:e.x-o.x,y:e.y-o.y};else if(e.top||e.right||e.bottom||e.left){var a=document.createElement("DIV");a.style.display="hidden",a.style.top=e.top,a.style.right=e.right,a.style.bottom=e.bottom,a.style.left=e.left,a.style.position="absolute",i.zone.appendChild(a);var l=a.getBoundingClientRect();i.zone.removeChild(a),r=e,e={x:l.left+s.x,y:l.top+s.y}}var c=new jce(n,{color:i.color,size:i.size,threshold:i.threshold,fadeTime:i.fadeTime,dataOnly:i.dataOnly,restJoystick:i.restJoystick,restOpacity:i.restOpacity,mode:i.mode,identifier:t,position:e,zone:i.zone,frontPosition:{x:0,y:0},shape:i.shape});return i.dataOnly||(SC(c.ui.el,r),SC(c.ui.front,c.frontPosition)),n.nipples.push(c),n.trigger("added "+c.identifier+":added",c),n.manager.trigger("added "+c.identifier+":added",c),n.bindNipple(c),c};ms.prototype.updateBox=function(){var e=this;e.box=e.options.zone.getBoundingClientRect()};ms.prototype.bindNipple=function(e){var t=this,n,s=function(r,i){n=r.type+" "+i.id+":"+r.type,t.trigger(n,i)};e.on("destroyed",t.onDestroyed.bind(t)),e.on("shown hidden rested dir plain",s),e.on("dir:up dir:right dir:down dir:left",s),e.on("plain:up plain:right plain:down plain:left",s)};ms.prototype.pressureFn=function(e,t,n){var s=this,r=0;clearInterval(s.pressureIntervals[n]),s.pressureIntervals[n]=setInterval(function(){var i=e.force||e.pressure||e.webkitForce||0;i!==r&&(t.trigger("pressure",i),s.trigger("pressure "+t.identifier+":pressure",i),r=i)}.bind(s),100)};ms.prototype.onstart=function(e){var t=this,n=t.options,s=e;e=BL(e),t.updateBox();var r=function(i){t.actives.length<n.maxNumberOfNipples?t.processOnStart(i):s.type.match(/^touch/)&&(Object.keys(t.manager.ids).forEach(function(o){if(Object.values(s.touches).findIndex(function(l){return l.identifier===o})<0){var a=[e[0]];a.identifier=o,t.processOnEnd(a)}}),t.actives.length<n.maxNumberOfNipples&&t.processOnStart(i))};return TC(e,r),t.manager.bindDocument(),!1};ms.prototype.processOnStart=function(e){var t=this,n=t.options,s,r=t.manager.getIdentifier(e),i=e.force||e.pressure||e.webkitForce||0,o={x:e.pageX,y:e.pageY},a=t.getOrCreate(r,o);a.identifier!==r&&t.manager.removeIdentifier(a.identifier),a.identifier=r;var l=function(h){h.trigger("start",h),t.trigger("start "+h.id+":start",h),h.show(),i>0&&t.pressureFn(e,h,h.identifier),t.processOnMove(e)};if((s=t.idles.indexOf(a))>=0&&t.idles.splice(s,1),t.actives.push(a),t.ids.push(a.identifier),n.mode!=="semi")l(a);else{var c=xx(o,a.position);if(c<=n.catchDistance)l(a);else{a.destroy(),t.processOnStart(e);return}}return a};ms.prototype.getOrCreate=function(e,t){var n=this,s=n.options,r;return/(semi|static)/.test(s.mode)?(r=n.idles[0],r?(n.idles.splice(0,1),r):s.mode==="semi"?n.createNipple(t,e):(console.warn("Coudln't find the needed nipple."),!1)):(r=n.createNipple(t,e),r)};ms.prototype.processOnMove=function(e){var t=this,n=t.options,s=t.manager.getIdentifier(e),r=t.nipples.get(s),i=t.manager.scroll;if(!Vce(e)){this.processOnEnd(e);return}if(!r){console.error("Found zombie joystick with ID "+s),t.manager.removeIdentifier(s);return}if(n.dynamicPage){var o=r.el.getBoundingClientRect();r.position={x:i.x+o.left,y:i.y+o.top}}r.identifier=s;var a=r.options.size/2,l={x:e.pageX,y:e.pageY};n.lockX&&(l.y=r.position.y),n.lockY&&(l.x=r.position.x);var c=xx(l,r.position),h=Bce(l,r.position),u=bC(h),d=c/a,p={distance:c,position:l},f,g;if(r.options.shape==="circle"?(f=Math.min(c,a),g=zce(r.position,f,h)):(g=Hce(l,r.position,a),f=xx(g,r.position)),n.follow){if(c>a){let b=l.x-g.x,x=l.y-g.y;r.position.x+=b,r.position.y+=x,r.el.style.top=r.position.y-(t.box.top+i.y)+"px",r.el.style.left=r.position.x-(t.box.left+i.x)+"px",c=xx(l,r.position)}}else l=g,c=f;var m=l.x-r.position.x,y=l.y-r.position.y;r.frontPosition={x:m,y},n.dataOnly||SC(r.ui.front,r.frontPosition);var v={identifier:r.identifier,position:l,force:d,pressure:e.force||e.pressure||e.webkitForce||0,distance:c,angle:{radian:u,degree:h},vector:{x:m/a,y:-y/a},raw:p,instance:r,lockX:n.lockX,lockY:n.lockY};v=r.computeDirection(v),v.angle={radian:bC(180-h),degree:180-h},r.trigger("move",v),t.trigger("move "+r.id+":move",v)};ms.prototype.processOnEnd=function(e){var t=this,n=t.options,s=t.manager.getIdentifier(e),r=t.nipples.get(s),i=t.manager.removeIdentifier(r.identifier);!r||(n.dataOnly||r.hide(function(){n.mode==="dynamic"&&(r.trigger("removed",r),t.trigger("removed "+r.id+":removed",r),t.manager.trigger("removed "+r.id+":removed",r),r.destroy())}),clearInterval(t.pressureIntervals[r.identifier]),r.resetDirection(),r.trigger("end",r),t.trigger("end "+r.id+":end",r),t.ids.indexOf(r.identifier)>=0&&t.ids.splice(t.ids.indexOf(r.identifier),1),t.actives.indexOf(r)>=0&&t.actives.splice(t.actives.indexOf(r),1),/(semi|static)/.test(n.mode)?t.idles.push(r):t.nipples.indexOf(r)>=0&&t.nipples.splice(t.nipples.indexOf(r),1),t.manager.unbindDocument(),/(semi|static)/.test(n.mode)&&(t.manager.ids[i.id]=i.identifier))};ms.prototype.onDestroyed=function(e,t){var n=this;n.nipples.indexOf(t)>=0&&n.nipples.splice(n.nipples.indexOf(t),1),n.actives.indexOf(t)>=0&&n.actives.splice(n.actives.indexOf(t),1),n.idles.indexOf(t)>=0&&n.idles.splice(n.idles.indexOf(t),1),n.ids.indexOf(t.identifier)>=0&&n.ids.splice(n.ids.indexOf(t.identifier),1),n.manager.removeIdentifier(t.identifier),n.manager.unbindDocument()};ms.prototype.destroy=function(){var e=this;e.unbindEvt(e.options.zone,"start"),e.nipples.forEach(function(n){n.destroy()});for(var t in e.pressureIntervals)e.pressureIntervals.hasOwnProperty(t)&&clearInterval(e.pressureIntervals[t]);e.trigger("destroyed",e.nipples),e.manager.unbindDocument(),e.off()};var qce=ms;function Ks(e){var t=this;t.ids={},t.index=0,t.collections=[],t.scroll=zL(),t.config(e),t.prepareCollections();var n=function(){var r;t.collections.forEach(function(i){i.forEach(function(o){r=o.el.getBoundingClientRect(),o.position={x:t.scroll.x+r.left,y:t.scroll.y+r.top}})})};if(typeof window>"u")return t.collections;bx(window,"resize",function(){FL(n)});var s=function(){t.scroll=zL()};return bx(window,"scroll",function(){FL(s)}),t.collections}Ks.prototype=new EC;Ks.constructor=Ks;Ks.prototype.prepareCollections=function(){var e=this;e.collections.create=e.create.bind(e),e.collections.on=e.on.bind(e),e.collections.off=e.off.bind(e),e.collections.destroy=e.destroy.bind(e),e.collections.get=function(t){var n;return e.collections.every(function(s){return n=s.get(t),!n}),n}};Ks.prototype.create=function(e){return this.createCollection(e)};Ks.prototype.createCollection=function(e){var t=this,n=new qce(t,e);return t.bindCollection(n),t.collections.push(n),n};Ks.prototype.bindCollection=function(e){var t=this,n,s=function(r,i){n=r.type+" "+i.id+":"+r.type,t.trigger(n,i)};e.on("destroyed",t.onDestroyed.bind(t)),e.on("shown hidden rested dir plain",s),e.on("dir:up dir:right dir:down dir:left",s),e.on("plain:up plain:right plain:down plain:left",s)};Ks.prototype.bindDocument=function(){var e=this;e.binded||(e.bindEvt(document,"move").bindEvt(document,"end"),e.binded=!0)};Ks.prototype.unbindDocument=function(e){var t=this;(!Object.keys(t.ids).length||e===!0)&&(t.unbindEvt(document,"move").unbindEvt(document,"end"),t.binded=!1)};Ks.prototype.getIdentifier=function(e){var t;return e?(t=e.identifier===void 0?e.pointerId:e.identifier,t===void 0&&(t=this.latest||0)):t=this.index,this.ids[t]===void 0&&(this.ids[t]=this.index,this.index+=1),this.latest=t,this.ids[t]};Ks.prototype.removeIdentifier=function(e){var t={};for(var n in this.ids)if(this.ids[n]===e){t.id=n,t.identifier=this.ids[n],delete this.ids[n];break}return t};Ks.prototype.onmove=function(e){var t=this;return t.onAny("move",e),!1};Ks.prototype.onend=function(e){var t=this;return t.onAny("end",e),!1};Ks.prototype.oncancel=function(e){var t=this;return t.onAny("end",e),!1};Ks.prototype.onAny=function(e,t){var n=this,s,r="processOn"+e.charAt(0).toUpperCase()+e.slice(1);t=BL(t);var i=function(a,l,c){c.ids.indexOf(l)>=0&&(c[r](a),a._found_=!0)},o=function(a){s=n.getIdentifier(a),TC(n.collections,i.bind(null,a,s)),a._found_||n.removeIdentifier(s)};return TC(t,o),!1};Ks.prototype.destroy=function(){var e=this;e.unbindDocument(!0),e.ids={},e.index=0,e.collections.forEach(function(t){t.destroy()}),e.off()};Ks.prototype.onDestroyed=function(e,t){var n=this;if(n.collections.indexOf(t)<0)return!1;n.collections.splice(n.collections.indexOf(t),1)};var Xce=Ks,HL=new Xce,Kce={create:function(e){return HL.create(e)},factory:HL},Yce=J0(gk());function lp(e,t){let n=new It;if(!e.getAttribute("position"))return n.setAttribute("position",new ot([],3)),n.setIndex([]),n;let{positions:s,triIndices:r}=H2(e.getAttribute("position"),e.getIndex());return n.setAttribute("position",new ot(s,3)),n.setIndex(r),t&&n.applyMatrix4(t),n}var Qce=new et,Zce=new et,La=[[0,0,0],[0,0,0],[0,0,0]];function jL(e){let t=e.elements;La[0][0]=t[0],La[0][1]=t[4],La[0][2]=t[8],La[1][0]=t[1],La[1][1]=t[5],La[1][2]=t[9],La[2][0]=t[2],La[2][1]=t[6],La[2][2]=t[10];let{u:n,v:s}=(0,Yce.SVD)(La),r=Qce.set(n[0][0],n[0][1],n[0][2],0,n[1][0],n[1][1],n[1][2],0,n[2][0],n[2][1],n[2][2],0,0,0,0,1),i=Zce.set(s[0][0],s[0][1],s[0][2],0,s[1][0],s[1][1],s[1][2],0,s[2][0],s[2][1],s[2][2],0,0,0,0,1);return r.multiply(i.transpose())}var Jce=class extends _M{constructor(){super(),this.layers.enable(3),this.layers.enable(8)}setFromCamera(e,t){t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,-1).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):t.isPerspectiveCamera?(this.ray.origin.set(e.x,e.y,-1).unproject(t),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):console.error("Raycaster: Unsupported camera type.")}intersectVisibleObjects(e,t=!0,n=[]){return e.forEach(s=>{s.visible&&this.intersectObject(s,t,n)}),n}createRaycastLineHelper(){let e=new nc({color:65280,linewidth:10}),t=new I(this.ray.origin.x,this.ray.origin.y,this.ray.origin.z),n=new I(this.ray.direction.x,this.ray.direction.y,this.ray.direction.z),s=this.camera.far-this.camera.near,r=new I().addVectors(t,n.multiplyScalar(s)),i=new It;return i.setFromPoints([t,r]),new Ny(i,e)}},qL=e=>e instanceof fC||e instanceof op;function eue(e,t){return e.distance-t.distance}function XL(e,t,n){if(!(!Ei(t)||!t.visible||t.raycastLock)){Cl(t)&&t.raycast(e,n);for(let s of t.children)XL(e,s,n)}}function AC(e,t,n){if(!n.some(r=>wx(e,r)!==void 0))return[];let s=[];return t.children.forEach(r=>XL(e,r,s)),s.sort(eue),s}function IC(e){let t=[];if(e.length){let n=e[0].object;Ei(n)&&t.push(n);let s=n.parent;for(;s;)qL(s)&&t.push(s),s=s.parent}return t}function wx(e,t){if(Cl(t)){if(!t.raycastLock&&t.visible){let n=[];return t.raycast(e,n),n.length?n[0]:void 0}}else if(qL(t))return KL(e,t)}function KL(e,t){if(!(!Ei(t)||!t.visible||t.raycastLock)){if(Cl(t)){let n=[];if(t.raycast(e,n),n.length)return n[0]}for(let n of t.children){let s=KL(e,n);if(s)return s}}}function tue(e){if(e.style.transform!==""){let t=getComputedStyle(e).getPropertyValue("transform");if(t!=="none"){let n=t.replace("matrix(","").split(",");return{x:parseFloat(n[0]),y:parseFloat(n[3])}}}return{x:1,y:1}}function YL(e){let t=e.getViewport(new Bt),n=tue(e.domElement);return{left:t.x*n.x,top:t.y*n.y,width:t.z*n.x,height:t.w*n.y}}function nue(e,t,n,s){let r=n.height-s.height,i=(e-s.left-n.left)*(n.width/s.width),o=(t-r+s.top-n.top)*(n.height/s.height);return{x:i/n.width*2-1,y:-(o/n.height)*2+1}}var sue=class{constructor(e,t,n,s,r,i){this.isExport=i,this.raycaster=new Jce,this.raycasterNeedsUpdate=!0,this.stopRaycast=!1,this.sharedAssets=new lx(Ov.emptyData()),this.scene=new vx(ue({},u2.defaultData),this.sharedAssets),this.camera=new _l,this.renderer=e,this.domElement=e.domElement,this._domRect=this.domElement.getBoundingClientRect(),this._viewRect=YL(this.renderer),this.stopRaycast=r,this.sharedAssets=s,this.scene=t,this.camera=n}get domRect(){return this._domRect}get viewRect(){return this._viewRect}updaterRect(){this._domRect=this.domElement.getBoundingClientRect(),this._viewRect=YL(this.renderer)}updateRaycaster(e){if(!this.raycasterNeedsUpdate)return;this.raycasterNeedsUpdate=!1;let{pageX:t,pageY:n}=e.touches!==void 0&&e.touches.length>0?e.touches[0]:e;this.raycaster.setFromCamera(nue(t,n,this._domRect,this._viewRect),this.camera)}},QL=(e=>(e[e.keydown=0]="keydown",e[e.keyup=1]="keyup",e[e.pointerdown=2]="pointerdown",e[e.pointerup=3]="pointerup",e[e.pointermove=4]="pointermove",e[e.wheel=5]="wheel",e))(QL||{}),Sc=class{constructor(e){this.eventContext=e,this.domEventsNeeded=new Set,this.hasVideoAction=!1}connect(){}disconnect(){}},ZL=new Map,Rm=new Map,cp=class{constructor(e,t,n,s){this.data=t;let{audio:r,volume:i,delay:o,loop:a}=t;if(!r)throw new Error("Missing property");let l=typeof r=="string"?s.getAudio(r).src:r.data;this.audioPlayer=new Am({src:l,volume:i,delay:o,loop:a}),Rm.has(n.uuid)?Rm.get(n.uuid).push(this):Rm.set(n.uuid,[this]),ZL.set(e,this)}playByToggle(){this.data.toggle==="stop"?this.audioPlayer.status==="playing"?this.audioPlayer.stop():(this.audioPlayer.stop(),this.audioPlayer.play()):this.data.toggle==="pause"?this.audioPlayer.status==="playing"?this.audioPlayer.pause():this.audioPlayer.play():(this.audioPlayer.stop(),this.audioPlayer.play())}dispose(){this.audioPlayer.stop()}},NC=class{constructor(e){this.data=e}dispatch(){this.data.playAudio?this.pauseAudio(this.data.playAudio):this.data.object?this.pauseAllAudiosFromObject(this.data.object):this.pauseAllAudios()}pauseAudio(e){let t=ZL.get(e);!t||(this.data.delay>0?(this.disposeDelay(),this.timeoutId=window.setTimeout(()=>{t.audioPlayer[this.data.interaction](),this.disposeDelay()},this.data.delay)):t.audioPlayer[this.data.interaction]())}pauseAllAudiosFromObject(e){let t=Rm.get(e);!(t==null?void 0:t.length)||(this.data.delay>0?(this.disposeDelay(),this.timeoutId=window.setTimeout(()=>{t.forEach(n=>n.audioPlayer[this.data.interaction]()),this.disposeDelay()},this.data.delay)):t.forEach(n=>n.audioPlayer[this.data.interaction]()))}pauseAllAudios(){let e=[...Rm.values()];!e.length||(this.data.delay>0?(this.disposeDelay(),this.timeoutId=window.setTimeout(()=>{e.forEach(t=>{t.forEach(n=>{n.audioPlayer[this.data.interaction]()})}),this.disposeDelay()},this.data.delay)):e.forEach(t=>{t.forEach(n=>{n.audioPlayer[this.data.interaction]()})}))}disposeDelay(){clearTimeout(this.timeoutId),delete this.timeoutId}dispose(){clearTimeout(this.timeoutId),delete this.timeoutId}},up=class{constructor(e,t,n,s){if(this.data=t,t.interaction==="play")this.interaction=new cp(e,t,n,s);else if(t.interaction==="pause"||t.interaction==="stop")this.interaction=new NC(t);else throw new Error("Missing property")}dispatchBasic(){this.interaction instanceof cp?this.interaction.playByToggle():this.interaction.dispatch()}dispatchConditional(){this.interaction instanceof cp?this.interaction.audioPlayer.play():this.interaction.dispatch()}dispatchGameControl(e){this.interaction instanceof cp&&(e==="start"?this.interaction.audioPlayer.play():this.interaction.audioPlayer.stop())}dispose(){this.interaction.dispose()}};function rue(e,t){let n=e.material.layers.find(s=>s.uuid===t);return n.color.texture.image.img instanceof HTMLVideoElement?n.color.texture.image.img:void 0}var JL=new Map,Lm=new Map,Fm=class{constructor(e,t,n){this.data=t,this.delay=0,this.status="stopped";let{layerId:s,loop:r,volume:i,delay:o}=t;if(this.object=n,s===void 0)throw new Error("Missing property");let a=rue(n,s);if(a)this.videoElement=a,this.videoElement.loop=r===1/0,this.videoElement.autoplay=!0,i!==void 0&&(this.videoElement.volume=i);else throw new Error("Missing property");o!==void 0&&(this.delay=o),Lm.has(n.uuid)?Lm.get(n.uuid).push(this):Lm.set(n.uuid,[this]),JL.set(e,this),this.pause()}mute(){this.videoElement.muted=!0}unMute(){this.videoElement.muted=!1}play(e){let t=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);e?this.mute():t?(this.mute(),window.setTimeout(()=>{this.unMute()},100)):this.unMute(),this.delayTimerId=window.setTimeout(()=>{this.videoElement.play(),this.clearDelay()},this.delay),this.status="playing"}clearDelay(){this.delayTimerId&&(clearTimeout(this.delayTimerId),delete this.delayTimerId)}pause(){this.videoElement.pause(),this.status="paused"}stop(){this.videoElement.pause(),this.videoElement.currentTime=0,this.status="stopped",this.clearDelay()}playByToggle(){this.data.toggle==="stop"?this.status==="playing"?this.stop():(this.stop(),this.play()):this.data.toggle==="pause"?this.status==="playing"?this.pause():this.play():(this.stop(),this.play())}dispose(){this.stop(),this.videoElement.muted=!0}},kC=class{constructor(e){this.data=e}dispatch(){this.data.playVideo?this.pauseVideo(this.data.playVideo):this.data.object?this.pauseAllVideosFromObject(this.data.object):this.pauseAllVideos()}pauseVideo(e){let t=JL.get(e);!t||(this.data.delay>0?(this.disposeDelay(),this.timeoutId=window.setTimeout(()=>{t[this.data.interaction](),this.disposeDelay()},this.data.delay)):t[this.data.interaction]())}pauseAllVideosFromObject(e){let t=Lm.get(e);!(t==null?void 0:t.length)||(this.data.delay>0?(this.disposeDelay(),this.timeoutId=window.setTimeout(()=>{t.forEach(n=>n[this.data.interaction]()),this.disposeDelay()},this.data.delay)):t.forEach(n=>n[this.data.interaction]()))}pauseAllVideos(){let e=[...Lm.values()];!e.length||(this.data.delay>0?(this.disposeDelay(),this.timeoutId=window.setTimeout(()=>{e.forEach(t=>{t.forEach(n=>{n[this.data.interaction]()})}),this.disposeDelay()},this.data.delay)):e.forEach(t=>{t.forEach(n=>{n[this.data.interaction]()})}))}disposeDelay(){clearTimeout(this.timeoutId),delete this.timeoutId}dispose(){clearTimeout(this.timeoutId),delete this.timeoutId}},Sx=class{constructor(e,t,n){if(this.data=t,t.interaction==="play")this.interaction=new Fm(e,t,n);else if(t.interaction==="pause"||t.interaction==="stop")this.interaction=new kC(t);else throw new Error("Missing property")}dispatchBasic(){this.interaction instanceof Fm?this.interaction.playByToggle():this.interaction.dispatch()}dispatchConditional(){this.interaction instanceof Fm?this.interaction.play():this.interaction.dispatch()}dispose(){this.interaction.dispose()}},iue="text/plain",oue="us-ascii",eF=(e,t)=>t.some(n=>n instanceof RegExp?n.test(e):n===e),aue=(e,{stripHash:t})=>{let n=/^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(e);if(!n)throw new Error(`Invalid URL: ${e}`);let{type:s,data:r,hash:i}=n.groups,o=s.split(";");i=t?"":i;let a=!1;o[o.length-1]==="base64"&&(o.pop(),a=!0);let l=(o.shift()||"").toLowerCase(),c=[...o.map(h=>{let[u,d=""]=h.split("=").map(p=>p.trim());return u==="charset"&&(d=d.toLowerCase(),d===oue)?"":`${u}${d?`=${d}`:""}`}).filter(Boolean)];return a&&c.push("base64"),(c.length>0||l&&l!==iue)&&c.unshift(l),`data:${c.join(";")},${a?r.trim():r}${i?`#${i}`:""}`};function lue(e,t){if(t=ue({defaultProtocol:"http:",normalizeProtocol:!0,forceHttp:!1,forceHttps:!1,stripAuthentication:!0,stripHash:!1,stripTextFragment:!0,stripWWW:!0,removeQueryParameters:[/^utm_\w+/i],removeTrailingSlash:!0,removeSingleSlash:!0,removeDirectoryIndex:!1,sortQueryParameters:!0},t),e=e.trim(),/^data:/i.test(e))return aue(e,t);if(/^view-source:/i.test(e))throw new Error("`view-source:` is not supported as it is a non-standard protocol");let n=e.startsWith("//");!n&&/^\.*\//.test(e)||(e=e.replace(/^(?!(?:\w+:)?\/\/)|^\/\//,t.defaultProtocol));let s=new URL(e);if(t.forceHttp&&t.forceHttps)throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");if(t.forceHttp&&s.protocol==="https:"&&(s.protocol="http:"),t.forceHttps&&s.protocol==="http:"&&(s.protocol="https:"),t.stripAuthentication&&(s.username="",s.password=""),t.stripHash?s.hash="":t.stripTextFragment&&(s.hash=s.hash.replace(/#?:~:text.*?$/i,"")),s.pathname){let i=/\b[a-z][a-z\d+\-.]{1,50}:\/\//g,o=0,a="";for(;;){let c=i.exec(s.pathname);if(!c)break;let h=c[0],u=c.index;a+=s.pathname.slice(o,u).replace(/\/{2,}/g,"/"),a+=h,o=u+h.length}a+=s.pathname.slice(o,s.pathname.length).replace(/\/{2,}/g,"/"),s.pathname=a}if(s.pathname)try{s.pathname=decodeURI(s.pathname)}catch{}if(t.removeDirectoryIndex===!0&&(t.removeDirectoryIndex=[/^index\.[a-z]+$/]),Array.isArray(t.removeDirectoryIndex)&&t.removeDirectoryIndex.length>0){let i=s.pathname.split("/"),o=i[i.length-1];eF(o,t.removeDirectoryIndex)&&(i=i.slice(0,-1),s.pathname=i.slice(1).join("/")+"/")}if(s.hostname&&(s.hostname=s.hostname.replace(/\.$/,""),t.stripWWW&&/^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(s.hostname)&&(s.hostname=s.hostname.replace(/^www\./,""))),Array.isArray(t.removeQueryParameters))for(let i of[...s.searchParams.keys()])eF(i,t.removeQueryParameters)&&s.searchParams.delete(i);if(t.removeQueryParameters===!0&&(s.search=""),t.sortQueryParameters){s.searchParams.sort();try{s.search=decodeURIComponent(s.search)}catch{}}t.removeTrailingSlash&&(s.pathname=s.pathname.replace(/\/$/,""));let r=e;return e=s.toString(),!t.removeSingleSlash&&s.pathname==="/"&&!r.endsWith("/")&&s.hash===""&&(e=e.replace(/\/$/,"")),(t.removeTrailingSlash||s.pathname==="/")&&s.hash===""&&t.removeSingleSlash&&(e=e.replace(/\/$/,"")),n&&!t.normalizeProtocol&&(e=e.replace(/^http:\/\//,"//")),t.stripProtocol&&(e=e.replace(/^(?:https?:)?\/\//,"")),e}var cue=class{constructor({url:e,context:t},n){if(this.managers=n,!e)throw new Error("Missing property");this.url=e.startsWith("mailto:")?e:lue(e),this.context=t!=null?t:"tab"}dispatch(){var e;l2?window.location.assign(this.url):(this.context==="tab"?window.open(this.url,"_blank"):this.context==="window"?window.open(this.url,"_blank",`width=${window.innerWidth}, height=${window.innerHeight}`):window.open(this.url,"_parent"),(e=this.managers.controlsManager.orbitControls)==null||e.onPointerUp(Pt[0]),die())}},uue=class{constructor(e,t,n,s){this.scene=t,this.sharedAssets=n,this.sceneData=e,this.managers=s}dispatch(){var e,t,n;DF(this.sceneData,this.scene,this.sharedAssets,!0),(e=this.managers.eventManager)==null||e.reset(),(t=this.managers.controlsManager.orbitControls)==null||t.reset(),(n=this.managers.controlsManager)==null||n.gameControls.forEach(s=>s.reset(!0))}},tF={update:null,begin:null,loopBegin:null,changeBegin:null,change:null,changeComplete:null,loopComplete:null,complete:null,loop:1,direction:"normal",autoplay:!0,timelineOffset:0,rewind:!0},DC={duration:1e3,delay:0,endDelay:0,easing:"easeOutElastic(1, .5)",round:0},hue=["translateX","translateY","translateZ","rotate","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ","skew","skewX","skewY","perspective","matrix","matrix3d"],_x={CSS:{},springs:{}};function Fa(e,t,n){return Math.min(Math.max(e,t),n)}function $m(e,t){return e.indexOf(t)>-1}function MC(e,t){return e.apply(null,t)}var Tt={arr:function(e){return Array.isArray(e)},obj:function(e){return $m(Object.prototype.toString.call(e),"Object")},pth:function(e){return Tt.obj(e)&&e.hasOwnProperty("totalLength")},svg:function(e){return e instanceof SVGElement},inp:function(e){return e instanceof HTMLInputElement},dom:function(e){return!("isNode"in e)&&(e.nodeType||Tt.svg(e))},str:function(e){return typeof e=="string"},fnc:function(e){return typeof e=="function"},und:function(e){return typeof e>"u"},hex:function(e){return/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(e)},rgb:function(e){return/^rgb/.test(e)},hsl:function(e){return/^hsl/.test(e)},col:function(e){return Tt.hex(e)||Tt.rgb(e)||Tt.hsl(e)},key:function(e){return!tF.hasOwnProperty(e)&&!DC.hasOwnProperty(e)&&e!=="targets"&&e!=="keyframes"}};function nF(e){var t=/\(([^)]+)\)/.exec(e);return t?t[1].split(",").map(function(n){return parseFloat(n)}):[]}function sF(e,t){var n=nF(e),s=Fa(Tt.und(n[0])?1:n[0],.1,100),r=Fa(Tt.und(n[1])?100:n[1],.1,100),i=Fa(Tt.und(n[2])?10:n[2],.1,100),o=Fa(Tt.und(n[3])?0:n[3],.1,100),a=Math.sqrt(r/s),l=i/(2*Math.sqrt(r*s)),c=l<1?a*Math.sqrt(1-l*l):0,h=1,u=l<1?(l*a+-o)/c:-o+a;function d(f){var g=t?t*f/1e3:f;return l<1?g=Math.exp(-g*l*a)*(h*Math.cos(c*g)+u*Math.sin(c*g)):g=(h+u*g)*Math.exp(-g*a),f===0||f===1?f:1-g}function p(){var f=_x.springs[e];if(f)return f;for(var g=1/6,m=0,y=0;;)if(m+=g,d(m)===1){if(y++,y>=16)break}else y=0;var v=m*g*1e3;return _x.springs[e]=v,v}return t?d:p}function due(e){return e===void 0&&(e=10),function(t){return Math.ceil(Fa(t,1e-6,1)*e)*(1/e)}}var pue=function(){var e=11,t=1/(e-1);function n(h,u){return 1-3*u+3*h}function s(h,u){return 3*u-6*h}function r(h){return 3*h}function i(h,u,d){return((n(u,d)*h+s(u,d))*h+r(u))*h}function o(h,u,d){return 3*n(u,d)*h*h+2*s(u,d)*h+r(u)}function a(h,u,d,p,f){var g,m,y=0;do m=u+(d-u)/2,g=i(m,p,f)-h,g>0?d=m:u=m;while(Math.abs(g)>1e-7&&++y<10);return m}function l(h,u,d,p){for(var f=0;f<4;++f){var g=o(u,d,p);if(g===0)return u;var m=i(u,d,p)-h;u-=m/g}return u}function c(h,u,d,p){if(!(0<=h&&h<=1&&0<=d&&d<=1))return;var f=new Float32Array(e);if(h!==u||d!==p)for(var g=0;g<e;++g)f[g]=i(g*t,h,d);function m(y){for(var v=0,b=1,x=e-1;b!==x&&f[b]<=y;++b)v+=t;--b;var w=(y-f[b])/(f[b+1]-f[b]),S=v+w*t,C=o(S,h,d);return C>=.001?l(y,S,h,d):C===0?S:a(y,v,v+t,h,d)}return function(y){return h===u&&d===p||y===0||y===1?y:i(m(y),u,p)}}return c}(),rF=function(){var e={linear:function(){return function(s){return s}}},t={Sine:function(){return function(s){return 1-Math.cos(s*Math.PI/2)}},Circ:function(){return function(s){return 1-Math.sqrt(1-s*s)}},Back:function(){return function(s){return s*s*(3*s-2)}},Bounce:function(){return function(s){for(var r,i=4;s<((r=Math.pow(2,--i))-1)/11;);return 1/Math.pow(4,3-i)-7.5625*Math.pow((r*3-2)/22-s,2)}},Elastic:function(s,r){s===void 0&&(s=1),r===void 0&&(r=.5);var i=Fa(s,1,10),o=Fa(r,.1,2);return function(a){return a===0||a===1?a:-i*Math.pow(2,10*(a-1))*Math.sin((a-1-o/(Math.PI*2)*Math.asin(1/i))*(Math.PI*2)/o)}}},n=["Quad","Cubic","Quart","Quint","Expo"];return n.forEach(function(s,r){t[s]=function(){return function(i){return Math.pow(i,r+2)}}}),Object.keys(t).forEach(function(s){var r=t[s];e["easeIn"+s]=r,e["easeOut"+s]=function(i,o){return function(a){return 1-r(i,o)(1-a)}},e["easeInOut"+s]=function(i,o){return function(a){return a<.5?r(i,o)(a*2)/2:1-r(i,o)(a*-2+2)/2}}}),e}();function PC(e,t){if(Tt.fnc(e))return e;var n=e.split("(")[0],s=rF[n],r=nF(e);switch(n){case"spring":return sF(e,t);case"cubicBezier":return MC(pue,r);case"steps":return MC(due,r);default:return MC(s,r)}}function iF(e){try{var t=document.querySelectorAll(e);return t}catch{return}}function Cx(e,t){for(var n=e.length,s=arguments.length>=2?arguments[1]:void 0,r=[],i=0;i<n;i++)if(i in e){var o=e[i];t.call(s,o,i,e)&&r.push(o)}return r}function Tx(e){return e.reduce(function(t,n){return t.concat(Tt.arr(n)?Tx(n):n)},[])}function oF(e){return Tt.arr(e)?e:(Tt.str(e)&&(e=iF(e)||e),e instanceof NodeList||e instanceof HTMLCollection?[].slice.call(e):[e])}function OC(e,t){return e.some(function(n){return n===t})}function RC(e){var t={};for(var n in e)t[n]=e[n];return t}function LC(e,t){var n=RC(e);for(var s in e)n[s]=t.hasOwnProperty(s)?t[s]:e[s];return n}function Ex(e,t){var n=RC(e);for(var s in t)n[s]=Tt.und(e[s])?t[s]:e[s];return n}function fue(e){var t=/rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(e);return t?"rgba("+t[1]+",1)":e}function mue(e){var t=/^#?([a-f\d])([a-f\d])([a-f\d])$/i,n=e.replace(t,function(a,l,c,h){return l+l+c+c+h+h}),s=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(n),r=parseInt(s[1],16),i=parseInt(s[2],16),o=parseInt(s[3],16);return"rgba("+r+","+i+","+o+",1)"}function gue(e){var t=/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(e)||/hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(e),n=parseInt(t[1],10)/360,s=parseInt(t[2],10)/100,r=parseInt(t[3],10)/100,i=t[4]||1;function o(d,p,f){return f<0&&(f+=1),f>1&&(f-=1),f<1/6?d+(p-d)*6*f:f<1/2?p:f<2/3?d+(p-d)*(2/3-f)*6:d}var a,l,c;if(s==0)a=l=c=r;else{var h=r<.5?r*(1+s):r+s-r*s,u=2*r-h;a=o(u,h,n+1/3),l=o(u,h,n),c=o(u,h,n-1/3)}return"rgba("+a*255+","+l*255+","+c*255+","+i+")"}function yue(e){if(Tt.rgb(e))return fue(e);if(Tt.hex(e))return mue(e);if(Tt.hsl(e))return gue(e)}function Tl(e){var t=/[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(e);if(t)return t[1]}function vue(e){if($m(e,"translate")||e==="perspective")return"px";if($m(e,"rotate")||$m(e,"skew"))return"deg"}function FC(e,t){return Tt.fnc(e)?e(t.target,t.id,t.total):e}function $a(e,t){return e.getAttribute(t)}function $C(e,t,n){var s=Tl(t);if(OC([n,"deg","rad","turn"],s))return t;var r=_x.CSS[t+n];if(!Tt.und(r))return r;var i=100,o=document.createElement(e.tagName),a=e.parentNode&&e.parentNode!==document?e.parentNode:document.body;a.appendChild(o),o.style.position="absolute",o.style.width=i+n;var l=i/o.offsetWidth;a.removeChild(o);var c=l*parseFloat(t);return _x.CSS[t+n]=c,c}function aF(e,t,n){if(t in e.style){var s=t.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),r=e.style[t]||getComputedStyle(e).getPropertyValue(s)||"0";return n?$C(e,r,n):r}}function BC(e,t){if(Tt.dom(e)&&!Tt.inp(e)&&($a(e,t)||Tt.svg(e)&&e[t]))return"attribute";if(Tt.dom(e)&&OC(hue,t))return"transform";if(Tt.dom(e)&&t!=="transform"&&aF(e,t))return"css";if(e[t]!=null)return"object"}function lF(e){if(Tt.dom(e)){for(var t=e.style.transform||"",n=/(\w+)\(([^)]*)\)/g,s=new Map,r;r=n.exec(t);)s.set(r[1],r[2]);return s}}function xue(e,t,n,s){var r=$m(t,"scale")?1:0+vue(t),i=lF(e).get(t)||r;return n&&(n.transforms.list.set(t,i),n.transforms.last=t),s?$C(e,i,s):i}function zC(e,t,n,s){switch(BC(e,t)){case"transform":return xue(e,t,s,n);case"css":return aF(e,t,n);case"attribute":return $a(e,t);default:return e[t]||0}}function UC(e,t){var n=/^(\*=|\+=|-=)/.exec(e);if(!n)return e;var s=Tl(e)||0,r=parseFloat(t),i=parseFloat(e.replace(n[0],""));switch(n[0][0]){case"+":return r+i+s;case"-":return r-i+s;case"*":return r*i+s}}function cF(e,t){if(Tt.col(e))return yue(e);if(/\s/g.test(e))return e;var n=Tl(e),s=n?e.substr(0,e.length-n.length):e;return t?s+t:s}function VC(e,t){return Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2))}function bue(e){return Math.PI*2*$a(e,"r")}function wue(e){return $a(e,"width")*2+$a(e,"height")*2}function Sue(e){return VC({x:$a(e,"x1"),y:$a(e,"y1")},{x:$a(e,"x2"),y:$a(e,"y2")})}function uF(e){for(var t=e.points,n=0,s,r=0;r<t.numberOfItems;r++){var i=t.getItem(r);r>0&&(n+=VC(s,i)),s=i}return n}function _ue(e){var t=e.points;return uF(e)+VC(t.getItem(t.numberOfItems-1),t.getItem(0))}function hF(e){if(e.getTotalLength)return e.getTotalLength();switch(e.tagName.toLowerCase()){case"circle":return bue(e);case"rect":return wue(e);case"line":return Sue(e);case"polyline":return uF(e);case"polygon":return _ue(e)}}function Cue(e){var t=hF(e);return e.setAttribute("stroke-dasharray",t),t}function Tue(e){for(var t=e.parentNode;Tt.svg(t)&&Tt.svg(t.parentNode);)t=t.parentNode;return t}function dF(e,t){var n=t||{},s=n.el||Tue(e),r=s.getBoundingClientRect(),i=$a(s,"viewBox"),o=r.width,a=r.height,l=n.viewBox||(i?i.split(" "):[0,0,o,a]);return{el:s,viewBox:l,x:l[0]/1,y:l[1]/1,w:o/l[2],h:a/l[3]}}function Eue(e,t){var n=Tt.str(e)?iF(e)[0]:e,s=t||100;return function(r){return{property:r,el:n,svg:dF(n),totalLength:hF(n)*(s/100)}}}function Aue(e,t){function n(a){a===void 0&&(a=0);var l=t+a>=1?t+a:0;return e.el.getPointAtLength(l)}var s=dF(e.el,e.svg),r=n(),i=n(-1),o=n(1);switch(e.property){case"x":return(r.x-s.x)*s.w;case"y":return(r.y-s.y)*s.h;case"angle":return Math.atan2(o.y-i.y,o.x-i.x)*180/Math.PI}}function pF(e,t){var n=/[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g,s=cF(Tt.pth(e)?e.totalLength:e,t)+"";return{original:s,numbers:s.match(n)?s.match(n).map(Number):[0],strings:Tt.str(e)||t?s.split(n):[]}}function fF(e){var t=e?Tx(Tt.arr(e)?e.map(oF):oF(e)):[];return Cx(t,function(n,s,r){return r.indexOf(n)===s})}function mF(e){var t=fF(e);return t.map(function(n,s){return{target:n,id:s,total:t.length,transforms:{list:lF(n)}}})}function Iue(e,t){var n=RC(t);if(/^spring/.test(n.easing)&&(n.duration=sF(n.easing)),Tt.arr(e)){var s=e.length,r=s===2&&!Tt.obj(e[0]);r?e={value:e}:Tt.fnc(t.duration)||(n.duration=t.duration/s)}var i=Tt.arr(e)?e:[e];return i.map(function(o,a){var l=Tt.obj(o)&&!Tt.pth(o)?o:{value:o};return Tt.und(l.delay)&&(l.delay=a?0:t.delay),Tt.und(l.endDelay)&&(l.endDelay=a===i.length-1?t.endDelay:0),l}).map(function(o){return Ex(o,n)})}function Nue(e){for(var t=Cx(Tx(e.map(function(i){return Object.keys(i)})),function(i){return Tt.key(i)}).reduce(function(i,o){return i.indexOf(o)<0&&i.push(o),i},[]),n={},s=function(i){var o=t[i];n[o]=e.map(function(a){var l={};for(var c in a)Tt.key(c)?c==o&&(l.value=a[c]):l[c]=a[c];return l})},r=0;r<t.length;r++)s(r);return n}function kue(e,t){var n=[],s=t.keyframes;s&&(t=Ex(Nue(s),t));for(var r in t)Tt.key(r)&&n.push({name:r,tweens:Iue(t[r],e)});return n}function Due(e,t){var n={};for(var s in e){var r=FC(e[s],t);Tt.arr(r)&&(r=r.map(function(i){return FC(i,t)}),r.length===1&&(r=r[0])),n[s]=r}return n.duration=parseFloat(n.duration),n.delay=parseFloat(n.delay),n}function Mue(e,t){var n;return e.tweens.map(function(s){var r=Due(s,t),i=r.value,o=Tt.arr(i)?i[1]:i,a=Tl(o),l=zC(t.target,e.name,a,t),c=n?n.to.original:l,h=Tt.arr(i)?i[0]:c,u=Tl(h)||Tl(l),d=a||u;return Tt.und(o)&&(o=c),r.from=pF(h,d),r.to=pF(UC(o,h),d),r.start=n?n.end:0,r.end=r.start+r.delay+r.duration+r.endDelay,r.easing=PC(r.easing,r.duration),r.isPath=Tt.pth(i),r.isColor=Tt.col(r.from.original),r.isColor&&(r.round=1),n=r,r})}var gF={css:function(e,t,n){return e.style[t]=n},attribute:function(e,t,n){return e.setAttribute(t,n)},object:function(e,t,n){return e[t]=n},transform:function(e,t,n,s,r){if(s.list.set(t,n),t===s.last||r){var i="";s.list.forEach(function(o,a){i+=a+"("+o+") "}),e.style.transform=i}}};function yF(e,t){var n=mF(e);n.forEach(function(s){for(var r in t){var i=FC(t[r],s),o=s.target,a=Tl(i),l=zC(o,r,a,s),c=a||Tl(l),h=UC(cF(i,c),l),u=BC(o,r);gF[u](o,r,h,s.transforms,!0)}})}function Pue(e,t){var n=BC(e.target,t.name);if(n){var s=Mue(t,e),r=s[s.length-1];return{type:n,property:t.name,animatable:e,tweens:s,duration:r.end,delay:s[0].delay,endDelay:r.endDelay}}}function Oue(e,t){return Cx(Tx(e.map(function(n){return t.map(function(s){return Pue(n,s)})})),function(n){return!Tt.und(n)})}function vF(e,t){var n=e.length,s=function(i){return i.timelineOffset?i.timelineOffset:0},r={};return r.duration=n?Math.max.apply(Math,e.map(function(i){return s(i)+i.duration})):t.duration,r.delay=n?Math.min.apply(Math,e.map(function(i){return s(i)+i.delay})):t.delay,r.endDelay=n?r.duration-Math.max.apply(Math,e.map(function(i){return s(i)+i.duration-i.endDelay})):t.endDelay,r}var xF=0;function Rue(e){var t=LC(tF,e),n=LC(DC,e),s=kue(n,e),r=mF(e.targets),i=Oue(r,s),o=vF(i,n),a=xF;return xF++,Ex(t,{id:a,children:[],animatables:r,animations:i,duration:o.duration,delay:o.delay,endDelay:o.endDelay})}var ro=[],bF=[],Ax,Lue=function(){function e(){Ax=requestAnimationFrame(t)}function t(n){var s=ro.length;if(s){for(var r=0;r<s;){var i=ro[r];i.paused?(ro.splice(r,1),s-=1):(i.tick(n),r++)}e()}else Ax=cancelAnimationFrame(Ax)}return e}();function Fue(){document.hidden?(ro.forEach(function(e){return e.pause()}),bF=ro.slice(0),Cs.running=ro=[]):bF.forEach(function(e){return e.play()})}typeof document<"u"&&document.addEventListener("visibilitychange",Fue);function Cs(e){e===void 0&&(e={});var t=0,n=0,s=0,r,i=0,o=null;function a(v){var b=window.Promise&&new Promise(function(x){return o=x});return v.finished=b,b}var l=Rue(e);a(l);function c(){var v=l.direction;v!=="alternate"&&(l.direction=v!=="normal"?"normal":"reverse"),l.reversed=!l.reversed,r.forEach(function(b){return b.reversed=l.reversed})}function h(v){return l.reversed?l.duration-v:v}function u(){t=0,n=h(l.currentTime)*(1/Cs.speed)}function d(v,b){b&&b.seek(v-b.timelineOffset)}function p(v){if(l.reversePlayback)for(var b=i;b--;)d(v,r[b]);else for(var x=0;x<i;x++)d(v,r[x])}function f(v){var b=0,x=l.animations,w=x.length;for(l.reversePlayback===!0&&l.rewind===!1&&(v=l.duration+l.delay-l.endDelay-v);b<w;){var S=x[b],C=S.animatable,_=S.tweens,T=_.length-1,E=_[T];T&&(E=Cx(_,function(X){return v<X.end})[0]||E);for(var A=Fa(v-E.start-E.delay,0,E.duration)/E.duration,D=isNaN(A)?1:E.easing(A),O=E.to.strings,P=E.round,L=[],B=E.to.numbers.length,F=void 0,M=0;M<B;M++){var U=void 0;if(l.reversePlayback===!0&&l.rewind===!1)var z=E.to.numbers[M],$=E.from.numbers[M]||0;else var $=E.to.numbers[M],z=E.from.numbers[M]||0;E.isPath?U=Aue(E.value,D*$):U=z+D*($-z),P&&(E.isColor&&M>2||(U=Math.round(U*P)/P)),L.push(U)}var R=O.length;if(!R)F=L[0];else{F=O[0];for(var H=0;H<R;H++){O[H];var K=O[H+1],Y=L[H];isNaN(Y)||(K?F+=Y+K:F+=Y+" ")}}gF[S.type](C.target,S.property,F,C.transforms),S.currentValue=F,b++}}function g(v){l[v]&&!l.passThrough&&l[v](l)}function m(){l.remaining&&l.remaining!==!0&&l.remaining--}function y(v){var b=l.duration,x=l.delay,w=b-l.endDelay,S=h(v);l.progress=Fa(S/b*100,0,100),l.reversePlayback=S<l.currentTime,r&&p(S),!l.began&&l.currentTime>=0&&(l.began=!0,g("begin")),!l.loopBegan&&l.currentTime>0&&(l.loopBegan=!0,g("loopBegin")),S<=x&&l.currentTime!==0&&(f(0),g("change")),(S>=w&&l.currentTime!==b||!b)&&(f(b),g("change")),S>x&&S<w?(l.changeBegan||(l.changeBegan=!0,l.changeCompleted=!1,g("changeBegin")),g("change"),f(S)):l.changeBegan?(l.changeCompleted=!0,l.changeBegan=!1,g("change"),g("changeComplete")):l.began&&S>w&&(g("change"),g("changeComplete")),l.currentTime=Fa(S,0,b),l.began&&g("update"),v>=b&&(n=0,m(),l.remaining?(t=s,g("loopComplete"),l.loopBegan=!1,l.direction==="alternate"&&c()):(l.paused=!0,l.completed||(l.completed=!0,g("loopComplete"),g("complete"),!l.passThrough&&"Promise"in window&&(o(),a(l)))))}return l.reset=function(){var v=l.direction;l.passThrough=!1,l.currentTime=0,l.progress=0,l.paused=!0,l.began=!1,l.loopBegan=!1,l.changeBegan=!1,l.completed=!1,l.changeCompleted=!1,l.reversePlayback=!1,l.reversed=v==="reverse",l.remaining=l.loop,r=l.children,i=r.length;for(var b=i;b--;)l.children[b].reset();(l.reversed&&l.loop!==!0||v==="alternate"&&l.loop===1)&&l.remaining++,f(l.reversed?l.duration:0)},l.set=function(v,b){return yF(v,b),l},l.tick=function(v){s=v,t||(t=s),y((s+(n-t))*Cs.speed)},l.seek=function(v){y(h(v))},l.pause=function(){l.paused=!0,u()},l.play=function(){!l.paused||(l.completed&&l.reset(),l.paused=!1,ro.push(l),u(),Ax||Lue())},l.reverse=function(){c(),l.completed=!l.reversed,u()},l.restart=function(){l.reset(),l.play()},l.reset(),l.autoplay&&l.play(),l}function wF(e,t){for(var n=t.length;n--;)OC(e,t[n].animatable.target)&&t.splice(n,1)}function $ue(e){for(var t=fF(e),n=ro.length;n--;){var s=ro[n],r=s.animations,i=s.children;wF(t,r);for(var o=i.length;o--;){var a=i[o],l=a.animations;wF(t,l),!l.length&&!a.children.length&&i.splice(o,1)}!r.length&&!i.length&&s.pause()}}function Bue(e,t){t===void 0&&(t={});var n=t.direction||"normal",s=t.easing?PC(t.easing):null,r=t.grid,i=t.axis,o=t.from||0,a=o==="first",l=o==="center",c=o==="last",h=Tt.arr(e),u=parseFloat(h?e[0]:e),d=h?parseFloat(e[1]):0,p=Tl(h?e[1]:e)||0,f=t.start||0+(h?u:0),g=[],m=0;return function(y,v,b){if(a&&(o=0),l&&(o=(b-1)/2),c&&(o=b-1),!g.length){for(var x=0;x<b;x++){if(!r)g.push(Math.abs(o-x));else{var w=l?(r[0]-1)/2:o%r[0],S=l?(r[1]-1)/2:Math.floor(o/r[0]),C=x%r[0],_=Math.floor(x/r[0]),T=w-C,E=S-_,A=Math.sqrt(T*T+E*E);i==="x"&&(A=-T),i==="y"&&(A=-E),g.push(A)}m=Math.max.apply(Math,g)}s&&(g=g.map(function(O){return s(O/m)*m})),n==="reverse"&&(g=g.map(function(O){return i?O<0?O*-1:-O:Math.abs(m-O)}))}var D=h?(d-u)/m:u;return f+D*(Math.round(g[v]*100)/100)+p}}function zue(e){e===void 0&&(e={});var t=Cs(e);return t.duration=0,t.add=function(n,s){var r=ro.indexOf(t),i=t.children;r>-1&&ro.splice(r,1);function o(d){d.passThrough=!0}for(var a=0;a<i.length;a++)o(i[a]);var l=Ex(n,LC(DC,e));l.targets=l.targets||e.targets;var c=t.duration;l.autoplay=!1,l.direction=t.direction,l.timelineOffset=Tt.und(s)?c:UC(s,c),o(t),l.rewind=t.rewind,t.seek(l.timelineOffset);var h=Cs(l);o(h),i.push(h);var u=vF(i,e);return t.delay=u.delay,t.endDelay=u.endDelay,t.duration=u.duration,t.seek(0),t.reset(),t.autoplay&&t.play(),t},t}Cs.version="3.2.0";Cs.speed=1;Cs.running=ro;Cs.remove=$ue;Cs.get=zC;Cs.set=yF;Cs.convertPx=$C;Cs.path=Eue;Cs.setDashoffset=Cue;Cs.stagger=Bue;Cs.timeline=zue;Cs.easing=PC;Cs.penner=rF;Cs.random=function(e,t){return Math.floor(Math.random()*(t-e+1))+e};var SF=Cs,_F=new I,CF=new I,TF=new un;function Uue(e,t,n,s){if(s===0)return n.copy(e);if(s===1)return n.copy(t);let r=e.w*t.w+e.x*t.x+e.y*t.y+e.z*t.z;if(r>=1)return n.copy(e);let i=1-r*r;if(i<=Number.EPSILON){let h=1-s;return n.w=h*e.w+s*t.w,n.x=h*e.x+s*t.x,n.y=h*e.y+s*t.y,n.z=h*e.z+s*t.z,n.normalize(),n}let o=Math.sqrt(i),a=Math.atan2(o,r),l=Math.sin((1-s)*a)/o,c=Math.sin(s*a)/o;return n.w=e.w*l+t.w*c,n.x=e.x*l+t.x*c,n.y=e.y*l+t.y*c,n.z=e.z*l+t.z*c,n}function Bm(e,t,n,s,r){let i=n[e]?n[e]:void 0,o=s[e];if(o==null)return;let a=i!=null?i:t[e],l=o;if(a!==l)return{update:c=>{let h=Kt.lerp(a,l,c);r?t[e]=Math.trunc(h):t[e]=h},start:()=>{t[e]=a},end:()=>{t[e]=l}}}function EF(e,t,n,s,r){let i=n[e]?n[e]:void 0,o=s[e];if(!o)return;let a=t[e],l=[...i!=null?i:a],c=[...o];if(!(l.length!==c.length||A_(l,c)))return{update:h=>{l.forEach((u,d)=>{let p=Kt.lerp(u,c[d],h);t[e][d]=r?Math.trunc(p):p})},start:()=>{Object.assign(t[e],l)},end:()=>{Object.assign(t[e],c)}}}function AF(e,t,n,s){let r=n[e]?n[e]:void 0,i=s[e];if(!i)return;let o=t[e],a=r?new I().fromArray(r):o.clone(),l=new I().fromArray(i);if(!a.equals(l))return{update:c=>{o.lerpVectors(a,l,c)},start:()=>{o.copy(a)},end:()=>{o.copy(l)}}}function Vue(e,t,n,s){let r=n[e]?n[e]:void 0,i=s[e];if(!i)return;let o=t[e],a=r?new et().fromArray(r):o.clone(),l=new I,c=new un,h=new I;a.decompose(l,c,h);let u=new et().fromArray(i),d=new I,p=new un,f=new I;if(u.decompose(d,p,f),!a.equals(u))return{update:g=>{TF.slerpQuaternions(c,p,g),_F.lerpVectors(l,d,g),CF.lerpVectors(h,f,g),o.compose(_F,TF,CF)},start:()=>{o.compose(l,c,h)},end:()=>{o.compose(d,p,f)}}}function Gue(e,t,n,s,r){let i=n[e]?n[e]:void 0,o=s[e];if(!o)return;let a=t[e],l=i?typeof i=="string"?r.getColor(i).clone():new _t().setRGB(i.r,i.g,i.b):a.clone(),c=typeof o=="string"?r.getColor(o).clone():new _t().setRGB(o.r,o.g,o.b);if(l.equals(c))return;let h=a.clone();return t[e]=h,{update:u=>{h.lerpColors(l,c,u)},start:()=>{h.copy(l)},end:()=>{h.copy(c)}}}function Wue(e,t,n){var o,a,l,c;let s=[],r=e.cameraType==="OrthographicCamera"?(o=t.orthographic)==null?void 0:o.zoom:(a=t.perspective)==null?void 0:a.zoom,i=e.cameraType==="OrthographicCamera"?(l=n.orthographic)==null?void 0:l.zoom:(c=n.perspective)==null?void 0:c.zoom;if(i!==void 0){let h=r!=null?r:e.zoom,u=i;h!==u&&s.push({update:d=>{e.zoom=Kt.lerp(h,u,d),e.updateProjectionMatrix()},start:()=>{e.zoom=h,e.updateProjectionMatrix()},end:()=>{e.zoom=u,e.updateProjectionMatrix()}})}if(n.targetOffset!==void 0){let h=Bm("targetOffset",e,t,n);h&&s.push(h)}return s}function Hue(e,t,n,s){var p,f;let r=[];if(!("geometry"in n))return r;let i="geometry"in t?t.geometry:{},o=n.geometry;if(e instanceof Nm){let g=(p=i.scaleBaked)!=null?p:e.data.geometry.scaleBaked,m=(f=o.scaleBaked)!=null?f:e.data.geometry.scaleBaked;return Du.isEqual(g,m)||r.push({update:y=>{e.updateGeometryInteractions({scaleBaked:[Kt.lerp(g[0],m[0],y),Kt.lerp(g[1],m[1],y),Kt.lerp(g[2],m[2],y)]},s),e.invalidateDownstreamBooleanData()},start:()=>{e.updateGeometryInteractions({scaleBaked:g},s),e.invalidateDownstreamBooleanData()},end:()=>{e.updateGeometryInteractions({scaleBaked:m},s),e.invalidateDownstreamBooleanData()}}),r}let{width:a,height:l,depth:c}=i,{width:h,height:u,depth:d}=o;if(h!==void 0||u!==void 0||d!==void 0){let{width:g,height:m,depth:y}=e.geometry.userData.parameters,v=a!=null?a:g,b=l!=null?l:m,x=c!=null?c:y,w=h!=null?h:g,S=u!=null?u:m,C=d!=null?d:y;(v!==w||b!==S||x!==C)&&r.push({update:_=>{e.updateGeometryInteractions({width:Kt.lerp(v,w,_),height:Kt.lerp(b,S,_),depth:Kt.lerp(x,C,_)},s),e.updateGeometryGroupsIfNeeded(),e.invalidateDownstreamBooleanData()},start:()=>{e.updateGeometryInteractions({width:v,height:b,depth:x},s),e.invalidateDownstreamBooleanData()},end:()=>{e.updateGeometryInteractions({width:w,height:S,depth:C},s),e.invalidateDownstreamBooleanData()}})}return r}function jue(e,t,n,s){let r=[];if(n.intensity!==void 0){let i=Bm("intensity",e,t,n);i&&r.push(i)}if(n.color!==void 0){let i=Gue("color",e,t,n,s);i&&r.push(i)}return r}function que(e,t,n,s){let r=[];if(Array.isArray(e.material)){if(!("materials"in n&&n.materials))return r;let i="materials"in t&&t.materials?t.materials:[],o=n.materials;e.material.forEach((a,l)=>{var u;if(!o[l])return;let c=(u=i[l])!=null?u:{},h=o[l];typeof c=="string"||typeof h=="string"||r.push(...IF(a,c,h,s))})}else{if(!("material"in n&&n.material))return r;let i="material"in t&&t.material?t.material:{},o=n.material;if(typeof i=="string"||typeof o=="string")return r;r.push(...IF(e.material,i,o,s))}return r}function IF(e,t,n,s){var i,o,a;let r=[];for(let l of e.layers){let c=(i=t.layers)==null?void 0:i.data(l.uuid),h=n.layers.data(l.uuid);if(!h||!((o=l.visible)!=null?o:!0)||!((a=h.visible)!=null?a:!0))continue;let u=l.getNames().filter(d=>!XP.some(p=>d.includes(p)));for(let d of u)try{let p=l.getValue(d),f;if(d==="colors")f=ehe(l,c,h,d);else if(Array.isArray(p))d==="steps"&&(f=Jue(l,c,h,d));else if(typeof p=="number")f=Xue(l,c,h,d);else{if(typeof p=="boolean")continue;p instanceof se?f=Kue(l,c,h,d):p instanceof I?f=Yue(l,c,h,d):p instanceof Ni?f=Zue(l,c,h,d,s):p instanceof _t?f=Que(l,c,h,d,s):"isTexture"in p&&(f=the(l,c,h,d))}f&&(Array.isArray(f)?r.push(...f):r.push(f))}catch(p){console.error(`lerpMaterial: unexpected material layer for ${d}`,p)}}return r}function Xue(e,t,n,s){if(!e.hasValue(s)||!(s in n))return;let r=t?t[s]:e.getValue(s),i=n[s];if(r!==i)return{update:o=>{e.setValue(s,Kt.lerp(r,i,o))},start:()=>{e.setValue(s,r)},end:()=>{e.setValue(s,i)}}}function Kue(e,t,n,s){if(!e.hasValue(s)||!(s in n))return;let r=e.getValue(s),i=t?new se().fromArray(t[s]):r.clone(),o=new se().fromArray(n[s]);if(!i.equals(o))return{update:a=>{r.lerpVectors(i,o,a)},start:()=>{r.copy(i)},end:()=>{r.copy(o)}}}function Yue(e,t,n,s){if(!e.hasValue(s)||!(s in n))return;let r=e.getValue(s),i=t?new I().fromArray(t[s]):r.clone(),o=new I().fromArray(n[s]);if(!i.equals(o))return{update:a=>{r.lerpVectors(i,o,a)},start:()=>{r.copy(i)},end:()=>{r.copy(o)}}}function Que(e,t,n,s,r){if(!e.hasValue(s)||!(s in n))return;let i=t?t[s]:void 0,o=n[s],a=e.getValue(s),l=i?typeof i=="string"?r.getColor(i).clone():new _t().setRGB(i.r,i.g,i.b):a.clone(),c=typeof o=="string"?r.getColor(o).clone():new _t().setRGB(o.r,o.g,o.b);if(l.equals(c))return;let h=a.clone();return e.setValue(s,h),{update:u=>{h.lerpColors(l,c,u)},start:()=>{h.copy(l)},end:()=>{h.copy(c)}}}function Zue(e,t,n,s,r){if(!e.hasValue(s)||!(s in n))return;let i=t?t[s]:void 0,o=n[s],a=e.getValue(s),l=i?typeof i=="string"?r.getColor(i).clone():new _t().setRGB(i.r,i.g,i.b):a.clone(),c=typeof o=="string"?r.getColor(o).clone():new Ni(o.r,o.g,o.b,o.a);if(l.equals(c))return;let h=a.clone();return e.setValue(s,h),{update:u=>{h.lerpColors(l,c,u)},start:()=>{h.copy(l)},end:()=>{h.copy(c)}}}function Jue(e,t,n,s="steps"){if(!e.hasValue(s)||!(s in n))return;let r=[],i=e.getValue(s),o=t?t[s]:i,a=n[s];for(let l=0;l<i.length;++l){let c=o[l],h=a[l];c!==h&&r.push({update:u=>{i[l]=Kt.lerp(c,h,u)},start:()=>{i[l]=c},end:()=>{i[l]=h}})}return r.length?r:void 0}function ehe(e,t,n,s="colors"){if(!e.hasValue(s)||!(s in n))return;let r=[],i=e.getValue(s),o=t?t[s]:i.map(l=>l.toArray()),a=n[s];for(let l=0;l<i.length;++l){let c=[...o[l]],h=[...a[l]];xv.isEqual(c,h)||r.push({update:u=>{i[l].fromArray(xv.lerp(c,h,u))},start:()=>{i[l].fromArray(c)},end:()=>{i[l].fromArray(h)}})}return r.length?r:void 0}function the(e,t,n,s="texture"){if(!e.hasValue(s)||!(s in n))return;let r=e.getNode("mat");if(!r)return;let i=t?t[s]:r,o=n[s],a=[...i.repeat],l=[...i.offset],c=[...o.repeat],h=[...o.offset];if(!kd.isEqual(a,c)||!kd.isEqual(l,h))return{update:u=>{r.repeat=kd.lerp(a,c,u),r.offset=kd.lerp(l,h,u),r.updateMatrix()},start:()=>{r.repeat=[...a],r.offset=[...l],r.updateMatrix()},end:()=>{r.repeat=[...c],r.offset=[...h],r.updateMatrix()}}}var GC=new I,NF=new gr;function nhe(e,t,n,s){let r=[],i=AF("position",e,t,n);i&&r.push(i);let o=AF("scale",e,t,n);o&&r.push(o);let a=she(e,t,n,s);a&&r.push(a);let l=Vue("hiddenMatrix",e,t,n);if(l&&r.push(l),i||o||a||l){let c=()=>{var h;e.updateMatrix(),e.hasNonUniformScale&&(e.updateMatrixWorld(),e.updateMatrixWorldSVD()),((h=e.parent)==null?void 0:h.matrixWorldFusedFalse)&&(e.matrixWorld.multiplyMatrices(e.parent.matrixWorldFusedFalse,e.matrix),e.matrixWorldNeedsUpdate=!1),Cl(e)&&wc(e.parent)&&e.invalidateDownstreamBooleanData(!0)};r.push({update:c,start:c,end:c})}return r}function she(e,t,n,s){let r=(t==null?void 0:t.rotation)?t.rotation:void 0,i=n.rotation;if(!i)return;let o=r?new I().fromArray(r):new I().setFromEuler(e.rotation),a=new I().fromArray(i);if(o.equals(a))return;let l=GC.subVectors(a,o);if(s&&l.toArray().every(c=>Math.abs(c)<2*Math.PI)){let c=new un().setFromEuler(NF.setFromVector3(o)),h=new un().setFromEuler(NF.setFromVector3(a));return{update:u=>{Uue(c,h,e.quaternion,u)},start:()=>{e.rotation.setFromVector3(o)},end:()=>{e.rotation.setFromVector3(a)}}}else return{update:c=>{GC.lerpVectors(o,a,c),e.rotation.setFromVector3(GC)},start:()=>{e.rotation.setFromVector3(o)},end:()=>{e.rotation.setFromVector3(a)}}}function hp(e,t,n,s){if(typeof t[e]=="number")return Bm(e,t,n!=null?n:{},s);if(Array.isArray(t[e]))return EF(e,t,n!=null?n:{},s)}function rhe(e,t,n){let s=[];if(!("cloner"in n)||!e.cloner)return s;let r=e.cloner,i="cloner"in t?t.cloner:{},o=n.cloner;VP.forEach(d=>{let p;d==="count"?p=Bm("count",r.parameters,i,o,!0):p=hp(d,r.parameters,i!=null?i:{},o),p&&s.push(p)});let a=ihe(r,i,o);(a==null?void 0:a.length)&&s.push(...a);let l=ohe(r,i,o);(l==null?void 0:l.length)&&s.push(...l);let c=ahe(r,i,o);(c==null?void 0:c.length)&&s.push(...c);let h=lhe(r,i,o);(h==null?void 0:h.length)&&s.push(...h);let u=che(r,i,o);return(u==null?void 0:u.length)&&s.push(...u),s.length&&s.push({update:()=>{r.update()}}),s}function ihe(e,t,n){if(e.parameters.type!=="radial")return;let s=t.radial,r=n.radial;if(!r)return;let i=e.parameters.radial,o=[];return GP.forEach(a=>{let l=hp(a,i,s!=null?s:{},r);l&&o.push(l)}),o}function ohe(e,t,n){if(e.parameters.type!=="linear")return;let s=t.linear,r=n.linear;if(!r)return;let i=[],o=e.parameters.linear;return WP.forEach(a=>{let l=hp(a,o,s!=null?s:{},r);l&&i.push(l)}),i}function ahe(e,t,n){if(e.parameters.type!=="grid")return;let s=t.grid,r=n.grid;if(!r)return;let i=[],o=e.parameters.grid;return HP.forEach(a=>{let l;a==="count"?l=EF(a,o,s!=null?s:{},r,!0):l=hp(a,o,s!=null?s:{},r),l&&i.push(l)}),i}function lhe(e,t,n){if(e.parameters.type!=="toObject")return;let s=t.toObject,r=n.toObject;if(!r)return;let i=[],o=e.parameters.toObject;return jP.forEach(a=>{let l;a==="count"?l=Bm(a,o,s!=null?s:{},r,!0):l=hp(a,o,s!=null?s:{},r),l&&i.push(l)}),i}function che(e,t,n){if(!e.parameters.randomness)return;let s=t.randomnessObject,r=n.randomnessObject;if(!r)return;let i=[],o=e.parameters.randomnessObject;return qP.forEach(a=>{let l=hp(a,o,s!=null?s:{},r);l&&i.push(l)}),i}function WC(e,t,n,s,r){let i=[];return e.data.visible&&i.push(...nhe(e,t,n,r)),e.data.visible&&i.push(...rhe(e,t,n)),Cl(e)?(e instanceof $o&&e.data.visible&&i.push(...Hue(e,t,n,s)),e.data.visible&&i.push(...que(e,t,n,s))):gce(e)?e.data.visible&&i.push(...jue(e,t,n,s)):mce(e)&&i.push(...Wue(e,t,n)),i.length?{update:o=>{i.forEach(a=>a.update(o))},start:o=>{i.forEach(a=>{var l;return(l=a.start)==null?void 0:l.call(a,o)})},end:o=>{i.forEach(a=>{var l;return(l=a.end)==null?void 0:l.call(a,o)})}}:void 0}var kF=new I;function DF(e,t,n,s=!1){let r=[];t.traverseObject(i=>{var c,h,u,d,p;if(s&&((c=i.rigidBody)==null||c.setTranslation(i.position0,!0),(h=i.rigidBody)==null||h.setRotation(i.rotation0,!0),(u=i.rigidBody)==null||u.setLinvel(kF,!0),(d=i.rigidBody)==null||d.setAngvel(kF,!0)),!fs.is(i))return;let o=i.uuid,a=i.data;if(delete i.states,!a.states)return;let l=!1;r.some(f=>e.objects.isDescendantOf(o,f))?l=!0:((p=a.physics)==null?void 0:p.fusedBody)===!0&&a.physics.rigidBody==="dynamic"&&r.push(o),i.data=a,i.currentState=null,i.reversibleToState=null,i.currentTransitionEvent=null;for(let f of a.states)e.environment.usePhysics===!0&&a.physics&&(a.physics.rigidBody==="dynamic"||l)&&(f.data.position!==void 0||f.data.rotation!==void 0||f.data.hiddenMatrix!==void 0)||(i.states||(i.states={}),i.states[f.id]=Pu.patch(a,f.data));uhe(t,i,null,n,a.events.find(f=>f.data.type==="Follow"||f.data.type==="LookAt")!==void 0)})}function uhe(e,t,n,s,r=!1){t instanceof $o&&t.removeInteractionGeometry(),t.changeSelectedState(n,{scene:e,shared:s},r),t instanceof $o&&t.updateGeometryGroupsIfNeeded()}function hhe(e){let t;switch(e.easing){case 0:t="cubicBezier( 0, 0, 1, 1 )";break;case 1:t="cubicBezier( .25, .1, .25, 1 )";break;case 2:t="cubicBezier( .42, 0, 1, 1 )";break;case 3:t="cubicBezier( 0, 0, .58, 1 )";break;case 4:t="cubicBezier( .42, 0, .58, 1 )";break;case 5:let{control1:n,control2:s}=e;t=`cubicBezier(
				${n[0]}, ${n[1]}, ${s[0]}, ${s[1]}
			)`;break;case 6:let{mass:r,stiffness:i,damping:o,velocity:a}=e;t=`spring( ${r}, ${i}, ${o}, ${a} )`;break;default:t="linear"}return{duration:e.duration,easing:t}}function dhe(e){let t={delay:0,repeatDelay:0,loop:e.repeat===-1?!0:e.repeat+1};if(e.repeat===0)t.direction="normal",t.rewind=e.direction==="pingpong-rewind";else switch(e.direction){case"pingpong":t.direction="alternate",t.rewind=!1;break;case"pingpong-rewind":t.direction="alternate",t.rewind=!0;break;default:t.direction="normal",t.rewind=!1;break}switch(e.delayDirection){case"start-once":break;case"start":t.delay=e.delay;break;case"end":t.endDelay=e.delay;break;case"start-end":case void 0:t.delay=e.delay,t.endDelay=e.delay;break}return t}var phe=class{constructor(e,t,n,s,r,i){if(this.object=e,this.data=s,this.sharedAssets=r,this.allowSlerp=i,this.targets={t:0},this.firstLoop=!0,this.reverse=!1,this._playing=!1,this._changeBegan=!1,this._changeCompleted=!0,this.onChange=()=>{this.callback&&(this.callback.update(this.targets.t),this.object.dispatchEvent({type:"requestRender"})),this.targets.t===0?this._changeCompleted||(this._changeCompleted=!0,this._changeBegan=!1,this.onChangeComplete()):this.targets.t===1?this._changeCompleted||(this._changeCompleted=!0,this._changeBegan=!1,this.onChangeComplete()):(this._changeCompleted&&(this._changeCompleted=!1),this._changeBegan||(this._changeBegan=!0,this.onChangeBegin()))},this.onChangeBegin=()=>{let o,a;this.reverse?(o=this.to,a=this.from):(o=this.from,a=this.to),this.object.reversibleToState=a.id;let l=this.targets.t>.5?o.id:a.id;this.object.prevState!==this.object.currentState&&(this.object.prevState=this.object.currentState),this.object.currentState=l,this.object.dispatchEvent({type:"beginState",state:l})},this.onChangeComplete=()=>{let o,a;this.reverse?(o=this.to,a=this.from):(o=this.from,a=this.to),this.firstLoop&&(this.onFirstLoop(),this.firstLoop=!1),this.object.reversibleToState=a.id;let l=this.targets.t<.5?o.id:a.id;this.object.prevState!==this.object.currentState&&(this.object.prevState=this.object.currentState),this.object.currentState=l,this.object.dispatchEvent({type:"completeState",state:l})},this.onFirstLoop=()=>{if(this.useCurrentState){let o,a;this.reverse?(o=this.to,a=this.from):(o=this.from,a=this.to),this.callback=WC(this.object,o.data,a.data,this.sharedAssets,this.allowSlerp)}},t===n)throw new Error("Missing property");if(t===void 0){let o=this.getState(this.object.currentState===n?this.object.prevState:this.object.currentState);if(!o)throw new Error("Missing property");this.from=o}else{let o=this.getState(t);if(!o)throw new Error("Missing property");this.from=o}if(n===void 0)throw new Error("Missing property");{let o=this.getState(n);if(!o)throw new Error("Missing property");this.to=o}this.useCurrentState=t===void 0||n===void 0,this.params=De(ue(ue({targets:this.targets,t:1,autoplay:!1},dhe(s)),hhe(s)),{change:this.onChange}),this.callback=WC(this.object,t===void 0?{}:this.from.data,n===void 0?{}:this.to.data,this.sharedAssets,this.allowSlerp),this.core=SF(ue({},this.params)),this.core.finished.then(()=>this._playing=!1)}get changeBegan(){return this._changeBegan}get changeCompleted(){return this._changeCompleted}get playing(){return this._playing}getState(e){var s;let t,n;if(typeof e=="string"?(t=e,n=(s=this.object.states)==null?void 0:s[t]):e===null&&(t=null,n=this.object.data),!(t===void 0||n===void 0))return{id:t,data:n}}play(){if(this._playing)return!1;this.core.play(),this._playing=!0}pause(){var e;(e=this.core)==null||e.pause(),this._playing=!1}stop(){var e;this.pause(),this.seek(0),(e=this.core)==null||e.reset(),this._playing=!1}seek(e){var n,s,r;let t=e*((s=(n=this.core)==null?void 0:n.duration)!=null?s:1);(r=this.core)==null||r.seek(t)}toggle(e){this._changeBegan=!1,this._changeCompleted=!0,this.targets.t=0;let t;e!==void 0?e?(this.reverse=!1,t=this.to):(this.reverse=!0,t=this.from):this.object.reversibleToState===this.from.id?(this.reverse=!1,t=this.to):(this.reverse=!0,t=this.from),this.callback=WC(this.object,{},t.data,this.sharedAssets,this.allowSlerp),this.core=SF(ue({},this.params))}dispose(){this.pause()}},dp=class extends Zr{constructor(e,t,n){super();if(this.data=e,this.scene=t,this.sharedAssets=n,!e.object)throw new Error("Missing property");let s=t.find(e.object);if(!s)throw new Error("Missing property");if(!s.states)throw new Error("Missing property");if(this.object=s,e.tweens.length<1)throw new Error("Missing property");this.startOnceDelay=e.tweens[1].data.delayDirection==="start-once"?e.tweens[1].data.delay:0}get playing(){var e,t;return(t=(e=this.tween)==null?void 0:e.playing)!=null?t:!1}init(){var e,t;try{let n=this.data.tweens[0],s=this.data.tweens[1];(e=this.tween)==null||e.pause(),this.tween=new phe(this.object,n.data.state,s.data.state,s.data,this.sharedAssets,(t=this.data.allowSlerp)!=null?t:!1)}catch(n){n instanceof Error&&console.error(n.message)}}play(){if(this.playing)return!1;clearTimeout(this.timeoutId),this.timeoutId=window.setTimeout(()=>{var e;try{this.init(),(e=this.tween)==null||e.play()}catch(t){t instanceof Error&&console.error(t.message)}},this.startOnceDelay)}pause(){var e;(e=this.tween)==null||e.pause(),clearTimeout(this.timeoutId),delete this.timeoutId}stop(){var e;(e=this.tween)==null||e.stop(),clearTimeout(this.timeoutId),delete this.timeoutId}seek(e){var t;(t=this.tween)==null||t.seek(e)}toggle(e){!this.tween||(clearTimeout(this.timeoutId),this.tween.changeCompleted?this.timeoutId=window.setTimeout(()=>{var t,n,s;(t=this.tween)==null||t.pause(),(n=this.tween)==null||n.toggle(e),(s=this.tween)==null||s.play()},this.startOnceDelay):(this.tween.pause(),this.tween.toggle(e),this.tween.play()))}dispose(){var e;(e=this.tween)==null||e.dispose()}};function Xu(e,t,n,s,r,i){let o={Audio:[],Video:[],Link:[],Reset:[],Transition:[]};return t.forEach(({id:a,data:l})=>{try{l.type==="Audio"?rm[e.type].includes("Audio")&&o.Audio.push(new up(a,l,n,r)):l.type==="Video"?rm[e.type].includes("Video")&&o.Video.push(new Sx(a,l,n)):l.type==="Link"?rm[e.type].includes("Link")&&o.Link.push(new cue(l,i)):l.type==="Reset"?rm[e.type].includes("Reset")&&o.Reset.push(new uue(s.data,s,r,i)):l.type==="Transition"&&rm[e.type].includes("Transition")&&o.Transition.push(new dp(l,s,r))}catch{}}),o}function Ku(e){Object.values(e).forEach(t=>{t.forEach(n=>{(n instanceof up||n instanceof Sx||n instanceof dp)&&n.dispose()})})}var HC=[["start","Start"],["keyDown","KeyDown"],["keyUp","KeyUp"],["mouseDown","MouseDown"],["mouseUp","MouseUp"],["mouseHover","MouseHover"],["collision","Collision"],["lookAt","LookAt"],["follow","Follow"],["scroll","Scroll"]],MF=e=>{var t;return(t=HC.find(([n,s])=>s===e))==null?void 0:t[0]},Ix=e=>{var t;return(t=HC.find(([n])=>n===e))==null?void 0:t[1]},fhe=(e,t)=>{let n=MF(e);if(n){let s=new CustomEvent(n,{bubbles:!0});return Object.defineProperty(s,"target",{writable:!1,value:t}),s}},mhe=class extends Sc{constructor(e){super(e);this.objectsPerEvents=new Map,this.splineEvents={},this.onBeginEvent=n=>{var i;if(!n.eventName||!n.target)return;let s=(i=this.splineEvents[MF(n.eventName)])==null?void 0:i[n.target.uuid];if(!s)return;n.eventName==="Scroll"&&n.deltaY!==void 0&&Object.assign(s,{deltaY:n.deltaY});let{domElement:r}=this.eventContext;r.dispatchEvent(s)};let{scene:t}=this.eventContext;t.traverseEntity(n=>{var s,r;if((s=n.data)==null?void 0:s.events.length){for(let[i,o]of HC)if(n.data.events.some(a=>a.data.type===o&&!a.data.disabled)){this.objectsPerEvents.has(i)?(r=this.objectsPerEvents.get(i))==null||r.push(n):this.objectsPerEvents.set(i,[n]);let a={id:n.uuid,name:n.name},l=fhe(o,a),c=this.splineEvents[i];c?c[n.uuid]=l:this.splineEvents[i]={[n.uuid]:l}}}})}connect(){this.objectsPerEvents.forEach(e=>{e.forEach(t=>{t.addEventListener("beginEvent",this.onBeginEvent)})})}disconnect(){this.objectsPerEvents.forEach(e=>{e.forEach(t=>{t.removeEventListener("beginEvent",this.onBeginEvent)})})}},ghe=class{constructor(e,t,n,s,r,i){if(this.id=e,this.data=t,this.object=n,this.entered=!1,this.useToggle=t.toggle,(t.type==="KeyDown"||t.type==="KeyUp"||t.type==="KeyPress")&&!t.key)throw new Error("Missing property");this.actions=Xu(t,t.actions,n,s,r,i)}disconnect(){Ku(this.actions)}dispatch(){this.useToggle?(this.object.currentTransitionEvent!==this.id&&(this.object.currentTransitionEvent=this.id,this.actions.Transition.forEach(e=>{e.init()})),this.actions.Transition.forEach(e=>{e.toggle()})):this.data.type==="MousePress"||this.data.type==="KeyPress"?(this.object.currentTransitionEvent!==this.id&&(this.object.currentTransitionEvent=this.id,this.actions.Transition.forEach(e=>{e.init()})),this.entered||(this.entered=!0,this.actions.Transition.forEach(e=>e.toggle(!0)))):this.actions.Transition.some(e=>e.playing)||(this.object.currentTransitionEvent=this.id,this.actions.Transition.forEach(e=>{e.play()})),this.actions.Link.forEach(e=>{e.dispatch()}),this.actions.Reset.forEach(e=>{e.dispatch()}),this.actions.Audio.forEach(e=>{e.dispatchBasic()}),this.actions.Video.forEach(e=>{e.dispatchBasic()})}dispatchRelease(){this.entered&&(this.entered=!1,this.actions.Transition.forEach(e=>e.toggle(!1)))}dispatchUserEvent(e){this.actions.Transition.forEach(t=>{t.toggle(!e)}),this.actions.Link.forEach(t=>{t.dispatch()}),this.actions.Reset.forEach(t=>{t.dispatch()}),this.actions.Audio.forEach(t=>{t.dispatchBasic()}),this.actions.Video.forEach(t=>{t.dispatchBasic()})}},yhe=class extends Sc{constructor(e,t,n){super(e);this.objectsPerTypes={MouseDown:[],MouseUp:[],MousePress:[],KeyDown:[],KeyUp:[],KeyPress:[]},this.eventsPerObjects={MouseDown:{},MouseUp:{},MousePress:{},KeyDown:{},KeyUp:{},KeyPress:{}},this.heldKeys={},this._prevObjects=[],this.onMouseDown=i=>{Pt.length>1||(this.eventContext.updateRaycaster(i),this.handleMouseEvent("MouseDown"))},this.onMouseUp=i=>{Pt.length>1||(this.eventContext.updateRaycaster(i),this.handleMouseEvent("MouseUp"))},this.onMousePressDown=i=>{Pt.length>1||(this.eventContext.updateRaycaster(i),this.handleMousePressEvent())},this.onMousePressRelease=i=>{Pt.length>1||(this.eventContext.updateRaycaster(i),this.handleMousePressEvent(!0))},this.onKeyDown=i=>{this.heldKeys[i.key]||this.handleKeyEvent(i,"KeyDown"),this.heldKeys[i.key]=!0},this.onKeyUp=i=>{this.handleKeyEvent(i,"KeyUp")},this.onKeyPressDown=i=>{this.heldKeys[i.key]||this.handleKeyEvent(i,"KeyPress"),this.heldKeys[i.key]=!0},this.onKeyPressUp=i=>{this.handleKeyEvent(i,"KeyPress",!0)},this.releaseHeldKey=i=>{delete this.heldKeys[i.key]},this._onUserEvent=({eventName:i,target:o,reverse:a})=>{var c,h,u,d;if(!i||!o)return;let l=Ix(i);l&&(l==="MouseDown"||l==="MouseUp"||l==="MousePress"?(o.dispatchEvent({type:"beginEvent",eventName:l}),(h=(c=this.eventsPerObjects[l])==null?void 0:c[o.uuid])==null||h.forEach(p=>{p.dispatchUserEvent(a)})):(l==="KeyDown"||l==="KeyUp"||l==="KeyPress")&&(o.dispatchEvent({type:"beginEvent",eventName:l}),(d=(u=this.eventsPerObjects[l])==null?void 0:u[o.uuid])==null||d.forEach(p=>{p.dispatchUserEvent()})))};let{scene:s,sharedAssets:r}=this.eventContext;s.traverseEntity(i=>{var a,l;if(!((a=i.data)==null?void 0:a.events.length))return;let o=i.visible?["MouseDown","MouseUp","MousePress","KeyDown","KeyUp","KeyPress"]:["KeyDown","KeyUp","KeyPress"];for(let c of o){let h=this.eventsPerObjects[c];i.data.events.filter(({data:u})=>u.type===c&&u.disabled!==!0).forEach(({id:u,data:d})=>{try{let p=new ghe(u,d,i,s,r,{controlsManager:t,eventManager:n});p.actions.Video.length&&(this.hasVideoAction=!0),h[i.uuid]?h[i.uuid].push(p):h[i.uuid]=[p]}catch{}}),((l=h[i.uuid])==null?void 0:l.length)&&this.objectsPerTypes[c].push(i)}})}connect(){var t,n,s,r,i,o;let{domElement:e}=this.eventContext;this.heldKeys={},this.domEventsNeeded.clear(),((t=this.objectsPerTypes.MouseDown)==null?void 0:t.length)&&(this.domEventsNeeded.add("pointerdown"),e.addEventListener("pointerdown",this.onMouseDown)),((n=this.objectsPerTypes.MouseUp)==null?void 0:n.length)&&(this.domEventsNeeded.add("pointerup"),e.addEventListener("pointerup",this.onMouseUp)),((s=this.objectsPerTypes.MousePress)==null?void 0:s.length)&&(this.domEventsNeeded.add("pointerdown"),e.addEventListener("pointerdown",this.onMousePressDown),this.domEventsNeeded.add("pointerup"),e.addEventListener("pointerup",this.onMousePressRelease)),((r=this.objectsPerTypes.KeyDown)==null?void 0:r.length)&&(this.domEventsNeeded.add("keydown"),document.addEventListener("keydown",this.onKeyDown),document.addEventListener("keyup",this.releaseHeldKey)),((i=this.objectsPerTypes.KeyUp)==null?void 0:i.length)&&(this.domEventsNeeded.add("keyup"),document.addEventListener("keyup",this.onKeyUp)),((o=this.objectsPerTypes.KeyPress)==null?void 0:o.length)&&(this.domEventsNeeded.add("keydown"),document.addEventListener("keydown",this.onKeyPressDown),document.addEventListener("keyup",this.releaseHeldKey),this.domEventsNeeded.add("keyup"),document.addEventListener("keyup",this.onKeyPressUp)),Object.entries(this.objectsPerTypes).forEach(([a,l])=>{l.forEach(c=>{c.addEventListener("userEvent",this._onUserEvent)})})}disconnect(){let{domElement:e}=this.eventContext;this.domEventsNeeded.clear(),this.heldKeys={},e.removeEventListener("pointerdown",this.onMouseDown),e.removeEventListener("pointerdown",this.onMousePressDown),e.removeEventListener("pointerup",this.onMouseUp),e.removeEventListener("pointerup",this.onMousePressRelease),document.removeEventListener("keydown",this.onKeyDown),document.removeEventListener("keyup",this.onKeyUp),document.removeEventListener("keydown",this.onKeyPressDown),document.removeEventListener("keyup",this.onKeyPressUp),document.removeEventListener("keyup",this.releaseHeldKey),Object.values(this.eventsPerObjects).forEach(t=>{Object.values(t).forEach(n=>{n.forEach(s=>{s.disconnect()})})}),Object.entries(this.objectsPerTypes).forEach(([t,n])=>{n.forEach(s=>{s.removeEventListener("userEvent",this._onUserEvent)})})}handleMouseEvent(e){let{stopRaycast:t,raycaster:n,scene:s}=this.eventContext,r=this.objectsPerTypes[e];if(r.length)if(t){let i=AC(n,s,r);IC(i).forEach(o=>{this.eventsPerObjects[e][o.uuid]&&this.handleObjectMouseEventDispatch(o,e)})}else r.forEach(i=>{wx(n,i)&&this.handleObjectMouseEventDispatch(i,e)})}handleMousePressEvent(e=!1){let t="MousePress",n=this.objectsPerTypes[t],s=[];if(n.length){if(!e){let{stopRaycast:r,raycaster:i,scene:o}=this.eventContext;if(r){let a=AC(i,o,n);s=IC(a)}else n.forEach(a=>{wx(i,a)&&s.push(a)})}this._prevObjects.length&&this._prevObjects.forEach(r=>{s.includes(r)||this.handleObjectMouseEventDispatchRelease(r,t)}),s.length&&s.forEach(r=>{this.handleObjectMouseEventDispatch(r,t)}),this._prevObjects=s}}handleObjectMouseEventDispatch(e,t){var n,s;e.dispatchEvent({type:"beginEvent",eventName:t}),(s=(n=this.eventsPerObjects[t])==null?void 0:n[e.uuid])==null||s.forEach(r=>{r.dispatch()})}handleObjectMouseEventDispatchRelease(e,t){var n,s;e.dispatchEvent({type:"beginEvent",eventName:t}),(s=(n=this.eventsPerObjects[t])==null?void 0:n[e.uuid])==null||s.forEach(r=>{r.dispatchRelease()})}handleKeyEvent(e,t,n=!1){this.objectsPerTypes[t].forEach(s=>{let r=this.eventsPerObjects[t][s.uuid];r.some(({data:i})=>"key"in i&&i.key===e.key)&&s.dispatchEvent({type:"beginEvent",eventName:t}),r.forEach(i=>{"key"in i.data&&i.data.key===e.key&&(n?i.dispatchRelease():i.dispatch())})})}},vhe=new I,xhe=new I,PF=class{constructor(e,t,n,s){this.actionsIn=Xu(e,e.inActions,t,n,s),this.actionsOut=Xu(e,e.outActions,t,n,s)}disconnect(){Ku(this.actionsIn),Ku(this.actionsOut)}},bhe=class extends PF{constructor(e,t,n,s){super(e,t,n,s);this.data=e,this.object=t,this.stage="out",this.objects=[],this.onUpdateMatrix=()=>{let a=vhe.setFromMatrixPosition(this.objects[0].matrixWorld),l=xhe.setFromMatrixPosition(this.objects[1].matrixWorld),c=a.distanceTo(l)<=this.distance?"in":"out";if(this.stage!==c){(this.stage==="in"?this.actionsIn:this.actionsOut).Transition.forEach(u=>u.pause());let h=c==="in"?this.actionsIn:this.actionsOut;h.Audio.forEach(u=>u.dispatchConditional()),h.Video.forEach(u=>u.dispatchConditional()),h.Transition.forEach(u=>u.play()),this.stage=c}};let{distance:r,fromObject:i,toObject:o}=e.condition;this.distance=r;for(let a of[i,o]){if(!a)throw new Error("Missing property");let l=n.find(a);if(!l)throw new Error("Missing property");this.objects.push(l)}}connect(){this.objects.forEach(e=>{e.addEventListener("updateMatrix",this.onUpdateMatrix)}),this.onUpdateMatrix()}disconnect(){super.disconnect(),this.stage="out",this.objects.forEach(e=>{e.removeEventListener("updateMatrix",this.onUpdateMatrix)})}},whe=class extends PF{constructor(e,t,n,s){super(e,t,n,s);var o;this.data=e,this.object=t,this.onBegin=({target:a,state:l})=>{this.toState!==l&&(this.actionsOut.Audio.forEach(c=>c.dispatchConditional()),this.actionsOut.Video.forEach(c=>c.dispatchConditional()),this.actionsIn.Transition.forEach(c=>c.pause()),this.actionsOut.Transition.forEach(c=>c.play()))},this.onComplete=({target:a,state:l})=>{this.toState===l&&(this.actionsIn.Audio.forEach(c=>c.dispatchConditional()),this.actionsIn.Video.forEach(c=>c.dispatchConditional()),this.actionsOut.Transition.forEach(c=>c.pause()),this.actionsIn.Transition.forEach(c=>c.play()))};let{condition:r}=e;if(!r.object)throw new Error("Missing property");let i=n.find(r.object);if(!i)throw new Error("Missing property");if(this.toObject=i,r.state&&!((o=this.toObject.states)==null?void 0:o[r.state]))throw new Error("Missing property");this.toState=r.state}connect(){(this.actionsOut.Audio.length||this.actionsOut.Video.length||this.actionsOut.Transition.length)&&this.toObject.addEventListener("beginState",this.onBegin),(this.actionsIn.Audio.length||this.actionsIn.Video.length||this.actionsIn.Transition.length)&&this.toObject.addEventListener("completeState",this.onComplete)}disconnect(){super.disconnect(),(this.actionsOut.Audio.length||this.actionsOut.Video.length||this.actionsOut.Transition.length)&&this.toObject.removeEventListener("beginState",this.onBegin),(this.actionsIn.Audio.length||this.actionsIn.Video.length||this.actionsIn.Transition.length)&&this.toObject.removeEventListener("completeState",this.onComplete)}},She=class extends Sc{constructor(e){super(e);this.eventsPerConditions={Comparison:[],Distance:[],State:[]},this.hasVideoAction=!1;let{scene:t,sharedAssets:n}=this.eventContext;t.traverseEntity(s=>{var r;if((r=s.data)==null?void 0:r.events.length){for(let{data:i}of s.data.events)if(!i.disabled&&i.type==="Conditional")try{let o;i.condition.type==="Comparison"||(i.condition.type==="Distance"?o=new bhe(i,s,t,n):i.condition.type==="State"&&(o=new whe(i,s,t,n))),o&&(this.eventsPerConditions[i.condition.type].push(o),(o.actionsIn.Video.length||o.actionsOut.Video.length)&&(this.hasVideoAction=!0))}catch{}}})}connect(){super.connect(),Object.values(this.eventsPerConditions).forEach(e=>e.forEach(t=>t.connect()))}disconnect(){super.disconnect(),Object.values(this.eventsPerConditions).forEach(e=>e.forEach(t=>t.disconnect()))}},pp=new I,jC=new I,qC=new I,Nx=new I,OF=new ji,RF=.01,_he={type:"requestRender"},Che=function(){let e=new I,t=new I;return(n,s,r)=>r>0?(e.subVectors(n,s),e.length()<=r?n:t.copy(s).add(e.normalize().multiplyScalar(r))):s}(),LF=function(){let e=new et;return(t,n)=>{t.position.copy(n),t.parent!==null&&(e.copy(t.parent.matrixWorld).invert(),t.position.applyMatrix4(e)),e.copy(t.hiddenMatrix).invert(),t.position.applyMatrix4(e),t.updateMatrix(),t instanceof Ai&&wc(t.parent)&&t.invalidateDownstreamBooleanData(!0)}}(),The=class{constructor(e,t,n){var s,r;this.data=e,this.object=t,this.tempPosition=new I,this.started=!1,this.paused=!0,this.snapComplete=!1,this.isReset=!1,this.worldPosition0=new I,this.target=e.target?n.find(e.target):void 0,this.maxDelta=(s=e.maxDelta)!=null?s:0,this.dampingFactor=e.dampingFactor?Math.max(e.dampingFactor,1):1,this.plane=(r=e.plane)!=null?r:"custom",this.snapDampingFactor=8,this.currentDampingFactor=this.snapDampingFactor,this.object.getWorldPosition(this.worldPosition0)}},Ehe=class extends Sc{constructor(e){super(e);this.events=[],this.onTargetChangeCallbacks=[],this.onMouseMove=n=>{if(!(Pt.length>1)){this.eventContext.updateRaycaster(n);for(let s of this.events)s.target===void 0&&this.updateSingleEvent(s)}},this.onMouseEnter=n=>{for(let s of this.events)s.target===void 0&&(s.tempPosition.copy(s.object.position),s.snapComplete=!1,s.isReset=!1,s.currentDampingFactor=s.snapDampingFactor)},this.onMouseLeave=n=>{var s;for(let r of this.events)r.target===void 0&&(r.tempPosition.copy(r.object.position),r.snapComplete=!1,((s=r.data.resetOnPointerLeave)!=null?s:!1)&&(r.isReset=!0,r.currentDampingFactor=r.snapDampingFactor),this.updateSingleEvent(r))},this.onTargetChange=n=>()=>{this.updateSingleEvent(n)};let{scene:t}=this.eventContext;t.traverseEntity(n=>{var r,i;let s=(r=n.data)==null?void 0:r.events.find(o=>o.data.type==="Follow"&&!o.data.disabled);s&&(!t.data.environment.usePhysics||((i=n.dataPatched.physics)==null?void 0:i.rigidBody)!=="dynamic")&&this.events.push(new The(s.data,n,t))})}connect(){if(!this.events.length)return;let{domElement:e}=this.eventContext;this.domEventsNeeded.clear(),Br&&(this.domEventsNeeded.add("pointerdown"),e.addEventListener("pointerdown",this.onMouseMove)),this.domEventsNeeded.add("pointermove"),e.addEventListener("pointermove",this.onMouseMove),e.addEventListener("pointerenter",this.onMouseEnter),e.addEventListener("pointerleave",this.onMouseLeave);for(let t of this.events)if(t.target!==void 0){let n=this.onTargetChange(t);this.onTargetChangeCallbacks.push(n),t.target.addEventListener("requestRender",n)}}disconnect(){if(!this.events.length)return;let{domElement:e}=this.eventContext;this.domEventsNeeded.clear(),Br&&e.removeEventListener("pointerdown",this.onMouseMove),e.removeEventListener("pointermove",this.onMouseMove),e.removeEventListener("pointerenter",this.onMouseEnter),e.removeEventListener("pointerleave",this.onMouseLeave);let t=0;for(let n of this.events)n.started=!1,n.paused=!0,n.target!==void 0&&n.target.removeEventListener("requestRender",this.onTargetChangeCallbacks[t++])}onAnimationFrameDamping(){for(let e of this.events)e.paused||this.updateSingleEvent(e)}updateSingleEvent(e){var o;let{tempPosition:t,object:n,maxDelta:s,plane:r}=e;if(n.getWorldPosition(qC),e.isReset)Nx.copy(e.worldPosition0);else if(e.target)e.target.getWorldPosition(Nx);else{let{camera:a,raycaster:l}=this.eventContext;if(r==="custom"?(a.getWorldDirection(jC),jC.negate(),pp.copy(jC)):r==="xy"?pp.set(0,0,1):r==="xz"?pp.set(0,1,0):r==="yz"&&pp.set(1,0,0),OF.setFromNormalAndCoplanarPoint(pp,qC),!l.ray.intersectPlane(OF,Nx))return}let i=Che(qC,Nx,s);if(e.currentDampingFactor>1||e.snapComplete===!1){e.started||(e.started=!0,t.copy(i));let a=pp.subVectors(i,t).divideScalar(e.currentDampingFactor);t.add(a),LF(n,t),e.paused=a.length()<RF,e.snapComplete=a.length()<RF*100,e.snapComplete&&(e.currentDampingFactor=e.dampingFactor)}else LF(n,i),e.paused=!0;(o=e.object)==null||o.dispatchEvent({type:"beginEvent",eventName:"Follow"}),n.dispatchEvent(_he)}},zm=new I,kx=new I,Yu=new et,Um=new un,fp=new un,Dx=new I,XC=new I,Vm=new I,Mx=new ji,FF=1e-5,Ahe={type:"requestRender"},Ihe={type:"changeRotation"},Nhe=function(){let e=new et,t=new I,n=new I,s=new I;return(r,i)=>(i==="x"?(t.set(0,0,1),n.set(0,1,0),s.set(-1,0,0)):i==="y"?(t.set(1,0,0),n.set(0,0,1),s.set(0,-1,0)):(t.set(1,0,0),n.set(0,1,0),s.set(0,0,1)),t.applyMatrix4(r),n.applyMatrix4(r),s.applyMatrix4(r),e.makeBasis(t,n,s))}(),$F=function(){let e=new et;return function(t,n){t.parent!==null?e.multiplyMatrices(t.parent.matrixWorld,t.hiddenMatrix):e.copy(t.hiddenMatrix),n.premultiply(jL(e).invert()),t.rotation.setFromRotationMatrix(n),t.updateMatrix(),t instanceof Ai&&wc(t.parent)&&t.invalidateDownstreamBooleanData(!0)}}(),khe=class{constructor(e,t,n){var s,r,i,o;this.data=e,this.object=t,this.paused=!0,this.snapComplete=!1,this.isReset=!1,this.worldQuaternion0=new un,this.target=e.target?n.find(e.target):void 0,this.dampingFactor=e.dampingFactor?Math.max(e.dampingFactor,1):1,this.distance=(s=e.distance)!=null?s:0,this.tilt=(r=e.tilt)!=null?r:"up",this.axis=(i=e.axis)!=null?i:"z",this.plane=(o=e.plane)!=null?o:"custom",this.snapDampingFactor=8,this.currentDampingFactor=this.dampingFactor,this.object.getWorldQuaternion(this.worldQuaternion0)}},Dhe=class extends Sc{constructor(e){super(e);this.events=[],this.onTargetChangeCallbacks=[],this.onMouseMove=n=>{if(!(Pt.length>1)){this.eventContext.updateRaycaster(n);for(let s of this.events)s.target===void 0&&this.updateSingleEvent(s)}},this.onMouseEnter=n=>{for(let s of this.events)s.target===void 0&&(s.snapComplete=!1,s.isReset=!1,s.currentDampingFactor=s.snapDampingFactor)},this.onMouseLeave=n=>{var s;for(let r of this.events)r.target===void 0&&(r.snapComplete=!1,((s=r.data.resetOnPointerLeave)!=null?s:!1)&&(r.isReset=!0,r.currentDampingFactor=r.snapDampingFactor),this.updateSingleEvent(r))},this.onTargetChange=n=>()=>{this.updateSingleEvent(n)};let{scene:t}=this.eventContext;t.traverseEntity(n=>{var r,i;let s=(r=n.data)==null?void 0:r.events.find(o=>o.data.type==="LookAt"&&!o.data.disabled);s&&(!t.data.environment.usePhysics||((i=n.dataPatched.physics)==null?void 0:i.rigidBody)!=="dynamic")&&this.events.push(new khe(s.data,n,t))})}connect(){if(!this.events.length)return;let{domElement:e}=this.eventContext;this.domEventsNeeded.clear(),Br&&(this.domEventsNeeded.add("pointerdown"),e.addEventListener("pointerdown",this.onMouseMove)),this.domEventsNeeded.add("pointermove"),e.addEventListener("pointermove",this.onMouseMove),e.addEventListener("pointerenter",this.onMouseEnter),e.addEventListener("pointerleave",this.onMouseLeave);for(let t of this.events)if(t.target!==void 0){let n=this.onTargetChange(t);this.onTargetChangeCallbacks.push(n),t.target.addEventListener("requestRender",n)}}disconnect(){if(!this.events.length)return;let{domElement:e}=this.eventContext;this.domEventsNeeded.clear(),Br&&e.removeEventListener("pointerdown",this.onMouseMove),e.removeEventListener("pointermove",this.onMouseMove),e.removeEventListener("pointerenter",this.onMouseEnter),e.removeEventListener("pointerleave",this.onMouseLeave);let t=0;for(let n of this.events)n.paused=!0,n.target!==void 0&&n.target.removeEventListener("requestRender",this.onTargetChangeCallbacks[t++])}onAnimationFrameDamping(){for(let e of this.events)e.paused||this.updateSingleEvent(e)}updateSingleEvent(e){var c;let{target:t,tilt:n,axis:s,distance:r,plane:i,object:o}=e,{camera:a,raycaster:l}=this.eventContext;if(o.getWorldPosition(Dx),!e.isReset){if(e.target)e.target.getWorldPosition(XC);else if(i==="custom"?(a.getWorldDirection(kx),kx.negate(),r>0?Mx.set(kx,-r):Mx.setFromNormalAndCoplanarPoint(kx,Dx)):(i==="xy"?zm.set(0,0,1):i==="xz"?zm.set(0,1,0):i==="yz"&&zm.set(1,0,0),Mx.setFromNormalAndCoplanarPoint(zm,Dx)),!l.ray.intersectPlane(Mx,XC))return}e.isReset||(t?n==="up"?Vm.set(0,1,0):n==="target"&&Vm.copy(t.up).applyMatrix4(Yu.extractRotation(t.matrixWorld)).normalize():i==="custom"?Vm.set(0,1,0):Vm.copy(zm)),e.isReset?fp.copy(e.worldQuaternion0):(Yu.lookAt(XC,Dx,Vm),Yu.copy(Nhe(Yu,s)),fp.setFromRotationMatrix(Yu)),e.currentDampingFactor>1||e.snapComplete===!1?(o.updateWorldMatrix(!0,!1),Um.setFromRotationMatrix(jL(o.matrixWorld)),Um.slerp(fp,1/e.currentDampingFactor),$F(o,Yu.makeRotationFromQuaternion(Um)),e.paused=8*(1-Um.dot(fp))<FF,e.snapComplete=8*(1-Um.dot(fp))<FF*100,e.snapComplete&&(e.currentDampingFactor=e.dampingFactor)):($F(o,Yu.makeRotationFromQuaternion(fp)),e.paused=!0),(c=e.object)==null||c.dispatchEvent({type:"beginEvent",eventName:"LookAt"}),o.dispatchEvent(Ahe),o.dispatchEvent(Ihe)}},Mhe=class{constructor(e,t,n,s,r){this.id=e,this.data=t,this.object=n,this.entered=!1,this.actions=Xu(t,t.actions,n,s,r)}disconnect(){Ku(this.actions)}dispatchEnter(){this.object.currentTransitionEvent!==this.id&&(this.object.currentTransitionEvent=this.id,this.actions.Transition.forEach(e=>{e.init()})),this.entered||(this.entered=!0,this.actions.Transition.forEach(e=>e.toggle(!0)))}dispatchLeave(){this.object.currentTransitionEvent!==this.id&&(this.object.currentTransitionEvent=this.id,this.actions.Transition.forEach(e=>{e.init()})),this.entered&&(this.entered=!1,this.actions.Transition.forEach(e=>e.toggle(!1)))}dispatchUserEvent(e){this.actions.Transition.forEach(t=>t.toggle(!e))}},Phe=class extends Sc{constructor(e){super(e);this.eventsPerObjects={},this.objects=[],this._prevObjects=[],this.onMouseDown=s=>{Pt.length>1||(this.eventContext.updateRaycaster(s),this.handleMouseHoverEvent())},this.onMouseUp=s=>{Pt.length>1||this.handleMouseHoverEvent(!0)},this.onMouseMove=s=>{Pt.length>1||(this.eventContext.updateRaycaster(s),this.handleMouseHoverEvent())},this.onUserEvent=({eventName:s,target:r,reverse:i})=>{var a;if(!s||!r)return;let o=Ix(s);o&&o==="MouseHover"&&(r.dispatchEvent({type:"beginEvent",eventName:"MouseHover"}),(a=this.eventsPerObjects[r.uuid])==null||a.forEach(l=>l.dispatchUserEvent(i)))};let{scene:t,sharedAssets:n}=this.eventContext;t.traverseEntity(s=>{var r,i;if(!(!s.visible||!((r=s.data)==null?void 0:r.events.length))){for(let{id:o,data:a}of s.data.events)if(!a.disabled&&a.type==="MouseHover")try{let l=new Mhe(o,a,s,t,n);this.eventsPerObjects[s.uuid]?this.eventsPerObjects[s.uuid].push(l):this.eventsPerObjects[s.uuid]=[l]}catch{}((i=this.eventsPerObjects[s.uuid])==null?void 0:i.length)&&this.objects.push(s)}})}connect(){if(!this.objects.length)return;let{domElement:e}=this.eventContext;this.domEventsNeeded.clear(),Br&&(this.domEventsNeeded.add("pointerdown"),e.addEventListener("pointerdown",this.onMouseDown),this.domEventsNeeded.add("pointerup"),e.addEventListener("pointerup",this.onMouseUp)),this.domEventsNeeded.add("pointermove"),e.addEventListener("pointermove",this.onMouseMove),this.objects.forEach(t=>{t.addEventListener("userEvent",this.onUserEvent)})}disconnect(){if(!this.objects.length)return;let{domElement:e}=this.eventContext;this.domEventsNeeded.clear(),Br&&(e.removeEventListener("pointerdown",this.onMouseDown),e.removeEventListener("pointerup",this.onMouseUp)),e.removeEventListener("pointermove",this.onMouseMove),Object.values(this.eventsPerObjects).forEach(t=>{t.forEach(n=>{n.disconnect()})}),this.objects.forEach(t=>{t.removeEventListener("userEvent",this.onUserEvent)})}handleMouseHoverEvent(e=!1){let t=[];if(!e){let{stopRaycast:n,raycaster:s,scene:r}=this.eventContext;if(n){let i=AC(s,r,this.objects);t=IC(i)}else this.objects.forEach(i=>{wx(s,i)&&t.push(i)})}this._prevObjects.length&&this._prevObjects.forEach(n=>{var s;t.includes(n)||(n.dispatchEvent({type:"beginEvent",eventName:"MouseHover"}),(s=this.eventsPerObjects[n.uuid])==null||s.forEach(r=>r.dispatchLeave()))}),t.length&&t.forEach(n=>{var s;n.dispatchEvent({type:"beginEvent",eventName:"MouseHover"}),(s=this.eventsPerObjects[n.uuid])==null||s.forEach(r=>r.dispatchEnter())}),this._prevObjects=t}},Ohe=class{constructor(e,t,n,s,r){this.id=e,this.data=t,this.object=n,this.scrollCounter=0,this.actions=Xu(t,t.actions,n,s,r)}connect(){this.scrollCounter=0}disconnect(){Ku(this.actions)}dispatch(e){this.object.currentTransitionEvent!==this.id&&(this.object.currentTransitionEvent=this.id,this.actions.Transition.forEach(s=>{s.init()}));let t=e>0?1:-1;this.scrollCounter+=t,this.scrollCounter=Math.min(Math.max(this.scrollCounter,0),this.data.steps);let n=this.scrollCounter/this.data.steps;this.actions.Transition.forEach(s=>s.seek(n))}dispatchUserEvent(e){this.actions.Transition.forEach(t=>{t.toggle(!e)})}},Rhe=class extends Sc{constructor(e){super(e);this.eventsPerObject=new Map,this.onWheel=s=>{[...this.eventsPerObject.entries()].forEach(([r,i])=>{r.dispatchEvent({type:"beginEvent",eventName:"Scroll",deltaY:s.deltaY}),i.forEach(o=>o.dispatch(s.deltaY))})},this.onUserEvent=({eventName:s,target:r,reverse:i})=>{var a;if(!s||!r)return;let o=Ix(s);o&&o==="Scroll"&&(r.dispatchEvent({type:"beginEvent",eventName:"Scroll"}),(a=this.eventsPerObject.get(r))==null||a.forEach(l=>{l.dispatchUserEvent(i)}))};let{scene:t,sharedAssets:n}=this.eventContext;t.traverseEntity(s=>{var r,i;if((r=s.data)==null?void 0:r.events.length)for(let{id:o,data:a}of s.data.events){if(a.disabled||a.type!=="Scroll")continue;let l=new Ohe(o,a,s,t,n);this.eventsPerObject.has(s)?(i=this.eventsPerObject.get(s))==null||i.push(l):this.eventsPerObject.set(s,[l])}})}connect(){[...this.eventsPerObject.entries()].forEach(([e,t])=>{t.forEach(n=>n.connect()),e.addEventListener("userEvent",this.onUserEvent)}),[...this.eventsPerObject.values()].some(e=>e.length)&&(this.domEventsNeeded.add("wheel"),window.addEventListener("wheel",this.onWheel))}disconnect(){window.removeEventListener("wheel",this.onWheel),this.domEventsNeeded.clear(),[...this.eventsPerObject.entries()].forEach(([e,t])=>{t.forEach(n=>n.disconnect()),e.removeEventListener("userEvent",this.onUserEvent)})}},Lhe=class{constructor(e,t,n,s){this.data=e,this.object=t,this.actions=Xu(e,e.actions,t,n,s)}disconnect(){Ku(this.actions)}dispatch(){this.actions.Transition.forEach(e=>{e.play()})}dispatchAfter(e){this.actions.Audio.forEach(t=>{var n;((n=t.interaction.data.triggerAfter)!=null?n:"any")===e&&(t.interaction instanceof cp?t.interaction.audioPlayer.play():t.interaction instanceof NC&&t.interaction.dispatch())}),this.actions.Video.forEach(t=>{var s;let n=(s=t.interaction.data.triggerAfter)!=null?s:"autoplay";n===e&&(t.interaction instanceof Fm?t.interaction.play(n==="autoplay"):t.interaction instanceof kC&&t.interaction.dispatch())})}dispatchUserEvent(e){this.actions.Transition.forEach(t=>{t.toggle(!e)}),this.actions.Audio.forEach(t=>{t.interaction instanceof cp?t.interaction.audioPlayer.play():t.interaction instanceof NC&&t.interaction.dispatch()}),this.actions.Video.forEach(t=>{t.interaction instanceof Fm?t.interaction.play():t.interaction instanceof kC&&t.interaction.dispatch()})}},Fhe=class extends Sc{constructor(e){super(e);this.eventsPerObject=new Map,this.eventsAfterPerObject=new Map,this.onMouseDown=()=>{[...this.eventsAfterPerObject.entries()].forEach(([s,r])=>{s.dispatchEvent({type:"beginEvent",eventName:"Start"}),r.forEach(i=>{i.dispatchAfter("mouseDown")})})},this.onKeyDown=()=>{[...this.eventsAfterPerObject.entries()].forEach(([s,r])=>{s.dispatchEvent({type:"beginEvent",eventName:"Start"}),r.forEach(i=>{i.dispatchAfter("keyDown")})})},this.onAny=()=>{let{domElement:s,isExport:r}=this.eventContext;(r?document:s).removeEventListener("pointerdown",this.onAny),document.removeEventListener("keydown",this.onAny),[...this.eventsAfterPerObject.entries()].forEach(([i,o])=>{i.dispatchEvent({type:"beginEvent",eventName:"Start"}),o.forEach(a=>{a.dispatchAfter("any")})})},this.onPlay=()=>{[...this.eventsAfterPerObject.entries()].forEach(([s,r])=>{s.dispatchEvent({type:"beginEvent",eventName:"Start"}),r.forEach(i=>{i.dispatchAfter("autoplay")})})},this.onUserEvent=({eventName:s,target:r,reverse:i})=>{var a,l;if(!s||!r)return;let o=Ix(s);o&&o==="Start"&&(r.dispatchEvent({type:"beginEvent",eventName:"Start"}),(a=this.eventsPerObject.get(r))==null||a.forEach(c=>{c.dispatchUserEvent(i)}),(l=this.eventsAfterPerObject.get(r))==null||l.forEach(c=>{c.dispatchUserEvent(i)}))};let{scene:t,sharedAssets:n}=this.eventContext;t.traverseEntity(s=>{var r,i,o,a;if((r=s.data)==null?void 0:r.events.length)for(let{data:l}of s.data.events){if(l.disabled||l.type!=="Start")continue;let c=new Lhe(l,s,t,n);c.actions.Transition.length&&(this.eventsPerObject.has(s)?(i=this.eventsPerObject.get(s))==null||i.push(c):this.eventsPerObject.set(s,[c])),c.actions.Audio.length&&(this.eventsAfterPerObject.has(s)?(o=this.eventsAfterPerObject.get(s))==null||o.push(c):this.eventsAfterPerObject.set(s,[c])),c.actions.Video.length&&(this.hasVideoAction=!0,this.eventsAfterPerObject.has(s)?(a=this.eventsAfterPerObject.get(s))==null||a.push(c):this.eventsAfterPerObject.set(s,[c]))}})}connect(){if([...this.eventsAfterPerObject.values()].some(e=>e.length)){let{domElement:e,isExport:t}=this.eventContext,n=t?document:e;n.addEventListener("pointerdown",this.onMouseDown,{once:!0}),document.addEventListener("keydown",this.onKeyDown,{once:!0}),n.addEventListener("pointerdown",this.onAny),document.addEventListener("keydown",this.onAny),[...this.eventsAfterPerObject.entries()].forEach(([s,r])=>{s.addEventListener("userEvent",this.onUserEvent)}),this.onPlay()}[...this.eventsPerObject.entries()].forEach(([e,t])=>{e.dispatchEvent({type:"beginEvent",eventName:"Start"}),t.forEach(n=>n.dispatch()),e.addEventListener("userEvent",this.onUserEvent)})}disconnect(){if([...this.eventsAfterPerObject.values()].some(e=>e.length)){let{domElement:e,isExport:t}=this.eventContext,n=t?document:e;n.removeEventListener("pointerdown",this.onMouseDown),document.removeEventListener("keydown",this.onKeyDown),n.removeEventListener("pointerdown",this.onAny),document.removeEventListener("keydown",this.onAny),[...this.eventsAfterPerObject.entries()].forEach(([s,r])=>{s.removeEventListener("userEvent",this.onUserEvent),r.forEach(i=>i.disconnect())})}[...this.eventsPerObject.entries()].forEach(([e,t])=>{e.removeEventListener("userEvent",this.onUserEvent),t.forEach(n=>n.disconnect())})}},$he=class{constructor(e,t,n,s){this.data=e,this.object=t,this.disabled=!0,this.actions=Xu(e,e.actions,t,n,s),this.target=e.target,this.useToggle=e.toggle}disconnect(){Ku(this.actions)}dispatch(){this.disabled||(this.object.dispatchEvent({type:"beginEvent",eventName:"Collision"}),this.useToggle?this.actions.Transition.forEach(e=>{e.toggle()}):this.actions.Transition.forEach(e=>{e.play()}),this.actions.Link.forEach(e=>{e.dispatch()}),this.actions.Audio.forEach(e=>{e.dispatchBasic()}),this.actions.Video.forEach(e=>{e.dispatchBasic()}))}},as;kre.then(e=>as=e);new et;new I(1,1,1);var Vr=new I,_c=new un,Qu=new I,KC=new gr(0,0,0,"YXZ"),Bhe={type:"updateMatrix"},BF={type:"beginEvent",eventName:"Collision"};function zhe(e){if(e.scene.environment.usePhysics)return!0;let t=!1;return e.scene.objects.traverse((n,s)=>{for(let r of s.events)if(r.data.disabled!==!0&&r.data.type==="GameControl"&&r.data.collisionEnabled){t=!0;break}}),t}var zF=e=>e.states.some(t=>t.data.position!==void 0||t.data.rotation!==void 0||t.data.hiddenMatrix!==void 0||t.data.cloner!==void 0),UF=e=>e.events.find(t=>t.data.disabled!==!0&&t.data.type==="Follow"),Uhe=class{constructor(e,t,n,s,r,i=!1){var m,y,v,b;this.scene=t,this.sharedAssets=r,this.isExport=i,this.orbitControlsNeedsUpdate=!0,this.gameControls=[],this.gameControlStates=[],this.joysticks=[],this.joystickToGameControls=[],this.sharedGameControlGlobals={entitiesWithTransformAnim:[],eventsPerObjects:{},colliderToEntity:{},gamePads:[]},this.needsCollisionDetection=!1,this.initializationCounter=-1,this.rigidBodyToMesh=new Map,this.nActiveRigidBodies=0,this.collisionEvents=[],this.processRigidBody=x=>{if(x.bodyType()!==as.RigidBodyType.Dynamic)return;x.isSleeping()||this.nActiveRigidBodies++;let[w,S,C]=this.rigidBodyToMesh.get(x.handle);if(Vr.copy(x.translation()).multiplyScalar(this.pixelsPerMeter),_c.copy(x.rotation()),w.matrixWorld.compose(Vr,_c,S),w.hasNonUniformScale&&w.matrixWorld.multiply(w.shearScale),w.dispatchEvent(Bhe),C){let _=w.cloner;if(_&&_.objectForSample===void 0){_.matrixWorld.copy(w.matrixWorld);for(let T of _.children)T.updateMatrixWorld(!0)}for(let T of w.children)T.updateMatrixWorld(!0)}},this.handleCollisionEvents=(x,w,S)=>{if(S!==!1)if(this.gameControls.some(C=>C.object===this.sharedGameControlGlobals.colliderToEntity[x])){let C=this.sharedGameControlGlobals.colliderToEntity[w],_=this.sharedGameControlGlobals.eventsPerObjects[C.uuid];if(_===void 0)return;for(let T of _)T.data.target==="character"&&this.dispatchCollisionEvent(T,C)}else if(this.gameControls.some(C=>C.object===this.sharedGameControlGlobals.colliderToEntity[w])){let C=this.sharedGameControlGlobals.colliderToEntity[x],_=this.sharedGameControlGlobals.eventsPerObjects[C.uuid];if(_===void 0)return;for(let T of _)T.data.target==="character"&&this.dispatchCollisionEvent(T,C)}else{let C=this.sharedGameControlGlobals.colliderToEntity[x],_=this.sharedGameControlGlobals.eventsPerObjects[C.uuid];if(_!==void 0)for(let A of _)A.data.target==="scene"&&this.dispatchCollisionEvent(A,C);let T=this.sharedGameControlGlobals.colliderToEntity[w],E=this.sharedGameControlGlobals.eventsPerObjects[T==null?void 0:T.uuid];if(E!==void 0)for(let A of E)A.data.target==="scene"&&this.dispatchCollisionEvent(A,T)}},this.onBeginState=()=>{this.orbitControls&&(this.orbitControls.enabled=!1,this.orbitControlsNeedsUpdate=!1)},this.onCompleteState=({target:x})=>{this.orbitControls&&(this.orbitControls.enabled=!0,this.orbitControls.resetTo(x.getTarget(Vr),x.position,x.zoom,x.isUpVectorFlipped),x.prevState=null,x.currentState=null,x.reversibleToState=null,x.currentTransitionEvent=null,this.orbitControlsNeedsUpdate=!0)},this.domElement=n.domElement;let o;e.scene.publish.playCamera===null?o=vx.PERSONAL_CAMERA_ID:o=e.scene.publish.playCamera;let a=this.scene.find(o),l=!1,c,h=5,u=8,d=9,p="drag";if(this.usePhysics=(m=e.scene.environment.usePhysics)!=null?m:Ti.defaultData.usePhysics,this.pixelsPerMeter=(y=e.scene.environment.pixelsPerMeter)!=null?y:Ti.defaultData.pixelsPerMeter,(v=e.scene.objects.data(e.scene.publish.gameControlObject))==null||v.events.forEach(x=>{x.data.disabled!==!0&&x.data.type==="GameControl"&&(c=x.data.keyAssignments,h=x.data.joystickPosLoc,u=x.data.joystickRotLoc,d=x.data.jumpTouchButtonLoc,p=x.data.rotByTouch)}),this.scene.traverseEntity(x=>{x.dataPatched.events.forEach(w=>{var C,_;if(w.data.disabled||w.data.type!=="GameControl")return;let S=x;for(;((C=S=S.parent)==null?void 0:C.parent)!==null;)if((_=S.dataPatched.physics)==null?void 0:_.fusedBody)return;w.data.collisionEnabled&&(this.needsCollisionDetection=!0),this.gameControlStates.push([x,w.data])})}),this.usePhysics&&this.initPhysics((b=e.scene.environment.gravity)!=null?b:Ti.defaultData.gravity),this.gameControlStates.forEach(([x,w])=>{l=l||w.camera===a.uuid||x.uuid===a.uuid;let S=new qF(x,n.domElement,De(ue({},w),{keyAssignments:c}),e.scene.environment,this.sharedGameControlGlobals,x.uuid!==a.uuid&&w.camera===a.uuid,a,this.scene,r);S.addEventListener("change",s),S.addEventListener("end",s),S.addEventListener("start",s),this.gameControls.push(S),Br&&w.touchControl&&(this.joystickToGameControls[h]!==void 0?this.joystickToGameControls[h].push([S,"pos"]):this.joystickToGameControls[h]=[[S,"pos"]],w.moveMode==="walk"&&(this.joystickToGameControls[d]!==void 0?this.joystickToGameControls[d].push([S,"jmp"]):this.joystickToGameControls[d]=[[S,"jmp"]]),p==="joystick"&&(this.joystickToGameControls[u]!==void 0?this.joystickToGameControls[u].push([S,"rot"]):this.joystickToGameControls[u]=[[S,"rot"]]))}),l===!1){let{enableRotate:x,enablePan:w,enableZoom:S,autoRotate:C,hoverRotatePanMode:_}=e.scene.publish.orbitControls;if(x||w||S||C||_!==0){this.orbitControls=new JF(a,n.domElement,this.isExport),this.orbitControls.addEventListener("change",s),this.orbitControls.addEventListener("end",s),this.orbitControls.addEventListener("start",s),this.orbitControls.fromJSON(e.scene.publish.orbitControls),this.orbitControls.useKeyEvents=!1,this.orbitControls.connect(),this.orbitControls.update();let T=this.orbitControls.object;T.addEventListener("beginState",this.onBeginState),T.addEventListener("completeState",this.onCompleteState)}}let f=n.domElement.width/n.getPixelRatio(),g=n.domElement.height/n.getPixelRatio();this.joystickToGameControls.forEach((x,w)=>{var B;let S=document.body.appendChild(document.createElement("div")),[C,_,T]=((B=e.scene.publish.joystickSizeAndXYOffset)!=null?B:Ld.defaultData.joystickSizeAndXYOffset)[w],E=(f-5*C)/4+C,A={},D=x.some(F=>F[1]==="jmp"),O=D?0:C;w<10?(w<5?A.top=O/2:A.bottom=O/2,A.left=O/2+w%5*E):w===10?(A.left=O/2,A.top=g/2):(A.right=O/2,A.top=g/2),A.top?A.top-=_[1]:A.bottom+=_[1],A.left?A.left+=_[0]:A.right-=_[0];for(let F in A)A[F]+="px";if(D){let F=S.appendChild(document.createElement("div"));Object.assign(F.style,A,{position:"absolute",width:C+"px",height:C+"px",backgroundColor:`rgba(255,255,255,${T==="show"?.4:0})`,zIndex:"9999",borderRadius:C+"px",border:T==="show"?"solid 2px rgba(0, 0, 0, .1)":"none",display:"flex",alignItems:"center",justifyContent:"center",touchAction:"none"});let M=C/16*16*.4;T==="show"&&(F.innerHTML=`
						<svg width="${M}" height="${C*.4}" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
							<path d="M2 10L8 4L14 10" stroke="black" stroke-opacity="40%" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
						</svg>
					`),F.addEventListener("pointerdown",()=>{x.forEach(U=>{U[0].movementState.jump=1}),s()}),F.addEventListener("touchend",U=>U.preventDefault()),this.joysticks[w]=[void 0,S];return}let P={zone:S,mode:"static",position:A,size:C};T==="hide"&&(P.restOpacity=0);let L=Kce.create(P);L.on("move",(F,M)=>{x.forEach(U=>{let z=U[0];U[1]==="pos"?M.force<.2?z.moveForce=0:(z.movementState.movePosZ=Math.sin(-M.angle.radian),z.movementState.movePosX=Math.cos(-M.angle.radian),M.force<.3?z.moveForce=(M.force-.2)/.1:z.moveForce=1):M.force<.2?z.rotForce=0:(z.movementState.rotPosX=M.vector.y,z.movementState.rotPosY=-M.vector.x,M.force<.3?z.rotForce=(M.force-.2)/.1:z.rotForce=1)}),s()}),L.on("end",(F,M)=>{x.forEach(U=>{let z=U[0];U[1]==="pos"?(z.movementState.movePosZ=0,z.movementState.movePosX=0,z.moveForce=1):(z.movementState.rotPosX=0,z.movementState.rotPosY=0,z.rotForce=1)})}),this.joysticks[w]=[L,S]}),this.usePhysics===!1&&this.needsCollisionDetection&&this.initBVH(),this.initializationCounter++,window.setTimeout(()=>this.collisionEvents.forEach(x=>x.disabled=!1),80)}attachVRControllers(e){e.forEach(t=>{t.addEventListener("connected",n=>{"gamepad"in n.data&&"axes"in n.data.gamepad&&this.sharedGameControlGlobals.gamePads.push(n.data.gamepad)})})}initBVH(){let e=[];if(this.scene.traverseObject(t=>{let n;if(t instanceof fx)return;t instanceof Ru?n=t.object:n=t;let s=n.dataPatched;if(!s.visible)return!0;let r=t.geometry;if(zF(s)||UF(s)||n.dataPatched.events.some(i=>i.data.disabled!==!0&&i.data.type==="GameControl")){t.updateMatrixWorldSVD();let i=[];if((r==null?void 0:r.getAttribute("position"))!==void 0&&i.push(lp(r,t.shearScale)),t.traverseObject(this.gatherChildrenGeom(t,i)),t.children.forEach(o=>o.updateMatrixWorld(!0)),i.length>0){let o=Bd(i,!1);t.boundsTree=new rr(o),this.sharedGameControlGlobals.entitiesWithTransformAnim.push(t)}return!0}else r&&e.push(lp(r,t.matrixWorld))}),e.length>0){let t=Bd(e,!1);this.sharedGameControlGlobals.staticMeshBVH=new rr(t)}}addCollider(e,t,n,s,r,i=!0){var l,c;if((s==null?void 0:s.getAttribute("position").count)===0||((l=s==null?void 0:s.getIndex())==null?void 0:l.count)===0)return;let o;r!==void 0?r.collider.type==="sphere"?o=as.ColliderDesc.ball(r.collider.radius/this.pixelsPerMeter):r.collider.type==="capsule"?o=as.ColliderDesc.capsule((r.collider.height/2-r.collider.radius)/this.pixelsPerMeter,r.collider.radius/this.pixelsPerMeter):o=as.ColliderDesc.cuboid(r.collider.width/this.pixelsPerMeter/2,r.collider.height/this.pixelsPerMeter/2,r.collider.depth/this.pixelsPerMeter/2):s&&(n.colliderType==="trimesh"?o=as.ColliderDesc.trimesh(s.getAttribute("position").array,s.getIndex().array):o=as.ColliderDesc.convexMesh(s.getAttribute("position").array,i?s.getIndex().array:void 0)),o.setFrictionCombineRule(as.CoefficientCombineRule.Average).setRestitutionCombineRule(as.CoefficientCombineRule.Average).setDensity(n.density).setFriction(n.friction).setRestitution(n.restitution);let a=this.sharedGameControlGlobals.rapierWorld.createCollider(o,t);if(this.sharedGameControlGlobals.colliderToEntity[a.handle]=e,r!==void 0){Vr.fromArray(r.collider.position).multiply(Qu.setFromMatrixScale(e.matrixWorld)).divideScalar(this.pixelsPerMeter),a.setTranslationWrtParent(Vr);let h=new un().setFromEuler(new gr().setFromVector3(new I().fromArray(r.collider.rotation)));a.setRotationWrtParent(h),a.setActiveEvents(as.ActiveEvents.COLLISION_EVENTS)}else((c=this.sharedGameControlGlobals.eventsPerObjects[e.uuid])==null?void 0:c.some(h=>h.target==="scene"))&&a.setActiveEvents(as.ActiveEvents.COLLISION_EVENTS)}gatherChildrenGeom(e,t){return(n,s)=>{if(s===0)return;s===1?e.hasNonUniformScale?n.matrixWorld.multiplyMatrices(e.shearScale,n.hiddenMatrix):n.matrixWorld.copy(e.hiddenMatrix):n.matrixWorld.multiplyMatrices(n.parent.matrixWorld,n.hiddenMatrix),n.matrixWorld.multiply(n.matrix);let r=n.geometry;(r==null?void 0:r.getAttribute("position"))!==void 0&&t.push(lp(r,n.matrixWorld))}}initPhysics(e){this.sharedGameControlGlobals.rapierWorld=new as.World(new as.Vector3(0,e!=null?e:-10,0)),this.events=new as.EventQueue(!0);let t=[];if(this.scene.traverseObject(o=>{var f;let a;if(o instanceof fx)if(o.objectForSample){if(o.objectForSample.dataPatched.physics.fusedBody)return;a=o.object}else return o.object.dataPatched.physics.fusedBody===!0&&o.object.dataPatched.physics.rigidBody==="dynamic"?!0:void 0;else o instanceof Ru?a=o.object:a=o;let l=a.dataPatched;if(!l.physics||!l.visible)return!0;o.updateMatrixWorldSVD();let c=zF(l),h=UF(l),u,d=!1;for(let g of l.events)if(g.data.disabled!==!0){if(g.data.type==="GameControl")u=g.data;else if(g.data.type==="Collision"){d=!0;let m=new $he(g.data,a,this.scene,this.sharedAssets);this.collisionEvents.push(m),this.sharedGameControlGlobals.eventsPerObjects[a.uuid]?this.sharedGameControlGlobals.eventsPerObjects[a.uuid].push(m):this.sharedGameControlGlobals.eventsPerObjects[a.uuid]=[m]}}l.physics.rigidBody==="dynamic"&&l.physics.fusedBody===!1&&(o.matrixWorldFusedFalse=o.matrixWorld.clone());let p=o.geometry;if(l.physics.rigidBody==="dynamic"||c||h||d||u!==void 0){let g=[];if((p==null?void 0:p.getAttribute("position"))!==void 0&&g.push(lp(p,o.shearScale)),l.physics.fusedBody){let m=this.gatherChildrenGeom(o,g);o.traverseObject(m),o.children.forEach(v=>v.updateMatrixWorld(!0));let y=o.cloner;y&&y.objectForSample===void 0&&l.physics.rigidBody==="dynamic"&&(y.traverseObject(m),y.children.forEach(v=>v.updateMatrixWorld(!0)))}if(g.length>0||u!==void 0){let m;u!==void 0?m=as.RigidBodyDesc.kinematicPositionBased():l.physics.rigidBody==="dynamic"?(m=as.RigidBodyDesc.dynamic(),m.setLinearDamping(l.physics.damping).setAdditionalMass(1e-9).setGravityScale(l.physics.gravityScale).enabledRotations(...l.physics.enabledRotation).enabledTranslations(...l.physics.enabledTranslation)):c||h?(m=as.RigidBodyDesc.kinematicPositionBased(),this.sharedGameControlGlobals.entitiesWithTransformAnim.push(o)):m=as.RigidBodyDesc.fixed();let y;y=g.length>0?Bd(g):void 0,(o.hasNonUniformScale?o.matrixWorldRigid:o.matrixWorld).decompose(Vr,_c,Qu),o.position0=Vr.clone().divideScalar(this.pixelsPerMeter),o.rotation0=_c.clone(),Vr.divideScalar(this.pixelsPerMeter),m.setTranslation(Vr.x,Vr.y,Vr.z).setRotation(_c),p?y==null||y.scale(1/this.pixelsPerMeter,1/this.pixelsPerMeter,1/this.pixelsPerMeter):y==null||y.scale(Qu.x/this.pixelsPerMeter,Qu.y/this.pixelsPerMeter,Qu.z/this.pixelsPerMeter);let v=this.sharedGameControlGlobals.rapierWorld.createRigidBody(m);u===void 0&&l.physics.rigidBody==="dynamic"&&this.rigidBodyToMesh.set(v.handle,[o,Qu.clone(),l.physics.fusedBody]),o.rigidBody=v;let b=!(l.geometry===void 0||l.geometry.type==="SubdivGeometry"||l.geometry.type==="NonParametricGeometry"||l.geometry.type==="BooleanGeometry"||l.geometry.type==="VectorGeometry"||l.geometry.type==="StarGeometry"||l.geometry.type==="RectangleGeometry"||l.geometry.type==="EllipseGeometry"||l.geometry.type==="TriangleGeometry"||l.geometry.type==="TorusGeometry"||l.geometry.type==="HelixGeometry");try{this.addCollider(a,v,l.physics,y,u,b)}catch{try{this.addCollider(a,v,l.physics,y,u,!1)}catch(x){console.error(x)}}}}else p&&t.push(lp(p,o.matrixWorld)),l.physics.fusedBody&&o.traverse(g=>{!g.geometry||g===o||t.push(lp(g.geometry,g.matrixWorld))});if(((f=l.physics)==null?void 0:f.fusedBody)===!0||u)return!0}),t.length===0)return;let n=Bd(t);n.scale(1/this.pixelsPerMeter,1/this.pixelsPerMeter,1/this.pixelsPerMeter);let s=as.RigidBodyDesc.fixed(),r=this.sharedGameControlGlobals.rapierWorld.createRigidBody(s),i=as.ColliderDesc.trimesh(n.getAttribute("position").array,n.getIndex().array).setFrictionCombineRule(as.CoefficientCombineRule.Multiply).setRestitutionCombineRule(as.CoefficientCombineRule.Multiply).setFriction(1).setRestitution(1);this.sharedGameControlGlobals.rapierWorld.createCollider(i,r)}updatePositions(){return this.nActiveRigidBodies=0,this.sharedGameControlGlobals.rapierWorld.forEachRigidBody(this.processRigidBody),this.nActiveRigidBodies>0}dispose(){var e;if(this.scene.traverse(t=>{let n=t;n.matrixWorldFusedFalse&&(n.matrixWorldFusedFalse=void 0),n.rigidBody&&(n.rigidBody=void 0),n.position0&&(n.position0=void 0),n.rotation0&&(n.rotation0=void 0)}),(e=this.sharedGameControlGlobals.rapierWorld)==null||e.free(),this.sharedGameControlGlobals.staticMeshBVH=void 0,this.sharedGameControlGlobals.entitiesWithTransformAnim=[],this.gameControls.forEach(t=>{t.reset(),t.dispose()}),this.gameControls=[],this.joysticks.forEach(([t,n])=>{t==null||t.destroy(),n.remove()}),this.joystickToGameControls=[],this.joysticks=[],this.orbitControls){let t=this.orbitControls.object;t.removeEventListener("beginState",this.onBeginState),t.removeEventListener("completeState",this.onCompleteState),this.orbitControls.dispose(),this.orbitControls=void 0}for(let t of Object.values(this.sharedGameControlGlobals.eventsPerObjects))t.forEach(n=>n.disconnect());this.sharedGameControlGlobals.eventsPerObjects={},this.scene.updateMatrixWorld(!0)}update(e,t,n){var r;let s=!0;if(this.orbitControls!==void 0&&this.orbitControlsNeedsUpdate&&(s=!this.orbitControls.update()),this.initializationCounter>=0&&this.initializationCounter<2)this.initializationCounter++,s=!1;else if(this.initializationCounter===2)for(let i of this.gameControls)s=!i.update(e,t,n)&&s;if(this.usePhysics){for(let i of this.sharedGameControlGlobals.entitiesWithTransformAnim){(i.hasNonUniformScale?i.matrixWorldRigid:i.matrixWorld).decompose(Vr,_c,Qu),KC.setFromQuaternion(_c);let o=i;o.prevR===void 0?(o.prevR=KC.clone(),o.prevT=Vr.clone()):(o.prevR.copy(KC),o.prevT.copy(Vr)),i.rigidBody.setNextKinematicTranslation(Vr.divideScalar(this.pixelsPerMeter)),i.rigidBody.setNextKinematicRotation(_c)}this.sharedGameControlGlobals.rapierWorld.step(this.events),(r=this.events)==null||r.drainCollisionEvents(this.handleCollisionEvents),s=!this.updatePositions()&&s}return s}dispatchCollisionEvent(e,t){t.dispatchEvent(BF),e.dispatch()}},YC={type:"change"},Vhe={type:"lock"},Ghe={type:"unlock"};new I;var VF=new I,GF=new I,Whe=new I,Gr=new I,Di=new I,Cc=new I,QC=new et,WF=new et,Hhe=new et;new et;var zo=new un,El=new un,Ba=new gr(0,0,0,"YXZ"),jhe=new I(1,0,0),Uo=new I(0,1,0),qhe=new I(0,0,1),HF=new I(1,1,1),Xhe=1,Khe=.025,Yhe=16e-6,Qhe=12,Zhe=20,br=new qi,io=new Ss,Jhe={type:"requestRender"},jF=Math.PI/6,ZC=class extends Zr{constructor(e,t,n,s,r,i,o,a,l){super();var f,g,m,y,v,b,x,w,S,C,_,T,E,A,D,O,P,L,B,F,M,U,z;this.object=e,this.domElement=t,this.sharedGameControlGlobals=r,this.cameraFollow=i,this.camera=o,this.scene=a,this.sharedAssets=l,this.enableDamping=!0,this.position0=new I,this.rotation0=new gr(0,0,0,"XYZ"),this.scale0=new I,this.hiddenMatrix0=new et,this.target0=new I,this.zoom0=1,this.rotForce=1,this.moveForce=1,this.euler0=new gr(0,0,0,"YXZ"),this.position0Cam=new I,this.quat0Cam=new un,this.scale0Cam=new I,this.hiddenMatrix0Cam=new et,this.threshEndTranslate=.01,this.threshEndRotate=1e-8,this.threshEndRotVel=.005,this.collider={type:"capsule",radius:40,segment:new qi(new I(0,-40,0),new I(0,40,0)),matrix:new et,position:new I,rotation:new un},this.euler=new gr(0,0,0,"YXZ"),this.eulerDelta=new I,this.lastPosition=new I,this.lastCameraQuaternion=new un,this.lastCameraPosition=new I,this.PI_2=Math.PI/2,this.prevMouse=new se,this.velocityTarget=new I,this.velocity=new I,this.directionXZ=new I,this.rotVelocityStick=new I,this.rotVelocityTarget=new I,this.rotVelocity=new I,this.rotDirection=new I,this.nonColliderRotOffset=new et,this.nonColliderPosOffset=new et,this.firstPointerId=-1,this.rot=new I,this.movementState={moveNegZ:0,movePosZ:0,moveNegX:0,movePosX:0,moveNegY:0,movePosY:0,rotPosX:0,rotNegX:0,rotPosY:0,rotNegY:0,jump:0},this.vrEulerYOffset=0,this.onObject=!1,this.actionState={},this.keyAssignments=[["moveNegZ","W"],["moveNegX","A"],["movePosZ","S"],["movePosX","D"],["rotPosX","ArrowUp"],["rotPosY","ArrowLeft"],["rotNegX","ArrowDown"],["rotNegY","ArrowRight"],["jump"," "]],this.collisionEnabled=!0,this.offsetMatrix=new et,this.objectToTarget=new I,this.objectToTarget0=new I,this.objectToCamXZ=new I,this.objectToCamXZ0=new I,this.targetToCamera=new I,this.targetToCamera0=new I,this.cameraPolarAxis0=new I,this.targetPos=new I,this.targetQuat=new un,this.lerpFactorPos=new I().setScalar(.3),this.lerpFactorPosStart=.3,this.lerpFactorPosEnd=.3,this.lerpFactorRotStart=.3,this.lerpFactorRotEnd=.3,this.lerpFactorPosCamera=.3,this.lerpFactorRotCamera=.3,this.objXZQuat=new un,this.objXZQuatInv=new un,this.objXZRotMat=new et,this.isFirstPerson=!1,this.actions={},this.didHit=!1,this.groundVelocity=new I,this.pushedVelocity=new I,this.groundYRotation=0,this.objectRealQuat=new un,this.colliderWorldQuat=new un,this.groundNormal=new I,this.groundTilt=new un,this.groundTiltInv=new un,this.lastHitObj=null,this.isFirstFrame=!0,this.rotationAccumWhenOrientWithCamera=0,this.onPointerDown=$=>{$.target!==this.domElement||this.firstPointerId!==-1||(this.firstPointerId=$.pointerId,this.domElement.ownerDocument.addEventListener("pointermove",this.onPointerMove),this.domElement.ownerDocument.addEventListener("pointerup",this.onPointerUp),this.rotBy!=="keys"&&!Br&&(!Iv||Nv>=15.5)&&this.domElement.requestPointerLock(),this.prevMouse.set($.clientX,$.clientY))},this.onPointerUp=$=>{this.firstPointerId=-1,this.domElement.ownerDocument.removeEventListener("pointermove",this.onPointerMove),this.domElement.ownerDocument.removeEventListener("pointerup",this.onPointerUp),$.pointerType==="mouse"&&this.domElement.ownerDocument.exitPointerLock()},this.onPointerMove=$=>{if($.pointerId!==this.firstPointerId)return;let R=$.clientX-this.prevMouse.x,H=$.clientY-this.prevMouse.y;this.prevMouse.set($.clientX,$.clientY),$.pointerType==="mouse"&&this.rotBy!=="keys"&&(Iv&&Nv<15.5&&!Br?(this.eulerDelta.y=-R*this.mouseOrbitSensitivity,this.eulerDelta.x=-H*this.mouseOrbitSensitivity):(this.eulerDelta.y=-$.movementX*this.mouseOrbitSensitivity,this.eulerDelta.x=-$.movementY*this.mouseOrbitSensitivity)),$.pointerType!=="mouse"&&this.rotByTouch==="drag"&&(this.eulerDelta.y=-R*this.mouseOrbitSensitivity*5,this.eulerDelta.x=-H*this.mouseOrbitSensitivity*5),this.dispatchEvent(YC)},this.onPointerlockChange=$=>{this.domElement.ownerDocument.pointerLockElement===this.domElement?(this.dispatchEvent(Vhe),ZC.isLocked=!0):(this.dispatchEvent(Ghe),ZC.isLocked=!1)},this.onPointerlockError=()=>{console.error("SPE.GameControls: Unable to use Pointer Lock API")},this.onKeyDown=$=>{!($.target instanceof HTMLInputElement)&&($.code==="ArrowLeft"||$.code==="ArrowUp"||$.code==="ArrowRight"||$.code==="ArrowDown"||$.code==="Space")&&$.preventDefault();for(let R of this.keyAssignments)if($.key.toUpperCase()===R[1]||$.key===R[1]){this.movementState[R[0]]=1;break}this.dispatchEvent(YC)},this.onKeyUp=$=>{for(let R of this.keyAssignments)if($.key.toUpperCase()===R[1]||$.key===R[1]||$.code.slice(3,$.code.length).toUpperCase()===R[1]){this.movementState[R[0]]=0;break}},this.copyVRGamePadValues=($,R)=>{for(let H=2;H<4;H++){let K=$.axes[H];R===0?H===2?this.movementState.movePosX=K:this.movementState.movePosZ=K:($.buttons[3].pressed?this.movementState.jump=1:this.movementState.jump=0,H===2?(Math.abs(this.movementState.rotPosY)<.3&&Math.abs(K)>=.3&&(this.vrEulerYOffset+=K<0?1:-1),this.movementState.rotPosY=K):this.moveMode==="fly"&&(this.movementState.moveNegY=K))}},e===o&&(this.isFirstPerson=!0),this.position0.copy(this.object.position),this.rotation0.copy(this.object.rotation),this.scale0.copy(this.object.scale),this.hiddenMatrix0.copy(this.object.hiddenMatrix),this.object.parent?this.object.hiddenMatrix.copy(this.object.parent.matrixWorld).invert():this.object.hiddenMatrix.identity(),this.object.matrix.copy(this.object.matrixWorld),this.object.matrix.decompose(this.object.position,this.object.quaternion,this.object.scale),this.object.rotation.reorder("YXZ"),this.euler0.copy(this.object.rotation);let c=this.object.rotation.y;if(this.objectRealQuat.copy(this.object.quaternion),this.object.rotation.y=0,this.objXZQuat.copy(this.object.quaternion),this.objXZQuatInv.copy(this.objXZQuat).invert(),this.objXZRotMat.makeRotationFromQuaternion(this.object.quaternion),this.object.rotation.set(0,c,0),this.rot.setFromEuler(this.object.rotation),this.object.matrixAutoUpdate=!1,(this.isFirstPerson||this.cameraFollow===!0)&&(this.target0.copy(this.camera.getTarget()),this.zoom0=this.camera.zoom),this.cameraFollow===!0){if(this.position0Cam.copy(this.camera.position),this.quat0Cam.copy(this.camera.quaternion),this.scale0Cam.copy(this.camera.scale),this.hiddenMatrix0Cam.copy(this.camera.hiddenMatrix),(g=(f=this.camera)==null?void 0:f.parent)==null?void 0:g.parent){let Y=this.camera.matrix.clone().invert().premultiply(this.camera.matrixWorld),X=Y.clone().invert();this.camera.hiddenMatrix.multiply(X),this.camera.matrix.premultiply(Y),this.camera.matrixWorld.decompose(this.camera.position,this.camera.quaternion,this.camera.scale)}this.camera.matrixAutoUpdate=!1,this.offsetMatrix.copy(this.object.matrix).invert().multiply(this.camera.matrix);let $=new I(0,0,-1).applyQuaternion(this.camera.quaternion),R=new I().subVectors(this.object.position,this.camera.position);this.objectToCamXZ.copy(R),this.objectToCamXZ.y=0,this.objectToCamXZ0.copy(this.objectToCamXZ);let H;if(Math.abs($.y)<1e-6){R.y=0,$.y=0;let Y=R.projectOnVector($);this.targetToCamera0.copy(Y).negate(),H=this.camera.position.clone().add(Y)}else{let Y=$.multiplyScalar(R.y/$.y);this.targetToCamera0.copy(Y).negate(),H=Y.clone().add(this.camera.position)}this.objectToTarget0.subVectors(H,this.object.position);let K=new gr().setFromQuaternion(this.camera.quaternion,"YXZ");this.cameraPolarOffset=-K.x,K.x=0,K.z=0,K.y-=Math.PI/2,this.cameraPolarAxis0.set(0,0,-1).applyEuler(K)}if(this.object instanceof _l&&(this.object.matrixAutoUpdate=!1),this.euler.setFromQuaternion(this.object.quaternion,"YXZ"),this.connect(),this.rotByTouch=(m=n.rotByTouch)!=null?m:"joystick",this.rotBy=(y=n.rotBy)!=null?y:"keys",this.rotationMode=(v=n.rotationMode)!=null?v:"normal",this.moveMode=(b=n.moveMode)!=null?b:"walk",this.collisionEnabled=n.collisionEnabled,this.speedTranslate=((x=n.speedTranslate)!=null?x:250)*Xhe,this.speedOrbit=((w=n.speedRotate)!=null?w:100)*Khe,this.mouseOrbitSensitivity=((S=n.speedRotate)!=null?S:100)*Yhe,this.keyAssignments=n.keyAssignments.map($=>{let R=[$[0],$[1]];return R[1]==="\u25B2"?R[1]="ArrowUp":R[1]==="\u25C0"?R[1]="ArrowLeft":R[1]==="\u25BC"?R[1]="ArrowDown":R[1]==="\u25B6"?R[1]="ArrowRight":R[1]==="\u21E7"?R[1]="Shift":R[1]==="\u21B5"?R[1]="Enter":R[1]==="Space"?R[1]=" ":R[1]==="\u2318"?R[1]="Meta":R[1]==="Ctrl"?R[1]="Control":R[1]==="Esc"&&(R[1]="Escape"),R}),n.rotBy==="mouse"){let $;$=this.keyAssignments.findIndex(R=>R[0]==="rotNegX"),$!==-1&&(this.keyAssignments[$][1]=""),$=this.keyAssignments.findIndex(R=>R[0]==="rotPosX"),$!==-1&&(this.keyAssignments[$][1]=""),$=this.keyAssignments.findIndex(R=>R[0]==="rotPosY"),$!==-1&&(this.keyAssignments[$][1]=""),$=this.keyAssignments.findIndex(R=>R[0]==="rotNegY"),$!==-1&&(this.keyAssignments[$][1]="")}this.lerpFactorPosStart=1-.02**(1/(((C=n.delayPos[0])!=null?C:.3)*60)),this.lerpFactorPosEnd=1-.02**(1/(((_=n.delayPos[1])!=null?_:.3)*60)),this.lerpFactorPos.setScalar(this.lerpFactorPosStart),this.lerpFactorRotStart=1-.02**(1/(((T=n.delayRot[0])!=null?T:.3)*60)),this.lerpFactorRotEnd=1-.02**(1/(((E=n.delayRot[1])!=null?E:.3)*60)),this.lerpFactorPosCamera=1-.02**(1/(((A=n.delayPosCamera)!=null?A:.3)*60)),this.lerpFactorRotCamera=1-.02**(1/(((D=n.delayRotCamera)!=null?D:.3)*60)),this.gravity=((O=s.gravity)!=null?O:Ti.defaultData.gravity)*Qhe,this.pixelsPerMeter=(P=s.pixelsPerMeter)!=null?P:Ti.defaultData.pixelsPerMeter,this.usePhysics=(L=s.usePhysics)!=null?L:Ti.defaultData.usePhysics,this.jumpPower=n.jumpPower*Zhe,this.resetYPosition=n.resetYPosition,this.alignToGround=(B=n.alignToGround)!=null?B:!1,this.orientMode=n.autoOrientMove?n.orientMode:"none",this.orientWith=(F=n.orientWith)!=null?F:p2.defaultDataThirdPerson.orientWith;let h=(M=s.skinWidthRelative)!=null?M:Ti.defaultData.skinWidthRelative,u=(U=s.stepThreshRelative)!=null?U:Ti.defaultData.stepThreshRelative;this.slopeThresh=((z=s.slopeThresh)!=null?z:Ti.defaultData.slopeThresh)*Math.PI/180,n.collider.type==="capsule"?(this.collider.radius=n.collider.radius,this.collider.segment.start.y=n.collider.height/2-n.collider.radius,this.collider.segment.end.y=-this.collider.segment.start.y,this.offset=n.collider.height*h/this.pixelsPerMeter,this.stepThresh=n.collider.height*u/this.pixelsPerMeter):n.collider.type==="sphere"?(this.collider.radius=n.collider.radius,this.collider.segment.start.y=0,this.collider.segment.end.y=0,this.offset=2*n.collider.radius*h/this.pixelsPerMeter,this.stepThresh=2*n.collider.radius*u/this.pixelsPerMeter):(this.offset=n.collider.height*h/this.pixelsPerMeter,this.stepThresh=n.collider.height*u/this.pixelsPerMeter),this.collider.type=n.collider.type;let d=new I().fromArray(n.collider.position),p=new un().setFromEuler(new gr().fromArray([...n.collider.rotation,"XYZ"]));this.collider.position.copy(d).multiply(this.object.scale),this.collider.rotation.copy(p),this.collider.matrix.compose(d,p,HF),n.cameraXAxis!==void 0&&(this.cameraXAxis=n.cameraXAxis,this.cameraYAxis=n.cameraYAxis,this.minPolarAngle=n.cameraRotXLimits[0],this.maxPolarAngle=n.cameraRotXLimits[1],this.minAzimuthAngleRel=n.cameraRotYLimits[0],this.maxAzimuthAngleRel=n.cameraRotYLimits[1]),n.gameActions!==void 0&&Object.entries(n.gameActions).forEach(([$,R],H)=>{R.forEach(({id:K,data:Y})=>{try{this.actions[$]===void 0&&(this.actions[$]=[]),Y.type==="Transition"?this.actions[$].push(new dp(Y,a,l)):Y.type==="Audio"?this.actions[$].push(new up(K,Y,e,l)):Y.type==="Video"&&this.actions[$].push(new Sx(K,Y,e))}catch{}})}),this.dispatchStopEvent("move"),this.dispatchStopEvent("jump"),this.dispatchStartEvent("idle")}reset(e=!1){if(this.object.rotation.copy(this.rotation0),this.object.position.copy(this.position0),this.object.scale.copy(this.scale0),this.object.hiddenMatrix.copy(this.hiddenMatrix0),e===!0){this.object.updateMatrix(),this.object.updateMatrixWorld(),this.object.matrix.copy(this.object.matrixWorld),this.object.matrix.decompose(this.object.position,this.object.quaternion,this.object.scale),this.object.parent?this.object.hiddenMatrix.copy(this.object.parent.matrixWorld).invert():this.object.hiddenMatrix.identity(),this.object.rotation.reorder("YXZ");let t=this.object.rotation.y;this.object.rotation.y=0,this.objXZQuat.copy(this.object.quaternion),this.objXZQuatInv.copy(this.objXZQuat).invert(),this.objXZRotMat.makeRotationFromQuaternion(this.object.quaternion),this.object.rotation.set(0,t,0),this.rot.setFromEuler(this.object.rotation),this.euler.setFromQuaternion(this.object.quaternion,"YXZ"),this.velocityTarget.set(0,0,0),this.velocity.set(0,0,0)}e===!1&&(this.object instanceof _l?this.object.matrixAutoUpdate=!0:this.object.updateMatrix()),this.cameraFollow===!0&&(this.camera.quaternion.copy(this.quat0Cam),this.camera.position.copy(this.position0Cam),this.camera.scale.copy(this.scale0Cam),this.camera.hiddenMatrix.copy(this.hiddenMatrix0Cam),this.camera.matrixAutoUpdate=!0),this.dispatchEvent(YC)}connect(){this.domElement.ownerDocument.addEventListener("pointerdown",this.onPointerDown),this.domElement.ownerDocument.addEventListener("keydown",this.onKeyDown),this.domElement.ownerDocument.addEventListener("keyup",this.onKeyUp),this.domElement.ownerDocument.addEventListener("pointerlockchange",this.onPointerlockChange),this.domElement.ownerDocument.addEventListener("pointerlockerror",this.onPointerlockError)}disconnect(){this.domElement.ownerDocument.removeEventListener("pointerdown",this.onPointerDown),this.domElement.ownerDocument.removeEventListener("keydown",this.onKeyDown),this.domElement.ownerDocument.removeEventListener("keyup",this.onKeyUp),this.domElement.ownerDocument.removeEventListener("pointerlockchange",this.onPointerlockChange),this.domElement.ownerDocument.removeEventListener("pointerlockerror",this.onPointerlockError)}dispose(){this.disconnect(),Object.values(this.actions).forEach(e=>{e.forEach(t=>{(t instanceof dp||t instanceof up||t instanceof Sx)&&t.dispose()})})}resetTo(e,t,n){}dispatchStartEvent(e){this.actions[e]!==void 0&&(this.actionState[e]||(this.actionState[e]=!0,this.actions[e].forEach(t=>{t instanceof dp?t.play():t instanceof up&&t.dispatchGameControl("start")})))}dispatchStopEvent(e){this.actions[e]!==void 0&&(!this.actionState[e]||(this.actionState[e]=!1,this.actions[e].forEach(t=>{t instanceof dp?t.stop():t instanceof up&&t.dispatchGameControl("stop")}),this.object.traverseEntity(t=>{t.currentState!==null&&t.changeSelectedState(null,{scene:this.scene,shared:this.sharedAssets})})))}update(e,t,n){var a,l,c,h,u;if(this.gravity<0?this.object.position.y<this.resetYPosition:this.object.position.y>this.resetYPosition)return this.reset(!0),!0;this.sharedGameControlGlobals.gamePads.forEach(this.copyVRGamePadValues);let s=(this.isFirstFrame?16.6:e)/1e3;this.isFirstFrame&&(this.isFirstFrame=!1);let r=s*60,i=!1;if(this.usePhysics&&this.collisionEnabled){let d=Di.set(0,(this.velocity.y===0?this.pixelsPerMeter*Math.max(Math.abs(this.gravity)/10,1)*(this.gravity>0?1:-1):this.velocity.y)*s,0).divideScalar(this.pixelsPerMeter),p=this.sharedGameControlGlobals.rapierWorld.castShape(Gr.copy(this.collider.position).applyQuaternion(this.objectRealQuat).add(this.object.position).divideScalar(this.pixelsPerMeter),this.colliderWorldQuat,d,(a=this.object.rigidBody)==null?void 0:a.collider(0).shape,1,8,void 0,void 0,this.object.rigidBody);if(p){this.onObject=!0,this.groundNormal.set(p.normal2.x,p.normal2.y,p.normal2.z).applyQuaternion(this.colliderWorldQuat).negate(),this.alignToGround&&this.groundTiltAdjustment(this.groundNormal),Math.acos(this.groundNormal.y)<this.slopeThresh&&(i=!0);let f=p.collider._parent;this.groundYRotation=0,this.groundVelocity.set(0,0,0);for(let g of this.sharedGameControlGlobals.entitiesWithTransformAnim)if(g.rigidBody===f){(g.hasNonUniformScale?g.matrixWorldRigid:g.matrixWorld).decompose(Gr,El,Di),this.groundVelocity.subVectors(Gr,g.prevT),this.object.getWorldPosition(Di).add(this.collider.position).sub(g.position),this.groundYRotation=Ba.setFromQuaternion(El).y-g.prevR.y,Cc.copy(Di).applyAxisAngle(Uo,this.groundYRotation),this.groundVelocity.add(Cc.sub(Di)).divideScalar(s);break}}else this.onObject=!1}this.moveMode==="walk"&&this.collisionEnabled&&(this.movementState.jump===1&&this.onObject&&(this.velocityTarget.y=this.jumpPower,this.movementState.jump=0,this.dispatchStopEvent("idle"),this.dispatchStopEvent("move"),this.dispatchStopEvent("jump"),this.dispatchStartEvent("jump"),this.onObject=!1),this.velocityTarget.y+=this.onObject?0:this.gravity*r),this.moveMode==="fly"&&(this.velocityTarget.y=(this.movementState.movePosY-this.movementState.moveNegY)*this.speedTranslate),this.directionXZ.z=this.movementState.movePosZ-this.movementState.moveNegZ,this.directionXZ.x=this.movementState.movePosX-this.movementState.moveNegX,this.directionXZ.normalize(),this.movementState.moveNegZ||this.movementState.movePosZ?this.velocityTarget.z=this.directionXZ.z*this.speedTranslate*this.moveForce:this.velocityTarget.z=0,this.movementState.moveNegX||this.movementState.movePosX?this.velocityTarget.x=this.directionXZ.x*this.speedTranslate*this.moveForce:this.velocityTarget.x=0,(this.moveMode==="walk"?this.velocityTarget.x+this.velocityTarget.z===0:this.velocityTarget.manhattanLength()===0)?this.lerpFactorPos.setScalar(this.lerpFactorPosEnd):this.lerpFactorPos.setScalar(this.lerpFactorPosStart),this.moveMode==="walk"&&(this.lerpFactorPos.y=1),this.didHit===!1&&this.pushedVelocity.manhattanLength()===0||this.usePhysics===!1?(this.velocity.x+=(this.velocityTarget.x-this.velocity.x)*(1-(1-this.lerpFactorPos.x)**r),this.velocity.y+=(this.velocityTarget.y-this.velocity.y)*(1-(1-this.lerpFactorPos.y)**r),this.velocity.z+=(this.velocityTarget.z-this.velocity.z)*(1-(1-this.lerpFactorPos.z)**r)):this.velocity.copy(this.velocityTarget),(this.moveMode==="walk"?this.velocity.x**2+this.velocity.z**2<this.speedTranslate:this.velocity.lengthSq()<this.speedTranslate)?(this.dispatchStopEvent("move"),this.onObject&&(this.dispatchStopEvent("jump"),this.dispatchStartEvent("idle"))):(this.dispatchStopEvent("idle"),this.onObject&&(this.dispatchStopEvent("jump"),this.dispatchStartEvent("move")));let o=Whe.copy(this.velocity);if(this.orientMode!=="none"&&this.isFirstPerson===!1){let d=Di.copy(o);d.y=0,o.set(0,o.y,d.length()*-1)}if(Ba.setFromVector3(this.rot),this.moveMode==="walk"&&(Ba.x=0),o.applyEuler(Ba),i&&(El.setFromUnitVectors(Uo,this.groundNormal),o.applyQuaternion(El)),n){let d=Ba.set(0,this.vrEulerYOffset*jF,0);n.applyEuler(d),o.x+=n.x,o.z+=n.z,this.nonColliderPosOffset.elements[13]+=n.y*s}if(this.usePhysics===!0){let d=Di;this.pushedVelocity.set(0,0,0);for(let p of this.sharedGameControlGlobals.entitiesWithTransformAnim){let f=Cc.setFromMatrixPosition(p.matrixWorld).sub(p.prevT).divideScalar(s).divideScalar(this.pixelsPerMeter),g=p.rigidBody.collider(0).castCollider(f,this.object.rigidBody.collider(0),Gr.copy(o).divideScalar(this.pixelsPerMeter),s);if(f.multiplyScalar(this.pixelsPerMeter),g!==null){this.pushedVelocity.copy(f),d.copy(g.normal1).applyQuaternion(p.quaternion);break}}if(this.pushedVelocity.manhattanLength()!==0){let p=d.dot(o);p<0&&o.addScaledVector(d,-p),o.add(this.pushedVelocity)}else o.add(this.groundVelocity)}if(this.rotDirection.y=Number(this.movementState.rotPosY)-Number(this.movementState.rotNegY),this.rotDirection.x=Number(this.movementState.rotPosX)-Number(this.movementState.rotNegX),this.rotDirection.normalize(),this.rotationMode==="normal"&&(this.movementState.rotPosX||this.movementState.rotNegX)||this.rotationMode==="steer"&&(this.movementState.rotPosX||this.movementState.rotNegX)&&(this.movementState.movePosZ||this.movementState.moveNegZ||this.moveMode==="walk")?this.rotVelocityStick.x=-this.rotDirection.x*this.speedOrbit*this.rotForce:this.rotVelocityStick.x=0,this.rotationMode==="normal"&&(this.movementState.rotPosY||this.movementState.rotNegY)||this.rotationMode==="steer"&&(this.movementState.rotPosY||this.movementState.rotNegY)&&(this.movementState.movePosZ||this.movementState.moveNegZ)?this.rotVelocityStick.y=-this.rotDirection.y*this.speedOrbit*this.rotForce:this.rotVelocityStick.y=0,this.rotVelocityTarget.subVectors(this.eulerDelta.divideScalar(s),this.rotVelocityStick),this.rotVelocityTarget.manhattanLength()===0?this.rotVelocity.lerp(this.rotVelocityTarget,1-(1-this.lerpFactorRotEnd)**r):this.rotVelocity.lerp(this.rotVelocityTarget,1-(1-this.lerpFactorRotStart)**r),this.euler.x+=this.rotVelocity.x*s,this.euler.y+=this.rotVelocity.y*s+this.groundYRotation,this.rotVelocityTarget.y===0&&this.directionXZ.manhattanLength()===0?this.rotationAccumWhenOrientWithCamera=0:(this.cameraFollow===!1||this.cameraYAxis==="Locked")&&(this.rotationAccumWhenOrientWithCamera+=this.rotVelocity.y*s),this.isFirstPerson===!1&&this.orientMode!=="none"&&this.directionXZ.manhattanLength()>0){let d=Gr,p=Di.copy(this.directionXZ);p.x*=-1,this.camera.getWorldDirection(d);let f=Cc.copy(Uo).multiplyScalar(d.dot(Uo));if(d.sub(f),this.orientWith==="camera"?this.rot.y=d.angleTo(p)*(d.cross(p).y>0?-1:1)+this.rotationAccumWhenOrientWithCamera:this.rot.y=this.euler.y+Math.atan2(-this.directionXZ.z,this.directionXZ.x)-Math.PI/2,this.orientMode==="radial"){this.objectToCamXZ.copy(this.objectToCamXZ0).applyAxisAngle(Uo,this.euler.y-this.euler0.y);let g=Di.copy(this.objectToCamXZ).normalize(),m=Cc.copy(o).multiplyScalar(s);m.y=0;let y=m.sub(Gr.copy(g).multiplyScalar(m.dot(g))).cross(g).y;this.euler.y-=Math.atan2(y,this.objectToCamXZ.length())}}else this.rot.y+=this.rotVelocity.y*s+this.groundYRotation,this.rotVelocityTarget.y!==0&&(this.cameraFollow===!1||this.cameraYAxis==="Locked")&&(this.euler.y=this.rot.y);if(this.cameraFollow===!0&&(this.moveMode==="walk"?this.cameraXAxis==="Limit"?this.euler.x=Kt.clamp(this.euler.x,-this.maxPolarAngle+this.cameraPolarOffset+1e-6,-this.minPolarAngle+this.cameraPolarOffset-1e-6):this.euler.x=Kt.clamp(this.euler.x,-this.PI_2+this.cameraPolarOffset,this.PI_2+this.cameraPolarOffset):this.cameraXAxis==="Limit"&&(this.euler.x=Kt.clamp(this.euler.x,-this.PI_2,this.PI_2))),this.moveMode==="fly"?this.rot.x=this.euler.x:this.isFirstPerson&&(t?(Ba.copy(t),Ba.y=0):(Ba.copy(this.euler),Ba.y=0),this.nonColliderRotOffset.makeRotationFromEuler(Ba)),t&&(this.moveMode==="walk"?(this.rot.y=t.y,this.rot.x=0,this.rot.z=0):this.rot.setFromEuler(t),this.rot.y+=this.vrEulerYOffset*jF),zo.setFromAxisAngle(jhe,this.rot.x),El.setFromAxisAngle(Uo,this.rot.y),El.multiply(zo),zo.setFromAxisAngle(qhe,this.rot.z),El.multiply(zo),this.object.quaternion.copy(El),this.objectRealQuat.multiplyQuaternions(this.object.quaternion,this.objXZQuat),this.objectRealQuat.multiply(this.objXZQuat),this.colliderWorldQuat.copy(this.objectRealQuat).multiply(this.collider.rotation),this.collisionEnabled)if(this.usePhysics){let d=Di.copy(o).multiplyScalar(s/this.pixelsPerMeter),p;this.didHit=!1;let f=new I;for(let g=0;g<5;g++){let m=d.length(),y=Cc.copy(d).normalize();if(p=this.sharedGameControlGlobals.rapierWorld.castShape(Gr.copy(this.collider.position).applyQuaternion(this.objectRealQuat).add(this.object.position).divideScalar(this.pixelsPerMeter).add(f),this.colliderWorldQuat,y,(l=this.object.rigidBody)==null?void 0:l.collider(0).shape,m,8,void 0,void 0,this.object.rigidBody),p!==null){this.didHit=!0;let v=this.sharedGameControlGlobals.colliderToEntity[p.collider.handle];if(v!==this.lastHitObj&&g===0){this.lastHitObj=v;let S=this.sharedGameControlGlobals.eventsPerObjects[v==null?void 0:v.uuid];if(S)for(let C of S)C.data.target==="character"&&(v.dispatchEvent(BF),C.dispatch())}let b=VF.set(p.normal2.x,p.normal2.y,p.normal2.z).applyQuaternion(this.colliderWorldQuat),x=GF.copy(y).multiplyScalar(p.toi).dot(b),w=p.toi;if(w===0&&(this.object.position.y+=this.offset*this.pixelsPerMeter),x>this.offset&&(w=p.toi*(x-this.offset)/x,f.addScaledVector(y,w)),d.copy(y).multiplyScalar(m-w),Math.acos(-b.y)>this.slopeThresh){let S=Gr.copy(this.collider.position).applyQuaternion(this.objectRealQuat).add(this.object.position).divideScalar(this.pixelsPerMeter).add(f),C=Cc.copy(p.witness2).applyQuaternion(this.colliderWorldQuat);C.y=0;let _=S.add(C);_.y+=this.stepThresh;let T=this.sharedGameControlGlobals.rapierWorld.castShape(_,this.colliderWorldQuat,d,(c=this.object.rigidBody)==null?void 0:c.collider(0).shape,1,8,void 0,void 0,this.object.rigidBody);T!==null&&T.toi===0&&(b.y=0,b.normalize())}d.addScaledVector(b,-d.dot(b))}else{g===0&&this.directionXZ.manhattanLength()!==0&&(this.lastHitObj=null),f.add(d);break}}this.object.position.addScaledVector(f,this.pixelsPerMeter),(h=this.object.rigidBody)==null||h.setTranslation(Gr.copy(this.object.position).divideScalar(this.pixelsPerMeter),!0),(u=this.object.rigidBody)==null||u.setRotation(zo.copy(this.object.quaternion).premultiply(this.groundTilt).multiply(this.objXZQuat),!0)}else{let d=this.onObject?1:5,p=o.multiplyScalar(s/d);for(let f=0;f<d;f++)this.object.position.add(p),this.collisionAdjustment(s/d)}else this.object.position.addScaledVector(o,s);if(this.moveMode==="walk"&&this.onObject&&(this.velocityTarget.y=0,this.velocity.y=0),this.object.quaternion.premultiply(this.groundTilt).multiply(this.objXZQuat),this.object.updateMatrix(),this.object.matrix.multiply(this.nonColliderPosOffset).multiply(this.nonColliderRotOffset),this.object.quaternion.premultiply(this.groundTiltInv).multiply(this.objXZQuatInv),this.cameraFollow===!0){this.updateFollowArms();let d=this.objectToTarget.add(this.object.position),p=this.targetToCamera.add(d);QC.lookAt(p,d,Uo).setPosition(p),QC.decompose(this.targetPos,this.targetQuat,Gr),this.camera.quaternion.slerp(this.targetQuat,1-(1-this.lerpFactorRotCamera)**r),this.camera.position.lerp(this.targetPos,1-(1-this.lerpFactorPosCamera)**r),this.camera.updateMatrix(),this.camera.matrixWorldNeedsUpdate=!0,this.cameraYAxis==="Limit"&&this.orientMode==="cartesian"&&(this.euler.y=Kt.clamp(this.euler.y,this.minAzimuthAngleRel,this.maxAzimuthAngleRel)),this.euler.x=Kt.clamp(this.euler.x,-this.PI_2+(this.cameraPolarOffset<0?this.cameraPolarOffset:0),this.PI_2+(this.cameraPolarOffset>0?this.cameraPolarOffset:0))}return this.eulerDelta.set(0,0,0),this.lastPosition.distanceToSquared(this.object.position)<this.threshEndTranslate&&Math.abs(this.rotVelocity.x)<this.threshEndRotVel&&Math.abs(this.rotVelocity.y)<this.threshEndRotVel&&(this.camera===void 0||this.isFirstPerson||this.lastCameraPosition.distanceToSquared(this.camera.position)<this.threshEndTranslate&&8*(1-this.lastCameraQuaternion.dot(this.camera.quaternion))<this.threshEndRotate)&&(this.moveMode==="fly"||this.onObject===!0||this.collisionEnabled===!1)?!1:(this.camera&&(this.lastCameraPosition.copy(this.camera.position),this.lastCameraQuaternion.copy(this.camera.quaternion)),this.lastPosition.copy(this.object.position),this.object.dispatchEvent(Jhe),!0)}updateFollowArms(){this.objectToTarget.copy(this.objectToTarget0),this.targetToCamera.copy(this.targetToCamera0);let e=zo.setFromAxisAngle(Uo,this.cameraYAxis==="Limit"&&this.orientMode!=="radial"?Kt.clamp(this.euler.y-this.euler0.y,this.minAzimuthAngleRel,this.maxAzimuthAngleRel):this.euler.y-this.euler0.y);(this.cameraYAxis!=="Locked"||this.orientMode==="radial")&&this.objectToTarget.applyQuaternion(e);let t;this.cameraXAxis==="Limit"?t=Kt.clamp(this.euler.x,-this.maxPolarAngle+this.cameraPolarOffset+1e-6,-this.minPolarAngle+this.cameraPolarOffset-1e-6):t=Kt.clamp(this.euler.x,-this.PI_2+this.cameraPolarOffset+1e-6,this.PI_2+this.cameraPolarOffset-1e-6);let n=Gr.copy(this.cameraPolarAxis0);(this.cameraYAxis!=="Locked"||this.orientMode==="radial")&&n.applyQuaternion(e);let s=El.setFromAxisAngle(n,t);this.cameraYAxis!=="Locked"&&this.targetToCamera.applyQuaternion(e),this.cameraXAxis!=="Locked"&&this.targetToCamera.applyQuaternion(s)}groundTiltAdjustment(e){Uo.angleTo(e)*180/Math.PI<15||Uo.angleTo(e)*180/Math.PI>85?zo.identity():zo.setFromUnitVectors(Uo,e),this.groundTilt.slerp(zo,.06),this.groundTiltInv.copy(this.groundTilt).invert()}collisionAdjustment(e){var r;let t=GF.set(0,0,0);this.object.updateMatrix();let n=QC.multiplyMatrices(this.object.matrix,this.objXZRotMat).multiply(this.collider.matrix).decompose(Gr,zo,Di).compose(Gr,zo,HF);this.sharedGameControlGlobals.entitiesWithTransformAnim.forEach(i=>{if(i===this.object||i.isDescendantOf(this.object))return;io.makeEmpty(),i.updateMatrixWorldSVD();let o=i.matrixWorldRigid,a=WF.copy(o).invert(),l=Hhe.copy(WF).multiply(n);br.copy(this.collider.segment),br.start.applyMatrix4(l),br.end.applyMatrix4(l);let c=VF.copy(this.object.position).applyMatrix4(a);io.expandByPoint(br.start),io.expandByPoint(br.end),io.min.addScalar(-this.collider.radius),io.max.addScalar(this.collider.radius),i.boundsTree.shapecast({intersectsBounds:h=>h.intersectsBox(io),intersectsTriangle:h=>{let u=Gr,d=Di,p=h.closestPointToSegment(br,u,d);if(p<this.collider.radius){let f=this.collider.radius-p,g=d.sub(u).normalize(),m=Cc.copy(c);m.addScaledVector(g,f);let y=m.applyMatrix4(o).sub(this.object.position);t.add(y),br.start.addScaledVector(g,f),br.end.addScaledVector(g,f)}}})}),io.makeEmpty(),br.copy(this.collider.segment),br.start.applyMatrix4(n),br.end.applyMatrix4(n),io.expandByPoint(br.start),io.expandByPoint(br.end),io.min.addScalar(-this.collider.radius),io.max.addScalar(this.collider.radius),(r=this.sharedGameControlGlobals.staticMeshBVH)==null||r.shapecast({intersectsBounds:i=>i.intersectsBox(io),intersectsTriangle:i=>{let o=Gr,a=Di,l=i.closestPointToSegment(br,o,a);if(l<this.collider.radius){let c=this.collider.radius-l,h=a.sub(o).normalize();this.alignToGround&&this.groundTiltAdjustment(h),t.addScaledVector(h,c),br.start.addScaledVector(h,c),br.end.addScaledVector(h,c)}}}),this.onObject=t.y>Math.abs(e*this.velocity.y*.25),this.onObject&&this.dispatchStopEvent("jump");let s=Math.max(0,t.length()-1e-5);t.normalize().multiplyScalar(s),this.object.position.add(t)}},qF=ZC;qF.isLocked=!1;var JC={type:"change"},XF={type:"changeZoom"},ede={type:"changePan"},Gm={type:"start"},Wm={type:"end",changed:!0},tde={type:"end",changed:!1},eT=new un,KF=new se,nde=2*Math.PI,sde=1e-8,rde=.01,YF=2,tT=.125,QF=2,Px=1,Ox=1,Hm=.1,ZF=new I,Rx=new se,JF=class extends Zr{constructor(e,t,n=!1){super();this.object=e,this.domElement=t,this.isExport=n,this.enabled=!0,this.useKeyEvents=!0,this.enableDamping=!1,this.enableZoom=!0,this.enableRotate=!0,this.enablePan=!0,this.autoRotate=!1,this.rotationLimitsMode=0,this.panLimitsMode=0,this.rotationSoftLimit=2,this.panSoftLimit=2,this.hoverRotatePanMode=0,this.zoomLimitsEnabled=!1,this.mouseButtons=[0,5],this.mouseButtonsPlay=[3,4,5],this.touches=[null,Gi.DOLLY_ROTATE,Gi.PAN],this.offset=new I,this.eye=new I,this.lastPosition=new I,this.lastQuaternion=new un,this.current=new se,this.overShoot=new se,this.overRatio=new se,this.spherical=new TM,this.sphericalDelta=new TM,this.panOffset=new I,this.panLeftV=new I,this.panUpV=new I,this.panV=new I,this.rotateStart=new se,this.rotateEnd=new se,this.rotateDelta=new se,this.panStart=new se,this.panEnd=new se,this.panDelta=new se,this.dollyStart=new se,this.dollyEnd=new se,this.dollyDelta=new se,this.rotationRangeFactor=new se,this.panRangeFactor=new se,this.state=-1,this.zoomChanged=!1,this.isPointerDown=!1,this.isThetaFlipped=!1,this.prevScale=0,this.scale=1,this.gesture=!1,this.timer=-1,this.timerHover=-1,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPhi=0,this.maxPhi=Math.PI,this.minTheta=-1/0,this.maxTheta=1/0,this.minH=0,this.maxH=Math.PI,this.minV=-1/0,this.maxV=1/0,this.autoRotateClockwise=!0,this.isPanOverShoot=!1,this.isRotateOverShoot=!1,this.resetHoverEffectOnPointerLeave=!1,this.hasChange=!1,this.update=()=>{let s=this.object.position;this.offset.copy(s).sub(this.target),this.spherical.setFromVector3(this.offset),this.object.isUpVectorFlipped&&(this.spherical.phi*=-1,this.spherical.theta-=Math.PI),this.autoRotate&&this.state===-1&&this.rotateLeft((this.autoRotateClockwise===!0?1:-1)*this.getAutoRotationAngle()),this.rotationLimitsMode!==0&&this.applyLimits(this.sphericalDelta,this.rotationLimitsMode,this.rotationSoftLimit,this.maxTheta,this.minTheta,this.maxPhi,this.minPhi,this.rotationRangeFactor),this.rotationLimitsMode!==2&&(this.spherical.phi+=this.sphericalDelta.phi),(this.rotationLimitsMode!==1||this.autoRotate===!0)&&(this.spherical.theta+=this.sphericalDelta.theta),this.spherical.radius*=this.scale,this.zoomLimitsEnabled&&(this.spherical.radius=Math.max(this.minDistance,Math.min(this.maxDistance,this.spherical.radius))),this.panLimitsMode!==0&&(this.target.applyQuaternion(eT.copy(this.object.quaternion).invert()),this.panOffset.applyQuaternion(eT),this.applyLimits(this.panOffset,this.panLimitsMode,this.panSoftLimit,this.maxH,this.minH,this.maxV,this.minV,this.panRangeFactor),this.target.applyQuaternion(this.object.quaternion),this.panOffset.applyQuaternion(this.object.quaternion)),this.panLimitsMode===2&&(this.panOffset.y=0),this.panLimitsMode===1&&(this.panOffset.x=0),this.state===-1&&!this.gesture?(this.panOffset.multiplyScalar(1-tT),this.target.add(this.panOffset)):(this.target.add(this.panOffset),this.panOffset.set(0,0,0)),this.offset.setFromSpherical(this.spherical),s.copy(this.target).add(this.offset);let r=this.spherical.phi%nde;return this.eye.copy(this.offset).normalize(),this.object.up.copy(Ln.DefaultUp).applyAxisAngle(this.eye,this.object.angleOffsetFromUp),r>0&&r>Math.PI||r<0&&r>-Math.PI?(this.object.up.negate(),this.object.lookAt(this.target),this.object.isUpVectorFlipped=!0):(this.object.lookAt(this.target),this.object.isUpVectorFlipped=!1),this.state===-1||this.enableDamping===!0?(this.sphericalDelta.theta*=1-tT,this.sphericalDelta.phi*=1-tT):this.sphericalDelta.set(0,0,0),this.scale=1,this.zoomChanged||this.lastPosition.distanceToSquared(this.object.position)>rde||8*(1-this.lastQuaternion.dot(this.object.quaternion))>sde?(this.dispatchEvent(JC),this.lastPosition.copy(this.object.position),this.lastQuaternion.copy(this.object.quaternion),this.zoomChanged=!1,!0):(this.isPanOverShoot=!1,this.isRotateOverShoot=!1,this.sphericalDelta.set(0,0,0),this.panOffset.set(0,0,0),!1)},this.onPointerDown=s=>{this.enabled!==!1&&(s.pointerType==="touch"||s.pointerType==="pen"&&Br?this.onPointerDownTouch(s):this.onPointerDownMouse(s),this.state!==-1&&(this.isPointerDown=!0,this.dispatchEvent(Gm),this.domElement.addEventListener("pointermove",this.onPointerMove),this.domElement.addEventListener("pointerup",this.onPointerUp),s.stopPropagation(),s.pointerType==="touch"||s.pointerType==="pen"&&Br||this.domElement.setPointerCapture(s.pointerId)))},this.onPointerLeave=s=>{this.resetHoverEffectOnPointerLeave?(this.hoverRotatePanMode===1?(this.sphericalDelta.theta=-this.spherical.theta,this.sphericalDelta.phi=-this.spherical.phi,ZF.subVectors(this.position0,this.target0),this.spherical.setFromVector3(ZF),this.sphericalDelta.theta+=this.spherical.theta,this.sphericalDelta.phi+=this.spherical.phi,this.sphericalDelta.theta/=8,this.sphericalDelta.phi/=8):this.hoverRotatePanMode===2&&this.panOffset.subVectors(this.target0,this.target).divideScalar(8),this.update()):this.pointerLeaveEvent=s},this.onPointerEnter=s=>{this.resetHoverEffectOnPointerLeave||this.pointerLeaveEvent===void 0?Rx.set(s.clientX-this.domElement.clientWidth/2,s.clientY-this.domElement.clientHeight/2):Rx.set(s.clientX-this.pointerLeaveEvent.clientX,s.clientY-this.pointerLeaveEvent.clientY),this.hoverRotatePanMode===1?(this.rotateDelta.copy(Rx).multiplyScalar(Px*Hm).rotateAround(KF,-this.object.angleOffsetFromUp),this.rotateLeft(2*Math.PI*this.rotateDelta.x/this.domElement.clientHeight),this.rotateUp(2*Math.PI*this.rotateDelta.y/this.domElement.clientHeight),this.rotateStart.set(s.clientX,s.clientY)):this.hoverRotatePanMode===2&&(this.panDelta.copy(Rx).multiplyScalar(Ox*Hm),this.pan(this.panDelta.x,this.panDelta.y),this.panStart.set(s.clientX,s.clientY)),this.update()},this.onPointerMove=s=>{this.enabled!==!1&&(s.pointerType==="touch"||s.pointerType==="pen"&&Br?this.onPointerMoveTouch(s):this.onPointerMoveMouse(s),s.stopPropagation())},this.onPointerUp=s=>{this.isPointerDown=!1,Pt.length===0&&(this.domElement.removeEventListener("pointermove",this.onPointerMove),this.domElement.removeEventListener("pointerup",this.onPointerUp)),this.hasChange?this.dispatchEvent(Wm):this.dispatchEvent(tde),this.state=-1,s&&(s.stopPropagation(),s.pointerType==="touch"||s.pointerType==="pen"&&Br||this.domElement.releasePointerCapture(s.pointerId))},this.onPointerDownMouse=s=>{let r;switch(this.useKeyEvents?r=this.mouseButtons[s.button]:r=this.mouseButtonsPlay[s.button],r){case 0:if(s.altKey===!0&&!s.shiftKey&&!kv(s)){if(this.enableRotate===!1)return;this.handleMouseDownRotate(s),this.state=0}else if(this.key===" "){if(this.enablePan===!1)return;this.handleMouseDownPan(s),this.state=2}break;case 4:if(this.enablePan===!1)return;this.handleMouseDownPan(s),this.state=2;break;case 3:if(kv(s)||s.shiftKey){if(this.enablePan===!1)return;this.handleMouseDownPan(s),this.state=2}else{if(this.enableRotate===!1)return;this.handleMouseDownRotate(s),this.state=0}break;case 5:if(kv(s)||s.shiftKey){if(this.enableRotate===!1)return;this.handleMouseDownRotate(s),this.state=0}else{if(this.enablePan===!1)return;this.handleMouseDownPan(s),this.state=2}break;default:this.state=-1}},this.onPointerMoveMouse=s=>{switch(this.state){case 0:if(this.enableRotate===!1)return;this.handleMouseMoveRotate(s);break;case 1:if(this.enableZoom===!1)return;this.handleMouseMoveDolly(s);break;case 2:if(this.enablePan===!1)return;this.handleMouseMovePan(s);break}},this.onPointerDownTouch=s=>{switch(this.touches[Pt.length-1]){case Gi.ROTATE:if(this.enableRotate===!1){this.state=-1;return}this.handleTouchStartRotate(),this.state=3;break;case Gi.PAN:if(this.enablePan===!1){this.state=-1;return}this.handleTouchStartPan(),this.state=4;break;case Gi.DOLLY_PAN:if(this.enableZoom===!1&&this.enablePan===!1)return;this.handleTouchStartDollyPan(),this.state=5;break;case Gi.DOLLY_ROTATE:if(this.enableZoom===!1&&this.enableRotate===!1)return;this.handleTouchStartDollyRotate(),this.state=6;break;default:this.state=-1}},this.onPointerMoveTouch=s=>{switch(this.state){case 3:if(this.enableRotate===!1)return;this.handleTouchMoveRotate(s),this.update();break;case 4:if(this.enablePan===!1)return;this.handleTouchMovePan(s),this.update();break;case 5:if(this.enableZoom===!1&&this.enablePan===!1)return;this.handleTouchMoveDollyPan(s),this.update();break;case 6:if(this.enableZoom===!1&&this.enableRotate===!1)return;this.handleTouchMoveDollyRotate(s),this.update();break;default:this.state=-1}},this.dispatchEndDebounced=X3(()=>this.dispatchEvent(Wm),33),this.onMouseWheel=s=>{this.enabled===!1||this.enableZoom===!1&&this.enablePan===!1||(this.isExport===!1&&this.domElement.clientHeight===document.body.clientHeight&&this.domElement.clientWidth===document.body.clientWidth&&s.preventDefault(),this.dispatchEvent(Gm),this.handleMouseWheel(s),this.dispatchEndDebounced())},this.onGesture=s=>{if(this.enabled!==!1)if(s.preventDefault(),s.type==="gesturechange"){if(this.enableZoom===!1)return;this.dispatchEvent(Gm),s.scale>this.prevScale?this.dollyIn(this.getZoomScale()):s.scale<this.prevScale&&this.dollyOut(this.getZoomScale()),this.prevScale=s.scale,this.update()}else this.dispatchEvent(Wm)},this.onContextMenu=s=>{this.enabled!==!1&&s.preventDefault()},this.onTouchEnd=s=>{s.preventDefault()},this.onKeyDown=s=>{this.enabled!==!1&&(this.key=s.key)},this.onKeyUp=()=>{this.enabled!==!1&&(this.key=void 0,this.state!==-1&&this.onPointerUp(Pt[0]))},this.onPointerHover=s=>{s.pointerType!=="mouse"||this.enabled===!1||this.state!==-1||this.hoverRotatePanMode===2&&this.isPanOverShoot||this.hoverRotatePanMode===1&&this.isRotateOverShoot||(this.isPointerDown=!0,this.hoverRotatePanMode===2?this.handleMouseMovePan(s,Hm):this.hoverRotatePanMode===1&&this.handleMouseMoveRotate(s,Hm))},this.target=this.object.getTarget(),this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.isUpVectorFlipped0=this.object.isUpVectorFlipped,this.offset.copy(this.object.position).sub(this.target),this.spherical.setFromVector3(this.offset)}dispatchEvent(e){e.type==="start"?this.hasChange=!1:this.hasChange=!0,super.dispatchEvent(e)}reset(){this.target.copy(this.target0),this.object.position.copy(this.position0),this.object.zoom=this.zoom0,this.object.isUpVectorFlipped=this.isUpVectorFlipped0,this.object.updateProjectionMatrix(),this.dispatchEvent(JC),this.update(),this.state=-1,this.pointerLeaveEvent=void 0}resetTo(e,t,n,s=!1){this.target.copy(e),this.object.position.copy(t),this.object.zoom=n,this.object.isUpVectorFlipped=s,this.object.updateProjectionMatrix(),this.dispatchEvent(JC),this.update(),this.state=-1}fromJSON(e){var n;this.setEnableDampingSpeed(e.enableDamping),this.enablePan=e.enablePan,this.enableZoom=e.enableZoom,this.enableRotate=e.enableRotate,this.rotationLimitsMode=e.rotationLimitsMode,this.panLimitsMode=e.panLimitsMode,this.panSoftLimit=e.panSoftLimit,this.rotationSoftLimit=e.rotationSoftLimit,this.hoverRotatePanMode=e.hoverRotatePanMode,this.hoverRotatePanMode!==0&&this.domElement.addEventListener("pointermove",this.onPointerHover),Hm=(e.hoverRotatePanStrength/100)**2,this.zoomLimitsEnabled=e.zoomLimitsEnabled,this.minZoom=e.zoomLimits.min,this.maxZoom=Math.max(e.zoomLimits.min,e.zoomLimits.max),this.minDistance=1e3/e.zoomLimits.max,this.maxDistance=Math.max(this.minDistance,1e3/e.zoomLimits.min),this.autoRotate=e.autoRotate,YF=e.autoRotateSpeed,this.autoRotateClockwise=e.autoRotateClockwise;let t=this.object.getTarget().applyQuaternion(eT.copy(this.object.quaternion).invert());this.minV=-e.panVerticalOffset.min+t.y,this.maxV=e.panVerticalOffset.max+t.y,this.minH=-e.panHorizontalOffset.min+t.x,this.maxH=e.panHorizontalOffset.max+t.x,this.panRangeFactor.set(this.maxH-this.minH,this.maxV-this.minV).divideScalar(2),this.rotationRangeFactor.setScalar(Math.PI).divideScalar(4),this.minPhi=Tc(this.spherical.phi-e.rotationVerticalOffset.min),this.maxPhi=Tc(this.spherical.phi+e.rotationVerticalOffset.max),this.minTheta=Tc(this.spherical.theta-e.rotationHorizontalOffset.min),this.maxTheta=Tc(this.spherical.theta+e.rotationHorizontalOffset.max),this.isThetaFlipped=this.minTheta>this.maxTheta,e.orbitTouches===1&&(this.touches[0]=Gi.ROTATE),e.panTouches===1&&(this.touches[0]=Gi.PAN),e.orbitTouches===2&&(this.touches[1]=Gi.DOLLY_ROTATE),e.panTouches===2&&(this.touches[1]=Gi.DOLLY_PAN),e.orbitTouches===3&&(this.touches[2]=Gi.ROTATE),e.panTouches===3&&(this.touches[2]=Gi.PAN),this.resetHoverEffectOnPointerLeave=(n=e.resetHoverEffectOnPointerLeave)!=null?n:!1}connect(){this.domElement.addEventListener("contextmenu",this.onContextMenu),this.domElement.addEventListener("pointerdown",this.onPointerDown),this.domElement.addEventListener("wheel",this.onMouseWheel),window.addEventListener("keydown",this.onKeyDown,!1),window.addEventListener("keyup",this.onKeyUp,!1),l2||(this.domElement.addEventListener("gesturestart",this.onGesture),this.domElement.addEventListener("gesturechange",this.onGesture),this.domElement.addEventListener("gestureend",this.onGesture)),this.domElement.addEventListener("touchend",this.onTouchEnd),this.hoverRotatePanMode!==0&&(this.domElement.addEventListener("pointerleave",this.onPointerLeave),this.domElement.addEventListener("pointerenter",this.onPointerEnter)),this.pointerLeaveEvent=void 0}dispose(){this.domElement.removeEventListener("contextmenu",this.onContextMenu),this.domElement.removeEventListener("pointerdown",this.onPointerDown),this.domElement.removeEventListener("wheel",this.onMouseWheel),window.removeEventListener("keydown",this.onKeyDown,!1),window.removeEventListener("keyup",this.onKeyUp,!1),this.domElement.removeEventListener("pointermove",this.onPointerHover),l2||(this.domElement.removeEventListener("gesturestart",this.onGesture),this.domElement.removeEventListener("gesturechange",this.onGesture),this.domElement.removeEventListener("gestureend",this.onGesture)),this.domElement.removeEventListener("touchend",this.onTouchEnd),this.domElement.removeEventListener("pointerleave",this.onPointerLeave),this.domElement.removeEventListener("pointerenter",this.onPointerEnter),this.domElement.removeEventListener("pointermove",this.onPointerMove),this.domElement.removeEventListener("pointerup",this.onPointerUp)}applyLimits(e,t,n,s,r,i,o,a){this.overShoot.set(0,0);let l,c,h;e instanceof I?(l=e.x,c=e.y,this.current.set(this.target.x,this.target.y),h=!0):(l=e.theta,c=e.phi,this.current.set(Tc(this.spherical.theta),Tc(this.spherical.phi)),h=!1),n===0&&(this.current.x+=l,this.current.y+=c),(t===3||t===2)&&(!h&&this.isThetaFlipped?this.current.x>s&&this.current.x<0?this.overShoot.x=s-this.current.x:this.current.x<r&&this.current.x>0&&(this.overShoot.x=r-this.current.x):this.current.x>s?this.overShoot.x=s-this.current.x:this.current.x<r&&(this.overShoot.x=r-this.current.x),s===r&&(l=0)),(t===3||t===1)&&(this.current.y>i?this.overShoot.y=i-this.current.y:this.current.y<o&&(this.overShoot.y=o-this.current.y),i===o&&(c=0)),h||(this.overShoot.x=Tc(this.overShoot.x),this.overShoot.y=Tc(this.overShoot.y)),n!==0?(this.overRatio.copy(this.overShoot).divide(a),this.overRatio.x=Math.min(Math.abs(this.overRatio.x),1),this.overRatio.y=Math.min(Math.abs(this.overRatio.y),1),n===1&&(this.overRatio.x=e$(Math.abs(this.overRatio.x)),this.overRatio.y=e$(Math.abs(this.overRatio.y))),this.isPointerDown||n===1?n===2&&(this.overRatio.x>.9||this.overRatio.y>.9)?this.isPointerDown=!1:(l*this.overShoot.x<0&&(l*=1-this.overRatio.x),c*this.overShoot.y<0&&(c*=1-this.overRatio.y)):n===2&&(!h&&(this.overRatio.x>.002||this.overRatio.y>.002)||h&&(Math.abs(this.overShoot.x)>2||Math.abs(this.overShoot.y)>2)?(l=this.overShoot.x*.05,c=this.overShoot.y*.05,h?this.isPanOverShoot=!0:this.isRotateOverShoot=!0):h?this.isPanOverShoot=!1:this.isRotateOverShoot=!1)):(l+=this.overShoot.x,c+=this.overShoot.y),e instanceof I?(e.x=l,e.y=c):(e.theta=l,e.phi=c)}setEnableDampingSpeed(e){this.enableDamping=e,Px=e===!0?.2:1}stopDamping(){this.sphericalDelta.theta=0,this.sphericalDelta.phi=0}getAutoRotationAngle(){return 2*Math.PI/60/60*YF}getZoomScale(){return Math.pow(.95,QF)}rotateLeft(e){this.sphericalDelta.theta-=e}rotateUp(e){this.sphericalDelta.phi-=e}panLeft(e,t){this.panLeftV.setFromMatrixColumn(t,0),this.panLeftV.multiplyScalar(-e),this.panOffset.add(this.panLeftV)}panUp(e,t){this.panUpV.setFromMatrixColumn(t,1),this.panUpV.multiplyScalar(e),this.panOffset.add(this.panUpV)}pan(e,t){let n=this.domElement;if(n&&this.object.isPerspectiveCamera){let s=this.object.position;this.panV.copy(s).sub(this.target);let r=this.panV.length();r*=Math.tan(this.object.fov/2*Math.PI/180),this.panLeft(2*e*r/n.clientHeight,this.object.matrix),this.panUp(2*t*r/n.clientHeight,this.object.matrix)}else n&&this.object.isOrthographicCamera&&(this.panLeft(e*(this.object.right-this.object.left)/this.object.zoom/n.clientWidth,this.object.matrix),this.panUp(t*(this.object.top-this.object.bottom)/this.object.zoom/n.clientHeight,this.object.matrix));this.dispatchEvent(ede)}dollyOut(e){this.object.isPerspectiveCamera?this.scale/=e:this.object.isOrthographicCamera&&(this.object.zoom*=e,this.zoomLimitsEnabled&&(this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom))),this.object.updateProjectionMatrix(),this.zoomChanged=!0),this.dispatchEvent(XF)}dollyIn(e){this.object.isPerspectiveCamera?this.scale*=e:this.object.isOrthographicCamera&&(this.object.zoom/=e,this.zoomLimitsEnabled&&(this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom))),this.object.updateProjectionMatrix(),this.zoomChanged=!0),this.dispatchEvent(XF)}zoomOut(e=this.getZoomScale()){this.dispatchEvent(Gm),this.dollyOut(e),this.dispatchEvent(Wm)}zoomIn(e=this.getZoomScale()){this.dispatchEvent(Gm),this.dollyIn(e),this.dispatchEvent(Wm)}handleMouseDownRotate(e){this.rotateStart.set(e.clientX,e.clientY)}handleMouseDownDolly(e){this.dollyStart.set(e.clientX,e.clientY)}handleMouseDownPan(e){this.panStart.set(e.clientX,e.clientY)}handleMouseMoveRotate(e,t=1){Iv&&Nv<15.5&&!Br?(this.rotateEnd.set(e.clientX,e.clientY),this.rotateDelta.subVectors(this.rotateEnd,this.rotateStart),this.rotateStart.copy(this.rotateEnd)):this.rotateDelta.set(e.movementX,e.movementY),this.rotateDelta.multiplyScalar(Px*t).rotateAround(KF,-this.object.angleOffsetFromUp);let n=this.domElement;this.rotateLeft(2*Math.PI*this.rotateDelta.x/n.clientHeight),this.rotateUp(2*Math.PI*this.rotateDelta.y/n.clientHeight),this.update()}handleMouseMoveDolly(e){this.dollyEnd.set(e.clientX,e.clientY),this.dollyDelta.subVectors(this.dollyEnd,this.dollyStart),this.dollyDelta.y>0?this.dollyOut(this.getZoomScale()):this.dollyDelta.y<0&&this.dollyIn(this.getZoomScale()),this.dollyStart.copy(this.dollyEnd),this.update()}handleMouseMovePan(e,t=1){Iv&&Nv<15.5&&!Br?(this.panEnd.set(e.clientX,e.clientY),this.panDelta.subVectors(this.panEnd,this.panStart),this.panStart.copy(this.panEnd)):this.panDelta.set(e.movementX,e.movementY),this.panDelta.multiplyScalar(Ox*t),this.pan(this.panDelta.x,this.panDelta.y),this.update()}handleMouseWheel(e){if(uie===!1&&kv(e)===!1&&ide(e)===!0){if(this.enablePan===!1)return;this.gesture?(this.panDelta.set(-e.deltaX,-e.deltaY).multiplyScalar(Ox),this.panDelta.x=Math.min(Math.abs(this.panDelta.x),100)*(this.panDelta.x<0?-1:1),this.panDelta.y=Math.min(Math.abs(this.panDelta.y),100)*(this.panDelta.y<0?-1:1),e.altKey?this.pan(0,this.panDelta.y):e.shiftKey?this.pan(this.panDelta.x,0):this.pan(this.panDelta.x,this.panDelta.y),this.update()):(this.gesture=!0,this.isPointerDown=!0),window.clearTimeout(this.timer),this.timer=window.setTimeout(()=>{this.gesture=!1,this.isPointerDown=!1},30)}else{if(this.enableZoom===!1)return;e.deltaY===0?e.deltaX<0?this.dollyIn(this.getZoomScale()):e.deltaX>0&&this.dollyOut(this.getZoomScale()):e.deltaY<0?this.dollyIn(this.getZoomScale()):e.deltaY>0&&this.dollyOut(this.getZoomScale()),this.update(),this.gesture=!1,this.isPointerDown=!1}}handleTouchStartRotate(){if(Pt.length===2){let e=.5*(Pt[0].pageX+Pt[1].pageX),t=.5*(Pt[0].pageY+Pt[1].pageY);this.rotateStart.set(e,t)}else this.rotateStart.set(Pt[0].pageX,Pt[0].pageY)}handleTouchStartPan(){if(Pt.length===2){let e=.5*(Pt[0].pageX+Pt[1].pageX),t=.5*(Pt[0].pageY+Pt[1].pageY);this.panStart.set(e,t)}else this.panStart.set(Pt[0].pageX,Pt[0].pageY)}handleTouchStartDolly(){let e=Pt[0].pageX-Pt[1].pageX,t=Pt[0].pageY-Pt[1].pageY,n=Math.sqrt(e*e+t*t);this.dollyStart.set(0,n)}handleTouchStartDollyPan(){this.enableZoom&&this.handleTouchStartDolly(),this.enablePan&&this.handleTouchStartPan()}handleTouchStartDollyRotate(){this.enableZoom&&this.handleTouchStartDolly(),this.enableRotate&&this.handleTouchStartRotate()}handleTouchMoveRotate(e){if(Pt.length===2){let n=c2(e),s=.5*(e.pageX+n.x),r=.5*(e.pageY+n.y);this.rotateEnd.set(s,r)}else{if(e.pointerId!==Pt[0].pointerId)return;this.rotateEnd.set(e.pageX,e.pageY)}this.rotateDelta.subVectors(this.rotateEnd,this.rotateStart).multiplyScalar(Px);let t=this.domElement;t&&(this.rotateLeft(2*Math.PI*this.rotateDelta.x/t.clientHeight),this.rotateUp(2*Math.PI*this.rotateDelta.y/t.clientHeight)),this.rotateStart.copy(this.rotateEnd)}handleTouchMovePan(e){if(Pt.length===2){let t=c2(e),n=.5*(e.pageX+t.x),s=.5*(e.pageY+t.y);this.panEnd.set(n,s)}else{if(e.pointerId!==Pt[0].pointerId)return;this.panEnd.set(e.pageX,e.pageY)}this.panDelta.subVectors(this.panEnd,this.panStart).multiplyScalar(Ox),this.pan(this.panDelta.x,this.panDelta.y),this.panStart.copy(this.panEnd)}handleTouchMoveDolly(e){let t=c2(e),n=e.pageX-t.x,s=e.pageY-t.y,r=Math.sqrt(n*n+s*s);this.dollyEnd.set(0,r),this.dollyDelta.set(0,Math.pow(this.dollyEnd.y/this.dollyStart.y,QF)),this.dollyOut(this.dollyDelta.y),this.dollyStart.copy(this.dollyEnd)}handleTouchMoveDollyPan(e){this.enableZoom&&this.handleTouchMoveDolly(e),this.enablePan&&this.handleTouchMovePan(e)}handleTouchMoveDollyRotate(e){this.enableZoom&&this.handleTouchMoveDolly(e),this.enableRotate&&this.handleTouchMoveRotate(e)}};function Tc(e){let t=Math.PI*2;for(;e<=-Math.PI;)e+=t;for(;e>Math.PI;)e-=t;return e}function e$(e){return 1-Math.pow(1-e,4)}function ide(e){return e.wheelDeltaY===0||e.deltaY===0?Av&&e.shiftKey&&Math.abs(e.wheelDeltaX)>=120?!1:e.wheelDeltaX?e.wheelDeltaX===-3*e.deltaX:e.deltaMode===0:e.wheelDeltaY?e.wheelDeltaY===-3*e.deltaY:e.deltaMode===0}var nT=new WeakMap,ode=class extends jS{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,n,s){let r=new qS(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,i=>{let o={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(i,o).then(t).catch(s)},n,s)}decodeDracoFile(e,t,n,s){let r={attributeIDs:n||this.defaultAttributeIDs,attributeTypes:s||this.defaultAttributeTypes,useUniqueIDs:!!n};this.decodeGeometry(e,r).then(t)}decodeGeometry(e,t){for(let a in t.attributeTypes){let l=t.attributeTypes[a];l.BYTES_PER_ELEMENT!==void 0&&(t.attributeTypes[a]=l.name)}let n=JSON.stringify(t);if(nT.has(e)){let a=nT.get(e);if(a.key===n)return a.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let s,r=this.workerNextTaskID++,i=e.byteLength,o=this._getWorker(r,i).then(a=>(s=a,new Promise((l,c)=>{s._callbacks[r]={resolve:l,reject:c},s.postMessage({type:"decode",id:r,taskConfig:t,buffer:e},[e])}))).then(a=>this._createGeometry(a.geometry));return o.catch(()=>!0).then(()=>{s&&r&&this._releaseTask(s,r)}),nT.set(e,{key:n,promise:o}),o}_createGeometry(e){let t=new It;e.index&&t.setIndex(new Lt(e.index.array,1));for(let n=0;n<e.attributes.length;n++){let s=e.attributes[n],r=s.name,i=s.array,o=s.itemSize;t.setAttribute(r,new Lt(i,o))}return t}_loadLibrary(e,t){let n=new qS(this.manager);return n.setPath(this.decoderPath),n.setResponseType(t),n.setWithCredentials(this.withCredentials),new Promise((s,r)=>{n.load(e,s,void 0,r)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;let e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(n=>{let s=n[0];e||(this.decoderConfig.wasmBinary=n[1]);let r=ade.toString(),i=["/* draco decoder */",s,"","/* worker */",r.substring(r.indexOf("{")+1,r.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([i]))}),this.decoderPending}_getWorker(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){let s=new Worker(this.workerSourceURL);s._callbacks={},s._taskCosts={},s._taskLoad=0,s.postMessage({type:"init",decoderConfig:this.decoderConfig}),s.onmessage=function(r){let i=r.data;switch(i.type){case"decode":s._callbacks[i.id].resolve(i);break;case"error":s._callbacks[i.id].reject(i);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+i.type+'"')}},this.workerPool.push(s)}else this.workerPool.sort(function(s,r){return s._taskLoad>r._taskLoad?-1:1});let n=this.workerPool[this.workerPool.length-1];return n._taskCosts[e]=t,n._taskLoad+=t,n})}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}};function ade(){let e,t;onmessage=function(o){let a=o.data;switch(a.type){case"init":e=a.decoderConfig,t=new Promise(function(h){e.onModuleLoaded=function(u){h({draco:u})},DracoDecoderModule(e)});break;case"decode":let l=a.buffer,c=a.taskConfig;t.then(h=>{let u=h.draco,d=new u.Decoder,p=new u.DecoderBuffer;p.Init(new Int8Array(l),l.byteLength);try{let f=n(u,d,p,c),g=f.attributes.map(m=>m.array.buffer);f.index&&g.push(f.index.array.buffer),self.postMessage({type:"decode",id:a.id,geometry:f},g)}catch(f){console.error(f),self.postMessage({type:"error",id:a.id,error:f.message})}finally{u.destroy(p),u.destroy(d)}});break}};function n(o,a,l,c){let h=c.attributeIDs,u=c.attributeTypes,d,p,f=a.GetEncodedGeometryType(l);if(f===o.TRIANGULAR_MESH)d=new o.Mesh,p=a.DecodeBufferToMesh(l,d);else if(f===o.POINT_CLOUD)d=new o.PointCloud,p=a.DecodeBufferToPointCloud(l,d);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!p.ok()||d.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+p.error_msg());let g={index:null,attributes:[]};for(let m in h){let y=self[u[m]],v,b;if(c.useUniqueIDs)b=h[m],v=a.GetAttributeByUniqueId(d,b);else{if(b=a.GetAttributeId(d,o[h[m]]),b===-1)continue;v=a.GetAttribute(d,b)}g.attributes.push(r(o,a,d,m,y,v))}return f===o.TRIANGULAR_MESH&&(g.index=s(o,a,d)),o.destroy(d),g}function s(o,a,l){let c=l.num_faces()*3,h=c*4,u=o._malloc(h);a.GetTrianglesUInt32Array(l,h,u);let d=new Uint32Array(o.HEAPF32.buffer,u,c).slice();return o._free(u),{array:d,itemSize:1}}function r(o,a,l,c,h,u){let d=u.num_components(),p=l.num_points()*d,f=p*h.BYTES_PER_ELEMENT,g=i(o,h),m=o._malloc(f);a.GetAttributeDataArrayForAllPoints(l,u,g,f,m);let y=new h(o.HEAPF32.buffer,m,p).slice();return o._free(m),{name:c,array:y,itemSize:d}}function i(o,a){switch(a){case Float32Array:return o.DT_FLOAT32;case Int8Array:return o.DT_INT8;case Int16Array:return o.DT_INT16;case Int32Array:return o.DT_INT32;case Uint8Array:return o.DT_UINT8;case Uint16Array:return o.DT_UINT16;case Uint32Array:return o.DT_UINT32}}}var Ec;function lde(){return Ec||(Ec=new ode,Ec.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.2/").preload()),Ec.decoderPending}async function cde(e){if(Ec){let t={attributeIDs:Ec.defaultAttributeIDs,attributeTypes:Ec.defaultAttributeTypes,useUniqueIDs:!1},n;try{n=await Ec.decodeGeometry(new Int8Array(e).buffer,t)}catch(s){console.error(s)}if(n)return{index:n.index?{array:n.index.array}:void 0,attributes:Object.entries(n.attributes).map(([s,r])=>({name:s,itemSize:r.itemSize,array:r.array}))}}return null}async function ude(e,t){let[n,s]=iP(Y_.deserialize(new Uint8Array(e)));Uie(n);let r=[];n.scene.objects.traverse((i,o)=>{o.type==="Mesh"&&o.geometry.type==="NonParametricGeometry"&&o.geometry.data.draco!==void 0&&r.push(o)}),r.length&&await lde();for(let i of r){let o=await cde(xr(i.geometry.data.draco));if(o){o.index&&(i.geometry.data.index={array:o.index.array,itemSize:1,normalized:!1,type:"Uint32Array"});let a={};o.attributes.forEach(({name:l,array:c,itemSize:h})=>{a[l]={array:c,itemSize:h,type:"Float32Array",normalized:!1}}),i.geometry.data.attributes=a,i.geometry.data.draco=void 0}}return t&&t(n),s.result().data}var t$=Object.keys(QL).filter(e=>isNaN(Number(e))),hde=class{constructor(e,t,n,s,r,i,o,a,l,c){this.preventScroll=r,this.hideCursor=i,this.requestRender=a,this.isEnable=!1,this.onResetRaycaster=()=>{this.eventContext.raycasterNeedsUpdate=!0},this.onTouchMovePreventScroll=h=>{(h.touches.length>1||this.preventScroll)&&h.preventDefault()},this.onMouseWheelPreventScroll=h=>{this.preventScroll&&h.preventDefault()},this.eventContext=new sue(e,t,n,o,s,c!=null?c:!1),this.handlers={Spline:new mhe(this.eventContext),Conditional:new She(this.eventContext),Start:new Fhe(this.eventContext),Basic:new yhe(this.eventContext,l,this),MouseHover:new Phe(this.eventContext),Scroll:new Rhe(this.eventContext),Follow:new Ehe(this.eventContext),LookAt:new Dhe(this.eventContext)}}activate(){let{scene:e,domElement:t}=this.eventContext;this.hideCursor&&(t.style.cursor="none"),this.isEnable=!0,e.traverseEntity(n=>{n.addEventListener("requestRender",this.requestRender)}),Object.values(this.handlers).forEach(n=>n.connect()),this.resize(),t$.forEach(n=>{Object.values(this.handlers).some(s=>s.domEventsNeeded.has(n))&&t.addEventListener(n,this.onResetRaycaster)}),t.addEventListener("wheel",this.onMouseWheelPreventScroll),t.addEventListener("touchmove",this.onTouchMovePreventScroll)}deactivate(){let{scene:e,domElement:t}=this.eventContext;this.isEnable=!1,t.style.cursor="",Object.values(this.handlers).forEach(n=>n.disconnect()),e.traverseEntity(n=>{n.removeEventListener("requestRender",this.requestRender)}),t$.forEach(n=>{t.removeEventListener(n,this.onResetRaycaster)}),t.removeEventListener("touchmove",this.onTouchMovePreventScroll),t.removeEventListener("wheel",this.onMouseWheelPreventScroll)}reset(){this.deactivate(),this.activate()}resize(){this.eventContext.updaterRect()}},dde=class{constructor(e,t,n,s,r){this._aspect=1,this._renderer=e,this._camera=t,this._frameSize=new se().copy(n),this._editorSize=new se().copy(s),this._aspect=t.aspect,this._fov=r!=null?r:t.fov}set frameSize(e){this._frameSize.copy(e)}updateRenderer(){!this._renderer||this._renderer.setSize(this._frameSize.x,this._frameSize.y)}updateViewportForImageExport(){if(!this._renderer||!this._camera||this._camera.cameraType!=="PerspectiveCamera")return;let e=this._frameSize.x,t=this._frameSize.y,n=this._editorSize.x,s=this._editorSize.y;this._aspect=e/t,this._camera.zoom*=Math.min(n/e,s/t),this._renderer.setViewport(0,0,e,t)}updateViewport(){if(!this._renderer||!this._camera||this._camera.cameraType!=="PerspectiveCamera")return;let e=this._frameSize.x,t=this._frameSize.y,n=this._editorSize.x,s=this._editorSize.y,r=0,i=0,o=e,a=t;e<n&&(r=(n-e)*.5,r=-r,o=n),t<s&&(i=(s-t)*.5,i=-i,a=s),this._aspect=o/a,this._renderer.setViewport(r,i,o,a)}updateCamera(){if(this._camera)if(this._camera.cameraType==="PerspectiveCamera"){let e=this._frameSize.y,t=this._editorSize.y,n=this._fov;if(e>t){let s=pde(e,1080,2160,1,15)/100;n*=e/t,n*=1-s}this._camera.aspect=this._aspect,this._camera.fov=n,this._camera.updateProjectionMatrix()}else this._camera.setViewplaneSize(this._frameSize.x,this._frameSize.y)}setCamera(e){this._camera=e,this._aspect=e.aspect,this._fov=e.fov}revert(){let e=window.innerWidth,t=window.innerHeight;this._renderer&&(this._renderer.setViewport(0,0,e,t),this._renderer.setSize(e,t)),this._camera&&(this._camera.aspect=e/t,this._camera.fov=this._fov,this._camera.setViewplaneSize(e,t),this._camera.updateProjectionMatrix())}};function pde(e,t,n,s,r){return(e-t)/(n-t)*(r-s)+s}var n$={RED:0,GREEN:1,BLUE:2,ALPHA:3},jm="varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",fde=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
varying vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 CoCNearFar=texture2D(cocBuffer,vUv).rg;float CoC=CoCNearFar.r*scale;
#else
float CoC=texture2D(cocBuffer,vUv).g*scale;
#endif
if(CoC==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=texelSize*max(CoC,CoCNearFar.g*scale);
#else
vec2 step=texelSize*CoC;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;
#else
vec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;
#endif
}}`,Lx=class extends Ms{constructor(e=!1,t=!1){super({name:"BokehMaterial",defines:{PASS:e?"2":"1"},uniforms:{kernel64:new dt(null),kernel16:new dt(null),inputBuffer:new dt(null),cocBuffer:new dt(null),texelSize:new dt(new se),scale:new dt(1)},blending:nr,depthWrite:!1,depthTest:!1,fragmentShader:fde,vertexShader:jm}),this.toneMapped=!1,t&&(this.defines.FOREGROUND="1"),this.generateKernel()}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}set cocBuffer(e){this.uniforms.cocBuffer.value=e}setCoCBuffer(e){this.uniforms.cocBuffer.value=e}get scale(){return this.uniforms.scale.value}set scale(e){this.uniforms.scale.value=e}getScale(e){return this.uniforms.scale.value=e}setScale(e){this.uniforms.scale.value=e}generateKernel(){let e=2.39996323,t=new Float32Array(128),n=new Float32Array(32),s=0,r=0;for(let a=0;a<80;++a){let l=a*e,c=Math.sqrt(a)/Math.sqrt(80),h=c*Math.cos(l),u=c*Math.sin(l);a%5==0?(n[r++]=h,n[r++]=u):(t[s++]=h,t[s++]=u)}let i=[],o=[];for(let a=0;a<128;)i.push(new Bt(t[a++],t[a++],t[a++],t[a++]));for(let a=0;a<32;)o.push(new Bt(n[a++],n[a++],n[a++],n[a++]));this.uniforms.kernel64.value=i,this.uniforms.kernel16.value=o}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t)}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}};function s$(e,t,n){return e*(t-n)-t}function sT(e,t,n){return Math.min(Math.max((e+t)/(t-n),0),1)}var mde=`#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}void main(){float depth=readDepth(vUv);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);
#else
float linearDepth=depth;
#endif
float signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`,gde=class extends Ms{constructor(e){super({name:"CircleOfConfusionMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new dt(null),focusDistance:new dt(0),focusRange:new dt(0),cameraNear:new dt(.3),cameraFar:new dt(1e3)},blending:nr,depthWrite:!1,depthTest:!1,fragmentShader:mde,vertexShader:jm}),this.toneMapped=!1,this.uniforms.focalLength=this.uniforms.focusRange,this.adoptCameraSettings(e)}get near(){return this.uniforms.cameraNear.value}get far(){return this.uniforms.cameraFar.value}set depthBuffer(e){this.uniforms.depthBuffer.value=e}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=cl){this.depthBuffer=e,this.depthPacking=t}get focusDistance(){return this.uniforms.focusDistance.value}set focusDistance(e){this.uniforms.focusDistance.value=e}get worldFocusDistance(){return-s$(this.focusDistance,this.near,this.far)}set worldFocusDistance(e){this.focusDistance=sT(-e,this.near,this.far)}getFocusDistance(e){this.uniforms.focusDistance.value=e}setFocusDistance(e){this.uniforms.focusDistance.value=e}get focalLength(){return this.focusRange}set focalLength(e){this.focusRange=e}get focusRange(){return this.uniforms.focusRange.value}set focusRange(e){this.uniforms.focusRange.value=e}get worldFocusRange(){return-s$(this.focusRange,this.near,this.far)}set worldFocusRange(e){this.focusRange=sT(-e,this.near,this.far)}getFocalLength(e){return this.focusRange}setFocalLength(e){this.focusRange=e}adoptCameraSettings(e){e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof vr?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}},yde=`#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <encodings_fragment>
#include <dithering_fragment>
}`,vde="uniform vec2 texelSize;uniform vec2 halfTexelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize*vec2(kernel)+halfTexelSize)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",r$=class extends Ms{constructor(e=new se){super({name:"KawaseBlurMaterial",uniforms:{inputBuffer:new dt(null),texelSize:new dt(new se),halfTexelSize:new dt(new se),kernel:new dt(0),scale:new dt(1)},blending:nr,depthWrite:!1,depthTest:!1,fragmentShader:yde,vertexShader:vde}),this.toneMapped=!1,this.setTexelSize(e.x,e.y)}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.inputBuffer=e}get scale(){return this.uniforms.scale.value}set scale(e){this.uniforms.scale.value=e}getScale(){return this.uniforms.scale.value}setScale(e){this.uniforms.scale.value=e}getKernel(){return null}get kernel(){return this.uniforms.kernel.value}set kernel(e){this.uniforms.kernel.value=e}setKernel(e){this.kernel=e}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t),this.uniforms.halfTexelSize.value.set(e,t).multiplyScalar(.5)}setSize(e,t){let n=this.uniforms;n.texelSize.value.set(1/e,1/t),n.halfTexelSize.value.copy(n.texelSize.value).multiplyScalar(.5)}},xde=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <encodings_fragment>
}`,bde=class extends Ms{constructor(){super({name:"CopyMaterial",uniforms:{inputBuffer:new dt(null),opacity:new dt(1)},blending:nr,depthWrite:!1,depthTest:!1,fragmentShader:xde,vertexShader:jm}),this.toneMapped=!1}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}getOpacity(e){return this.uniforms.opacity.value}setOpacity(e){this.uniforms.opacity.value=e}},wde=`varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
#if EDGE_DETECTION_MODE == 1
#include <common>
#endif
#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}
#elif PREDICATION_MODE == 2
uniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}
#endif
#if PREDICATION_MODE != 0
vec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}
#endif
#if EDGE_DETECTION_MODE != 0
uniform sampler2D inputBuffer;
#endif
void main(){
#if EDGE_DETECTION_MODE == 0
const vec2 threshold=vec2(DEPTH_THRESHOLD);
#elif PREDICATION_MODE != 0
vec2 threshold=calculatePredicatedThreshold();
#else
const vec2 threshold=vec2(EDGE_THRESHOLD);
#endif
#if EDGE_DETECTION_MODE == 0
vec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 1
float l=linearToRelativeLuminance(texture2D(inputBuffer,vUv).rgb);float lLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv0).rgb);float lTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=linearToRelativeLuminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=linearToRelativeLuminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 2
vec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#endif
}`,Sde=`uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);
#if EDGE_DETECTION_MODE != 0
vUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`,rT={DEPTH:0,LUMA:1,COLOR:2},i$={DISABLED:0,DEPTH:1,CUSTOM:2},_de=class extends Ms{constructor(e=new se,t=rT.COLOR){super({name:"EdgeDetectionMaterial",defines:{LOCAL_CONTRAST_ADAPTATION_FACTOR:"2.0",EDGE_THRESHOLD:"0.1",DEPTH_THRESHOLD:"0.01",PREDICATION_MODE:"0",PREDICATION_THRESHOLD:"0.01",PREDICATION_SCALE:"2.0",PREDICATION_STRENGTH:"1.0",DEPTH_PACKING:"0"},uniforms:{inputBuffer:new dt(null),depthBuffer:new dt(null),predicationBuffer:new dt(null),texelSize:new dt(e)},blending:nr,depthWrite:!1,depthTest:!1,fragmentShader:wde,vertexShader:Sde}),this.toneMapped=!1,this.edgeDetectionMode=t}set depthBuffer(e){this.uniforms.depthBuffer.value=e}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=cl){this.depthBuffer=e,this.depthPacking=t}get edgeDetectionMode(){return Number(this.defines.EDGE_DETECTION_MODE)}set edgeDetectionMode(e){this.defines.EDGE_DETECTION_MODE=e.toFixed(0),this.needsUpdate=!0}getEdgeDetectionMode(){return this.edgeDetectionMode}setEdgeDetectionMode(e){this.edgeDetectionMode=e}get localContrastAdaptationFactor(){return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR)}set localContrastAdaptationFactor(e){this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR=e.toFixed("6"),this.needsUpdate=!0}getLocalContrastAdaptationFactor(){return this.localContrastAdaptationFactor}setLocalContrastAdaptationFactor(e){this.localContrastAdaptationFactor=e}get edgeDetectionThreshold(){return Number(this.defines.EDGE_THRESHOLD)}set edgeDetectionThreshold(e){this.defines.EDGE_THRESHOLD=e.toFixed("6"),this.defines.DEPTH_THRESHOLD=(e*.1).toFixed("6"),this.needsUpdate=!0}getEdgeDetectionThreshold(){return this.edgeDetectionThreshold}setEdgeDetectionThreshold(e){this.edgeDetectionThreshold=e}get predicationMode(){return Number(this.defines.PREDICATION_MODE)}set predicationMode(e){this.defines.PREDICATION_MODE=e.toFixed(0),this.needsUpdate=!0}getPredicationMode(){return this.predicationMode}setPredicationMode(e){this.predicationMode=e}set predicationBuffer(e){this.uniforms.predicationBuffer.value=e}setPredicationBuffer(e){this.uniforms.predicationBuffer.value=e}get predicationThreshold(){return Number(this.defines.PREDICATION_THRESHOLD)}set predicationThreshold(e){this.defines.PREDICATION_THRESHOLD=e.toFixed("6"),this.needsUpdate=!0}getPredicationThreshold(){return this.predicationThreshold}setPredicationThreshold(e){this.predicationThreshold=e}get predicationScale(){return Number(this.defines.PREDICATION_SCALE)}set predicationScale(e){this.defines.PREDICATION_SCALE=e.toFixed("6"),this.needsUpdate=!0}getPredicationScale(){return this.predicationScale}setPredicationScale(e){this.predicationScale=e}get predicationStrength(){return Number(this.defines.PREDICATION_STRENGTH)}set predicationStrength(e){this.defines.PREDICATION_STRENGTH=e.toFixed("6"),this.needsUpdate=!0}getPredicationStrength(){return this.predicationStrength}setPredicationStrength(e){this.predicationStrength=e}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},Cde=`#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <encodings_fragment>
#endif
#include <dithering_fragment>
}`,Tde="uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}",Vo={FRAGMENT_HEAD:"FRAGMENT_HEAD",FRAGMENT_MAIN_UV:"FRAGMENT_MAIN_UV",FRAGMENT_MAIN_IMAGE:"FRAGMENT_MAIN_IMAGE",VERTEX_HEAD:"VERTEX_HEAD",VERTEX_MAIN_SUPPORT:"VERTEX_MAIN_SUPPORT"},iT=class extends Ms{constructor(e,t,n,s,r=!1){super({name:"EffectMaterial",defines:{THREE_REVISION:_f.replace(/\D+/g,""),DEPTH_PACKING:"0",ENCODE_OUTPUT:"1"},uniforms:{inputBuffer:new dt(null),depthBuffer:new dt(null),resolution:new dt(new se),texelSize:new dt(new se),cameraNear:new dt(.3),cameraFar:new dt(1e3),aspect:new dt(1),time:new dt(0)},blending:nr,depthWrite:!1,depthTest:!1,dithering:r}),this.toneMapped=!1,e&&this.setShaderParts(e),t&&this.setDefines(t),n&&this.setUniforms(n),this.adoptCameraSettings(s)}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(e){this.uniforms.depthBuffer.value=e}get depthPacking(){return Number(this.defines.DEPTH_PACKING)}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=cl){this.depthBuffer=e,this.depthPacking=t}setShaderParts(e){return this.fragmentShader=Cde.replace(Vo.FRAGMENT_HEAD,e.get(Vo.FRAGMENT_HEAD)).replace(Vo.FRAGMENT_MAIN_UV,e.get(Vo.FRAGMENT_MAIN_UV)).replace(Vo.FRAGMENT_MAIN_IMAGE,e.get(Vo.FRAGMENT_MAIN_IMAGE)),this.vertexShader=Tde.replace(Vo.VERTEX_HEAD,e.get(Vo.VERTEX_HEAD)).replace(Vo.VERTEX_MAIN_SUPPORT,e.get(Vo.VERTEX_MAIN_SUPPORT)),this.needsUpdate=!0,this}setDefines(e){for(let t of e.entries())this.defines[t[0]]=t[1];return this.needsUpdate=!0,this}setUniforms(e){for(let t of e.entries())this.uniforms[t[0]]=t[1];return this}setExtensions(e){this.extensions={};for(let t of e)this.extensions[t]=!0;return this}get encodeOutput(){return this.defines.ENCODE_OUTPUT!==void 0}set encodeOutput(e){this.encodeOutput!==e&&(e?this.defines.ENCODE_OUTPUT="1":delete this.defines.ENCODE_OUTPUT,this.needsUpdate=!0)}isOutputEncodingEnabled(e){return this.encodeOutput}setOutputEncodingEnabled(e){this.encodeOutput=e}get time(){return this.uniforms.time.value}set time(e){this.uniforms.time.value=e}setDeltaTime(e){this.uniforms.time.value+=e}adoptCameraSettings(e){e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof vr?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}setSize(e,t){let n=this.uniforms;n.resolution.value.set(e,t),n.texelSize.value.set(1/e,1/t),n.aspect.value=e/t}static get Section(){return Vo}},Ede=`#include <common>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=linearToRelativeLuminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*l,l);
#else
gl_FragColor=vec4(l);
#endif
}`,Ade=class extends Ms{constructor(e=!1,t=null){super({name:"LuminanceMaterial",uniforms:{inputBuffer:new dt(null),threshold:new dt(0),smoothing:new dt(1),range:new dt(null)},blending:nr,depthWrite:!1,depthTest:!1,fragmentShader:Ede,vertexShader:jm}),this.toneMapped=!1,this.colorOutput=e,this.luminanceRange=t}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get threshold(){return this.uniforms.threshold.value}set threshold(e){this.smoothing>0||e>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.threshold.value=e}getThreshold(){return this.threshold}setThreshold(e){this.threshold=e}get smoothing(){return this.uniforms.smoothing.value}set smoothing(e){this.threshold>0||e>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.smoothing.value=e}getSmoothingFactor(){return this.smoothing}setSmoothingFactor(e){this.smoothing=e}get useThreshold(){return this.threshold>0||this.smoothing>0}set useThreshold(e){}get colorOutput(){return this.defines.COLOR!==void 0}set colorOutput(e){e?this.defines.COLOR="1":delete this.defines.COLOR,this.needsUpdate=!0}isColorOutputEnabled(e){return this.colorOutput}setColorOutputEnabled(e){this.colorOutput=e}get useRange(){return this.luminanceRange!==null}set useRange(e){this.luminanceRange=null}get luminanceRange(){return this.uniforms.range.value}set luminanceRange(e){e!==null?this.defines.RANGE="1":delete this.defines.RANGE,this.uniforms.range.value=e,this.needsUpdate=!0}getLuminanceRange(){return this.luminanceRange}setLuminanceRange(e){this.luminanceRange=e}},Ide=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
varying vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture2D(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture2D(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture2D(maskTexture,vUv).b;
#else
float mask=texture2D(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=step(mask,0.0);
#else
mask=1.0-step(mask,0.0);
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 2
gl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);
#else
gl_FragColor=mask*texture2D(inputBuffer,vUv);
#endif
}`,o$={DISCARD:0,MULTIPLY:1,MULTIPLY_RGB_SET_ALPHA:2},Nde=class extends Ms{constructor(e=null){super({name:"MaskMaterial",uniforms:{maskTexture:new dt(e),inputBuffer:new dt(null),strength:new dt(1)},blending:nr,depthWrite:!1,depthTest:!1,fragmentShader:Ide,vertexShader:jm}),this.toneMapped=!1,this.setColorChannel(n$.RED),this.setMaskFunction(o$.DISCARD)}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}set maskTexture(e){this.uniforms.maskTexture.value=e,delete this.defines.MASK_PRECISION_HIGH,e.type!==pr&&(this.defines.MASK_PRECISION_HIGH="1"),this.needsUpdate=!0}setMaskTexture(e){this.maskTexture=e}set colorChannel(e){this.defines.COLOR_CHANNEL=e.toFixed(0),this.needsUpdate=!0}setColorChannel(e){this.colorChannel=e}set maskFunction(e){this.defines.MASK_FUNCTION=e.toFixed(0),this.needsUpdate=!0}setMaskFunction(e){this.maskFunction=e}get inverted(){return this.defines.INVERTED!==void 0}set inverted(e){this.inverted&&!e?delete this.defines.INVERTED:e&&(this.defines.INVERTED="1"),this.needsUpdate=!0}isInverted(){return this.inverted}setInverted(e){this.inverted=e}get strength(){return this.uniforms.strength.value}set strength(e){this.uniforms.strength.value=e}getStrength(){return this.strength}setStrength(e){this.strength=e}},kde=`#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)
#if __VERSION__ < 300
#define round(v) floor(v + 0.5)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);
#endif
}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);
#endif
}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){
#if !defined(DISABLE_DIAG_DETECTION)
weights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){
#endif
vec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);
#if !defined(DISABLE_DIAG_DETECTION)
}else{e.r=0.0;}
#endif
}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}`,Dde="uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}",Mde=class extends Ms{constructor(e=new se,t=new se){super({name:"SMAAWeightsMaterial",defines:{MAX_SEARCH_STEPS_INT:"16",MAX_SEARCH_STEPS_FLOAT:"16.0",MAX_SEARCH_STEPS_DIAG_INT:"8",MAX_SEARCH_STEPS_DIAG_FLOAT:"8.0",CORNER_ROUNDING:"25",CORNER_ROUNDING_NORM:"0.25",AREATEX_MAX_DISTANCE:"16.0",AREATEX_MAX_DISTANCE_DIAG:"20.0",AREATEX_PIXEL_SIZE:"(1.0 / vec2(160.0, 560.0))",AREATEX_SUBTEX_SIZE:"(1.0 / 7.0)",SEARCHTEX_SIZE:"vec2(66.0, 33.0)",SEARCHTEX_PACKED_SIZE:"vec2(64.0, 16.0)"},uniforms:{inputBuffer:new dt(null),searchTexture:new dt(null),areaTexture:new dt(null),resolution:new dt(t),texelSize:new dt(e)},blending:nr,depthWrite:!1,depthTest:!1,fragmentShader:kde,vertexShader:Dde}),this.toneMapped=!1}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get searchTexture(){return this.uniforms.searchTexture.value}set searchTexture(e){this.uniforms.searchTexture.value=e}get areaTexture(){return this.uniforms.areaTexture.value}set areaTexture(e){this.uniforms.areaTexture.value=e}setLookupTextures(e,t){this.searchTexture=e,this.areaTexture=t}get orthogonalSearchSteps(){return Number(this.defines.MAX_SEARCH_STEPS_INT)}set orthogonalSearchSteps(e){let t=Math.min(Math.max(e,0),112);this.defines.MAX_SEARCH_STEPS_INT=t.toFixed("0"),this.defines.MAX_SEARCH_STEPS_FLOAT=t.toFixed("1"),this.needsUpdate=!0}setOrthogonalSearchSteps(e){this.orthogonalSearchSteps=e}get diagonalSearchSteps(){return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT)}set diagonalSearchSteps(e){let t=Math.min(Math.max(e,0),20);this.defines.MAX_SEARCH_STEPS_DIAG_INT=t.toFixed("0"),this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT=t.toFixed("1"),this.needsUpdate=!0}setDiagonalSearchSteps(e){this.diagonalSearchSteps=e}get diagonalDetection(){return this.defines.DISABLE_DIAG_DETECTION===void 0}set diagonalDetection(e){e?delete this.defines.DISABLE_DIAG_DETECTION:this.defines.DISABLE_DIAG_DETECTION="1",this.needsUpdate=!0}isDiagonalDetectionEnabled(){return this.diagonalDetection}setDiagonalDetectionEnabled(e){this.diagonalDetection=e}get cornerRounding(){return Number(this.defines.CORNER_ROUNDING)}set cornerRounding(e){let t=Math.min(Math.max(e,0),100);this.defines.CORNER_ROUNDING=t.toFixed("4"),this.defines.CORNER_ROUNDING_NORM=(t/100).toFixed("4"),this.needsUpdate=!0}setCornerRounding(e){this.cornerRounding=e}get cornerDetection(){return this.defines.DISABLE_CORNER_DETECTION===void 0}set cornerDetection(e){e?delete this.defines.DISABLE_CORNER_DETECTION:this.defines.DISABLE_CORNER_DETECTION="1",this.needsUpdate=!0}isCornerRoundingEnabled(){return this.cornerDetection}setCornerRoundingEnabled(e){this.cornerDetection=e}setSize(e,t){let n=this.uniforms;n.texelSize.value.set(1/e,1/t),n.resolution.value.set(e,t)}},Pde=new ud,Ac=null;function Ode(){if(Ac===null){let e=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),t=new Float32Array([0,0,2,0,0,2]);Ac=new It,Ac.setAttribute!==void 0?(Ac.setAttribute("position",new Lt(e,3)),Ac.setAttribute("uv",new Lt(t,2))):(Ac.addAttribute("position",new Lt(e,3)),Ac.addAttribute("uv",new Lt(t,2)))}return Ac}var oo=class{constructor(e="Pass",t=new _u,n=Pde){this.name=e,this.renderer=null,this.scene=t,this.camera=n,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(e){if(this.rtt===e){let t=this.getFullscreenMaterial();t!==null&&(t.needsUpdate=!0),this.rtt=!e}}setRenderer(e){this.renderer=e}isEnabled(){return this.enabled}setEnabled(e){this.enabled=e}get fullscreenMaterial(){return this.screen!==null?this.screen.material:null}set fullscreenMaterial(e){let t=this.screen;t!==null?t.material=e:(t=new bi(Ode(),e),t.frustumCulled=!1,this.scene===null&&(this.scene=new _u),this.scene.add(t),this.screen=t)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(e){this.fullscreenMaterial=e}getDepthTexture(){return null}setDepthTexture(e,t=cl){}render(e,t,n,s,r){throw new Error("Render method not implemented!")}setSize(e,t){}initialize(e,t,n){}dispose(){for(let e of Object.keys(this)){let t=this[e];if(t!==null&&typeof t.dispose=="function"){if(t instanceof _u||t===this.renderer)continue;this[e].dispose()}}}},Fx=class extends oo{constructor(e,t=!0){super("CopyPass"),this.fullscreenMaterial=new bde,this.needsSwap=!1,this.renderTarget=e,e===void 0&&(this.renderTarget=new hs(1,1,{minFilter:xn,magFilter:xn,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="CopyPass.Target"),this.autoResize=t}get resize(){return this.autoResize}set resize(e){this.autoResize=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}setAutoResizeEnabled(e){this.autoResize=e}render(e,t,n,s,r){this.fullscreenMaterial.inputBuffer=t.texture,e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){this.autoResize&&this.renderTarget.setSize(e,t)}initialize(e,t,n){n!==void 0&&(this.renderTarget.texture.type=n,n!==pr?this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1":e.outputEncoding===Gt&&(this.renderTarget.texture.encoding=Gt))}},Rde=class extends oo{constructor(){super("ClearMaskPass",null,null),this.needsSwap=!1}render(e,t,n,s,r){let i=e.state.buffers.stencil;i.setLocked(!1),i.setTest(!1)}},oT=new _t,$x=class extends oo{constructor(e=!0,t=!0,n=!1){super("ClearPass",null,null),this.needsSwap=!1,this.color=e,this.depth=t,this.stencil=n,this.overrideClearColor=null,this.overrideClearAlpha=-1}setClearFlags(e,t,n){this.color=e,this.depth=t,this.stencil=n}getOverrideClearColor(){return this.overrideClearColor}setOverrideClearColor(e){this.overrideClearColor=e}getOverrideClearAlpha(){return this.overrideClearAlpha}setOverrideClearAlpha(e){this.overrideClearAlpha=e}render(e,t,n,s,r){let i=this.overrideClearColor,o=this.overrideClearAlpha,a=e.getClearAlpha(),l=i!==null,c=o>=0;l?(oT.copy(e.getClearColor(oT)),e.setClearColor(i,c?o:a)):c&&e.setClearAlpha(o),e.setRenderTarget(this.renderToScreen?null:t),e.clear(this.color,this.depth,this.stencil),l?e.setClearColor(oT,a):c&&e.setClearAlpha(a)}},Ic=-1,ri=class extends Zr{constructor(e,t=Ic,n=Ic,s=1){super(),this.resizable=e,this.base=new se(1,1),this.preferred=new se(t,n),this.target=this.preferred,this.s=s}get width(){let{base:e,preferred:t,scale:n}=this,s;return t.width!==Ic?s=t.width:t.height!==Ic?s=Math.round(t.height*(e.width/Math.max(e.height,1))):s=Math.round(e.width*n),s}set width(e){this.preferredWidth=e}get height(){let{base:e,preferred:t,scale:n}=this,s;return t.height!==Ic?s=t.height:t.width!==Ic?s=Math.round(t.width/Math.max(e.width/Math.max(e.height,1),1)):s=Math.round(e.height*n),s}set height(e){this.preferredHeight=e}getWidth(){return this.width}getHeight(){return this.height}get scale(){return this.s}set scale(e){this.s!==e&&(this.s=e,this.preferred.setScalar(Ic),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.base.width,this.base.height))}getScale(){return this.scale}setScale(e){this.scale=e}get baseWidth(){return this.base.width}set baseWidth(e){this.base.width!==e&&(this.base.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.base.width,this.base.height))}getBaseWidth(){return this.base.width}setBaseWidth(e){this.base.width!==e&&(this.base.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.base.width,this.base.height))}get baseHeight(){return this.base.height}set baseHeight(e){this.base.height!==e&&(this.base.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.base.width,this.base.height))}getBaseHeight(){return this.baseHeight}setBaseHeight(e){this.baseHeight=e}setBaseSize(e,t){(this.base.width!==e||this.base.height!==t)&&(this.base.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.base.width,this.base.height))}get preferredWidth(){return this.preferred.width}set preferredWidth(e){this.preferred.width!==e&&(this.preferred.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.base.width,this.base.height))}getPreferredWidth(){return this.preferredWidth}setPreferredWidth(e){this.preferredWidth=e}get preferredHeight(){return this.preferred.height}set preferredHeight(e){this.preferred.height!==e&&(this.preferred.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.base.width,this.base.height))}getPreferredHeight(){return this.preferredHeight}setPreferredHeight(e){this.preferredHeight=e}setPreferredSize(e,t){(this.preferred.width!==e||this.preferred.height!==t)&&(this.preferred.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.base.width,this.base.height))}copy(e){this.base.set(e.getBaseWidth(),e.getBaseHeight()),this.preferred.set(e.getPreferredWidth(),e.getPreferredHeight()),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.base.width,this.base.height)}static get AUTO_SIZE(){return Ic}},aT=!1,a$=class{constructor(e=null){this.originalMaterials=new Map,this.material=null,this.materials=null,this.materialsBackSide=null,this.materialsDoubleSide=null,this.materialsFlatShaded=null,this.materialsFlatShadedBackSide=null,this.materialsFlatShadedDoubleSide=null,this.setMaterial(e),this.meshCount=0,this.replaceMaterial=t=>{if(t.isMesh){let n;if(t.material.flatShading)switch(t.material.side){case Ao:n=this.materialsFlatShadedDoubleSide;break;case dr:n=this.materialsFlatShadedBackSide;break;default:n=this.materialsFlatShaded;break}else switch(t.material.side){case Ao:n=this.materialsDoubleSide;break;case dr:n=this.materialsBackSide;break;default:n=this.materials;break}this.originalMaterials.set(t,t.material),t.isSkinnedMesh?t.material=n[2]:t.isInstancedMesh?t.material=n[1]:t.material=n[0],++this.meshCount}}}setMaterial(e){if(this.disposeMaterials(),this.material=e,e!==null){let t=this.materials=[e.clone(),e.clone(),e.clone()];for(let n of t)n.uniforms=Object.assign({},e.uniforms),n.side=jl;t[2].skinning=!0,this.materialsBackSide=t.map(n=>{let s=n.clone();return s.uniforms=Object.assign({},e.uniforms),s.side=dr,s}),this.materialsDoubleSide=t.map(n=>{let s=n.clone();return s.uniforms=Object.assign({},e.uniforms),s.side=Ao,s}),this.materialsFlatShaded=t.map(n=>{let s=n.clone();return s.uniforms=Object.assign({},e.uniforms),s.flatShading=!0,s}),this.materialsFlatShadedBackSide=t.map(n=>{let s=n.clone();return s.uniforms=Object.assign({},e.uniforms),s.flatShading=!0,s.side=dr,s}),this.materialsFlatShadedDoubleSide=t.map(n=>{let s=n.clone();return s.uniforms=Object.assign({},e.uniforms),s.flatShading=!0,s.side=Ao,s})}}render(e,t,n){let s=e.shadowMap.enabled;if(e.shadowMap.enabled=!1,aT){let r=this.originalMaterials;this.meshCount=0,t.traverse(this.replaceMaterial),e.render(t,n);for(let i of r)i[0].material=i[1];this.meshCount!==r.size&&r.clear()}else{let r=t.overrideMaterial;t.overrideMaterial=this.material,e.render(t,n),t.overrideMaterial=r}e.shadowMap.enabled=s}disposeMaterials(){if(this.material!==null){let e=this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);for(let t of e)t.dispose()}}dispose(){this.originalMaterials.clear(),this.disposeMaterials()}static get workaroundEnabled(){return aT}static set workaroundEnabled(e){aT=e}},Lde=class extends oo{constructor(e,t,n=null){super("RenderPass",e,t),this.needsSwap=!1,this.clearPass=new $x,this.overrideMaterialManager=n===null?null:new a$(n),this.ignoreBackground=!1,this.skipShadowMapUpdate=!1,this.selection=null}get renderToScreen(){return super.renderToScreen}set renderToScreen(e){super.renderToScreen=e,this.clearPass.renderToScreen=e}get overrideMaterial(){let e=this.overrideMaterialManager;return e!==null?e.material:null}set overrideMaterial(e){let t=this.overrideMaterialManager;e!==null?t!==null?t.setMaterial(e):this.overrideMaterialManager=new a$(e):t!==null&&(t.dispose(),this.overrideMaterialManager=null)}getOverrideMaterial(){return this.overrideMaterial}setOverrideMaterial(e){this.overrideMaterial=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getSelection(){return this.selection}setSelection(e){this.selection=e}isBackgroundDisabled(){return this.ignoreBackground}setBackgroundDisabled(e){this.ignoreBackground=e}isShadowMapDisabled(){return this.skipShadowMapUpdate}setShadowMapDisabled(e){this.skipShadowMapUpdate=e}getClearPass(){return this.clearPass}render(e,t,n,s,r){let i=this.scene,o=this.camera,a=this.selection,l=o.layers.mask,c=i.background,h=e.shadowMap.autoUpdate,u=this.renderToScreen?null:t;a!==null&&o.layers.set(a.getLayer()),this.skipShadowMapUpdate&&(e.shadowMap.autoUpdate=!1),(this.ignoreBackground||this.clearPass.overrideClearColor!==null)&&(i.background=null),this.clearPass.enabled&&this.clearPass.render(e,t),e.setRenderTarget(u),this.overrideMaterialManager!==null?this.overrideMaterialManager.render(e,i,o):e.render(i,o),o.layers.mask=l,i.background=c,e.shadowMap.autoUpdate=h}},l$=class extends oo{constructor(e,t,{resolutionScale:n=1,width:s=ri.AUTO_SIZE,height:r=ri.AUTO_SIZE,renderTarget:i}={}){super("DepthPass"),this.needsSwap=!1,this.renderPass=new Lde(e,t,new jD({depthPacking:Zk}));let o=this.renderPass;o.skipShadowMapUpdate=!0,o.ignoreBackground=!0;let a=o.getClearPass();a.overrideClearColor=new _t(16777215),a.overrideClearAlpha=1,this.renderTarget=i,this.renderTarget===void 0&&(this.renderTarget=new hs(1,1,{minFilter:ns,magFilter:ns,stencilBuffer:!1}),this.renderTarget.texture.name="DepthPass.Target");let l=this.resolution=new ri(this,s,r,n);l.addEventListener("change",c=>this.setSize(l.baseWidth,l.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,n,s,r){let i=this.renderToScreen?null:this.renderTarget;this.renderPass.render(e,i)}setSize(e,t){let n=this.resolution;n.setBaseSize(e,t),this.renderTarget.setSize(n.width,n.height)}},an={SKIP:0,ADD:1,ALPHA:2,AVERAGE:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,EXCLUSION:8,LIGHTEN:9,MULTIPLY:10,DIVIDE:11,NEGATION:12,NORMAL:13,OVERLAY:14,REFLECT:15,SCREEN:16,SOFT_LIGHT:17,SUBTRACT:18},Fde="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}",$de="vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}",Bde="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}",zde="float blend(const in float x,const in float y){return(y==0.0)? y : max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",Ude="float blend(const in float x,const in float y){return(y==1.0)? y : min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",Vde="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}",Gde="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}",Wde="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}",Hde="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}",jde="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}",qde="float blend(const in float x,const in float y){return(y>0.0)? min(x/y,1.0): 1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",Xde="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}",Kde="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}",Yde="float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",Qde="float blend(const in float x,const in float y){return(y==1.0)? y : min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",Zde="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}",Jde="float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}",epe="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}",tpe=new Map([[an.SKIP,null],[an.ADD,Fde],[an.ALPHA,$de],[an.AVERAGE,Bde],[an.COLOR_BURN,zde],[an.COLOR_DODGE,Ude],[an.DARKEN,Vde],[an.DIFFERENCE,Gde],[an.EXCLUSION,Wde],[an.LIGHTEN,Hde],[an.MULTIPLY,jde],[an.DIVIDE,qde],[an.NEGATION,Xde],[an.NORMAL,Kde],[an.OVERLAY,Yde],[an.REFLECT,Qde],[an.SCREEN,Zde],[an.SOFT_LIGHT,Jde],[an.SUBTRACT,epe]]),npe=class extends Zr{constructor(e,t=1){super(),this.f=e,this.opacity=new dt(t)}getOpacity(){return this.opacity.value}setOpacity(e){this.opacity.value=e}get blendFunction(){return this.f}set blendFunction(e){this.f=e,this.dispatchEvent({type:"change"})}getBlendFunction(){return this.blendFunction}setBlendFunction(e){this.blendFunction=e}getShaderCode(){return tpe.get(this.blendFunction)}},za={NONE:0,DEPTH:1,CONVOLUTION:2},Ua=class extends Zr{constructor(e,t,{attributes:n=za.NONE,blendFunction:s=an.SCREEN,defines:r=new Map,uniforms:i=new Map,extensions:o=null,vertexShader:a=null}={}){super(),this.name=e,this.renderer=null,this.attributes=n,this.fragmentShader=t,this.vertexShader=a,this.defines=r,this.uniforms=i,this.extensions=o,this.blendMode=new npe(s),this.blendMode.addEventListener("change",l=>this.setChanged())}getName(){return this.name}setRenderer(e){this.renderer=e}getDefines(){return this.defines}getUniforms(){return this.uniforms}getExtensions(){return this.extensions}getBlendMode(){return this.blendMode}getAttributes(){return this.attributes}setAttributes(e){this.attributes=e,this.setChanged()}getFragmentShader(){return this.fragmentShader}setFragmentShader(e){this.fragmentShader=e,this.setChanged()}getVertexShader(){return this.vertexShader}setVertexShader(e){this.vertexShader=e,this.setChanged()}setChanged(){this.dispatchEvent({type:"change"})}setDepthTexture(e,t=cl){}update(e,t,n){}setSize(e,t){}initialize(e,t,n){}dispose(){for(let e of Object.keys(this)){let t=this[e];if(t!==null&&typeof t.dispose=="function"){if(t instanceof _u||t===this.renderer)continue;this[e].dispose()}}}};function c$(e,t,n){for(let s of t){let r="$1"+e+s.charAt(0).toUpperCase()+s.slice(1),i=new RegExp("([^\\.])(\\b"+s+"\\b)","g");for(let o of n.entries())o[1]!==null&&n.set(o[0],o[1].replace(i,r))}}function spe(e,t,n,s,r,i,o){let a=new Map([["fragment",t.getFragmentShader()],["vertex",t.getVertexShader()]]),l=a.get("fragment")!==void 0&&/mainImage/.test(a.get("fragment")),c=a.get("fragment")!==void 0&&/mainUv/.test(a.get("fragment")),h=[],u=[],d=!1,p=!1;if(a.get("fragment")===void 0)console.error("Missing fragment shader",t);else if(c&&(o&za.CONVOLUTION)!=0)console.error("Effects that transform UV coordinates are incompatible with convolution effects",t);else if(!l&&!c)console.error("The fragment shader contains neither a mainImage nor a mainUv function",t);else{let f=/(?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+})/g,g=iT.Section;if(c){let y=`	${e}MainUv(UV);
`;n.set(g.FRAGMENT_MAIN_UV,n.get(g.FRAGMENT_MAIN_UV)+y),d=!0}if(a.get("vertex")!==null&&/mainSupport/.test(a.get("vertex"))){let y=`	${e}MainSupport(`;y+=/mainSupport *\([\w\s]*?uv\s*?\)/.test(a.get("vertex"))?`vUv);
`:`);
`,n.set(g.VERTEX_MAIN_SUPPORT,n.get(g.VERTEX_MAIN_SUPPORT)+y),h=h.concat([...a.get("vertex").matchAll(/(?:varying\s+\w+\s+(\w*))/g)].map(v=>v[1])),u=u.concat(h).concat([...a.get("vertex").matchAll(f)].map(v=>v[1]))}u=u.concat([...a.get("fragment").matchAll(f)].map(y=>y[1])),u=u.concat([...t.defines.keys()].map(y=>y.replace(/\([\w\s,]*\)/g,""))),u=u.concat([...t.uniforms.keys()]),t.uniforms.forEach((y,v)=>i.set(e+v.charAt(0).toUpperCase()+v.slice(1),y)),t.defines.forEach((y,v)=>r.set(e+v.charAt(0).toUpperCase()+v.slice(1),y)),c$(e,u,r),c$(e,u,a);let m=t.blendMode;if(s.set(m.blendFunction,m),l){let y=/MainImage *\([\w\s,]*?depth[\w\s,]*?\)/,v=`${e}MainImage(color0, UV, `;(o&za.DEPTH)!=0&&y.test(a.get("fragment"))&&(v+="depth, ",p=!0),v+=`color1);
	`;let b=e+"BlendOpacity";i.set(b,m.opacity),v+=`color0 = blend${m.blendFunction}(color0, color1, ${b});

	`,n.set(g.FRAGMENT_MAIN_IMAGE,n.get(g.FRAGMENT_MAIN_IMAGE)+v),v=`uniform float ${b};

`,n.set(g.FRAGMENT_HEAD,n.get(g.FRAGMENT_HEAD)+v)}n.set(g.FRAGMENT_HEAD,n.get(g.FRAGMENT_HEAD)+a.get("fragment")+`
`),a.get("vertex")!==null&&n.set(g.VERTEX_HEAD,n.get(g.VERTEX_HEAD)+a.get("vertex")+`
`)}return{varyings:h,transformedUv:d,readDepth:p}}var lT=class extends oo{constructor(e,...t){super("EffectPass"),this.fullscreenMaterial=new iT(null,null,null,e),this.effects=t.sort((n,s)=>s.attributes-n.attributes),this.skipRendering=!1,this.uniformCount=0,this.varyingCount=0,this.minTime=1,this.maxTime=Number.POSITIVE_INFINITY}get encodeOutput(){return this.fullscreenMaterial.encodeOutput}set encodeOutput(e){this.fullscreenMaterial.encodeOutput=e}get dithering(){return this.fullscreenMaterial.dithering}set dithering(e){let t=this.fullscreenMaterial;t.dithering=e,t.needsUpdate=!0}verifyResources(){let e=this.renderer.capabilities,t=Math.min(e.maxFragmentUniforms,e.maxVertexUniforms);this.uniformCount>t&&console.warn("The current rendering context doesn't support more than "+t+" uniforms, but "+this.uniformCount+" were defined"),t=e.maxVaryings,this.varyingCount>t&&console.warn("The current rendering context doesn't support more than "+t+" varyings, but "+this.varyingCount+" were defined")}updateMaterial(){let e=iT.Section,t=new Map([[e.FRAGMENT_HEAD,""],[e.FRAGMENT_MAIN_UV,""],[e.FRAGMENT_MAIN_IMAGE,""],[e.VERTEX_HEAD,""],[e.VERTEX_MAIN_SUPPORT,""]]),n=new Map,s=new Map,r=new Map,i=new Set,o=0,a=0,l=0,c=!1,h=!1;for(let d of this.effects)if(d.blendMode.blendFunction===an.SKIP)l|=d.getAttributes()&za.DEPTH;else if((l&d.getAttributes()&za.CONVOLUTION)!=0)console.error("Convolution effects cannot be merged",d);else{l|=d.getAttributes();let p="e"+o++,f=spe(p,d,t,n,s,r,l);if(a+=f.varyings.length,c=c||f.transformedUv,h=h||f.readDepth,d.extensions!==null)for(let g of d.extensions)i.add(g)}let u=/\bblend\b/g;for(let d of n.values()){let p=d.getShaderCode().replace(u,`blend${d.blendFunction}`);t.set(e.FRAGMENT_HEAD,t.get(e.FRAGMENT_HEAD)+p+`
`)}if((l&za.DEPTH)!=0){if(h){let d=`float depth = readDepth(UV);

	`;t.set(e.FRAGMENT_MAIN_IMAGE,d+t.get(e.FRAGMENT_MAIN_IMAGE))}this.needsDepthTexture=this.getDepthTexture()===null}else this.needsDepthTexture=!1;if(c){let d=`vec2 transformedUv = vUv;
`;t.set(e.FRAGMENT_MAIN_UV,d+t.get(e.FRAGMENT_MAIN_UV)),s.set("UV","transformedUv")}else s.set("UV","vUv");t.forEach((d,p,f)=>f.set(p,d.trim().replace(/^#/,`
#`))),this.uniformCount=r.size,this.varyingCount=a,this.skipRendering=o===0,this.needsSwap=!this.skipRendering,this.fullscreenMaterial.setShaderParts(t).setExtensions(i).setUniforms(r).setDefines(s)}recompile(){this.updateMaterial(),this.verifyResources()}getDepthTexture(){return this.fullscreenMaterial.depthBuffer}setDepthTexture(e,t=cl){this.fullscreenMaterial.depthBuffer=e,this.fullscreenMaterial.depthPacking=t;for(let n of this.effects)n.setDepthTexture(e,t)}render(e,t,n,s,r){for(let i of this.effects)i.update(e,t,s);if(!this.skipRendering||this.renderToScreen){let i=this.fullscreenMaterial;i.inputBuffer=t.texture,i.time+=s,e.setRenderTarget(this.renderToScreen?null:n),e.render(this.scene,this.camera)}}setSize(e,t){this.fullscreenMaterial.setSize(e,t);for(let n of this.effects)n.setSize(e,t)}initialize(e,t,n){this.renderer=e;for(let s of this.effects)s.initialize(e,t,n),s.addEventListener("change",r=>this.handleEvent(r));this.updateMaterial(),this.verifyResources(),n!==void 0&&n!==pr&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}dispose(){super.dispose();for(let e of this.effects)e.dispose()}handleEvent(e){switch(e.type){case"change":this.recompile();break}}},rpe=[new Float32Array([0,0]),new Float32Array([0,1,1]),new Float32Array([0,1,1,2]),new Float32Array([0,1,2,2,3]),new Float32Array([0,1,2,3,4,4,5]),new Float32Array([0,1,2,3,4,5,7,8,9,10])],u$=class extends oo{constructor({resolutionScale:e=.5,width:t=ri.AUTO_SIZE,height:n=ri.AUTO_SIZE,kernelSize:s=uT.LARGE}={}){super("KawaseBlurPass"),this.renderTargetA=new hs(1,1,{minFilter:xn,magFilter:xn,stencilBuffer:!1,depthBuffer:!1}),this.renderTargetA.texture.name="Blur.Target.A",this.renderTargetB=this.renderTargetA.clone(),this.renderTargetB.texture.name="Blur.Target.B";let r=this.resolution=new ri(this,t,n,e);r.addEventListener("change",i=>this.setSize(r.baseWidth,r.baseHeight)),this.blurMaterial=new r$,this.ditheredBlurMaterial=new r$,this.ditheredBlurMaterial.uniforms.scale=this.blurMaterial.uniforms.scale,this.ditheredBlurMaterial.dithering=!0,this.dithering=!1,this.kernelSize=s}getResolution(){return this.resolution}get width(){return this.resolution.width}set width(e){this.resolution.preferredWidth=e}get height(){return this.resolution.height}set height(e){this.resolution.preferredHeight=e}get scale(){return this.blurMaterial.scale}set scale(e){this.blurMaterial.scale=e}getScale(){return this.blurMaterial.scale}setScale(e){this.blurMaterial.scale=e}getKernelSize(){return this.kernelSize}setKernelSize(e){this.kernelSize=e}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,n,s,r){let i=this.scene,o=this.camera,a=this.renderTargetA,l=this.renderTargetB,c=rpe[this.kernelSize],h=this.blurMaterial,u=t,d,p;for(this.fullscreenMaterial=h,d=0,p=c.length-1;d<p;++d){let f=(d&1)==0?a:l;h.kernel=c[d],h.inputBuffer=u.texture,e.setRenderTarget(f),e.render(i,o),u=f}this.dithering&&(h=this.ditheredBlurMaterial,this.fullscreenMaterial=h),h.kernel=c[d],h.inputBuffer=u.texture,e.setRenderTarget(this.renderToScreen?null:n),e.render(i,o)}setSize(e,t){let n=this.resolution;n.setBaseSize(e,t);let s=n.width,r=n.height;this.renderTargetA.setSize(s,r),this.renderTargetB.setSize(s,r),this.blurMaterial.setSize(s,r),this.ditheredBlurMaterial.setSize(s,r)}initialize(e,t,n){n!==void 0&&(this.renderTargetA.texture.type=n,this.renderTargetB.texture.type=n,n!==pr?(this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.ditheredBlurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1"):e.outputEncoding===Gt&&(this.renderTargetA.texture.encoding=Gt,this.renderTargetB.texture.encoding=Gt))}static get AUTO_SIZE(){return ri.AUTO_SIZE}},ipe=class extends oo{constructor({width:e=ri.AUTO_SIZE,height:t=ri.AUTO_SIZE,renderTarget:n,luminanceRange:s,colorOutput:r}={}){super("LuminancePass"),this.fullscreenMaterial=new Ade(r,s),this.needsSwap=!1,this.renderTarget=n,this.renderTarget===void 0&&(this.renderTarget=new hs(1,1,{minFilter:xn,magFilter:xn,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="LuminancePass.Target",this.renderTarget.texture.generateMipmaps=!1);let i=this.resolution=new ri(this,e,t);i.addEventListener("change",o=>this.setSize(i.baseWidth,i.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}render(e,t,n,s,r){let i=this.fullscreenMaterial;i.inputBuffer=t.texture,e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){let n=this.resolution;n.setBaseSize(e,t),this.renderTarget.setSize(n.width,n.height)}initialize(e,t,n){n!==void 0&&n!==pr&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},ope=class extends oo{constructor(e,t){super("MaskPass",e,t),this.needsSwap=!1,this.clearPass=new $x(!1,!1,!0),this.inverse=!1}get inverted(){return this.inverse}set inverted(e){this.inverse=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getClearPass(){return this.clearPass}isInverted(){return this.inverted}setInverted(e){this.inverted=e}render(e,t,n,s,r){let i=e.getContext(),o=e.state.buffers,a=this.scene,l=this.camera,c=this.clearPass,h=this.inverted?0:1,u=1-h;o.color.setMask(!1),o.depth.setMask(!1),o.color.setLocked(!0),o.depth.setLocked(!0),o.stencil.setTest(!0),o.stencil.setOp(i.REPLACE,i.REPLACE,i.REPLACE),o.stencil.setFunc(i.ALWAYS,h,4294967295),o.stencil.setClear(u),o.stencil.setLocked(!0),this.clearPass.enabled&&(this.renderToScreen?c.render(e,null):(c.render(e,t),c.render(e,n))),this.renderToScreen?(e.setRenderTarget(null),e.render(a,l)):(e.setRenderTarget(t),e.render(a,l),e.setRenderTarget(n),e.render(a,l)),o.color.setLocked(!1),o.depth.setLocked(!1),o.stencil.setLocked(!1),o.stencil.setFunc(i.EQUAL,1,4294967295),o.stencil.setOp(i.KEEP,i.KEEP,i.KEEP),o.stencil.setLocked(!0)}},Nc=class extends oo{constructor(e,t="inputBuffer"){super("ShaderPass"),this.fullscreenMaterial=e,this.inputBufferUniform=null,this.setInput(t)}setInput(e){if(this.inputBufferUniform=null,this.fullscreenMaterial!==null){let t=this.fullscreenMaterial.uniforms;t!==void 0&&t[e]!==void 0&&(this.inputBufferUniform=t[e])}}render(e,t,n,s,r){this.inputBufferUniform!==null&&t!==null&&(this.inputBufferUniform.value=t.texture),e.setRenderTarget(this.renderToScreen?null:n),e.render(this.scene,this.camera)}initialize(e,t,n){n!==void 0&&n!==pr&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},cT=1/1e3,ape=1e3,lpe=class{constructor(){this.previousTime=0,this.currentTime=0,this.delta=0,this.fixedDelta=1e3/60,this.elapsed=0,this.timescale=1,this.fixedDeltaEnabled=!1,this.autoReset=!1}setFixedDeltaEnabled(e){return this.fixedDeltaEnabled=e,this}isAutoResetEnabled(e){return this.autoReset}setAutoResetEnabled(e){return typeof document<"u"&&document.hidden!==void 0&&(e?document.addEventListener("visibilitychange",this):document.removeEventListener("visibilitychange",this),this.autoReset=e),this}getDelta(){return this.delta*cT}getFixedDelta(){return this.fixedDelta*cT}setFixedDelta(e){return this.fixedDelta=e*ape,this}getElapsed(){return this.elapsed*cT}getTimescale(){return this.timescale}setTimescale(e){return this.timescale=e,this}update(e){return this.fixedDeltaEnabled?this.delta=this.fixedDelta:(this.previousTime=this.currentTime,this.currentTime=e!==void 0?e:performance.now(),this.delta=this.currentTime-this.previousTime),this.delta*=this.timescale,this.elapsed+=this.delta,this}reset(){return this.delta=0,this.elapsed=0,this.currentTime=performance.now(),this}handleEvent(e){document.hidden||(this.currentTime=performance.now())}dispose(){this.setAutoResetEnabled(!1)}},cpe=class{constructor(e=null,{depthBuffer:t=!0,stencilBuffer:n=!1,multisampling:s=0,frameBufferType:r}={}){this.renderer=null,this.inputBuffer=this.createBuffer(t,n,r,s),this.outputBuffer=this.inputBuffer.clone(),this.copyPass=new Fx,this.depthTexture=null,this.passes=[],this.timer=new lpe,this.autoRenderToScreen=!0,this.setRenderer(e)}get multisampling(){return this.inputBuffer.samples||0}set multisampling(e){let t=this.inputBuffer,n=this.multisampling;n>0&&e>0?(this.inputBuffer.samples=e,this.outputBuffer.samples=e,this.inputBuffer.dispose(),this.outputBuffer.dispose()):n!==e&&(this.inputBuffer.dispose(),this.outputBuffer.dispose(),this.inputBuffer=this.createBuffer(t.depthBuffer,t.stencilBuffer,t.texture.type,e),this.inputBuffer.depthTexture=this.depthTexture,this.outputBuffer=this.inputBuffer.clone())}getTimer(){return this.timer}getRenderer(){return this.renderer}setRenderer(e){if(this.renderer=e,e!==null){let t=e.getSize(new se),n=e.getContext().getContextAttributes().alpha,s=this.inputBuffer.texture.type;s===pr&&e.outputEncoding===Gt&&(this.inputBuffer.texture.encoding=Gt,this.outputBuffer.texture.encoding=Gt,this.inputBuffer.dispose(),this.outputBuffer.dispose()),e.autoClear=!1,this.setSize(t.width,t.height);for(let r of this.passes)r.initialize(e,n,s)}}replaceRenderer(e,t=!0){let n=this.renderer,s=n.domElement.parentNode;return this.setRenderer(e),t&&s!==null&&(s.removeChild(n.domElement),s.appendChild(e.domElement)),n}createDepthTexture(){let e=this.depthTexture=new PS;return this.inputBuffer.depthTexture=e,this.inputBuffer.dispose(),this.inputBuffer.stencilBuffer?(e.format=mu,e.type=pu):e.type=ql,e}deleteDepthTexture(){if(this.depthTexture!==null){this.depthTexture.dispose(),this.depthTexture=null,this.inputBuffer.depthTexture=null,this.inputBuffer.dispose();for(let e of this.passes)e.setDepthTexture(null)}}createBuffer(e,t,n,s){let r=this.renderer,i=r===null?new se:r.getDrawingBufferSize(new se),o={minFilter:xn,magFilter:xn,stencilBuffer:t,depthBuffer:e,type:n},a;return s>0?(a=Number(_f.replace(/\D+/g,""))<138?new xY(i.width,i.height,o):new hs(i.width,i.height,o),a.ignoreDepthForMultisampleCopy=!1,a.samples=s):a=new hs(i.width,i.height,o),n===pr&&r!==null&&r.outputEncoding===Gt&&(a.texture.encoding=Gt),a.texture.name="EffectComposer.Buffer",a.texture.generateMipmaps=!1,a}addPass(e,t){let n=this.passes,s=this.renderer,r=s.getDrawingBufferSize(new se),i=s.getContext().getContextAttributes().alpha,o=this.inputBuffer.texture.type;if(e.setRenderer(s),e.setSize(r.width,r.height),e.initialize(s,i,o),this.autoRenderToScreen&&(n.length>0&&(n[n.length-1].renderToScreen=!1),e.renderToScreen&&(this.autoRenderToScreen=!1)),t!==void 0?n.splice(t,0,e):n.push(e),this.autoRenderToScreen&&(n[n.length-1].renderToScreen=!0),e.needsDepthTexture||this.depthTexture!==null)if(this.depthTexture===null){let a=this.createDepthTexture();for(e of n)e.setDepthTexture(a)}else e.setDepthTexture(this.depthTexture)}removePass(e){let t=this.passes,n=t.indexOf(e);if(n!==-1&&t.splice(n,1).length>0){if(this.depthTexture!==null){let s=(r,i)=>r||i.needsDepthTexture;t.reduce(s,!1)||(e.getDepthTexture()===this.depthTexture&&e.setDepthTexture(null),this.deleteDepthTexture())}this.autoRenderToScreen&&n===t.length&&(e.renderToScreen=!1,t.length>0&&(t[t.length-1].renderToScreen=!0))}}removeAllPasses(){let e=this.passes;this.deleteDepthTexture(),e.length>0&&(this.autoRenderToScreen&&(e[e.length-1].renderToScreen=!1),this.passes=[])}render(e){let t=this.renderer,n=this.copyPass,s=this.inputBuffer,r=this.outputBuffer,i=!1,o,a,l;e===void 0&&(e=this.timer.update().getDelta());for(let c of this.passes)c.enabled&&(c.render(t,s,r,e,i),c.needsSwap&&(i&&(n.renderToScreen=c.renderToScreen,o=t.getContext(),a=t.state.buffers.stencil,a.setFunc(o.NOTEQUAL,1,4294967295),n.render(t,s,r,e,i),a.setFunc(o.EQUAL,1,4294967295)),l=s,s=r,r=l),c instanceof ope?i=!0:c instanceof Rde&&(i=!1))}setSize(e,t,n){let s=this.renderer;if(e===void 0||t===void 0){let i=s.getSize(new se);e=i.width,t=i.height}s.setSize(e,t,n);let r=s.getDrawingBufferSize(new se);this.inputBuffer.setSize(r.width,r.height),this.outputBuffer.setSize(r.width,r.height);for(let i of this.passes)i.setSize(r.width,r.height)}reset(){let e=this.timer.isAutoResetEnabled();this.dispose(),this.autoRenderToScreen=!0,this.timer.setAutoResetEnabled(e)}dispose(){for(let e of this.passes)e.dispose();this.passes=[],this.inputBuffer!==null&&this.inputBuffer.dispose(),this.outputBuffer!==null&&this.outputBuffer.dispose(),this.deleteDepthTexture(),this.copyPass.dispose(),this.timer.dispose()}},uT={VERY_SMALL:0,SMALL:1,MEDIUM:2,LARGE:3,VERY_LARGE:4,HUGE:5},upe=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=clamp(texture2D(map,uv)*intensity,0.0,1.0);}`,hpe=class extends Ua{constructor({blendFunction:e=an.SCREEN,luminanceThreshold:t=.9,luminanceSmoothing:n=.025,resolutionScale:s=.5,intensity:r=1,width:i=ri.AUTO_SIZE,height:o=ri.AUTO_SIZE,kernelSize:a=uT.LARGE}={}){super("BloomEffect",upe,{blendFunction:e,uniforms:new Map([["map",new dt(null)],["intensity",new dt(r)]])}),this.renderTarget=new hs(1,1,{minFilter:xn,magFilter:xn,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="Bloom.Target",this.renderTarget.texture.generateMipmaps=!1,this.uniforms.get("map").value=this.renderTarget.texture,this.luminancePass=new ipe({renderTarget:this.renderTarget,colorOutput:!0}),this.luminanceMaterial.threshold=t,this.luminanceMaterial.smoothingFactor=n,this.blurPass=new u$({resolutionScale:s,width:i,height:o,kernelSize:a});let l=this.blurPass.getResolution();l.addEventListener("change",c=>this.setSize(l.baseWidth,l.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}get resolution(){return this.blurPass.resolution}getResolution(){return this.blurPass.resolution}getBlurPass(){return this.blurPass}getLuminancePass(){return this.luminancePass}get luminanceMaterial(){return this.luminancePass.fullscreenMaterial}getLuminanceMaterial(){return this.luminancePass.fullscreenMaterial}get width(){return this.resolution.width}set width(e){this.resolution.preferredWidth=e}get height(){return this.resolution.height}set height(e){this.resolution.preferredHeight=e}get dithering(){return this.blurPass.dithering}set dithering(e){this.blurPass.dithering=e}get kernelSize(){return this.blurPass.kernelSize}set kernelSize(e){this.blurPass.kernelSize=e}get distinction(){return console.warn(this.name,"distinction was removed"),1}set distinction(e){console.warn(this.name,"distinction was removed")}get intensity(){return this.uniforms.get("intensity").value}set intensity(e){this.uniforms.get("intensity").value=e}getIntensity(){return this.intensity}setIntensity(e){this.intensity=e}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}update(e,t,n){let s=this.renderTarget;this.luminancePass.enabled?(this.luminancePass.render(e,t,s),this.blurPass.render(e,s,s)):this.blurPass.render(e,t,s)}setSize(e,t){let n=this.resolution;n.setBaseSize(e,t),this.renderTarget.setSize(n.width,n.height),this.luminancePass.resolution.copy(n)}initialize(e,t,n){this.blurPass.initialize(e,t,n),n!==void 0&&(this.renderTarget.texture.type=n,e.outputEncoding===Gt&&(this.renderTarget.texture.encoding=Gt))}},dpe="uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(min(color+vec3(0.5),1.0),inputColor.a);}",ppe=class extends Ua{constructor({blendFunction:e=an.NORMAL,brightness:t=0,contrast:n=0}={}){super("BrightnessContrastEffect",dpe,{blendFunction:e,uniforms:new Map([["brightness",new dt(t)],["contrast",new dt(n)]])})}get brightness(){return this.uniforms.get("brightness").value}set brightness(e){this.uniforms.get("brightness").value=e}getBrightness(e){return this.brightness}setBrightness(e){this.brightness=e}get contrast(){return this.uniforms.get("contrast").value}set contrast(e){this.uniforms.get("contrast").value=e}getContrast(e){return this.contrast}setContrast(e){this.contrast=e}},fpe="void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(vec3(average(inputColor.rgb)),inputColor.a);}",mpe=class extends Ua{constructor(e=an.NORMAL){super("ColorAverageEffect",fpe,{blendFunction:e})}},gpe="varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=texture2D(inputBuffer,vUvR).ra;vec2 ba=texture2D(inputBuffer,vUvB).ba;outputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}",ype="uniform vec2 offset;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vUvR=uv+shift;vUvB=uv-shift;}",vpe=class extends Ua{constructor({blendFunction:e=an.NORMAL,offset:t=new se(.001,5e-4)}={}){super("ChromaticAberrationEffect",gpe,{vertexShader:ype,blendFunction:e,attributes:za.CONVOLUTION,uniforms:new Map([["offset",new dt(t)]])})}get offset(){return this.uniforms.get("offset").value}set offset(e){this.uniforms.get("offset").value=e}getOffset(){return this.offset}setOffset(e){this.offset=e}},xpe=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;
#else
uniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;
#endif
uniform lowp sampler2D nearCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);float CoCNear=texture2D(nearCoCBuffer,uv).r;CoCNear=min(CoCNear*scale,1.0);vec4 result=inputColor*(1.0-colorFar.a)+colorFar;result=mix(result,colorNear,CoCNear);outputColor=result;}`,bpe=class extends Ua{constructor(e,{blendFunction:t=an.NORMAL,worldFocusDistance:n,worldFocusRange:s,focusDistance:r=0,focalLength:i=.1,focusRange:o=i,bokehScale:a=1,width:l=ri.AUTO_SIZE,height:c=ri.AUTO_SIZE}={}){super("DepthOfFieldEffect",xpe,{blendFunction:t,attributes:za.DEPTH,uniforms:new Map([["nearColorBuffer",new dt(null)],["farColorBuffer",new dt(null)],["nearCoCBuffer",new dt(null)],["scale",new dt(1)]])}),this.camera=e,this.renderTarget=new hs(1,1,{minFilter:xn,magFilter:xn,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="DoF.Intermediate",this.renderTarget.texture.generateMipmaps=!1,this.renderTargetMasked=this.renderTarget.clone(),this.renderTargetMasked.texture.name="DoF.Masked.Far",this.renderTargetNear=this.renderTarget.clone(),this.renderTargetNear.texture.name="DoF.Bokeh.Near",this.uniforms.get("nearColorBuffer").value=this.renderTargetNear.texture,this.renderTargetFar=this.renderTarget.clone(),this.renderTargetFar.texture.name="DoF.Bokeh.Far",this.uniforms.get("farColorBuffer").value=this.renderTargetFar.texture,this.renderTargetCoC=this.renderTarget.clone(),this.renderTargetCoC.texture.name="DoF.CoC",this.renderTargetCoCBlurred=this.renderTargetCoC.clone(),this.renderTargetCoCBlurred.texture.name="DoF.CoC.Blurred",this.uniforms.get("nearCoCBuffer").value=this.renderTargetCoCBlurred.texture,this.cocPass=new Nc(new gde(e));let h=this.cocMaterial;h.focusDistance=r,h.focusRange=o,n!==void 0&&(h.worldFocusDistance=n),s!==void 0&&(h.worldFocusRange=s),this.blurPass=new u$({kernelSize:uT.MEDIUM,width:l,height:c});let u=this.blurPass.getResolution();u.addEventListener("change",p=>this.setSize(u.getBaseWidth(),u.getBaseHeight())),this.maskPass=new Nc(new Nde(this.renderTargetCoC.texture));let d=this.maskPass.fullscreenMaterial;d.maskFunction=o$.MULTIPLY,d.colorChannel=n$.GREEN,this.bokehNearBasePass=new Nc(new Lx(!1,!0)),this.bokehNearBasePass.fullscreenMaterial.cocBuffer=this.renderTargetCoCBlurred.texture,this.bokehNearFillPass=new Nc(new Lx(!0,!0)),this.bokehNearFillPass.fullscreenMaterial.cocBuffer=this.renderTargetCoCBlurred.texture,this.bokehFarBasePass=new Nc(new Lx(!1,!1)),this.bokehFarBasePass.fullscreenMaterial.cocBuffer=this.renderTargetCoC.texture,this.bokehFarFillPass=new Nc(new Lx(!0,!1)),this.bokehFarFillPass.fullscreenMaterial.cocBuffer=this.renderTargetCoC.texture,this.target=null,this.bokehScale=a}get cocTexture(){return this.renderTargetCoC.texture}get cocMaterial(){return this.cocPass.fullscreenMaterial}get circleOfConfusionMaterial(){return this.cocMaterial}getCircleOfConfusionMaterial(){return this.circleOfConfusionMaterial}getBlurPass(){return this.blurPass}get resolution(){return this.blurPass.getResolution()}getResolution(){return this.blurPass.getResolution()}get bokehScale(){return this.uniforms.get("scale").value}set bokehScale(e){let t=[this.bokehNearBasePass,this.bokehNearFillPass,this.bokehFarBasePass,this.bokehFarFillPass];for(let n of t)n.fullscreenMaterial.setScale(e);this.maskPass.fullscreenMaterial.setStrength(e),this.uniforms.get("scale").value=e}getBokehScale(){return this.bokehScale}setBokehScale(e){this.bokehScale=e}getTarget(){return this.target}setTarget(e){this.target=e}calculateFocusDistance(e){let t=this.camera,n=t.position.distanceTo(e);return sT(-n,t.near,t.far)}setDepthTexture(e,t=cl){this.circleOfConfusionMaterial.depthBuffer=e,this.circleOfConfusionMaterial.depthPacking=t}update(e,t,n){let s=this.renderTarget,r=this.renderTargetCoC,i=this.renderTargetCoCBlurred,o=this.renderTargetMasked;if(this.target!==null){let a=this.calculateFocusDistance(this.target);this.circleOfConfusionMaterial.focusDistance=a}this.cocPass.render(e,null,r),this.blurPass.render(e,r,i),this.maskPass.render(e,t,o),this.bokehFarBasePass.render(e,o,s),this.bokehFarFillPass.render(e,s,this.renderTargetFar),this.bokehNearBasePass.render(e,t,s),this.bokehNearFillPass.render(e,s,this.renderTargetNear)}setSize(e,t){let n=this.resolution;n.setBaseSize(e,t);let s=n.width,r=n.height,i=[this.cocPass,this.blurPass,this.maskPass,this.bokehNearBasePass,this.bokehNearFillPass,this.bokehFarBasePass,this.bokehFarFillPass];i.push(this.renderTargetCoC,this.renderTargetMasked),i.forEach(o=>o.setSize(e,t)),i=[this.renderTarget,this.renderTargetNear,this.renderTargetFar,this.renderTargetCoCBlurred],i.forEach(o=>o.setSize(s,r)),[this.bokehNearBasePass,this.bokehNearFillPass,this.bokehFarBasePass,this.bokehFarFillPass].forEach(o=>o.fullscreenMaterial.setSize(s,r))}initialize(e,t,n){[this.cocPass,this.maskPass,this.bokehNearBasePass,this.bokehNearFillPass,this.bokehFarBasePass,this.bokehFarFillPass].forEach(s=>s.initialize(e,t,n)),this.blurPass.initialize(e,t,pr),n!==void 0&&(this.renderTarget.texture.type=n,this.renderTargetNear.texture.type=n,this.renderTargetFar.texture.type=n,this.renderTargetMasked.texture.type=n,e.outputEncoding===Gt&&(this.renderTarget.texture.encoding=Gt,this.renderTargetNear.texture.encoding=Gt,this.renderTargetFar.texture.encoding=Gt,this.renderTargetMasked.texture.encoding=Gt))}};new I;new et;var wpe="uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}",Spe=class extends Ua{constructor({blendFunction:e=an.NORMAL,hue:t=0,saturation:n=0}={}){super("HueSaturationEffect",wpe,{blendFunction:e,uniforms:new Map([["hue",new dt(new I)],["saturation",new dt(n)]])}),this.hue=t}get saturation(){return this.uniforms.get("saturation").value}set saturation(e){this.uniforms.get("saturation").value=e}getSaturation(){return this.saturation}setSaturation(e){this.saturation=e}get hue(){let e=this.uniforms.get("hue").value;return Math.acos((e.x*3-1)/2)}set hue(e){let t=Math.sin(e),n=Math.cos(e);this.uniforms.get("hue").value.set((2*n+1)/3,(-Math.sqrt(3)*t-n+1)/3,(Math.sqrt(3)*t-n+1)/3)}getHue(){return this.hue}setHue(e){this.hue=e}};new _t;var _pe=`void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));
#ifdef PREMULTIPLY
outputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);
#else
outputColor=vec4(noise,inputColor.a);
#endif
}`,Cpe=class extends Ua{constructor({blendFunction:e=an.SCREEN,premultiply:t=!1}={}){super("NoiseEffect",_pe,{blendFunction:e}),this.premultiply=t}get premultiply(){return this.defines.has("PREMULTIPLY")}set premultiply(e){this.premultiply!==e&&(e?this.defines.set("PREMULTIPLY","1"):this.defines.delete("PREMULTIPLY"),this.setChanged())}isPremultiplied(){return this.premultiply}setPremultiplied(e){this.premultiply=e}},Tpe="uniform bool active;uniform vec2 d;void mainUv(inout vec2 uv){if(active){uv=vec2(d.x*(floor(uv.x/d.x)+0.5),d.y*(floor(uv.y/d.y)+0.5));}}",Epe=class extends Ua{constructor(e=30){super("PixelationEffect",Tpe,{uniforms:new Map([["active",new dt(!1)],["d",new dt(new se)]])}),this.resolution=new se,this.d=0,this.granularity=e}get granularity(){return this.d}set granularity(e){let t=Math.floor(e);t%2>0&&(t+=1),this.d=t,this.uniforms.get("active").value=t>0,this.setSize(this.resolution.width,this.resolution.height)}getGranularity(){return this.granularity}setGranularity(e){this.granularity=e}setSize(e,t){this.resolution.set(e,t),this.uniforms.get("d").value.setScalar(this.d).divide(this.resolution)}};new I;new I;var h$="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC",d$="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC",Ape="uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}",Ipe="varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}",mp={LOW:0,MEDIUM:1,HIGH:2,ULTRA:3},Npe=class extends Ua{constructor({preset:e=mp.MEDIUM,edgeDetectionMode:t=rT.COLOR,predicationMode:n=i$.DISABLED}={}){super("SMAAEffect",Ape,{vertexShader:Ipe,blendFunction:an.NORMAL,attributes:za.CONVOLUTION|za.DEPTH,uniforms:new Map([["weightMap",new dt(null)]])});let s,r;arguments.length>1&&(s=arguments[0],r=arguments[1],arguments.length>2&&(e=arguments[2]),arguments.length>3&&(t=arguments[3])),this.renderTargetEdges=new hs(1,1,{minFilter:xn,stencilBuffer:!1,depthBuffer:!1}),this.renderTargetEdges.texture.name="SMAA.Edges",this.renderTargetWeights=this.renderTargetEdges.clone(),this.renderTargetWeights.texture.name="SMAA.Weights",this.uniforms.get("weightMap").value=this.renderTargetWeights.texture,this.clearPass=new $x(!0,!1,!1),this.clearPass.overrideClearColor=new _t(0),this.clearPass.overrideClearAlpha=1,this.edgeDetectionPass=new Nc(new _de),this.edgeDetectionMaterial.edgeDetectionMode=t,this.edgeDetectionMaterial.predicationMode=n,this.weightsPass=new Nc(new Mde);let i=new mM;i.onLoad=()=>{let o=new mr(s);o.name="SMAA.Search",o.magFilter=ns,o.minFilter=ns,o.generateMipmaps=!1,o.needsUpdate=!0,o.flipY=!0,this.weightsMaterial.searchTexture=o;let a=new mr(r);a.name="SMAA.Area",a.magFilter=xn,a.minFilter=xn,a.generateMipmaps=!1,a.needsUpdate=!0,a.flipY=!1,this.weightsMaterial.areaTexture=a,this.dispatchEvent({type:"load"})},i.itemStart("search"),i.itemStart("area"),s!==void 0&&r!==void 0?(i.itemEnd("search"),i.itemEnd("area")):typeof Image<"u"&&(s=new Image,r=new Image,s.addEventListener("load",()=>i.itemEnd("search")),r.addEventListener("load",()=>i.itemEnd("area")),s.src=h$,r.src=d$),this.applyPreset(e)}get edgesTexture(){return this.renderTargetEdges.texture}getEdgesTexture(){return this.edgesTexture}get weightsTexture(){return this.renderTargetWeights.texture}getWeightsTexture(){return this.weightsTexture}get edgeDetectionMaterial(){return this.edgeDetectionPass.fullscreenMaterial}get colorEdgesMaterial(){return this.edgeDetectionMaterial}getEdgeDetectionMaterial(){return this.edgeDetectionMaterial}get weightsMaterial(){return this.weightsPass.fullscreenMaterial}getWeightsMaterial(){return this.weightsMaterial}setEdgeDetectionThreshold(e){this.edgeDetectionMaterial.edgeDetectionThreshold=e}setOrthogonalSearchSteps(e){this.weightsMaterial.orthogonalSearchSteps=e}applyPreset(e){let t=this.edgeDetectionMaterial,n=this.weightsMaterial;switch(e){case mp.LOW:t.edgeDetectionThreshold=.15,n.orthogonalSearchSteps=4,n.diagonalDetection=!1,n.cornerDetection=!1;break;case mp.MEDIUM:t.edgeDetectionThreshold=.1,n.orthogonalSearchSteps=8,n.diagonalDetection=!1,n.cornerDetection=!1;break;case mp.HIGH:t.edgeDetectionThreshold=.1,n.orthogonalSearchSteps=16,n.diagonalSearchSteps=8,n.cornerRounding=25,n.diagonalDetection=!0,n.cornerDetection=!0;break;case mp.ULTRA:t.edgeDetectionThreshold=.05,n.orthogonalSearchSteps=32,n.diagonalSearchSteps=16,n.cornerRounding=25,n.diagonalDetection=!0,n.cornerDetection=!0;break}}setDepthTexture(e,t=cl){this.edgeDetectionMaterial.depthBuffer=e,this.edgeDetectionMaterial.depthPacking=t}update(e,t,n){this.clearPass.render(e,this.renderTargetEdges),this.edgeDetectionPass.render(e,t,this.renderTargetEdges),this.weightsPass.render(e,this.renderTargetEdges,this.renderTargetWeights)}setSize(e,t){this.edgeDetectionMaterial.setSize(e,t),this.weightsMaterial.setSize(e,t),this.renderTargetEdges.setSize(e,t),this.renderTargetWeights.setSize(e,t)}dispose(){let{searchTexture:e,areaTexture:t}=this.weightsMaterial;e!==null&&t!==null&&(e.dispose(),t.dispose()),super.dispose()}static get searchImageDataURL(){return h$}static get areaImageDataURL(){return d$}},kpe=`uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`,Bx={DEFAULT:0,ESKIL:1},Dpe=class extends Ua{constructor({blendFunction:e=an.NORMAL,technique:t=Bx.DEFAULT,eskil:n=!1,offset:s=.5,darkness:r=.5}={}){super("VignetteEffect",kpe,{blendFunction:e,defines:new Map([["VIGNETTE_TECHNIQUE",t.toFixed(0)]]),uniforms:new Map([["offset",new dt(s)],["darkness",new dt(r)]])})}get technique(){return Number(this.defines.get("VIGNETTE_TECHNIQUE"))}set technique(e){this.technique!==e&&(this.defines.set("VIGNETTE_TECHNIQUE",e.toFixed(0)),this.setChanged())}get eskil(){return this.technique===Bx.ESKIL}set eskil(e){this.technique=e?Bx.ESKIL:Bx.DEFAULT}getTechnique(){return this.technique}setTechnique(e){this.technique=e}get offset(){return this.uniforms.get("offset").value}set offset(e){this.uniforms.get("offset").value=e}getOffset(){return this.offset}setOffset(e){this.offset=e}get darkness(){return this.uniforms.get("darkness").value}set darkness(e){this.uniforms.get("darkness").value=e}getDarkness(){return this.darkness}setDarkness(e){this.darkness=e}},Al=class{constructor(e,t){this.enabled=!1,this.effect=new e(t),Object.defineProperty(this,"opacity",{enumerable:!0,set(n){this.effect.blendMode.opacity.value=n},get(){return this.effect.blendMode.opacity.value}}),Object.defineProperty(this,"blendFunction",{enumerable:!0,set(n){this.effect.blendMode.setBlendFunction(Number(n))},get(){return this.effect.blendMode.blendFunction}}),this.blendFunction=an.NORMAL}},Mpe=class extends Al{constructor(){super(hpe),this.blendFunction=an.SCREEN}set intensity(e){this.effect.intensity=e}get intensity(){return this.effect.intensity}set luminanceThreshold(e){this.effect.luminanceMaterial.threshold=e}get luminanceThreshold(){return this.effect.luminanceMaterial.threshold}set luminanceSmoothing(e){this.effect.luminanceMaterial.smoothing=e}get luminanceSmoothing(){return this.effect.luminanceMaterial.smoothing}set blurScale(e){this.effect.blurPass.scale=e}get blurScale(){return this.effect.blurPass.scale}set kernelSize(e){this.effect.blurPass.kernelSize=e}get kernelSize(){return this.effect.blurPass.kernelSize}},Ppe=class extends Al{constructor(){super(ppe)}set contrast(e){this.effect.uniforms.get("contrast").value=e}get contrast(){return this.effect.uniforms.get("contrast").value}set brightness(e){this.effect.uniforms.get("brightness").value=e}get brightness(){return this.effect.uniforms.get("brightness").value}},Ope=class extends Al{constructor(){super(vpe),this.effect.offset=new se(.01,.01)}set offset(e){this.effect.offset.set(e[0]/1e3,e[1]/1e3)}get offset(){return[this.effect.offset.x*1e3,this.effect.offset.y*1e3]}},Rpe=class extends Al{constructor(){super(mpe)}},Lpe=class extends Al{constructor(){super(Spe);this._hue=0}set hue(e){this._hue=e,this.effect.setHue(e)}get hue(){return this._hue}set saturation(e){this.effect.uniforms.get("saturation").value=e}get saturation(){return this.effect.uniforms.get("saturation").value}},Fpe=class extends Al{constructor(){super(Cpe),this.blendFunction=an.OVERLAY}},$pe=class extends Al{constructor(){super(Dpe)}get eskil(){return this.effect.eskil}set eskil(e){this.effect.eskil=e}get darkness(){return this.effect.uniforms.get("darkness").value}set darkness(e){this.effect.uniforms.get("darkness").value=e}get offset(){return this.effect.uniforms.get("offset").value}set offset(e){this.effect.uniforms.get("offset").value=e}},Bpe=class extends Al{constructor(e){super(bpe,e)}set focalLength(e){this.effect.circleOfConfusionMaterial.uniforms.focalLength.value=e}get focalLength(){return this.effect.circleOfConfusionMaterial.uniforms.focalLength.value}set focusDistance(e){this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value=e}get focusDistance(){return this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value}get bokehScale(){return this.effect.bokehScale}set bokehScale(e){this.effect.bokehScale=e}},zpe=class extends Al{constructor(){super(Epe)}get granularity(){return this.effect.getGranularity()}set granularity(e){this.effect.setGranularity(e)}},Upe=class extends oo{constructor(e,t,n){super("TransmissionPass",e,t);this.copyPass=new Fx(n.transmissionRenderTarget),this.depthPass=new l$(e,t,{renderTarget:n.transmissionDepthTarget}),this.needsSwap=!1}updatePasses(e){this.copyPass=new Fx(e.transmissionRenderTarget),this.depthPass=new l$(this.scene,this.camera,{renderTarget:e.transmissionDepthTarget})}setCamera(e){this.camera=e}setScene(e){this.scene=e}render(e,t,n){let s=this.camera.layers.mask;this.copyPass.render(e,t,n),this.camera.layers.disable(3),this.depthPass.render(e,t,n),e.shadowMap.needsUpdate=!1,e.shadowMap.autoUpdate=!1;let r=this.renderToScreen?null:t;this.camera.layers.set(3),e.setRenderTarget(r),e.render(this.scene,this.camera),this.camera.layers.mask=s}},p$=new _u,Vpe=new Ms({transparent:!0,vertexShader:`
        void main() {
            gl_Position = vec4(0.0);
        }
    `,fragmentShader:`
        void main() {
            gl_FragColor = vec4(0.0);
        }
    `}),hT=class extends oo{constructor(e,t){super("OpaquePass",e!=null?e:p$,t);this.hasTransmissionPass=!1,this.clear=!0,this.needsSwap=!1,this.originalMaterials=new Map}setCamera(e){this.camera=e}setScene(e){this.scene=e!=null?e:p$}getScene(){return this.scene}render(e,t){this.originalMaterials.clear(),this.camera.layers.enable(3),this.hasTransmissionPass&&this.scene.traverse(s=>{s.layers.isEnabled(3)&&s instanceof Ai&&(this.originalMaterials.set(s.id,s.material),s.material=Vpe)}),this.camera.layers.enable(8),e.shadowMap.needsUpdate=!0,e.shadowMap.autoUpdate=!0;let n=this.renderToScreen?null:t;e.setRenderTarget(n),this.clear&&e.clear(),e.render(this.scene,this.camera),this.hasTransmissionPass&&this.originalMaterials.forEach((s,r)=>{let i=this.scene.getObjectById(r);i&&(i.material=s)})}};function f$(e,t){return t&&t.enabled&&e.push(t.effect),e}var Gpe=class extends Zr{constructor(e){super();this.postprocessingState=om.defaultData,this._scene=new _u,this._camera=new _l,this.effects=new Map,this._renderToScreen=!0,this.clock=new hY,this.renderer=e,this.debug=!1,this.effects.set("bloom",new Mpe),this.effects.set("chromaticAberration",new Ope),this.effects.set("vignette",new $pe),this.effects.set("noise",new Fpe),this.effects.set("colorAverage",new Rpe),this.effects.set("hueSaturation",new Lpe),this.effects.set("brightnessContrast",new Ppe),this.effects.set("depthOfField",new Bpe),this.effects.set("pixelation",new zpe),this.effectComposer=new cpe(this.renderer),this.opaquePass=new hT(this.scene,this.camera),this.transmissionPass=new Upe(this.scene,this.camera,this.renderer),this.helperPass=new hT(void 0,this.camera),this.helperPass.hasTransmissionPass=!1,this.helperPass.clear=!1,this.helperClearPass=new $x(!1,!0,!1),this.helperPassOnTop=new hT(void 0,this.camera),this.helperPassOnTop.hasTransmissionPass=!1,this.helperPassOnTop.clear=!1,this._initCopyPass(),this._initSmaa(),this._initPasses()}get scene(){return this._scene}set scene(e){this._scene=e,this.opaquePass.setScene(e),this.transmissionPass.setScene(e)}set sceneHelpers(e){this.helperPass.setScene(e)}get sceneHelpers(){return this.helperPass.getScene()}set sceneHelpersOnTop(e){this.helperPassOnTop.setScene(e)}get sceneHelpersOnTop(){return this.helperPassOnTop.getScene()}get camera(){return this._camera}set camera(e){this._camera=e,this.opaquePass.setCamera(e),this.transmissionPass.setCamera(e),this.helperPass.setCamera(e),this.helperPassOnTop.setCamera(e)}setTransmissionPassEnabled(e){this.transmissionPass.enabled=e,this.opaquePass.hasTransmissionPass=e}disableHelpers(){this.helperPass.enabled=!1,this.helperClearPass.enabled=!1,this.helperPassOnTop.enabled=!1}enableHelpers(){this.helperPass.enabled=!0,this.helperClearPass.enabled=!0,this.helperPassOnTop.enabled=!0}_initSmaa(){let e=new Npe({preset:mp.ULTRA,edgeDetectionMode:rT.COLOR}),t=()=>{e.removeEventListener("load",t),this.dispatchEvent({type:"smaaloaded"})};e.addEventListener("load",t),e.edgeDetectionMaterial.predicationMode=i$.DEPTH,e.edgeDetectionMaterial.edgeDetectionThreshold=.05,e.edgeDetectionMaterial.predicationThreshold=.002,e.edgeDetectionMaterial.predicationScale=1,this.smaaPass=new lT(this.camera,e)}_initPasses(){var e,t;if((e=this.uvEffectPass)==null||e.dispose(),(t=this.effectPass)==null||t.dispose(),this.effectComposer.removeAllPasses(),this.transmissionPass.updatePasses(this.renderer),this.effectComposer.addPass(this.opaquePass),this.effectComposer.addPass(this.transmissionPass),this.postprocessingState.enabled){let n=[this.effects.get("pixelation")].reduce(f$,[]);n.length>0&&(this.uvEffectPass=new lT(this.camera,...n),this.effectComposer.addPass(this.uvEffectPass));let s=[this.effects.get("chromaticAberration"),this.effects.get("bloom"),this.effects.get("colorAverage"),this.effects.get("hueSaturation"),this.effects.get("brightnessContrast"),this.effects.get("vignette"),this.effects.get("noise")].reduce(f$,[]);s.length>0&&(this.effectPass=new lT(this.camera,...s),this.effectComposer.addPass(this.effectPass))}this.effectComposer.addPass(this.helperPass),this.effectComposer.addPass(this.helperClearPass),this.effectComposer.addPass(this.helperPassOnTop),this.effectComposer.addPass(this.smaaPass)}_initCopyPass(){if(this._savePass)return;let e=new se;this.renderer.getDrawingBufferSize(e),this._rt=new hs(e.x,e.y,{depthBuffer:!1,stencilBuffer:!1,wrapS:Ef,wrapT:Ef}),this._rt.samples=0,this._savePass=new Fx(this._rt,!1),this._savePass.renderToScreen=!1}get renderToScreen(){return this._renderToScreen}set renderToScreen(e){if(this._renderToScreen===e)return;let t=this.effectComposer;!t||(e===!0?(t.removePass(this._savePass),t.passes[t.passes.length-1].renderToScreen=!0,t.autoRenderToScreen=!0):(t.autoRenderToScreen=!1,t.passes[t.passes.length-1].renderToScreen=!1,this._savePass.renderToScreen=!1,this.postprocessingState.enabled||(this._savePass.needsDepthTexture=!0),t.addPass(this._savePass)),this._renderToScreen=e)}get texture(){return this._rt&&this._rt.texture}get renderTarget(){return this._rt}updatePostprocessing(e){let r=e,{enabled:t}=r,n=qh(r,["enabled"]),s=!1;t!==this.postprocessingState.enabled&&(s=!0);for(let i of Object.entries(n)){let o=i[1],a=this.effects.get(i[0]);if(a){a.enabled!==o.enabled&&(s=!0),a.enabled=o.enabled;for(let[l,c]of Object.entries(o))a[l]=c}}this.postprocessingState=e,s&&this._initPasses()}render(){this.effectComposer.render(this.clock.getDelta())}setScissor(e,t,n,s){e instanceof Bt?(this.effectComposer.inputBuffer.scissor.set(e.x,e.y,e.z,e.w),this.effectComposer.outputBuffer.scissor.set(e.x,e.y,e.z,e.w)):(this.effectComposer.inputBuffer.scissor.set(e,t,n,s),this.effectComposer.outputBuffer.scissor.set(e,t,n,s));let r=this.renderer.getPixelRatio();this.effectComposer.inputBuffer.scissor.multiplyScalar(r),this.effectComposer.outputBuffer.scissor.multiplyScalar(r),this.renderer.setScissor(e,t,n,s)}setScissorTest(e){this.effectComposer.inputBuffer.scissorTest=e,this.effectComposer.outputBuffer.scissorTest=e,this.renderer.setScissorTest(e)}setViewport(e,t,n,s){e instanceof Bt?(this.effectComposer.inputBuffer.viewport.copy(e),this.effectComposer.outputBuffer.viewport.copy(e)):(this.effectComposer.inputBuffer.viewport.set(e,t,n,s),this.effectComposer.outputBuffer.viewport.set(e,t,n,s))}resize(e,t,n){if(this.effectComposer.setSize(e,t,n),this._rt){let s=this.renderer.getPixelRatio();this._rt.setSize(e*s,t*s)}}dispose(){var e,t;(e=this.uvEffectPass)==null||e.dispose(),(t=this.effectPass)==null||t.dispose(),this.effectComposer.dispose()}},m$=new mr,Wpe=class extends qD{constructor(e){super(e);this._pixelRatio=this.getPixelRatio(),this.viewportWidth=1,this.viewportHeight=1,this.resolution=new se,this.pipeline=new Gpe(this),this.overrideTransmission=e==null?void 0:e.overrideTransmission,this.autoClear=!1;let t=this.setPixelRatio.bind(this),n=this.setSize.bind(this);this.setPixelRatio=s=>{this._pixelRatio=s,t(s)},this.setSize=(s,r,i=!0)=>{var o,a,l;(this.viewportWidth!==s||this.viewportHeight!==r)&&(this.viewportWidth=s,this.viewportHeight=r,n(s,r,i),(o=this.normalRenderTarget)==null||o.setSize(s*this._pixelRatio,r*this._pixelRatio),(a=this.transmissionRenderTarget)==null||a.setSize(s*this._pixelRatio/2,r*this._pixelRatio/2),(l=this.transmissionDepthTarget)==null||l.setSize(s*this._pixelRatio/2,r*this._pixelRatio/2),this.pipeline.resize(s,r,i))},this._superDispose=this.dispose,this.dispose=this._currentDispose}createTransmissionRenderTarget(){this.transmissionRenderTarget===void 0&&(this.transmissionRenderTarget=new hs(this.viewportWidth*this._pixelRatio/2,this.viewportHeight*this._pixelRatio/2,{generateMipmaps:!0,minFilter:Af,magFilter:xn,wrapS:yi,wrapT:yi,depthBuffer:!1}),this.transmissionDepthTarget=new hs(this.viewportWidth*this._pixelRatio/2,this.viewportHeight*this._pixelRatio/2,{minFilter:ns,magFilter:ns,depthBuffer:!1}))}createNormalRenderTarget(){this.normalRenderTarget===void 0&&(this.normalRenderTarget=new hs(this.viewportWidth*this._pixelRatio,this.viewportHeight*this._pixelRatio,{generateMipmaps:!1,minFilter:ns,magFilter:ns,type:Xl,depthTexture:new PS(this.viewportWidth*this._pixelRatio,this.viewportHeight*this._pixelRatio)}))}renderNormal(e,t){this.normalRenderTarget&&(this.setClearColor(0),t.layers.enable(8),t.layers.disable(0),t.layers.disable(3),this.setRenderTarget(this.normalRenderTarget),this.clear(),t instanceof _l?vC.uniforms.depthContrast.value=(t.far-t.near)/1e4:vC.uniforms.depthContrast.value=1,e.overrideMaterial=vC,this.render(e,t),this.setClearColor(e.bgColor,e.bgColor.a),this.setRenderTarget(null),e.overrideMaterial=e.wireframeState?xC:null,t.layers.enable(0),t.layers.enable(3))}renderSplineScene(e,t,n,s,r){this.setClearColor(e.bgColor,e.bgColor.a),n.penumbraSize.forEach((o,a)=>{Kn.penumbraSize.value[a]=o}),Kn.pixelRatioNode.value=this.getPixelRatio(),this.resolution.x!==0&&this.resolution.y!==0?Kn.resolution.value.set(this.resolution.x,this.resolution.y):Kn.resolution.value.set(this.viewportWidth*this._pixelRatio,this.viewportHeight*this._pixelRatio),this.overrideNormal!==void 0?(Kn.normalRenderTarget.value=this.overrideNormal,Kn.normalRenderTargetDepth.value=m$):e.needsNormal()&&(this.createNormalRenderTarget(),Kn.normalRenderTarget.value=this.normalRenderTarget.texture,Kn.normalRenderTargetDepth.value=this.normalRenderTarget.depthTexture,this.renderNormal(e,t));let i=!1;if(this.overrideTransmission!==void 0)Kn.transmissionRenderTarget.value=this.overrideTransmission,Kn.transmissionRenderTargetDepth.value=m$,this.pipeline.setTransmissionPassEnabled(!1);else{let o=e.needsTransmission();o&&(this.transmissionRenderTarget===void 0&&(i=!0),this.createTransmissionRenderTarget(),Kn.transmissionRenderTarget.value=this.transmissionRenderTarget.texture,Kn.transmissionRenderTargetDepth.value=this.transmissionDepthTarget.texture),this.pipeline.setTransmissionPassEnabled(o)}t.layers.enable(3),t.layers.enable(8),this.pipeline.sceneHelpers=s,this.pipeline.sceneHelpersOnTop=r,this.pipeline.scene=e,this.pipeline.camera=t,i&&this.pipeline.transmissionPass.updatePasses(this),this.pipeline.postprocessingState!==e.postprocessing&&this.pipeline.updatePostprocessing(e.postprocessing),this.clearAlphaOverride!==void 0&&this.setClearAlpha(this.clearAlphaOverride),e.overrideMaterial=e.wireframeState?xC:null,this.pipeline.render()}_currentDispose(){var e,t,n,s,r;this._superDispose(),this.pipeline.dispose(),(e=this.transmissionRenderTarget)==null||e.dispose(),(t=this.transmissionDepthTarget)==null||t.dispose(),(n=this.normalRenderTarget)==null||n.dispose(),(r=(s=this.normalRenderTarget)==null?void 0:s.depthTexture)==null||r.dispose()}},Hpe=class{get sharedAssets(){return this.shared}constructor(e,t={}){this.shared=new lx(e.shared,t),this.scene=new vx(e.scene,this.sharedAssets),this.scene.switchActiveCamera(this.scene.activeCamera)}reset(e,t){this.scene.clearScene(),this.sharedAssets.reset(e.shared),this.scene.resetAfterClear(e.scene,this.sharedAssets)}dispose(){this.scene.dispose(),this.shared.dispose()}gc(){this.shared.geometryCache.startGc(),this.shared.geometryCache2.startGc(),this.scene.traverseEntity(e=>{e instanceof $o&&e.markGeometryAsReachable(this.shared)}),this.shared.geometryCache.endGc(),this.shared.geometryCache2.endGc()}},jpe=class{constructor({x:e=10,y:t=10}){this._startTime=0;let n=document.getElementById("spe-perfs");n?this.element=n:(this.element=document.createElement("div"),document.body.appendChild(this.element),this.element.style.position="absolute",this.element.style.zIndex="10000",this.element.style.fontFamily="monospace",this.element.style.background="black",this.element.style.color="white",this.element.style.padding="10px",this.element.style.opacity="0.5",this.element.style.fontSize="11px",this.element.setAttribute("id","spe-perfs")),this.element.style.left=`${e}px`,this.element.style.top=`${t}px`}dispose(){var e;(e=this.element.parentElement)==null||e.removeChild(this.element)}start(){this._startTime=performance.now()}end(){let e=performance.now()-this._startTime;this.element.innerHTML=e.toFixed(3)+" ms"}};function qpe(e){let t;if(e.index)for(let n=0;n<e.index.array.length;n+=3)t=e.index.array[n],e.index.array[n]=e.index.array[n+2],e.index.array[n+2]=t}function qm(e){return e instanceof Nm?"SubdivObject":e.geometry.type==="NonParametricGeometry"?"NonParametric":"Mesh"}function Xpe(e,t){let n={};return e.traverseEntity(s=>{var l;if(!s.visible||!(s instanceof Ai)||s.type!=="Mesh"||Array.isArray(s.material)||s.states&&Object.keys(s.states).length)return;let r=s.parent;for(;r;){if(r instanceof Ai&&s.states&&Object.keys(s.states).length)return;r=r.parent}let i=s.material.uuid,o=t.shared.materials[i];if(o){if(!Ci.isMergable(o))return}else{let c=(l=t.scene.objects.get(s.uuid))==null?void 0:l.data;if(c&&"material"in c&&typeof c.material!="string"){if(!Ci.isMergable(c.material))return;i=Ci.getHash(c.material)}}n[i]||(n[i]={});let a=n[i][qm(s)];if(a){if(a.push(s),s.cloner)for(let c of s.cloner.children)a.push(c)}else if(n[i][qm(s)]=[s],s.cloner)for(let c of s.cloner.children)n[i][qm(s)].push(c)}),n}function Kpe(e){let t=0;return Object.values(e).forEach(n=>{Object.values(n).forEach(s=>{let r=s.length;r>t&&(t=r)})}),t}function Ype(e,t){let n=Xpe(t,e),s=Kpe(n),r=new Array(s),i=0,o=new Array(s),a=0,l=new Array(s),c=0,h=new Array(s),u=0;for(let[d,p]of Object.entries(n))for(let f of Object.values(p)){if(a=0,c=0,f.forEach(m=>{m instanceof Ai&&(o[a++]=m.geometry.clone(),l[c++]=m)}),c<2)continue;for(let m=0;m<c;m++)l[m].updateWorldMatrix(!0,!1),o[m].applyMatrix4(l[m].matrixWorld),l[m].matrixWorld.determinant()<0&&qpe(o[m]);let g=Bd(o.slice(0,a),!1);if(g){let m;switch(d){case"SubdivObject":{console.warn("Turning subdiv object into mesh"),m=new bi(g,l[0].material);break}default:{m=new bi(g,l[0].material);break}}m.castShadow=l[0].castShadow,m.receiveShadow=l[0].receiveShadow,t.add(m);let y=v=>{u=0;for(let b of v)b.children&&y(b.children),b instanceof Ai&&(Array.isArray(b.material)||n[b.material.uuid]&&n[b.material.uuid][qm(b)]&&n[b.material.uuid][qm(b)].length>1||(h[u++]=b));for(let b=0;b<u;b++)t.attach(h[b])};for(let v=0;v<c;v++){let b=l[v];y(b.children),r[i++]=b}}}for(let d=0;d<i;d++)r[d].removeFromParent()}var Qpe=new se;function Zpe(e){let t="The Spline Runtime only accepts .splinecode files that are generated from Spline export panel.";e.endsWith(".spline")?console.warn(t+" The .spline files are only meant to be used by the Editor."):e.endsWith(".splinecode")||console.warn(t)}var Jpe=class{constructor(e,{renderOnDemand:t=!0}={}){this._viewportMode=1,this._viewportWidth=window.innerWidth,this._viewportHeight=window.innerHeight,this._proxyObjectCache=new Map,this._lastTime=performance.now(),this.time=performance.now(),this.dt=0,this._skipRender=!1,this.renderOnDemand=!0,this.disposed=!1,this.requestRender=()=>{this._skipRender=!1},this.render=n=>{var s,r,i,o;!this._renderer||(this._rafId=requestAnimationFrame(this.render),this.time=n,this.dt=this.time-this._lastTime,this._lastTime=this.time,(s=this._perfs)==null||s.start(),!(this.renderOnDemand&&this._skipRender)&&(this._skipRender=(i=(r=this._controls)==null?void 0:r.update(this.dt))!=null?i:!0,this._eventManager&&(this._eventManager.isEnable||this._eventManager.activate(),this._eventManager.handlers.Follow.onAnimationFrameDamping(),this._eventManager.handlers.LookAt.onAnimationFrameDamping(),(this._eventManager.handlers.Start.hasVideoAction||this._eventManager.handlers.Basic.hasVideoAction||this._eventManager.handlers.Conditional.hasVideoAction)&&(this._skipRender=!1)),this._scene&&this._camera&&this._renderer.renderSplineScene(this._scene,this._camera,this._sharedAssetsManager),(o=this._perfs)==null||o.end()))},this._resize=X3(()=>{var n,s,r;!this._renderer||(this._viewportMode===1&&this._frameView&&(this._frameView.frameSize=Qpe.set(this._viewportWidth,this._viewportHeight)),this._renderer.setSize(this._viewportWidth,this._viewportHeight,!1),this._viewportMode!==1&&((n=this._frameView)==null||n.updateViewport()),this._camera&&((s=this._frameView)==null||s.updateCamera(),this._camera.cameraType==="PerspectiveCamera"&&this._viewportMode===1&&(this._camera.aspect=this._viewportWidth/this._viewportHeight),this._camera.updateProjectionMatrix()),(r=this._eventManager)==null||r.resize(),this.requestRender())},10),this.canvas=e,this.renderOnDemand=t,window.location.search.includes("perfs")&&(this._perfs=new jpe({x:10,y:10})),pie(e)}async load(e,t){Zpe(e);let n=await(await fetch(e,t)).arrayBuffer();await this.start(n)}async start(e,{interactive:t=!0}={}){var r;if(this.disposed)return;let n=await ude(e);await Promise.all([_L(n)&&$ae(),Kle(n)&&Rae(),n.scene.environment.usePhysics&&Dre(),fL(n)&&Fle()].filter(Boolean)),this._eventManager&&this._eventManager.deactivate(),this._controls&&this._controls.dispose(),(r=this._scene)==null||r.dispose();let s=new Hpe(n);if(this._scene=s.scene,this._sharedAssetsManager=s.sharedAssets,this._camera=this._scene.activeCamera,window.location.search.includes("merge-geometries")){let i=performance.now();Ype(n,s.scene);let o=performance.now();console.log("Merged geometries in ",o-i," ms")}if(_L(n)&&this._scene.traverse(i=>{wc(i)&&i.recomputeBoolean()}),this._sharedAssetsManager.setRequestRender(()=>{var i;this.requestRender(),(i=this._scene)==null||i.traverse(o=>{o instanceof fx&&o.pendingMediaLoad&&o.update()})}),fL(n)&&zhe(n)){let i=Object.keys(n.shared.fonts).map(o=>this._sharedAssetsManager.getFont(o)).map(o=>o.loadingPromise);await Promise.all(i)}if(this._scene.rewriteEventsBeforeGoToPlayMode(),DF(n.scene,this._scene,this._sharedAssetsManager),this._renderer||(this._renderer=new Wpe({canvas:this.canvas,antialias:!1,alpha:!0,stencil:!1,depth:!1,powerPreference:"high-performance"}),this._renderer.setPixelRatio(window.devicePixelRatio),this._renderer.pipeline.addEventListener("smaaloaded",this.requestRender),this._renderer.shadowMap.enabled=!0,this._renderer.shadowMap.type=n.scene.environment.ambientLight.softShadows?Vw:vk,Lce(n.scene.environment.ambientLight.softShadowQuality)),this._frameView)this._frameView.setCamera(this._camera);else{let i=Object.values(n.frames)[0];if(i.preset==="fullscreen"){this._viewportMode=1;let{width:o,height:a}=window.getComputedStyle(this.canvas);this.canvas.parentElement&&(o==="300px"||o==="auto")?(this._viewportWidth=this.canvas.parentElement.clientWidth||300,this.canvas.style.width="100%"):this._viewportWidth=this.canvas.clientWidth,this.canvas.parentElement&&(a==="150px"||a==="auto")?(this._viewportHeight=this.canvas.parentElement.clientHeight||150,this.canvas.style.height="100%"):this._viewportHeight=this.canvas.clientHeight}else this._viewportMode=2,this._viewportWidth=i.size[0],this._viewportHeight=i.size[1],this.canvas.style.width=`${this._viewportWidth}px`,this.canvas.style.height=`${this._viewportHeight}px`;this._renderer.setSize(this._viewportWidth,this._viewportHeight,!1),this._frameView=new dde(this._renderer,this._camera,new se(this._viewportWidth,this._viewportHeight),new se(window.innerWidth,window.innerHeight))}if(t&&(this._scene.updateMatrixWorld(!0),this._controls=new Uhe(n,this._scene,this._renderer,this.requestRender,this._sharedAssetsManager,!0),this._eventManager=new hde(this._renderer,this._scene,this._camera,n.scene.publish.stopRaycast,n.scene.publish.preventScroll,n.scene.publish.hideCursor,this._sharedAssetsManager,this.requestRender,this._controls,!0)),this._resize(),!this._resizeObserver&&this.canvas.parentElement){let i=!0;this._resizeObserver=new ResizeObserver(()=>{if(i){i=!1;return}this._viewportWidth=this.canvas.clientWidth,this._viewportHeight=this.canvas.clientHeight,this._resize()}),this._resizeObserver.observe(this.canvas.parentElement)}this._rafId===void 0?this.render(performance.now()):this.requestRender()}findObjectById(e){var n;let t=(n=this._scene)==null?void 0:n.getObjectByProperty("uuid",e);return this._createProxyObject(t)}findObjectByName(e){var n;let t=(n=this._scene)==null?void 0:n.getObjectByName(e);return this._createProxyObject(t)}getSplineEvents(){var e;return((e=this._eventManager)==null?void 0:e.handlers.Spline).splineEvents}emitEvent(e,t){var n;(n=this.findObjectById(t)||this.findObjectByName(t))==null||n.emitEvent(e)}emitEventReverse(e,t){var n;(n=this.findObjectById(t)||this.findObjectByName(t))==null||n.emitEventReverse(e)}addEventListener(e,t){this.canvas.addEventListener(e,t)}removeEventListener(e,t){this.canvas.removeEventListener(e,t)}setZoom(e){var t,n;((t=this._controls)==null?void 0:t.orbitControls)instanceof JF&&((n=this._controls)==null||n.orbitControls.zoomOut(e))}setSize(e,t){this._viewportWidth=e,this._viewportHeight=t,this._viewportMode=2,this._resize()}dispose(){var e,t,n,s,r,i;this.disposed=!0,(e=this._eventManager)==null||e.deactivate(),(t=this._scene)==null||t.dispose(),(n=this._sharedAssetsManager)==null||n.dispose(),this._rafId&&cancelAnimationFrame(this._rafId),this._proxyObjectCache.forEach(o=>{VM.unsubscribe(o)}),(s=this._renderer)==null||s.dispose(),(r=this._sharedAssetsManager)==null||r.dispose(),this._resizeObserver&&this._resizeObserver.disconnect(),this.canvas.style.width="",this.canvas.style.height="",(i=this._controls)==null||i.dispose(),fie(this.canvas)}_createProxyObject(e){if(e==null)return;if(this._proxyObjectCache.has(e.uuid))return this._proxyObjectCache.get(e.uuid);let t={name:e.name,uuid:e.uuid,visible:e.visible,intensity:e.intensity,position:e.position,rotation:e.rotation,scale:e.scale,emitEvent(s){e.dispatchEvent({type:"userEvent",eventName:s})},emitEventReverse(s){e.dispatchEvent({type:"userEvent",eventName:s,reverse:!0})}},n=VM(t,(s,r)=>{var i;typeof e[s]!="object"&&((i=Object.getOwnPropertyDescriptor(e,s))==null?void 0:i.writable)&&(e[s]=r),this.requestRender(),e.updateMatrix()});return this._proxyObjectCache.set(e.uuid,n),n}},efe=Object.defineProperty,zx=Object.getOwnPropertySymbols,g$=Object.prototype.hasOwnProperty,y$=Object.prototype.propertyIsEnumerable,v$=(e,t,n)=>t in e?efe(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,x$=(e,t)=>{for(var n in t||(t={}))g$.call(t,n)&&v$(e,n,t[n]);if(zx)for(var n of zx(t))y$.call(t,n)&&v$(e,n,t[n]);return e},tfe=(e,t)=>{var n={};for(var s in e)g$.call(e,s)&&t.indexOf(s)<0&&(n[s]=e[s]);if(e!=null&&zx)for(var s of zx(e))t.indexOf(s)<0&&y$.call(e,s)&&(n[s]=e[s]);return n};function nfe(e){return function(t){e.forEach(function(n){typeof n=="function"?n(t):n!=null&&(n.current=t)})}}var b$={exports:{}},Ux={};/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var sfe=ck,rfe=Symbol.for("react.element"),ife=Symbol.for("react.fragment"),ofe=Object.prototype.hasOwnProperty,afe=sfe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,lfe={key:!0,ref:!0,__self:!0,__source:!0};function w$(e,t,n){var s,r={},i=null,o=null;n!==void 0&&(i=""+n),t.key!==void 0&&(i=""+t.key),t.ref!==void 0&&(o=t.ref);for(s in t)ofe.call(t,s)&&!lfe.hasOwnProperty(s)&&(r[s]=t[s]);if(e&&e.defaultProps)for(s in t=e.defaultProps,t)r[s]===void 0&&(r[s]=t[s]);return{$$typeof:rfe,type:e,key:i,ref:o,props:r,_owner:afe.current}}Ux.Fragment=ife;Ux.jsx=w$;Ux.jsxs=w$;b$.exports=Ux;const cfe=b$.exports.jsx,ufe=he.exports.forwardRef((e,t)=>{var n=e,{scene:s,style:r,onMouseDown:i,onMouseUp:o,onMouseHover:a,onKeyDown:l,onKeyUp:c,onStart:h,onLookAt:u,onFollow:d,onWheel:p,onLoad:f,renderOnDemand:g=!0}=n,m=tfe(n,["scene","style","onMouseDown","onMouseUp","onMouseHover","onKeyDown","onKeyUp","onStart","onLookAt","onFollow","onWheel","onLoad","renderOnDemand"]);const y=he.exports.useRef(null),[v,b]=he.exports.useState(!0);return he.exports.useEffect(()=>{b(!0);let x;const w=[{name:"mouseDown",cb:i},{name:"mouseUp",cb:o},{name:"mouseHover",cb:a},{name:"keyDown",cb:l},{name:"keyUp",cb:c},{name:"start",cb:h},{name:"lookAt",cb:u},{name:"follow",cb:d},{name:"scroll",cb:p}];if(y.current){x=new Jpe(y.current,{renderOnDemand:g});async function S(){await x.load(s);for(let C of w)C.cb&&x.addEventListener(C.name,C.cb);b(!1),f==null||f(x)}S()}return()=>{for(let S of w)S.cb&&x.removeEventListener(S.name,S.cb);x.dispose()}},[s]),cfe("canvas",x$({ref:nfe([t,y]),style:x$({display:v?"none":"block"},r)},m))});var hfe="/assets/ImageClassifier.89da1eaa.png";function S$(){he.exports.useContext(Ve);const{Pcolor:e}=he.exports.useContext(Ve),{SecondaryColor:t}=he.exports.useContext(Ve);return ne("div",{style:{color:e,background:"none"},children:[k("h2",{className:"Cardhead",style:{color:e,background:"none"},children:"Image Classifier"}),ne("div",{className:"ProjectCard-card",style:{color:e,background:t},children:[k("div",{className:"ProjectCard-card-img",children:k("img",{src:hfe,alt:""})}),ne("div",{className:"ProjectCard-card-info",style:{color:e,background:"none"},children:[k("p",{className:"ProjectCard-text-title",children:"Image Classifier "}),k("p",{className:"ProjectCard-text-body",children:"This is an Image classifying model which classifies objects based on trained data and returns a fair classification with a confidence percentage as a result."})]}),ne("div",{className:"ProjectCard-card-footer",children:[k("span",{className:"ProjectCard-text-title",children:"Model by ML5.js"}),k("a",{href:"http://vinayakporwal.github.io/machineLearning",style:{background:"none"},children:ne("div",{className:"ProjectCard-card-button",children:["Live Demo",k(pk,{className:"flex-shrink-0 h-5 w-5 text-gray-400","aria-hidden":"true",style:{background:"none",alignItems:"center"}})]})})]})]})]})}var dfe="/assets/Chathook1.6ee5e0d8.png",pfe="/assets/MovieApp.e529cf3c.png",ffe="/assets/SnakeGame.b73d9fc3.png",mfe="/assets/weatherApp.e0b5a0f6.png",gfe="/assets/PhpChathook.df742cb3.png",yfe="/assets/Portfolio.89d4ec31.png",vfe="/assets/youtool.2961e55c.png",xfe="/assets/fookreywebs.e4aa483e.png";function bfe(){he.exports.useContext(Ve);const{Pcolor:e}=he.exports.useContext(Ve),{SecondaryColor:t}=he.exports.useContext(Ve);return k("div",{style:{color:e,background:"none",margin:"-15vh 0 0 0"},children:[{name:"Movie review App",desc:"",tab:"3",auhtor:"",link:"https://fluxmovies.vercel.app",id:"MovieReviewApp",img:pfe},{name:"Youtube Clone",desc:"Youtube Clone",tab:"3",auhtor:"",link:"https://you-tool.vercel.app",img:vfe,id:"YoutubeClone"},{name:"PortFolio",desc:"",tab:"3",auhtor:"",link:"https://vinayakporwal.netlify.app",img:yfe,id:"Portfolio"},{name:"Firebase Chat Web App",tab:"3",auhtor:"",link:"https://chathook-f2855.web.app",img:dfe,id:"ChatWebApp",desc:""},{name:"Weather App",desc:"",tab:"3",link:"https://vinayakporwal.github.io/WeatherApp/",auhtor:"",img:mfe,id:"WeatherApp"},{name:"Snake Game",desc:"",tab:"3",auhtor:"",link:"https://vinayakporwal.gihtub.io/SnakeGame",img:ffe,id:"SnakeGame"},{name:"PHP Chat Web App",desc:"",tab:"3",auhtor:"",link:"http://chathook.epizy.com",img:gfe,id:"PhpChatApp"},{name:"PHP Social Web App",desc:"",tab:"3",auhtor:"",link:"",img:xfe,id:"PhpSocialApp"}].map((s,r)=>ne("div",{style:{background:"none",padding:"20px 0 0 0"},id:s.id,children:[k("br",{}),k("br",{}),k("h2",{className:"Cardhead",style:{color:e,background:"none"},children:s.name}),ne("div",{className:"ProjectCard-card",style:{color:e,background:t},children:[k("div",{className:"ProjectCard-card-img",children:k("img",{src:s.img,alt:""})}),ne("div",{className:"ProjectCard-card-info",style:{color:e,background:"none"},children:[ne("p",{className:"ProjectCard-text-title",children:[s.name," "]}),k("p",{className:"ProjectCard-text-body",children:"This is an Image classifying model which classifies objects based on trained data and returns a fair classification with a confidence percentage as a result."})]}),ne("div",{className:"ProjectCard-card-footer",children:[k("span",{className:"ProjectCard-text-title",children:"Model by ML5.js"}),k("a",{href:"http://vinayakporwal.github.io/machineLearning",style:{background:"none"},children:ne("div",{className:"ProjectCard-card-button",children:["Live Demo",k(pk,{className:"flex-shrink-0 h-5 w-5 text-gray-400","aria-hidden":"true",style:{background:"none",alignItems:"center"}})]})})]})]},r)]}))})}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wfe=1e-7,Sfe=1e-4;class _${constructor(t,n){this.backend=t,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,n){this.dataIdsCount++,this.data.set(t,n)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class dT{refCount(t){return ii("refCount")}incRef(t){return ii("incRef")}timerAvailable(){return!0}time(t){return ii("time")}read(t){return ii("read")}readSync(t){return ii("readSync")}readToGPU(t,n){return ii("readToGPU")}numDataIds(){return ii("numDataIds")}disposeData(t,n){return ii("disposeData")}write(t,n,s){return ii("write")}move(t,n,s,r,i){return ii("move")}createTensorFromGPUData(t,n,s){return ii("createTensorFromGPUData")}memory(){return ii("memory")}floatPrecision(){return ii("floatPrecision")}epsilon(){return this.floatPrecision()===32?wfe:Sfe}dispose(){return ii("dispose")}}function ii(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _fe(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,gp(e,t,n)}function Zu(e,t,n){return Math.max(e,Math.min(t,n))}function pT(e){return e%2==0?e:e+1}function gp(e,t,n){const s=e[t];e[t]=e[n],e[n]=s}function Cfe(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function W(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function fT(e,t,n=""){W(dn(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function C$(e){W(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Ae(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function dn(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function yp(e){return e%1==0}function mT(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function vp(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function T$(e,t=r=>0,n,s){return new Promise((r,i)=>{let o=0;const a=()=>{if(e()){r();return}o++;const l=t(o);if(n!=null&&o>=n){i();return}s!=null?s(a,l):setTimeout(a,l)};a()})}function E$(e,t){let n=1,s=-1;for(let i=0;i<e.length;++i)if(e[i]>=0)n*=e[i];else if(e[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(e[i]<0)throw Error(`Shapes can not be < 0. Found ${e[i]} at dim ${i}`);if(s===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const r=e.slice();return r[s]=t/n,r}function Ht(e,t){const n=t.length;return e=e==null?t.map((s,r)=>r):[].concat(e),W(e.every(s=>s>=-n&&s<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),W(e.every(s=>yp(s)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(s=>s<0?n+s:s)}function kc(e,t){const n=[],s=[],r=t!=null&&Array.isArray(t)&&t.length===0,i=t==null||r?null:Ht(t,e).sort();let o=0;for(let a=0;a<e.length;++a){if(i!=null){if(i[o]===a&&e[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${e[a]}' is not 1`);(i[o]==null||i[o]>a)&&e[a]===1&&(n.push(e[a]),s.push(a)),i[o]<=a&&o++}e[a]!==1&&(n.push(e[a]),s.push(a))}return{newShape:n,keptDims:s}}function Ys(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else throw new Error(`Unknown data type ${e}`);return n}function gs(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function Tfe(e,t){for(let n=0;n<e.length;n++){const s=e[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function Efe(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function A$(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function Vx(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function Afe(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function Xm(e){return typeof e=="string"||e instanceof String}function Ife(e){return typeof e=="boolean"}function gT(e){return typeof e=="number"}function Km(e){return Array.isArray(e)?Km(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":gT(e)?"float32":Xm(e)?"string":Ife(e)?"bool":"float32"}function yT(e){return!!(e&&e.constructor&&e.call&&e.apply)}function vT(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function gt(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let s=t-3;s>=0;--s)n[s]=n[s+1]*e[s+1];return n}function I$(e,t,n,s=!1){const r=new Array;if(t.length===1){const i=t[0]*(s?2:1);for(let o=0;o<i;o++)r[o]=n[e+o]}else{const i=t[0],o=t.slice(1),a=o.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<i;l++)r[l]=I$(e+l*a,o,n,s)}return r}function Go(e,t,n=!1){if(e.length===0)return t[0];const s=e.reduce((r,i)=>r*i)*(n?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return I$(0,e,t,n)}function Nfe(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function xT(e,t){const n=ar(e,t);for(let s=0;s<n.length;s++)n[s]=1;return n}function ar(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function N$(e,t){const n=e.reduce((s,r)=>s*r,1);if(t==null||t==="float32")return Go(e,new Float32Array(n));if(t==="int32")return Go(e,new Int32Array(n));if(t==="bool")return Go(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Il(e){e.forEach(t=>{W(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function Va(e,t,n){if(t===0)return 0;if(t===1)return e[0];let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=n[r]*e[r];return s}function xp(e,t,n){if(t===0)return[];if(t===1)return[e];const s=new Array(t);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(e/n[r]),e-=s[r]*n[r];return s[s.length-1]=e,s}function bT(e){return e&&e.then&&typeof e.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k$="tfjsflags";class kfe{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Dfe,this.populateURLFlags()}setPlatform(t,n){this.platform!=null&&(xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=n}registerFlag(t,n,s){if(this.flagRegistry[t]={evaluationFn:n,setHook:s},this.urlFlags[t]!=null){const r=this.urlFlags[t];xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const n=this.evaluateFlag(t);if(bT(n))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=n,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=n,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(n)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;const t=this.getQueryParams(this.global.location.search);k$ in t&&t[k$].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=Pfe(r,i)})}}function Dfe(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...s)=>(Mfe(t,s[0],s[1]),s.join("="))),t}function Mfe(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function Pfe(e,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}function xe(){return D$}let D$=null;function Ofe(e){D$=e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let wT;function M$(){if(wT==null){let e;if(typeof window!="undefined")e=window;else if(typeof global!="undefined")e=global;else if(typeof process!="undefined")e=process;else if(typeof self!="undefined")e=self;else throw new Error("Could not find a global object");wT=e}return wT}function Rfe(){const e=M$();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function ST(e,t){const n=Rfe();if(n.has(e))return n.get(e);{const s=t();return n.set(e,s),n.get(e)}}const Gx="Abs",Ym="Acos",Qm="Acosh",bp="Add",_T="AddN",CT="All",TT="Any",Wx="ArgMax",Hx="ArgMin",Zm="Asin",Jm="Asinh",eg="Atan",tg="Atanh",ng="Atan2",jx="AvgPool",ET="AvgPoolGrad",qx="AvgPool3D",AT="AvgPool3DGrad",Xx="BatchMatMul",Kx="BatchToSpaceND",IT="Bincount",Lfe="BroadcastTo",P$="BroadcastArgs",sg="Cast",rg="Ceil",ig="ClipByValue",NT="Complex",Yx="ComplexAbs",Qx="Concat",Zx="Conv2D",kT="Conv2DBackpropFilter",Jx="Conv2DBackpropInput",eb="Conv3D",DT="Conv3DBackpropFilterV2",MT="Conv3DBackpropInputV2",og="Cos",ag="Cosh",PT="Cumprod",tb="Cumsum",OT="CropAndResize",RT="DenseBincount",LT="DepthToSpace",nb="DepthwiseConv2dNative",FT="DepthwiseConv2dNativeBackpropFilter",$T="DepthwiseConv2dNativeBackpropInput",O$="Diag",sb="Dilation2D",BT="Dilation2DBackpropInput",zT="Dilation2DBackpropFilter",lg="RealDiv",R$="Einsum",cg="Elu",UT="EluGrad",ug="Erf",rb="Equal",hg="Exp",ib="ExpandDims",dg="Expm1",VT="FFT",GT="Fill",WT="FlipLeftRight",pg="Floor",fg="FloorDiv",ob="FusedBatchNorm",ab="GatherV2",L$="GatherNd",lb="Greater",mg="GreaterEqual",gg="Identity",HT="IFFT",jT="Imag",yg="IsFinite",vg="IsInf",xg="IsNan",cb="LeakyRelu",ub="Less",hb="LessEqual",F$="LinSpace",bg="Log",wg="Log1p",db="LogicalAnd",pb="LogicalNot",fb="LogicalOr",Ffe="LogSoftmax",mb="LRN",qT="LRNGrad",gb="Max",Sg="Maximum",yb="MaxPool",XT="MaxPoolGrad",vb="MaxPool3D",KT="MaxPool3DGrad",$$="MaxPoolWithArgmax",xb="Mean",bb="Min",_g="Minimum",wb="MirrorPad",Cg="Mod",B$="Multinomial",Tg="Multiply",Sb="Neg",_b="NotEqual",YT="NonMaxSuppressionV3",QT="NonMaxSuppressionV4",ZT="NonMaxSuppressionV5",Cb="OnesLike",Tb="OneHot",Eb="Pack",Ab="PadV2",Eg="Pow",Ib="Prelu",Nb="Prod",z$="RaggedGather",U$="RaggedRange",V$="RaggedTensorToTensor",JT="Range",eE="Real",Ag="Reciprocal",Ig="Relu",kb="Reshape",Db="ResizeNearestNeighbor",tE="ResizeNearestNeighborGrad",Mb="ResizeBilinear",nE="ResizeBilinearGrad",Ng="Relu6",Pb="Reverse",kg="Round",Dg="Rsqrt",G$="ScatterNd",W$="SearchSorted",Ob="Select",Mg="Selu",Rb="Slice",Pg="Sin",Og="Sinh",Rg="Sign",Lg="Sigmoid",Fg="Softplus",$g="Sqrt",Lb="Sum",Fb="SpaceToBatchND",$b="SplitV",Bb="Softmax",H$="SparseFillEmptyRows",j$="SparseReshape",q$="SparseSegmentMean",X$="SparseSegmentSum",K$="SparseToDense",Bg="SquaredDifference",sE="Square",rE="StridedSlice",Y$="StringNGrams",Q$="StringSplit",Z$="StringToHashBucketFast",zg="Sub",Ug="Tan",Vg="Tanh",Gg="Tile",iE="TopK",oE="Transform",wp="Transpose",aE="Unique",zb="Unpack",Ub="UnsortedSegmentSum",Vb="ZerosLike",Wg="Step",$fe="FromPixels",lE="RotateWithOffset",Gb="_FusedMatMul",Wb="FusedConv2D",J$="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mi(...e){xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(...e)}function Bfe(...e){xe().getBool("IS_TEST")||xe().getBool("PROD")||console.log(...e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hb=ST("kernelRegistry",()=>new Map),cE=ST("gradRegistry",()=>new Map);function eB(e,t){const n=rB(e,t);return Hb.get(n)}function tB(e){return cE.get(e)}function nB(e){const t=Hb.entries(),n=[];for(;;){const{done:s,value:r}=t.next();if(s)break;const[i,o]=r,[a]=i.split("_");a===e&&n.push(o)}return n}function sB(e){const{kernelName:t,backendName:n}=e,s=rB(t,n);Hb.has(s)&&Mi(`The kernel '${t}' for backend '${n}' is already registered`),Hb.set(s,e)}function zfe(e){const{kernelName:t}=e;cE.has(t)&&xe().getBool("DEBUG")&&Mi(`Overriding the gradient for '${t}'`),cE.set(t,e)}function rB(e,t){return`${t}_${e}`}var uE=$n,ao=null;try{ao=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function $n(e,t,n){this.low=e|0,this.high=t|0,this.unsigned=!!n}$n.prototype.__isLong__;Object.defineProperty($n.prototype,"__isLong__",{value:!0});function oi(e){return(e&&e.__isLong__)===!0}$n.isLong=oi;var iB={},oB={};function Ju(e,t){var n,s,r;return t?(e>>>=0,(r=0<=e&&e<256)&&(s=oB[e],s)?s:(n=Bn(e,(e|0)<0?-1:0,!0),r&&(oB[e]=n),n)):(e|=0,(r=-128<=e&&e<128)&&(s=iB[e],s)?s:(n=Bn(e,e<0?-1:0,!1),r&&(iB[e]=n),n))}$n.fromInt=Ju;function lo(e,t){if(isNaN(e))return t?eh:co;if(t){if(e<0)return eh;if(e>=lB)return pB}else{if(e<=-cB)return ai;if(e+1>=cB)return dB}return e<0?lo(-e,t).neg():Bn(e%Sp|0,e/Sp|0,t)}$n.fromNumber=lo;function Bn(e,t,n){return new $n(e,t,n)}$n.fromBits=Bn;var jb=Math.pow;function hE(e,t,n){if(e.length===0)throw Error("empty string");if(e==="NaN"||e==="Infinity"||e==="+Infinity"||e==="-Infinity")return co;if(typeof t=="number"?(n=t,t=!1):t=!!t,n=n||10,n<2||36<n)throw RangeError("radix");var s;if((s=e.indexOf("-"))>0)throw Error("interior hyphen");if(s===0)return hE(e.substring(1),t,n).neg();for(var r=lo(jb(n,8)),i=co,o=0;o<e.length;o+=8){var a=Math.min(8,e.length-o),l=parseInt(e.substring(o,o+a),n);if(a<8){var c=lo(jb(n,a));i=i.mul(c).add(lo(l))}else i=i.mul(r),i=i.add(lo(l))}return i.unsigned=t,i}$n.fromString=hE;function Wo(e,t){return typeof e=="number"?lo(e,t):typeof e=="string"?hE(e,t):Bn(e.low,e.high,typeof t=="boolean"?t:e.unsigned)}$n.fromValue=Wo;var aB=1<<16,Ufe=1<<24,Sp=aB*aB,lB=Sp*Sp,cB=lB/2,uB=Ju(Ufe),co=Ju(0);$n.ZERO=co;var eh=Ju(0,!0);$n.UZERO=eh;var _p=Ju(1);$n.ONE=_p;var hB=Ju(1,!0);$n.UONE=hB;var dE=Ju(-1);$n.NEG_ONE=dE;var dB=Bn(4294967295|0,2147483647|0,!1);$n.MAX_VALUE=dB;var pB=Bn(4294967295|0,4294967295|0,!0);$n.MAX_UNSIGNED_VALUE=pB;var ai=Bn(0,2147483648|0,!1);$n.MIN_VALUE=ai;var Qe=$n.prototype;Qe.toInt=function(){return this.unsigned?this.low>>>0:this.low};Qe.toNumber=function(){return this.unsigned?(this.high>>>0)*Sp+(this.low>>>0):this.high*Sp+(this.low>>>0)};Qe.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(ai)){var n=lo(t),s=this.div(n),r=s.mul(n).sub(this);return s.toString(t)+r.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var i=lo(jb(t,6),this.unsigned),o=this,a="";;){var l=o.div(i),c=o.sub(l.mul(i)).toInt()>>>0,h=c.toString(t);if(o=l,o.isZero())return h+a;for(;h.length<6;)h="0"+h;a=""+h+a}};Qe.getHighBits=function(){return this.high};Qe.getHighBitsUnsigned=function(){return this.high>>>0};Qe.getLowBits=function(){return this.low};Qe.getLowBitsUnsigned=function(){return this.low>>>0};Qe.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ai)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,n=31;n>0&&(t&1<<n)==0;n--);return this.high!=0?n+33:n+1};Qe.isZero=function(){return this.high===0&&this.low===0};Qe.eqz=Qe.isZero;Qe.isNegative=function(){return!this.unsigned&&this.high<0};Qe.isPositive=function(){return this.unsigned||this.high>=0};Qe.isOdd=function(){return(this.low&1)==1};Qe.isEven=function(){return(this.low&1)==0};Qe.equals=function(t){return oi(t)||(t=Wo(t)),this.unsigned!==t.unsigned&&this.high>>>31==1&&t.high>>>31==1?!1:this.high===t.high&&this.low===t.low};Qe.eq=Qe.equals;Qe.notEquals=function(t){return!this.eq(t)};Qe.neq=Qe.notEquals;Qe.ne=Qe.notEquals;Qe.lessThan=function(t){return this.comp(t)<0};Qe.lt=Qe.lessThan;Qe.lessThanOrEqual=function(t){return this.comp(t)<=0};Qe.lte=Qe.lessThanOrEqual;Qe.le=Qe.lessThanOrEqual;Qe.greaterThan=function(t){return this.comp(t)>0};Qe.gt=Qe.greaterThan;Qe.greaterThanOrEqual=function(t){return this.comp(t)>=0};Qe.gte=Qe.greaterThanOrEqual;Qe.ge=Qe.greaterThanOrEqual;Qe.compare=function(t){if(oi(t)||(t=Wo(t)),this.eq(t))return 0;var n=this.isNegative(),s=t.isNegative();return n&&!s?-1:!n&&s?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};Qe.comp=Qe.compare;Qe.negate=function(){return!this.unsigned&&this.eq(ai)?ai:this.not().add(_p)};Qe.neg=Qe.negate;Qe.add=function(t){oi(t)||(t=Wo(t));var n=this.high>>>16,s=this.high&65535,r=this.low>>>16,i=this.low&65535,o=t.high>>>16,a=t.high&65535,l=t.low>>>16,c=t.low&65535,h=0,u=0,d=0,p=0;return p+=i+c,d+=p>>>16,p&=65535,d+=r+l,u+=d>>>16,d&=65535,u+=s+a,h+=u>>>16,u&=65535,h+=n+o,h&=65535,Bn(d<<16|p,h<<16|u,this.unsigned)};Qe.subtract=function(t){return oi(t)||(t=Wo(t)),this.add(t.neg())};Qe.sub=Qe.subtract;Qe.multiply=function(t){if(this.isZero())return co;if(oi(t)||(t=Wo(t)),ao){var n=ao.mul(this.low,this.high,t.low,t.high);return Bn(n,ao.get_high(),this.unsigned)}if(t.isZero())return co;if(this.eq(ai))return t.isOdd()?ai:co;if(t.eq(ai))return this.isOdd()?ai:co;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(uB)&&t.lt(uB))return lo(this.toNumber()*t.toNumber(),this.unsigned);var s=this.high>>>16,r=this.high&65535,i=this.low>>>16,o=this.low&65535,a=t.high>>>16,l=t.high&65535,c=t.low>>>16,h=t.low&65535,u=0,d=0,p=0,f=0;return f+=o*h,p+=f>>>16,f&=65535,p+=i*h,d+=p>>>16,p&=65535,p+=o*c,d+=p>>>16,p&=65535,d+=r*h,u+=d>>>16,d&=65535,d+=i*c,u+=d>>>16,d&=65535,d+=o*l,u+=d>>>16,d&=65535,u+=s*h+r*c+i*l+o*a,u&=65535,Bn(p<<16|f,u<<16|d,this.unsigned)};Qe.mul=Qe.multiply;Qe.divide=function(t){if(oi(t)||(t=Wo(t)),t.isZero())throw Error("division by zero");if(ao){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var n=(this.unsigned?ao.div_u:ao.div_s)(this.low,this.high,t.low,t.high);return Bn(n,ao.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?eh:co;var s,r,i;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return eh;if(t.gt(this.shru(1)))return hB;i=eh}else{if(this.eq(ai)){if(t.eq(_p)||t.eq(dE))return ai;if(t.eq(ai))return _p;var o=this.shr(1);return s=o.div(t).shl(1),s.eq(co)?t.isNegative()?_p:dE:(r=this.sub(t.mul(s)),i=s.add(r.div(t)),i)}else if(t.eq(ai))return this.unsigned?eh:co;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();i=co}for(r=this;r.gte(t);){s=Math.max(1,Math.floor(r.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(s)/Math.LN2),l=a<=48?1:jb(2,a-48),c=lo(s),h=c.mul(t);h.isNegative()||h.gt(r);)s-=l,c=lo(s,this.unsigned),h=c.mul(t);c.isZero()&&(c=_p),i=i.add(c),r=r.sub(h)}return i};Qe.div=Qe.divide;Qe.modulo=function(t){if(oi(t)||(t=Wo(t)),ao){var n=(this.unsigned?ao.rem_u:ao.rem_s)(this.low,this.high,t.low,t.high);return Bn(n,ao.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};Qe.mod=Qe.modulo;Qe.rem=Qe.modulo;Qe.not=function(){return Bn(~this.low,~this.high,this.unsigned)};Qe.and=function(t){return oi(t)||(t=Wo(t)),Bn(this.low&t.low,this.high&t.high,this.unsigned)};Qe.or=function(t){return oi(t)||(t=Wo(t)),Bn(this.low|t.low,this.high|t.high,this.unsigned)};Qe.xor=function(t){return oi(t)||(t=Wo(t)),Bn(this.low^t.low,this.high^t.high,this.unsigned)};Qe.shiftLeft=function(t){return oi(t)&&(t=t.toInt()),(t&=63)==0?this:t<32?Bn(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):Bn(0,this.low<<t-32,this.unsigned)};Qe.shl=Qe.shiftLeft;Qe.shiftRight=function(t){return oi(t)&&(t=t.toInt()),(t&=63)==0?this:t<32?Bn(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):Bn(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};Qe.shr=Qe.shiftRight;Qe.shiftRightUnsigned=function(t){if(oi(t)&&(t=t.toInt()),t&=63,t===0)return this;var n=this.high;if(t<32){var s=this.low;return Bn(s>>>t|n<<32-t,n>>>t,this.unsigned)}else return t===32?Bn(n,0,this.unsigned):Bn(n>>>t-32,0,this.unsigned)};Qe.shru=Qe.shiftRightUnsigned;Qe.shr_u=Qe.shiftRightUnsigned;Qe.toSigned=function(){return this.unsigned?Bn(this.low,this.high,!1):this};Qe.toUnsigned=function(){return this.unsigned?this:Bn(this.low,this.high,!0)};Qe.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};Qe.toBytesLE=function(){var t=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};Qe.toBytesBE=function(){var t=this.high,n=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};$n.fromBytes=function(t,n,s){return s?$n.fromBytesLE(t,n):$n.fromBytesBE(t,n)};$n.fromBytesLE=function(t,n){return new $n(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,n)};$n.fromBytesBE=function(t,n){return new $n(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],n)};var Vfe=Object.freeze(Xj({__proto__:null,[Symbol.toStringTag]:"Module",default:uE},[uE]));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const th=uE||Vfe;function qb(e){return th.fromString(e,!0,16)}const fB=qb("c3a5c85c97cb3127"),nh=qb("b492b66fbe98f273"),wr=qb("9ae16a3b2f90404f");function pE(e){return e.xor(e.shru(47))}function mB(e,t,n){const s=e.slice(t,t+n);return th.fromBytes(Array.from(s),!0,!0)}function Nn(e,t){return mB(e,t,8)}function gB(e,t){return mB(e,t,4)}function Ls(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Dc(e,t,n=qb("9ddfea08eb382d69")){let s=e.xor(t).mul(n);s=s.xor(s.shru(47));let r=t.xor(s).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function Gfe(e,t,n,s,r,i){r=r.add(e),i=Ls(i.add(r).add(s),21);const o=r;return r=r.add(t),r=r.add(n),i=i.add(Ls(r,44)),[r.add(s),i.add(o)]}function Xb(e,t,n,s){return Gfe(Nn(e,t),Nn(e,t+8),Nn(e,t+16),Nn(e,t+24),n,s)}function Wfe(e,t=e.length){if(t>=8){const n=wr.add(t*2),s=Nn(e,0).add(wr),r=Nn(e,t-8),i=Ls(r,37).mul(n).add(s),o=Ls(s,25).add(r).mul(n);return Dc(i,o,n)}if(t>=4){const n=wr.add(t*2),s=gB(e,0);return Dc(s.shl(3).add(t),gB(e,t-4),n)}if(t>0){const n=e[0],s=e[t>>1],r=e[t-1],i=n+(s<<8),o=t+(r<<2);return pE(wr.mul(i).xor(fB.mul(o))).mul(wr)}return wr}function Hfe(e,t=e.length){const n=wr.add(t*2),s=Nn(e,0).mul(nh),r=Nn(e,8),i=Nn(e,t-8).mul(n),o=Nn(e,t-16).mul(wr);return Dc(Ls(s.add(r),43).add(Ls(i,30)).add(o),s.add(Ls(r.add(wr),18)).add(i),n)}function jfe(e,t=e.length){const n=wr.add(t*2),s=Nn(e,0).mul(wr),r=Nn(e,8),i=Nn(e,t-8).mul(n),o=Nn(e,t-16).mul(wr),a=Ls(s.add(r),43).add(Ls(i,30)).add(o),l=Dc(a,s.add(Ls(r.add(wr),18)).add(i),n),c=Nn(e,16).mul(n),h=Nn(e,24),u=a.add(Nn(e,t-32)).mul(n),d=l.add(Nn(e,t-24)).mul(n);return Dc(Ls(c.add(h),43).add(Ls(u,30)).add(d),c.add(Ls(h.add(s),18)).add(u),n)}function qfe(e,t=e.length){const n=th.fromNumber(81,!0);if(t<=32)return t<=16?Wfe(e,t):Hfe(e,t);if(t<=64)return jfe(e,t);let s=n,r=n.mul(nh).add(113),i=pE(r.mul(wr).add(113)).mul(wr),o=[th.UZERO,th.UZERO],a=[th.UZERO,th.UZERO];s=s.mul(wr).add(Nn(e,0));let l=0;const c=(t-1>>6)*64,h=c+(t-1&63)-63;do s=Ls(s.add(r).add(o[0]).add(Nn(e,l+8)),37).mul(nh),r=Ls(r.add(o[1]).add(Nn(e,l+48)),42).mul(nh),s=s.xor(a[1]),r=r.add(o[0]).add(Nn(e,l+40)),i=Ls(i.add(a[0]),33).mul(nh),o=Xb(e,l,o[1].mul(nh),s.add(a[0])),a=Xb(e,l+32,i.add(a[1]),r.add(Nn(e,l+16))),[i,s]=[s,i],l+=64;while(l!==c);const u=nh.add(i.and(255).shl(1));return l=h,a[0]=a[0].add(t-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),s=Ls(s.add(r).add(o[0]).add(Nn(e,l+8)),37).mul(u),r=Ls(r.add(o[1]).add(Nn(e,l+48)),42).mul(u),s=s.xor(a[1].mul(9)),r=r.add(o[0].mul(9).add(Nn(e,l+40))),i=Ls(i.add(a[0]),33).mul(u),o=Xb(e,l,o[1].mul(u),s.add(a[0])),a=Xb(e,l+32,i.add(a[1]),r.add(Nn(e,l+16))),[i,s]=[s,i],Dc(Dc(o[0],a[0],u).add(pE(r).mul(fB)).add(i),Dc(o[1],a[1],u).add(s),u)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mc(e,t){return t==="string"?Pc(e):sh([e],t)}function Xfe(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function sh(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=rh(e)),xe().getBool("DEBUG")&&Tfe(e,t),Xfe(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){const n=new Uint8Array(e.length);for(let s=0;s<n.length;++s)Math.round(e[s])!==0&&(n[s]=1);return n}else throw new Error(`Unknown data type ${t}`)}function Wr(){return xe().platform.now()}function Pc(e,t="utf-8"){return t=t||"utf-8",xe().platform.encode(e,t)}function Oc(e,t="utf-8"){return t=t||"utf-8",xe().platform.decode(e,t)}function Ho(e){return xe().platform.isTypedArray(e)}function rh(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||bT(e)||e==null||Ho(e)&&n)t.push(e);else if(Array.isArray(e)||Ho(e))for(let s=0;s<e.length;++s)rh(e[s],t,n);else{let s=-1;for(const r of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)rh(e[r],t,n)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kfe{constructor(t,n){this.backendTimer=t,this.logger=n,n==null&&(this.logger=new Qfe)}profileKernel(t,n,s){let r;const i=()=>{r=s()};let o;const a=Wr();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of r)c.dataSync();o=Promise.resolve({kernelMs:Wr()-a})}if(xe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const h=r[c];h.data().then(u=>{Yfe(u,h.dtype,t)})}return{kernelName:t,outputs:r,inputs:n,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:n,outputs:s,timeMs:r,inputs:i,extraInfo:o}=t;s.forEach(a=>{Promise.all([a.data(),r,o]).then(l=>{this.logger.logKernelProfile(n,a,l[0],l[1],i,l[2])})})}}function Yfe(e,t,n){if(t!=="float32")return!1;for(let s=0;s<e.length;s++){const r=e[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class Qfe{logKernelProfile(t,n,s,r,i,o){const a=typeof r=="number"?vp(`${r}ms`,9):r.error,l=vp(t,25),c=n.rank,h=n.size,u=vp(n.shape.toString(),14);let d="";for(const p in i){const f=i[p];if(f!=null){const g=f.shape||n.shape,m=g.length;d+=`${p}: ${m}D ${m>0?g:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${u}	%c${h}	%c${d}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zfe(e,t,n){const s={},r={};for(let l=0;l<t.length;l++)s[t[l].id]=!0;for(let l=0;l<e.length;l++){const c=e[l],h=c.inputs;for(const u in h){const d=h[u];let p=!1;for(let f=0;f<t.length;f++)if(s[d.id]){c.outputs.forEach(g=>s[g.id]=!0),p=!0,r[c.id]=!0;break}if(p)break}}const i={};i[n.id]=!0;const o={};for(let l=e.length-1;l>=0;l--){const c=e[l],h=c.inputs;for(let u=0;u<c.outputs.length;u++)if(i[c.outputs[u].id]){for(const d in h)i[h[d].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<e.length;l++){const c=e[l];if(r[c.id]&&o[c.id]){const h={};for(const d in c.inputs){const p=c.inputs[d];s[p.id]&&(h[d]=p)}const u=Object.assign({},c);u.inputs=h,u.outputs=c.outputs,a.push(u)}}return a}function Jfe(e,t,n,s){for(let r=t.length-1;r>=0;r--){const i=t[r],o=[];if(i.outputs.forEach(l=>{const c=e[l.id];c!=null?o.push(c):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=n(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const h=i.inputs[l];if(!dn(c.shape,h.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${h.shape}'`);if(e[h.id]==null)e[h.id]=c;else{const u=e[h.id];e[h.id]=s(u,c),u.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yB=20,Hg=3,fE=7;function eme(e,t,n,s){const r=gt(t),i=tme(e,t,n,r),o=t.length,a=Kb(e,t,n,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function tme(e,t,n,s){const r=Ae(t),i=s[s.length-1],o=new Array(i).fill(0),a=t.length,l=n==="complex64"?qg(e):e;if(a>1)for(let c=0;c<r/i;c++){const h=c*i;for(let u=0;u<i;u++)o[u]=Math.max(o[u],jg(l[h+u],0,n).length)}return o}function jg(e,t,n){let s;return Array.isArray(e)?s=`${parseFloat(e[0].toFixed(fE))} + ${parseFloat(e[1].toFixed(fE))}j`:Xm(e)?s=`'${e}'`:n==="bool"?s=vB(e):s=parseFloat(e.toFixed(fE)).toString(),vp(s,t)}function vB(e){return e===0?"false":"true"}function Kb(e,t,n,s,r,i=!0){const o=n==="complex64"?2:1,a=t[0],l=t.length;if(l===0){if(n==="complex64"){const g=qg(e);return[jg(g[0],0,n)]}return n==="bool"?[vB(e[0])]:[e[0].toString()]}if(l===1){if(a>yB){const m=Hg*o;let y=Array.from(e.slice(0,m)),v=Array.from(e.slice((a-Hg)*o,a*o));return n==="complex64"&&(y=qg(y),v=qg(v)),["["+y.map((b,x)=>jg(b,r[x],n)).join(", ")+", ..., "+v.map((b,x)=>jg(b,r[a-Hg+x],n)).join(", ")+"]"]}const g=n==="complex64"?qg(e):Array.from(e);return["["+g.map((m,y)=>jg(m,r[y],n)).join(", ")+"]"]}const c=t.slice(1),h=s.slice(1),u=s[0]*o,d=[];if(a>yB){for(let g=0;g<Hg;g++){const m=g*u,y=m+u;d.push(...Kb(e.slice(m,y),c,n,h,r,!1))}d.push("...");for(let g=a-Hg;g<a;g++){const m=g*u,y=m+u;d.push(...Kb(e.slice(m,y),c,n,h,r,g===a-1))}}else for(let g=0;g<a;g++){const m=g*u,y=m+u;d.push(...Kb(e.slice(m,y),c,n,h,r,g===a-1))}const p=l===2?",":"";d[0]="["+(a>0?d[0]+p:"");for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+p;let f=`,
`;for(let g=2;g<l;g++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":f),d}function qg(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lr{constructor(t,n,s){if(this.dtype=n,this.shape=t.slice(),this.size=Ae(t),s!=null){const r=s.length;W(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||gs(n,this.size),this.strides=gt(t)}set(t,...n){n.length===0&&(n=[0]),W(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const s=this.locToIndex(n);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let n=0;for(const r of t){if(r<0||r>=this.shape[n]){const i=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(i)}n++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let n=t[t.length-1];for(let s=0;s<t.length-1;++s)n+=this.strides[s]*t[s];return n}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const n=new Array(this.shape.length);for(let s=0;s<n.length-1;++s)n[s]=Math.floor(t/this.strides[s]),t-=n[s]*this.strides[s];return n[n.length-1]=t,n}get rank(){return this.shape.length}toTensor(){return jo().makeTensor(this.values,this.shape,this.dtype)}}let jo=null,Cp=null;function nme(e){jo=e}function sme(e){Cp=e}class ys{constructor(t,n,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=n||"float32",this.size=Ae(t),this.strides=gt(t),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Cp.buffer(this.shape,this.dtype,t)}bufferSync(){return Cp.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Go(this.shape,t,this.dtype==="complex64")}arraySync(){return Go(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=jo().read(this.dataId);if(this.dtype==="string"){const n=await t;try{return n.map(s=>Oc(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),jo().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=jo().readSync(this.dataId);if(this.dtype==="string")try{return t.map(n=>Oc(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await jo().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(jo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Cp.print(this,t)}clone(){return this.throwIfDisposed(),Cp.clone(this)}toString(t=!1){const n=this.dataSync();return eme(n,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Cp.cast(this,t)}variable(t=!0,n,s){return this.throwIfDisposed(),jo().makeVariable(this,t,n,s)}}Object.defineProperty(ys,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Ee(){return ST("Tensor",()=>ys)}Ee();class Yb extends ys{constructor(t,n,s,r){super(t.shape,t.dtype,t.dataId,r);this.trainable=n,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!dn(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);jo().disposeTensor(this),this.dataId=t.dataId,jo().incRef(this,null)}dispose(){jo().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Yb,Symbol.hasInstance,{value:e=>e instanceof ys&&e.assign!=null&&e.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var xB;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(xB||(xB={}));var mE;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(mE||(mE={}));var gE;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(gE||(gE={}));var yE;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(yE||(yE={}));var vE;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(vE||(vE={}));const rme={float32:yE,int32:mE,bool:gE,complex64:vE};function li(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return rme[e][t]}function xE(e){return li(e,"int32")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ls(e,t){if(e.dtype===t.dtype)return[e,t];const n=li(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function bB(e){const t=[],n=new Set;return wB(e,t,n),t}function wB(e,t,n){if(e==null)return;if(e instanceof ys){t.push(e);return}if(!ime(e))return;const s=e;for(const r in s){const i=s[r];n.has(i)||(n.add(i),wB(i,t,n))}}function ime(e){return Array.isArray(e)||typeof e=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bE(e){return e.kernelName!=null}class SB{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Tp{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new SB}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,s=1){return t in this.registryFactory?(Mi(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:n,asyncInit:s}=this.initializeBackend(t);if(!(s?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Kfe(this.backendInstance),!0}setupRegisteredKernels(){nB(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){nB(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=n.factory();if(s&&!(s instanceof dT)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[t]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Mi(`Initialization of backend ${t} failed`),Mi(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return Mi(`Initialization of backend ${t} failed`),Mi(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){const s=this.state.tensorInfo.get(n),r=s.backend,i=this.readSync(n),o=r.refCount(n);r.disposeData(n,!0),s.backend=t,t.move(n,i,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let s=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,n,s){t();try{const r=s();return n(),r}catch(r){throw n(),r}}nextTensorId(){return Tp.nextTensorId++}nextVariableId(){return Tp.nextVariableId++}clone(t){const n=ae.runKernel(gg,{x:t}),s={x:t},r=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return ae.runKernel(sg,l,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[n],r,i,{}),n}runKernel(t,n,s){if(this.backendName==null&&this.backend,!(eB(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,s){const r=this.backend.numDataIds();let i=0;s.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-n-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t){let n,s=[];const r=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=bE(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(bE(t)){const{kernelName:f,inputs:g,attrs:m}=t;this.backendName==null&&this.backend;const y=eB(f,this.backendName);W(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),a=()=>{const v=this.backend.numDataIds();l=y.kernelFunc({inputs:g,attrs:m,backend:this.backend});const b=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,v,b);const x=b.map(w=>w.rank!=null?w:this.makeTensorFromTensorInfo(w));if(r){const w=this.getTensorsForGradient(f,g,x);s=this.saveTensorsForBackwardMode(w)}return x}}else{const{forwardFunc:f}=t,g=m=>{!r||(s=m.map(y=>this.keep(this.clone(y))))};a=()=>{const m=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,g));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,m,y),y}}const{inputs:h,attrs:u}=t,d=bE(t)?null:t.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=a():(p=this.profiler.profileKernel(c,h,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),n=p.outputs)}),r&&this.addTapeNode(c,h,n,d,s,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(f=>h[f]!=null?h[f].shape:null),outputShapes:n.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,n,s){const r=tB(t);if(r!=null){const i=r.inputsToSave||[],o=r.outputsToSave||[];let a;r.saveAllInputs?(W(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(n).map(c=>n[c])):a=i.map(c=>n[c]);const l=s.filter((c,h)=>o[h]);return a.concat(l)}return[]}makeTensor(t,n,s,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=t;s==="string"&&Xm(t[0])&&(i=t.map(l=>Pc(l)));const o=r.write(i,n,s),a=new ys(n,s,o,this.nextTensorId());if(this.trackTensor(a,r),s==="string"){const l=this.state.tensorInfo.get(o),c=Afe(i);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(t,n,s,r){s=s||"float32";const i={dataId:t,shape:n,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(t,n){const{dataId:s,shape:r,dtype:i}=t,o=new ys(r,i,s,this.nextTensorId());return this.trackTensor(o,n),o}makeVariable(t,n=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));const i=new Yb(t,n,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*Vx(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof Yb||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*Vx(t.dtype);this.state.numBytes-=s}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const n=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,s,r,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:s,saved:i},l=tB(t);l!=null&&(r=l.gradFunc),r!=null&&(a.gradient=c=>(c=c.map((h,u)=>{if(h==null){const d=s[u],p=ar(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return h}),r(c.length>1?c:c[0],i,o))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){const n=bB(t),s=new Set(n.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(t,n,s,r=!1){if(W(n.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));W(i instanceof ys,()=>"The result y returned by f() must be a tensor.");const o=Zfe(this.state.activeTape,n,i);if(!r&&o.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=s==null?ome(i.shape):s,Jfe(a,o,c=>this.tidy(c),ame);const l=n.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const h of c.saved)h.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(t){return W(yT(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{W(n.every(a=>a instanceof ys),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};n.forEach((a,l)=>{r[l]=a});const i=(a,l)=>(s=t(...n,l),W(s.value instanceof ys,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),W(yT(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(a,l)=>{const c=s.gradFunc(a,l),h=Array.isArray(c)?c:[c];W(h.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),W(h.every(d=>d instanceof ys),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const u={};return h.forEach((d,p)=>{u[p]=()=>d}),u};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){const n=Wr(),s=await this.backend.time(t);return s.wallMs=Wr()-n,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new SB;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Tp.nextTensorId=0;Tp.nextVariableId=0;function ome(e){const t=xT(Ae(e),"float32");return ae.makeTensor(t,e,"float32")}function _B(){const e=M$();if(e._tfengine==null){const t=new kfe(e);e._tfengine=new Tp(t)}return Ofe(e._tfengine.ENV),nme(()=>e._tfengine),e._tfengine}const ae=_B();function ame(e,t){const n={a:e,b:t};return ae.runKernel(bp,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lme(){return typeof navigator!="undefined"&&navigator!=null}function CB(e){if(e||lme()){if(e||(e=navigator),e.product==="ReactNative")return!0;const t=e.userAgent||e.vendor||(typeof window!="undefined"?window.opera:"");if(!t){const n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function TB(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pi=xe();Pi.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Pi.registerFlag("IS_BROWSER",()=>TB());Pi.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Pi.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Pi.registerFlag("PROD",()=>!1);Pi.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Pi.getBool("DEBUG"));Pi.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Pi.registerFlag("IS_TEST",()=>!1);Pi.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Pi.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Pi.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Pi.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qb(e,t){let n=e;if(Ho(e))return t==="string"?[]:[e.length];if(typeof e=="object"){if("texture"in e){const i=e.channels||"RGBA";return[e.height,e.width*i.length]}else if("buffer"in e&&!(e.buffer instanceof ArrayBuffer))return[e.buffer.size/(t==null?4:Vx(t))]}if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||Ho(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&xe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&EB(e,r,[]),r}function EB(e,t,n){if(n=n||[],!Array.isArray(e)&&!Ho(e)){W(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}W(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),W(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const s=t.slice(1);for(let r=0;r<e.length;++r)EB(e[r],s,n.concat(r))}function AB(e,t,n,s){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${s}' must be ${e} tensor, but got ${t} tensor`)}}function J(e,t,n,s="numeric"){if(e instanceof ys)return AB(s,e.dtype,t,n),e;let r=Km(e);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),AB(s,r,t,n),e==null||!Ho(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){const l=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const i=Qb(e,r);!Ho(e)&&!Array.isArray(e)&&(e=[e]);const a=r!=="string"?sh(e,r):rh(e,[],!0);return ae.makeTensor(a,i,r)}function IB(e,t,n,s="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((i,o)=>J(i,`${t}[${o}]`,n,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cme="__op";function fe(e){const t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const s=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+cme;const r=(...i)=>{ae.startScope(n);try{const o=s(...i);return bT(o)&&console.error("Cannot return a Promise inside of tidy."),ae.endScope(o),o}catch(o){throw ae.endScope(null),o}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ume(e,t){const n=J(e,"real","complex"),s=J(t,"imag","complex");fT(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:n,imag:s};return ae.runKernel(NT,r)}const Ep=fe({complex_:ume});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zb(e,t,n,s){if(s==null)s=Km(e);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(typeof e=="object"&&("texture"in e||"buffer"in e&&!(e.buffer instanceof ArrayBuffer))){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return ae.backend.createTensorFromGPUData(e,t||n,s)}if(!Ho(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Il(t);const r=Ae(t),i=Ae(n);W(r===i,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${i}`);for(let o=0;o<n.length;++o){const a=n[o],l=o===n.length-1?a!==Ae(t.slice(o)):!0;W(n[o]===t[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!Ho(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=s!=="string"?sh(e,s):rh(e,[],!0),ae.makeTensor(e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NB(e,t,n){const s=Qb(e,n);return Zb(e,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kB=4;async function DB(e,t){const n=[],s=[],r=Array.isArray(e)?e.map(o=>o.name):Object.keys(e);for(let o=0;o<r.length;++o){const a=r[o],l=Array.isArray(e)?e[o].tensor:e[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const h=new Promise(async u=>{const d=await l.bytes(),p=d.reduce((m,y)=>m+y.length,0)+kB*d.length,f=new Uint8Array(p);let g=0;for(let m=0;m<d.length;m++){const y=d[m],v=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(v,g),g+=kB,f.set(y,g),g+=y.length}u(f)});s.push(h)}else s.push(l.data());t!=null&&(c.group=t),n.push(c)}const i=await Promise.all(s);return{data:hme(i),specs:n}}function hme(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(i=>{if(t+=i.byteLength,n.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(t);let r=0;return n.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const wE=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function MB(e){return wE?Buffer.byteLength(e):new Blob([e]).size}function dme(e){if(wE)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let s=0,r=t.length;s<r;s++)n+=String.fromCharCode(t[s]);return btoa(n)}function pme(e){if(wE){const s=Buffer.from(e,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let s=0;s<t.length;++s)n.set([t.charCodeAt(s)],s);return n.buffer}function PB(e){if(e.length===1)return e[0];let t=0;e.forEach(r=>{t+=r.byteLength});const n=new Uint8Array(t);let s=0;return e.forEach(r=>{n.set(new Uint8Array(r),s),s+=r.byteLength}),n.buffer}function OB(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function fme(e,t,n){const s={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(s.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=n}return e.signature!=null&&(s.signature=e.signature),e.userDefinedMetadata!=null&&(s.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(s.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(s.initializerSignature=e.initializerSignature),s}async function mme(e,t){let n,s;return e.weightsManifest!=null&&([n,s]=await t(e.weightsManifest)),fme(e,n,s)}function Jb(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:MB(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:MB(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:e.weightData.byteLength}}function gme(e){const t=[];for(const n of e)t.push(...n.weights);return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fs{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Fs.instance==null&&(Fs.instance=new Fs),Fs.instance}static registerSaveRouter(t){Fs.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Fs.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Fs.getHandlers(t,"save")}static getLoadHandlers(t,n){return Fs.getHandlers(t,"load",n)}static getHandlers(t,n,s){const r=[];return(n==="load"?Fs.getInstance().loadRouters:Fs.getInstance().saveRouters).forEach(o=>{const a=o(t,s);a!==null&&r.push(a)}),r}}const yme=e=>Fs.getSaveHandlers(e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SE="tensorflowjs",_E=1,ih="models_store",Rc="model_info_store";function RB(){if(!xe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e=typeof window=="undefined"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function CE(e){const t=e.result;t.createObjectStore(ih,{keyPath:"modelPath"}),t.createObjectStore(Rc,{keyPath:"modelPath"})}class oh{constructor(t){if(this.indexedDB=RB(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise((s,r)=>{const i=this.indexedDB.open(SE,_E);i.onupgradeneeded=()=>CE(i),i.onsuccess=()=>{const o=i.result;if(n==null){const a=o.transaction(ih,"readonly"),c=a.objectStore(ih).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=h=>(o.close(),r(c.error)),a.oncomplete=()=>o.close()}else{const a=Jb(n),l=o.transaction(Rc,"readwrite");let c=l.objectStore(Rc);const h=c.put({modelPath:this.modelPath,modelArtifactsInfo:a});let u;h.onsuccess=()=>{u=o.transaction(ih,"readwrite");const p=u.objectStore(ih).put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:a});p.onsuccess=()=>s({modelArtifactsInfo:a}),p.onerror=f=>{c=l.objectStore(Rc);const g=c.delete(this.modelPath);g.onsuccess=()=>(o.close(),r(p.error)),g.onerror=m=>(o.close(),r(p.error))}},h.onerror=d=>(o.close(),r(h.error)),l.oncomplete=()=>{u==null?o.close():u.oncomplete=()=>o.close()}}},i.onerror=o=>r(i.error)})}}oh.URL_SCHEME="indexeddb://";const LB=e=>xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(oh.URL_SCHEME)?vme(e.slice(oh.URL_SCHEME.length)):null;Fs.registerSaveRouter(LB);Fs.registerLoadRouter(LB);function vme(e){return new oh(e)}function xme(e){return e.startsWith(oh.URL_SCHEME)?e.slice(oh.URL_SCHEME.length):e}class bme{constructor(){this.indexedDB=RB()}async listModels(){return new Promise((t,n)=>{const s=this.indexedDB.open(SE,_E);s.onupgradeneeded=()=>CE(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(Rc,"readonly"),a=i.objectStore(Rc).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;t(l)},a.onerror=l=>(r.close(),n(a.error)),i.oncomplete=()=>r.close()},s.onerror=r=>n(s.error)})}async removeModel(t){return t=xme(t),new Promise((n,s)=>{const r=this.indexedDB.open(SE,_E);r.onupgradeneeded=()=>CE(r),r.onsuccess=()=>{const i=r.result,o=i.transaction(Rc,"readwrite"),a=o.objectStore(Rc),l=a.get(t);let c;l.onsuccess=()=>{if(l.result==null)return i.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const h=a.delete(t),u=()=>{c=i.transaction(ih,"readwrite");const p=c.objectStore(ih).delete(t);p.onsuccess=()=>n(l.result.modelArtifactsInfo),p.onerror=f=>s(l.error)};h.onsuccess=u,h.onerror=d=>(u(),i.close(),s(l.error))}},l.onerror=h=>(i.close(),s(l.error)),o.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nl="/",Ap="tensorflowjs_models",FB="info",wme="model_topology",Sme="weight_specs",_me="weight_data",Cme="model_metadata";function $B(e){return{info:[Ap,e,FB].join(Nl),topology:[Ap,e,wme].join(Nl),weightSpecs:[Ap,e,Sme].join(Nl),weightData:[Ap,e,_me].join(Nl),modelMetadata:[Ap,e,Cme].join(Nl)}}function BB(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Tme(e){const t=e.split(Nl);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Nl)}function Eme(e){return e.startsWith(ah.URL_SCHEME)?e.slice(ah.URL_SCHEME.length):e}class ah{constructor(t){if(!xe().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=$B(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),r=Jb(t);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,dme(t.weightData));const i={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:r}}catch{throw BB(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);n.format=a.format,n.generatedBy=a.generatedBy,n.convertedBy=a.convertedBy,a.signature!=null&&(n.signature=a.signature),a.userDefinedMetadata!=null&&(n.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(n.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(n.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(n.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=pme(o),n}}ah.URL_SCHEME="localstorage://";const zB=e=>xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ah.URL_SCHEME)?Ame(e.slice(ah.URL_SCHEME.length)):null;Fs.registerSaveRouter(zB);Fs.registerLoadRouter(zB);function Ame(e){return new ah(e)}class Ime{constructor(){W(xe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),W(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},n=Ap+Nl,s=Nl+FB;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(n)&&i.endsWith(s)){const o=Tme(i);t[o]=JSON.parse(this.LS.getItem(i))}}return t}async removeModel(t){t=Eme(t);const n=$B(t);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(n.info));return BB(n),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UB="://";class Ga{constructor(){this.managers={}}static getInstance(){return Ga.instance==null&&(Ga.instance=new Ga),Ga.instance}static registerManager(t,n){W(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(UB)&&(t=t.slice(0,t.indexOf(UB))),W(t.length>0,()=>"scheme must not be an empty string.");const s=Ga.getInstance();W(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=n}static getManager(t){const n=Ga.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(Ga.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nme{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}setTimeoutCustom(t,n){if(typeof window=="undefined"||!xe().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,n);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{s.source===window&&s.data.name===this.messageName&&(s.stopPropagation(),this.functionRefs[s.data.index](),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0))}isTypedArray(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}}if(xe().get("IS_BROWSER")){xe().setPlatform("browser",new Nme);try{Ga.registerManager(ah.URL_SCHEME,new Ime)}catch{}try{Ga.registerManager(oh.URL_SCHEME,new bme)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kme={importFetch:()=>require("node-fetch")};let TE;class Dme{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,n){return xe().global.fetch!=null?xe().global.fetch(t,n):(TE==null&&(TE=kme.importFetch()),TE(t,n))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(t)}decode(t,n){return t.length===0?"":new this.util.TextDecoder(n).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}xe().get("IS_NODE")&&!xe().get("IS_BROWSER")&&xe().setPlatform("node",new Dme);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jt(e,t="float32",n){return t=t||"float32",Il(e),new lr(e,t,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mme(e,t){const n=J(e,"x","cast");if(!Efe(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:n},r={dtype:t};return ae.runKernel(sg,s,r)}const rt=fe({cast_:Mme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pme(e){const n={x:J(e,"x","clone","string_or_numeric")};return ae.runKernel(gg,n)}const lh=fe({clone_:Pme});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ome(e,t=!1){console.log(e.toString(t))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_B();const Rme={buffer:jt,cast:rt,clone:lh,print:Ome};sme(Rme);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wa(){return ae}function EE(){return ae.memory()}function ye(e,t){return ae.tidy(e,t)}function qt(e){bB(e).forEach(n=>n.dispose())}function Ha(e){return ae.keep(e)}function VB(e,t,n=1){return ae.registerBackend(e,t,n)}function Lme(){return ae.backend}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fme(e,t){let n=J(e,"a","add"),s=J(t,"b","add");[n,s]=ls(n,s);const r={a:n,b:s};return ae.runKernel(bp,r)}const ze=fe({add_:Fme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $me(e,t){let n=J(e,"a","floorDiv"),s=J(t,"b","floorDiv");[n,s]=ls(n,s);const r={a:n,b:s};return ae.runKernel(fg,r)}const GB=fe({floorDiv_:$me});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bme(e,t){let n=J(e,"a","div"),s=J(t,"b","div");if([n,s]=ls(n,s),n.dtype==="int32"&&s.dtype==="int32")return GB(n,s);const r={a:n,b:s},i={};return ae.runKernel(lg,r,i)}const St=fe({div_:Bme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zme(e,t){let n=J(e,"a","mul"),s=J(t,"b","mul");[n,s]=ls(n,s);const r={a:n,b:s};return ae.runKernel(Tg,r)}const le=fe({mul_:zme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ume(e){const t=J(e,"x","abs");if(t.dtype==="complex64"){const n={x:t};return ae.runKernel(Yx,n)}else{const n={x:t};return ae.runKernel(Gx,n)}}const Sr=fe({abs_:Ume});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vme(e){const n={x:J(e,"x","acos")};return ae.runKernel(Ym,n)}const Gme=fe({acos_:Vme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wme(e){const n={x:J(e,"x","acosh")};return ae.runKernel(Qm,n)}const Hme=fe({acosh_:Wme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jme(e,t=null,n=!1){const r={x:J(e,"x","all","bool")},i={axis:t,keepDims:n};return ae.runKernel(CT,r,i)}const WB=fe({all_:jme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qme(e,t=null,n=!1){const r={x:J(e,"x","any","bool")},i={axis:t,keepDims:n};return ae.runKernel(TT,r,i)}const AE=fe({any_:qme});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xme(e,t=0){const s={x:J(e,"x","argMax")},r={axis:t};return ae.runKernel(Wx,s,r)}const Xg=fe({argMax_:Xme});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kme(e,t=0){const s={x:J(e,"x","argMin")},r={axis:t};return ae.runKernel(Hx,s,r)}const Yme=fe({argMin_:Kme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qme(e){const n={x:J(e,"x","asin")};return ae.runKernel(Zm,n)}const Zme=fe({asin_:Qme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jme(e){const n={x:J(e,"x","asinh")};return ae.runKernel(Jm,n)}const ege=fe({asinh_:Jme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tge(e){const n={x:J(e,"x","atan")};return ae.runKernel(eg,n)}const nge=fe({atan_:tge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sge(e,t){let n=J(e,"a","atan2"),s=J(t,"b","atan2");[n,s]=ls(n,s);const r={a:n,b:s};return ae.runKernel(ng,r)}const rge=fe({atan2_:sge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ige(e){const n={x:J(e,"x","atanh")};return ae.runKernel(tg,n)}const oge=fe({atanh_:ige});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kg(e,t,n,s,r="NHWC",i){const o=e[3],a=[...t,o],l=Dl(r);return Qs(e,a,n,i,s,null,null,l)}function uo(e,t,n,s,r,i,o="channelsLast"){const[a,l]=Yg(t);let c;if(o==="channelsLast")c=[a,l,e[3],e[3]];else if(o==="channelsFirst")c=[a,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${o}`);return Qs(e,c,n,s,r,i,!1,o)}function kl(e,t,n,s,r,i,o="NDHWC"){const[a,l,c]=NE(t);let h,u;if(o==="NDHWC")u="channelsLast",h=[a,l,c,e[4],e[4]];else if(o==="NCDHW")u="channelsFirst",h=[a,l,c,e[1],e[1]];else throw new Error(`Unknown dataFormat ${o}`);return Lc(e,h,n,s,r,!1,u,i)}function Qs(e,t,n,s,r,i,o=!1,a="channelsLast"){let[l,c,h,u]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,h,u]=e;else if(a==="channelsFirst")[l,u,c,h]=e;else throw new Error(`Unknown dataFormat ${a}`);const[d,p,,f]=t,[g,m]=Yg(n),[y,v]=Yg(s),b=Ip(d,y),x=Ip(p,v),{padInfo:w,outHeight:S,outWidth:C}=cge(r,c,h,g,m,b,x,i,a),_=o?f*u:f;let T;return a==="channelsFirst"?T=[l,_,S,C]:a==="channelsLast"&&(T=[l,S,C,_]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:h,inChannels:u,outHeight:S,outWidth:C,outChannels:_,padInfo:w,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:b,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:v,inShape:e,outShape:T,filterShape:t}}function Lc(e,t,n,s,r,i=!1,o="channelsLast",a){let[l,c,h,u,d]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,h,u,d]=e;else if(o==="channelsFirst")[l,d,c,h,u]=e;else throw new Error(`Unknown dataFormat ${o}`);const[p,f,g,,m]=t,[y,v,b]=NE(n),[x,w,S]=NE(s),C=Ip(p,x),_=Ip(f,w),T=Ip(g,S),{padInfo:E,outDepth:A,outHeight:D,outWidth:O}=uge(r,c,h,u,y,v,b,C,_,T,a),P=i?m*d:m;let L;return o==="channelsFirst"?L=[l,P,A,D,O]:o==="channelsLast"&&(L=[l,A,D,O,P]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:h,inWidth:u,inChannels:d,outDepth:A,outHeight:D,outWidth:O,outChannels:P,padInfo:E,strideDepth:y,strideHeight:v,strideWidth:b,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:C,effectiveFilterHeight:_,effectiveFilterWidth:T,dilationDepth:x,dilationHeight:w,dilationWidth:S,inShape:e,outShape:L,filterShape:t}}function age(e,t,n,s,r){s==null&&(s=IE(e,t,n));const i=e[0],o=e[1],a=Qg((i-t+2*s)/n+1,r),l=Qg((o-t+2*s)/n+1,r);return[a,l]}function lge(e,t,n,s,r,i){r==null&&(r=IE(e,t[0],s[0]));const o=[0,0,0,n];for(let a=0;a<3;a++)e[a]+2*r>=t[a]&&(o[a]=Qg((e[a]-t[a]+2*r)/s[a]+1,i));return o}function IE(e,t,n,s=1){const r=Ip(t,s);return Math.floor((e[0]*(n-1)-n+r)/2)}function Yg(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function NE(e){return typeof e=="number"?[e,e,e]:e}function Ip(e,t){return t<=1?e:e+(e-1)*(t-1)}function cge(e,t,n,s,r,i,o,a,l){let c,h,u;if(typeof e=="number"){c={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};const p=age([t,n],i,s,e,a);h=p[0],u=p[1]}else if(e==="same"){h=Math.ceil(t/s),u=Math.ceil(n/r);const d=Math.max(0,(h-1)*s+i-t),p=Math.max(0,(u-1)*r+o-n),f=Math.floor(d/2),g=d-f,m=Math.floor(p/2),y=p-m;c={top:f,bottom:g,left:m,right:y,type:"SAME"}}else if(e==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((t-i+1)/s),u=Math.ceil((n-o+1)/r);else if(typeof e=="object"){const d=l==="channelsLast"?e[1][0]:e[2][0],p=l==="channelsLast"?e[1][1]:e[2][1],f=l==="channelsLast"?e[2][0]:e[3][0],g=l==="channelsLast"?e[2][1]:e[3][1];c={top:d,bottom:p,left:f,right:g,type:d===0&&p===0&&f===0&&g===0?"VALID":"EXPLICIT"},h=Qg((t-i+d+p)/s+1,a),u=Qg((n-o+f+g)/r+1,a)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:c,outHeight:h,outWidth:u}}function uge(e,t,n,s,r,i,o,a,l,c,h){let u,d,p,f;if(e==="valid"&&(e=0),typeof e=="number"){u={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};const m=lge([t,n,s,1],[a,l,c],1,[r,i,o],e,h);d=m[0],p=m[1],f=m[2]}else if(e==="same"){d=Math.ceil(t/r),p=Math.ceil(n/i),f=Math.ceil(s/o);const g=(d-1)*r+a-t,m=(p-1)*i+l-n,y=(f-1)*o+c-s,v=Math.floor(g/2),b=g-v,x=Math.floor(m/2),w=m-x,S=Math.floor(y/2),C=y-S;u={top:x,bottom:w,left:S,right:C,front:v,back:b,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outDepth:d,outHeight:p,outWidth:f}}function Qg(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function ch(e){const[t,n,s]=Yg(e);return t===1&&n===1&&s===1}function cr(e,t){return ch(e)||ch(t)}function uh(e){return Yg(e).every(t=>t>0)}function Dl(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Hr(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")W(yp(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(r=>{W(yp(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hge(e,t){const s={x:J(e,"x","reshape","string_or_numeric")},r={shape:t};return ae.runKernel(kb,s,r)}const pe=fe({reshape_:hge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dge(e,t,n,s,r){const i=J(e,"x","avgPool","float32"),o=1;W(cr(n,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let a=i,l=!1;i.rank===3&&(l=!0,a=pe(i,[1,i.shape[0],i.shape[1],i.shape[2]])),W(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Hr("avgPool",s,r);const c={x:a},h={filterSize:t,strides:n,pad:s,dimRoundingMode:r};let u=ae.runKernel(jx,c,h);return u=rt(u,i.dtype),l?pe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const kE=fe({avgPool_:dge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pge(e,t,n,s,r,i="NDHWC"){const o=J(e,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=pe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),W(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),W(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),W(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),Hr("avgPool3d",s,r);const c={x:a},h={filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:i};let u=ae.runKernel(qx,c,h);return u=rt(u,a.dtype),l?pe(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}const fge=fe({avgPool3d_:pge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mge(e,t=0){W(e.length>=1,()=>"Pass at least one tensor to concat");const n=IB(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),n.length===1)return lh(n[0]);const s=n,r={axis:t};return ae.runKernel(Qx,s,r)}const jr=fe({concat_:mge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gge(e,t,n=!1,s=!1){let r=J(e,"a","matMul"),i=J(t,"b","matMul");[r,i]=ls(r,i);const o={a:r,b:i},a={transposeA:n,transposeB:s};return ae.runKernel(Xx,o,a)}const pn=fe({matMul_:gge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yge(e){const n={x:J(e,"x","sigmoid","float32")};return ae.runKernel(Lg,n)}const Np=fe({sigmoid_:yge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vge(e,t,n){const s=J(e,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:t,size:n};return ae.runKernel(Rb,r,i)}const kn=fe({slice_:vge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xge(e){const n={x:J(e,"x","tanh","float32")};return ae.runKernel(Vg,n)}const DE=fe({tanh_:xge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bge(e,t,n){const s=J(e,"x","batchToSpaceND"),r=t.reduce((a,l)=>a*l);W(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),W(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),W(s.shape[0]%r==0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);const i={x:s},o={blockShape:t,crops:n};return ae.runKernel(Kx,i,o)}const ME=fe({batchToSpaceND_:bge});function wge(e){let t;return e.rank===0||e.rank===1?t=pe(e,[1,1,1,e.size]):e.rank===2?t=pe(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=pe(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sge(e,t,n,s,r,i){i==null&&(i=.001);const o=J(e,"x","batchNorm"),a=J(t,"mean","batchNorm"),l=J(n,"variance","batchNorm");let c;r!=null&&(c=J(r,"scale","batchNorm"));let h;s!=null&&(h=J(s,"offset","batchNorm")),W(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),W(h==null||a.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),W(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:wge(o),scale:c,offset:h,mean:a,variance:l},p={varianceEpsilon:i},f=ae.runKernel(ob,d,p);return pe(f,o.shape)}const e1=fe({batchNorm_:Sge});function _ge(e,t,n,s,r,i){const o=J(e,"x","batchNorm"),a=J(t,"mean","batchNorm"),l=J(n,"variance","batchNorm");let c;r!=null&&(c=J(r,"scale","batchNorm"));let h;return s!=null&&(h=J(s,"offset","batchNorm")),W(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),W(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),W(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&W(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),h!=null&&W(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`),e1(o,a,l,h,c,i)}const Cge=fe({batchNorm2d_:_ge});function Tge(e,t,n,s,r,i){const o=J(e,"x","batchNorm"),a=J(t,"mean","batchNorm"),l=J(n,"variance","batchNorm");let c;r!=null&&(c=J(r,"scale","batchNorm"));let h;return s!=null&&(h=J(s,"offset","batchNorm")),W(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),W(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),W(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&W(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),h!=null&&W(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`),e1(o,a,l,h,c,i)}const Ege=fe({batchNorm3d_:Tge});function Age(e,t,n,s,r,i){const o=J(e,"x","batchNorm"),a=J(t,"mean","batchNorm"),l=J(n,"variance","batchNorm");let c;r!=null&&(c=J(r,"scale","batchNorm"));let h;return s!=null&&(h=J(s,"offset","batchNorm")),W(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),W(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),W(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&W(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),h!=null&&W(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`),e1(o,a,l,h,c,i)}const Ige=fe({batchNorm4d_:Age});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nge(e,t,n){const s=J(e,"x","bincount"),r=J(t,"weights","bincount");W(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),W(n>=0,()=>`size must be non-negative, but got ${n}.`),W(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},o={size:n};return ae.runKernel(IT,i,o)}const kge=fe({bincount_:Nge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dge(e,t){let n=J(e,"broadcastTo","x");const s=n.shape;if(Il(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const c=n.shape.slice();for(;c.length<t.length;)c.unshift(1);n=pe(n,c)}const r=n.shape,i=Array.from(t);for(let c=t.length-1;c>=0;c--)if(r[c]===t[c])i[c]=1;else if(n.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(i.map((c,h)=>c>1?h:-1).filter(c=>c>=0).length===0)return lh(n);const a={x:n},l={reps:i};return ae.runKernel(Gg,a,l)}const Zg=fe({broadcastTo_:Dge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mge(e){const n={x:J(e,"x","ceil","float32")};return ae.runKernel(rg,n)}const Pge=fe({ceil_:Mge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t1(e,t,n){Il(e);const s={shape:e,value:t,dtype:n};return ae.runKernel(GT,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oge(e,t,n){const s=J(e,"x","clipByValue");if(W(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return t1(s.shape,t,s.dtype);const r={x:s},i={clipValueMin:t,clipValueMax:n};return ae.runKernel(ig,r,i)}const Oi=fe({clipByValue_:Oge});function Rge(e){return jr(e,0)}const Lge=fe({concat1d_:Rge});function Fge(e,t){return jr(e,t)}const $ge=fe({concat2d_:Fge});function Bge(e,t){return jr(e,t)}const zge=fe({concat3d_:Bge});function Uge(e,t){return jr(e,t)}const Vge=fe({concat4d_:Uge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gge(e,t,n,s,r="NHWC",i=[1,1],o){const a=J(e,"x","conv2d","float32"),l=J(t,"filter","conv2d","float32");let c=a,h=!1;a.rank===3&&(h=!0,c=pe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),W(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),W(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Hr("conv2d",s,o);const u=r==="NHWC"?c.shape[3]:c.shape[1];W(u===l.shape[2],()=>`Error in conv2d: depth of input (${u}) must match input depth for filter ${l.shape[2]}.`),W(cr(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),W(uh(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),W(uh(n),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:c,filter:l},p={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},f=ae.runKernel(Zx,d,p);return h?pe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const hh=fe({conv2d_:Gge});function Wge(e,t,n,s,r="NWC",i=1,o){const a=J(e,"x","conv1d"),l=J(t,"filter","conv1d");let c=a,h=!1;a.rank===2&&(h=!0,c=pe(a,[1,a.shape[0],a.shape[1]])),W(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),W(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Hr("conv1d",s,o),W(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),W(cr(n,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`),W(uh(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),W(uh(n),()=>"Error in conv1D: Stride should be larger than 0."),W(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const u=pe(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=pe(c,[c.shape[0],1,c.shape[1],c.shape[2]]),m=hh(d,u,[1,n],s,"NHWC",[1,i],o);return h?pe(m,[m.shape[2],m.shape[3]]):pe(m,[m.shape[0],m.shape[2],m.shape[3]])}const HB=fe({conv1d_:Wge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hge(e,t,n,s,r,i="NHWC",o){W(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,l=t,c=!1;t.rank===3&&(c=!0,l=pe(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,e[0],e[1],e[2]]),W(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),W(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),W(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const h=i==="NHWC"?a[3]:a[1],u=i==="NHWC"?l.shape[3]:l.shape[1];W(h===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${n.shape[2]}.`),W(u===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[3]}.`),Hr("conv2dDerInput",r,o);const d={dy:l,filter:n},p={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:a},f=ae.runKernel(Jx,d,p);return c?pe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const PE=fe({conv2DBackpropInput_:Hge});function jge(e,t,n,s,r,i){const o=J(e,"x","conv2dTranspose"),a=J(t,"filter","conv2dTranspose");return PE(n,o,a,s,r,"NHWC",i)}const jB=fe({conv2dTranspose_:jge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qge(e,t,n,s,r="NDHWC",i=[1,1,1]){const o=J(e,"x","conv3d"),a=J(t,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=pe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),W(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),W(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),W(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),W(cr(n,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),W(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),W(uh(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),W(uh(n),()=>"Error in conv3D: Strides should be larger than 0.");const h={x:l,filter:a},u={strides:n,pad:s,dataFormat:r,dilations:i},d=ae.runKernel(eb,h,u);return c?pe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Xge=fe({conv3d_:qge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kge(e,t,n,s,r){W(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let i=e,o=t,a=!1;t.rank===4&&(a=!0,o=pe(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,e[0],e[1],e[2],e[3]]);const l=i[4],c=o.shape[4];W(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),W(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),W(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),W(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),W(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const h={dy:o,filter:n},u={pad:r,strides:s,inputShape:i},d=ae.runKernel(MT,h,u);return a?pe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const qB=fe({conv3DBackpropInput_:Kge});function Yge(e,t,n,s,r){const i=J(e,"x","conv3dTranspose"),o=J(t,"filter","conv3dTranspose");return qB(n,i,o,s,r)}const Qge=fe({conv3dTranspose_:Yge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zge(e){const n={x:J(e,"x","cos","float32")};return ae.runKernel(og,n)}const OE=fe({cos_:Zge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jge(e){const n={x:J(e,"x","cosh","float32")};return ae.runKernel(ag,n)}const XB=fe({cosh_:Jge});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e0e(e,t=0,n=!1,s=!1){const i={x:J(e,"x","cumprod")},o={axis:t,exclusive:n,reverse:s};return ae.runKernel(PT,i,o)}const RE=fe({cumprod_:e0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t0e(e,t=0,n=!1,s=!1){const i={x:J(e,"x","cumsum")},o={axis:t,exclusive:n,reverse:s};return ae.runKernel(tb,i,o)}const KB=fe({cumsum_:t0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n0e(e,t,n,s=!1){const r=J(e,"x","denseBincount"),i=J(t,"weights","denseBincount");W(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),W(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),W(n>=0,()=>`size must be non-negative, but got ${n}.`),W(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const o={x:r,weights:i},a={size:n,binaryOutput:s};return ae.runKernel(RT,o,a)}const YB=fe({denseBincount_:n0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s0e(e,t,n="NHWC"){const s=J(e,"x","depthToSpace","float32"),r=n==="NHWC"?s.shape[1]:s.shape[2],i=n==="NHWC"?s.shape[2]:s.shape[3],o=n==="NHWC"?s.shape[3]:s.shape[1];W(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),W(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${s.shape}`),W(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t} for depthToSpace with input shape
        ${s.shape}`),W(o%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${s.shape}`);const a={x:s},l={blockSize:t,dataFormat:n};return ae.runKernel(LT,a,l)}const r0e=fe({depthToSpace_:s0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i0e(e,t,n,s,r="NHWC",i=[1,1],o){const a=J(e,"x","depthwiseConv2d","float32"),l=J(t,"filter","depthwiseConv2d","float32");let c=a,h=!1;a.rank===3&&(h=!0,c=pe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),W(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),W(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const u=r==="NHWC"?c.shape[3]:c.shape[1];W(u===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${u}) must match the inChannels dimension in filter ${l.shape[2]}.`),Hr("depthwiseConv2d",s,o);const d={x:c,filter:l},p={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},f=ae.runKernel(nb,d,p);return h?pe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const LE=fe({depthwiseConv2d_:i0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o0e(e,t,n,s,r=[1,1],i="NHWC"){const o=J(e,"x","dilation2d"),a=J(t,"filter","dilation2d");W(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),W(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),W(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,c=!1;o.rank===3&&(l=pe(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),W(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const h={x:l,filter:a},u={strides:n,pad:s,dilations:r},d=ae.runKernel(sb,h,u);return c?pe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const a0e=fe({dilation2d_:o0e});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kp(e,t){const n=e.length,s=[];for(let r=0;r<n;r++){const i=n-1-r,o=e[i]||1;(t[t.length-1-r]||1)>1&&o===1&&s.unshift(i)}return s}function Ts(e,t){const n=[];for(let s=0;s<t.length;s++){const r=e[e.length-s-1],i=t.length-s-1,o=t[i];(r==null||r===1&&o>1)&&n.unshift(i)}return n}function Ft(e,t){const n=[],s=Math.max(e.length,t.length);for(let r=0;r<s;r++){let i=e[e.length-r-1];i==null&&(i=1);let o=t[t.length-r-1];if(o==null&&(o=1),i===1)n.unshift(o);else if(o===1)n.unshift(i);else if(i!==o){const a=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(a)}else n.unshift(i)}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l0e(e,t){let n=J(e,"a","equal","string_or_numeric"),s=J(t,"b","equal","string_or_numeric");[n,s]=ls(n,s),Ft(n.shape,s.shape);const r={a:n,b:s};return ae.runKernel(rb,r)}const ja=fe({equal_:l0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c0e(e,t,n){const s=J(t,"a","where"),r=J(n,"b","where"),i=J(e,"condition","where","bool"),o=Ft(Ft(i.shape,s.shape),r.shape),a=Zg(i,o),l=Zg(s,o),c=Zg(r,o),h={condition:a,t:l,e:c};return ae.runKernel(Ob,h)}const ci=fe({where_:c0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u0e(e){const n={x:J(e,"x","zerosLike")};return ae.runKernel(Vb,n)}const Jt=fe({zerosLike_:u0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h0e(e,t){let n=J(e,"a","div"),s=J(t,"b","div");[n,s]=ls(n,s);const r=St(n,s),i=Jt(r),o=ja(s,i);return ci(o,i,r)}const d0e=fe({divNoNan_:h0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p0e(e,t){const n=J(e,"t1","dot"),s=J(t,"t2","dot");W((n.rank===1||n.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=n.rank===1?n.size:n.shape[1],i=s.rank===1?s.size:s.shape[0];if(W(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),n.rank===1&&s.rank===1){const o=pe(n,[1,-1]),a=pe(s,[-1,1]),l=pn(o,a);return pe(l,[])}else if(n.rank===1&&s.rank===2){const o=pe(n,[1,-1]),a=pe(s,[s.shape[0],s.shape[1]]),l=pn(o,a);return pe(l,[l.size])}else if(n.rank===2&&s.rank===1){const o=pe(s,[-1,1]),a=pn(n,o);return pe(a,[a.size])}else{const o=pe(s,[s.shape[0],s.shape[1]]);return pn(n,o)}}const f0e=fe({dot_:p0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m0e(e){const n={x:J(e,"x","elu","float32")};return ae.runKernel(cg,n)}const n1=fe({elu_:m0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g0e(e){let t=J(e,"x","erf");W(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=rt(t,"float32"));const n={x:t};return ae.runKernel(ug,n)}const y0e=fe({erf_:g0e});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FE(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function QB(e,t,n){const s=e.length+t.length,r=[];let i=0,o=0;for(let a=0;a<s;a++)n.indexOf(a)===-1?r.push(e[i++]):r.push(t[o++]);return r}function $s(e,t){const n=[],s=e.length;for(let i=0;i<s;i++)t.indexOf(i)===-1&&n.push(e[i]);const r=t.map(i=>e[i]);return[n,r]}function vs(e,t){const n=t.map(s=>1);return QB(e,n,t)}function Zs(e,t,n){W(FE(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function Yn(e,t){if(FE(e,t))return null;const n=[];for(let s=0;s<t;++s)e.indexOf(s)===-1&&n.push(s);return e.forEach(s=>n.push(s)),n}function Fc(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function cs(e,t){const n=[];for(let s=t-e;s<t;++s)n.push(s);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v0e(e,t=null,n=!1){const r={x:J(e,"x","max")},i={reductionIndices:t,keepDims:n};return ae.runKernel(gb,r,i)}const qo=fe({max_:v0e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x0e(e,t=null,n=!1){const r={x:J(e,"x","min")},i={axis:t,keepDims:n};return ae.runKernel(bb,r,i)}const s1=fe({min_:x0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b0e(e,t){let n=J(e,"base","pow"),s=J(t,"exp","pow");[n,s]=ls(n,s);const r={a:n,b:s};return ae.runKernel(Eg,r)}const Dp=fe({pow_:b0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fn(e,t){if((Ho(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Ho(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Zb(e,[],[],t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w0e(e){const n={x:J(e,"x","sqrt","float32")};return ae.runKernel($g,n)}const _r=fe({sqrt_:w0e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S0e(e){const t=J(e,"x","square"),n={};return ae.runKernel("Square",{x:t},n)}const zn=fe({square_:S0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _0e(e,t=null,n=!1){let s=J(e,"x","sum");s.dtype==="bool"&&(s=rt(s,"int32"));const r={x:s},i={axis:t,keepDims:n};return ae.runKernel(Lb,r,i)}const xt=fe({sum_:_0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C0e(e,t="euclidean",n=null,s=!1){e=J(e,"x","norm");const r=ZB(e,t,n);let i=r.shape;if(s){const o=Ht(n,e.shape);i=vs(r.shape,o)}return pe(r,i)}function ZB(e,t,n=null){if(e.rank===0)return Sr(e);if(e.rank!==1&&n===null)return ZB(pe(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return xt(Sr(e),n);if(t===1/0)return qo(Sr(e),n);if(t===-1/0)return s1(Sr(e),n);if(t==="euclidean"||t===2)return _r(xt(Dp(Sr(e),fn(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return qo(xt(Sr(e),n[0]),n[1]-1);if(t===1/0)return qo(xt(Sr(e),n[1]),n[0]);if(t===-1/0)return s1(xt(Sr(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return _r(xt(zn(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const r1=fe({norm_:C0e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T0e(e,t=null,n=!1){return r1(e,"euclidean",t,n)}const E0e=fe({euclideanNorm_:T0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A0e(e){const n={x:J(e,"x","exp")};return ae.runKernel(hg,n)}const Ml=fe({exp_:A0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I0e(e,t=0){const n=J(e,"x","expandDims","string_or_numeric");W(t<=n.rank,()=>"Axis must be <= rank of the tensor");const s={input:n},r={dim:t};return ae.runKernel(ib,s,r)}const ui=fe({expandDims_:I0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N0e(e){const n={x:J(e,"x","expm1")};return ae.runKernel(dg,n)}const k0e=fe({expm1_:N0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D0e(e,t){const n=J(e,"x","tile","string_or_numeric");W(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);const s={x:n},r={reps:t};return ae.runKernel(Gg,s,r)}const Xo=fe({tile_:D0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M0e(e,t,n,s="float32"){t==null&&(t=e);const r=jt([e,t],s),i=e<=t?e:t;for(let a=0;a<i;++a)r.set(1,a,a);const o=pe(r.toTensor(),[e,t]);if(n==null)return o;if(n.length===1)return Xo(ui(o,0),[n[0],1,1]);if(n.length===2)return Xo(ui(ui(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return Xo(ui(ui(ui(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const JB=fe({eye_:M0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P0e(e){const n={x:J(e,"x","floor","float32")};return ae.runKernel(pg,n)}const i1=fe({floor_:P0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O0e(e,t,n=0,s=0){const r=J(e,"x","gather"),i=J(t,"indices","gather","int32"),o={x:r,indices:i},a={axis:n,batchDims:s};return ae.runKernel(ab,o,a)}const $E=fe({gather_:O0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R0e(e,t){let n=J(e,"a","greater","string_or_numeric"),s=J(t,"b","greater","string_or_numeric");[n,s]=ls(n,s),Ft(n.shape,s.shape);const r={a:n,b:s};return ae.runKernel(lb,r)}const Ri=fe({greater_:R0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L0e(e,t){let n=J(e,"a","greaterEqual","string_or_numeric"),s=J(t,"b","greaterEqual","string_or_numeric");[n,s]=ls(n,s),Ft(n.shape,s.shape);const r={a:n,b:s};return ae.runKernel(mg,r)}const dh=fe({greaterEqual_:L0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F0e(e){const n={input:J(e,"input","imag")};return ae.runKernel(jT,n)}const BE=fe({imag_:F0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $0e(e){const n={x:J(e,"x","isFinite")};return ae.runKernel(yg,n)}const B0e=fe({isFinite_:$0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z0e(e){const n={x:J(e,"x","isInf")};return ae.runKernel(vg,n)}const U0e=fe({isInf_:z0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V0e(e){const n={x:J(e,"x","isNaN")};return ae.runKernel(xg,n)}const G0e=fe({isNaN_:V0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W0e(e,t=.2){const s={x:J(e,"x","leakyRelu")},r={alpha:t};return ae.runKernel(cb,s,r)}const zE=fe({leakyRelu_:W0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H0e(e,t){let n=J(e,"a","less","string_or_numeric"),s=J(t,"b","less","string_or_numeric");[n,s]=ls(n,s),Ft(n.shape,s.shape);const r={a:n,b:s};return ae.runKernel(ub,r)}const ez=fe({less_:H0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j0e(e,t){let n=J(e,"a","lessEqual","string_or_numeric"),s=J(t,"b","lessEqual","string_or_numeric");[n,s]=ls(n,s),Ft(n.shape,s.shape);const r={a:n,b:s};return ae.runKernel(hb,r)}const Mp=fe({lessEqual_:j0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q0e(e,t=5,n=1,s=1,r=.5){const i=J(e,"x","localResponseNormalization");W(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),W(yp(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=i,a=!1;i.rank===3&&(a=!0,o=pe(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:o},c={depthRadius:t,bias:n,alpha:s,beta:r},h=ae.runKernel(mb,l,c);return a?pe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const X0e=fe({localResponseNormalization_:q0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K0e(e){const n={x:J(e,"x","log","float32")};return ae.runKernel(bg,n)}const qa=fe({log_:K0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y0e(e){const n={x:J(e,"x","log1p")};return ae.runKernel(wg,n)}const tz=fe({log1p_:Y0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q0e(e,t){W(yT(e),()=>"The f passed in variableGrads(f) must be a function"),W(t==null||Array.isArray(t)&&t.every(c=>c instanceof Yb),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=t!=null;if(!n){t=[];for(const c in ae.registeredVariables)t.push(ae.registeredVariables[c])}const s=n?t.filter(c=>!c.trainable):null,r=t.length;t=t.filter(c=>c.trainable),W(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:o,grads:a}=ae.gradients(e,t,null,i);W(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),W(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return t.forEach((c,h)=>{a[h]!=null&&(l[c.name]=a[h])}),s!=null&&s.forEach(c=>l[c.name]=null),{value:o,grads:l}}function Pp(e){return ae.customGrad(e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z0e(e){const n={x:J(e,"x","neg")};return ae.runKernel(Sb,n)}const xs=fe({neg_:Z0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J0e(e){const n={x:J(e,"x","softplus")};return ae.runKernel(Fg,n)}const Jg=fe({softplus_:J0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eye(e){const t=J(e,"x","logSigmoid");return Pp(s=>({value:xs(Jg(xs(s))),gradFunc:o=>le(o,Np(xs(s)))}))(t)}const tye=fe({logSigmoid_:eye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nye(e,t){let n=J(e,"a","sub"),s=J(t,"b","sub");[n,s]=ls(n,s);const r={a:n,b:s};return ae.runKernel(zg,r)}const Nt=fe({sub_:nye});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sye(e,t=-1){const n=J(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Pp((r,i)=>{const o=!0,a=qo(r,t,!0),l=Nt(r,a),c=Nt(rt(l,"float32"),qa(xt(Ml(l),t,o)));return i([c]),{value:c,gradFunc:(u,d)=>{const[p]=d,f=!0,g=Ml(p);return Nt(u,le(xt(u,t,f),g))}}})(n)}const nz=fe({logSoftmax_:sye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rye(e,t=null,n=!1){const s=J(e,"x","logSumExp"),r=Ht(t,s.shape),i=qo(s,r,!0),o=Nt(s,i),a=Ml(o),l=xt(a,r),c=qa(l),h=ze(pe(i,c.shape),c);if(n){const u=vs(h.shape,r);return pe(h,u)}return h}const iye=fe({logSumExp_:rye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oye(e,t){const n=J(e,"a","logicalAnd","bool"),s=J(t,"b","logicalAnd","bool");Ft(n.shape,s.shape);const r={a:n,b:s};return ae.runKernel(db,r)}const Pl=fe({logicalAnd_:oye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aye(e){const n={x:J(e,"x","logicalNot","bool")};return ae.runKernel(pb,n)}const UE=fe({logicalNot_:aye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lye(e,t){const n=J(e,"a","logicalOr","bool"),s=J(t,"b","logicalOr","bool");Ft(n.shape,s.shape);const r={a:n,b:s};return ae.runKernel(fb,r)}const sz=fe({logicalOr_:lye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cye(e,t){const n=J(e,"a","logicalXor","bool"),s=J(t,"b","logicalXor","bool");return Ft(n.shape,s.shape),Pl(sz(e,t),UE(Pl(e,t)))}const uye=fe({logicalXor_:cye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hye(e,t,n,s,r){const i=J(e,"x","maxPool"),o=1;let a=i,l=!1;i.rank===3&&(l=!0,a=pe(i,[1,i.shape[0],i.shape[1],i.shape[2]])),W(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),W(cr(n,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),Hr("maxPool",s,r);const c={x:a},h={filterSize:t,strides:n,pad:s,dimRoundingMode:r},u=ae.runKernel(yb,c,h);return l?pe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const VE=fe({maxPool_:hye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dye(e,t=[1,1,1],n,s,r,i="NDHWC"){const o=J(e,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=pe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),W(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),W(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Hr("maxPool3d",s,r);const c={x:a},h={filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:i},u=ae.runKernel(vb,c,h);return l?pe(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}const pye=fe({maxPool3d_:dye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fye(e,t){let n=J(e,"a","maximum"),s=J(t,"b","maximum");[n,s]=ls(n,s),n.dtype==="bool"&&(n=rt(n,"int32"),s=rt(s,"int32")),Ft(n.shape,s.shape);const r={a:n,b:s};return ae.runKernel(Sg,r)}const $c=fe({maximum_:fye});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mye(e,t=null,n=!1){const r={x:J(e,"x","mean")},i={axis:t,keepDims:n};return ae.runKernel(xb,r,i)}const bs=fe({mean_:mye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bs(e,t="float32"){if(Il(e),t==="complex64"){const s=Bs(e,"float32"),r=Bs(e,"float32");return Ep(s,r)}const n=ar(Ae(e),t);return ae.makeTensor(n,e,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ph(e,t="float32"){if(Il(e),t==="complex64"){const s=ph(e,"float32"),r=Bs(e,"float32");return Ep(s,r)}const n=xT(Ae(e),t);return ae.makeTensor(n,e,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gye(e,t){let n=J(e,"a","minimum"),s=J(t,"b","minimum");[n,s]=ls(n,s),n.dtype==="bool"&&(n=rt(n,"int32"),s=rt(s,"int32")),Ft(n.shape,s.shape);const r={a:n,b:s};return ae.runKernel(_g,r)}const GE=fe({minimum_:gye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yye(e,t,n){W(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=J(e,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");W(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const r=n==="reflect"?1:0;for(let a=0;a<s.rank;a++)W(t[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),W(t[a][0]>=0&&t[a][0]<=s.shape[a]-r&&t[a][1]>=0&&t[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:t,mode:n},o={x:s};return ae.runKernel(wb,o,i)}const vye=fe({mirrorPad_:yye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xye(e,t){let n=J(e,"a","mod"),s=J(t,"b","mod");[n,s]=ls(n,s);const r={a:n,b:s};return ae.runKernel(Cg,r)}const bye=fe({mod_:xye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wye(e,t=null,n=!1){e=J(e,"x","moments");const s=Ht(t,e.shape),r=bs(e,s,n);let i=r.shape;n||(i=vs(r.shape,s));const o=zn(Nt(rt(e,"float32"),pe(r,i))),a=bs(o,s,n);return{mean:r,variance:a}}const WE=fe({moments_:wye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sye(e,t){let n=J(e,"a","notEqual","string_or_numeric"),s=J(t,"b","notEqual","string_or_numeric");[n,s]=ls(n,s),Ft(n.shape,s.shape);const r={a:n,b:s};return ae.runKernel(_b,r)}const o1=fe({notEqual_:Sye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ye(e,t,n=1,s=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:J(e,"indices","oneHot","int32")},a={dtype:r,depth:t,onValue:n,offValue:s};return ae.runKernel(Tb,o,a)}const rz=fe({oneHot_:_ye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cye(e){const n={x:J(e,"x","onesLike")};return ae.runKernel(Cb,n)}const ho=fe({onesLike_:Cye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tye(e,t,n=0){const s=J(e,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},i={x:s};return ae.runKernel(Ab,i,r)}const HE=fe({pad_:Tye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eye(e,t,n){const s=J(e,"x","spaceToBatchND");W(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),W(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),W(s.shape.reduce((o,a,l)=>l>0&&l<=t.length?o&&(a+n[l-1][0]+n[l-1][1])%t[l-1]==0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);const r={x:s},i={blockShape:t,paddings:n};return ae.runKernel(Fb,r,i)}const jE=fe({spaceToBatchND_:Eye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aye(e,t,n,s,r,i,o){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const a=J(e,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=pe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),W(cr(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const h=uo(l.shape,t,i,r,s),u=[h.dilationHeight,h.dilationWidth];let d;s==="same"?d=Nye([h.filterHeight,h.filterWidth],u):d=[[0,0],[0,0]];const p=u[0]===1&&u[1]===1,[f,g]=Iye([h.inHeight,h.inWidth],u,d),m=p?s:"valid",y=p?l:jE(l,u,f),b=(n==="avg"?()=>kE(y,t,i,m,o):()=>VE(y,t,i,m,o))(),x=p?b:ME(b,u,g);return c?pe(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function Iye(e,t,n){const s=n.map(h=>h[0]),r=n.map(h=>h[1]),i=e.concat(s,r),o=t.map((h,u)=>(h-i[u]%h)%h),a=r.map((h,u)=>h+o[u]),l=t.map((h,u)=>[s[u],a[u]]),c=t.map((h,u)=>[0,o[u]]);return[l,c]}function Nye(e,t){const s=e.map((o,a)=>o+(o-1)*(t[a]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),i=s.map((o,a)=>o-r[a]);return s.map((o,a)=>[r[a],i[a]])}const kye=fe({pool_:Aye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dye(e,t){const n=J(e,"x","prelu"),s=J(t,"alpha","prelu"),r={x:n,alpha:s};return ae.runKernel(Ib,r)}const qE=fe({prelu_:Dye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mye(e,t=null,n=!1){let s=J(e,"x","prod");s.dtype==="bool"&&(s=rt(s,"int32"));const r={x:s},i={axis:t,keepDims:n};return ae.runKernel(Nb,r,i)}const Pye=fe({prod_:Mye});var iz={exports:{}};(function(e){(function(t,n,s){function r(l){var c=this,h=a();c.next=function(){var u=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=u-(c.c=u|0)},c.c=1,c.s0=h(" "),c.s1=h(" "),c.s2=h(" "),c.s0-=h(l),c.s0<0&&(c.s0+=1),c.s1-=h(l),c.s1<0&&(c.s1+=1),c.s2-=h(l),c.s2<0&&(c.s2+=1),h=null}function i(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function o(l,c){var h=new r(l),u=c&&c.state,d=h.next;return d.int32=function(){return h.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,u&&(typeof u=="object"&&i(u,h),d.state=function(){return i(h,{})}),d}function a(){var l=4022871197,c=function(h){h=String(h);for(var u=0;u<h.length;u++){l+=h.charCodeAt(u);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return c}n&&n.exports?n.exports=o:s&&s.amd?s(function(){return o}):this.alea=o})(uu,e,!1)})(iz);var oz={exports:{}};(function(e){(function(t,n,s){function r(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var u=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^u^u>>>8},a===(a|0)?l.x=a:c+=a;for(var h=0;h<c.length+64;h++)l.x^=c.charCodeAt(h)|0,l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var c=new r(a),h=l&&l.state,u=function(){return(c.next()>>>0)/4294967296};return u.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},u.int32=c.next,u.quick=u,h&&(typeof h=="object"&&i(h,c),u.state=function(){return i(c,{})}),u}n&&n.exports?n.exports=o:s&&s.amd?s(function(){return o}):this.xor128=o})(uu,e,!1)})(oz);var az={exports:{}};(function(e){(function(t,n,s){function r(a){var l=this,c="";l.next=function(){var u=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(u^u<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var h=0;h<c.length+64;h++)l.x^=c.charCodeAt(h)|0,h==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var c=new r(a),h=l&&l.state,u=function(){return(c.next()>>>0)/4294967296};return u.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},u.int32=c.next,u.quick=u,h&&(typeof h=="object"&&i(h,c),u.state=function(){return i(c,{})}),u}n&&n.exports?n.exports=o:s&&s.amd?s(function(){return o}):this.xorwow=o})(uu,e,!1)})(az);var lz={exports:{}};(function(e){(function(t,n,s){function r(a){var l=this;l.next=function(){var h=l.x,u=l.i,d,p;return d=h[u],d^=d>>>7,p=d^d<<24,d=h[u+1&7],p^=d^d>>>10,d=h[u+3&7],p^=d^d>>>3,d=h[u+4&7],p^=d^d<<7,d=h[u+7&7],d=d^d<<13,p^=d^d<<9,h[u]=p,l.i=u+1&7,p};function c(h,u){var d,p=[];if(u===(u|0))p[0]=u;else for(u=""+u,d=0;d<u.length;++d)p[d&7]=p[d&7]<<15^u.charCodeAt(d)+p[d+1&7]<<13;for(;p.length<8;)p.push(0);for(d=0;d<8&&p[d]===0;++d);for(d==8&&(p[7]=-1),h.x=p,h.i=0,d=256;d>0;--d)h.next()}c(l,a)}function i(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var c=new r(a),h=l&&l.state,u=function(){return(c.next()>>>0)/4294967296};return u.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},u.int32=c.next,u.quick=u,h&&(h.x&&i(h,c),u.state=function(){return i(c,{})}),u}n&&n.exports?n.exports=o:s&&s.amd?s(function(){return o}):this.xorshift7=o})(uu,e,!1)})(lz);var cz={exports:{}};(function(e){(function(t,n,s){function r(a){var l=this;l.next=function(){var h=l.w,u=l.X,d=l.i,p,f;return l.w=h=h+1640531527|0,f=u[d+34&127],p=u[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=u[d]=f^p,l.i=d,f+(h^h>>>16)|0};function c(h,u){var d,p,f,g,m,y=[],v=128;for(u===(u|0)?(p=u,u=null):(u=u+"\0",p=0,v=Math.max(v,u.length)),f=0,g=-32;g<v;++g)u&&(p^=u.charCodeAt((g+32)%u.length)),g===0&&(m=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,g>=0&&(m=m+1640531527|0,d=y[g&127]^=p+m,f=d==0?f+1:0);for(f>=128&&(y[(u&&u.length||0)&127]=-1),f=127,g=4*128;g>0;--g)p=y[f+34&127],d=y[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,y[f]=p^d;h.w=m,h.X=y,h.i=f}c(l,a)}function i(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var c=new r(a),h=l&&l.state,u=function(){return(c.next()>>>0)/4294967296};return u.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},u.int32=c.next,u.quick=u,h&&(h.X&&i(h,c),u.state=function(){return i(c,{})}),u}n&&n.exports?n.exports=o:s&&s.amd?s(function(){return o}):this.xor4096=o})(uu,e,!1)})(cz);var uz={exports:{}};(function(e){(function(t,n,s){function r(a){var l=this,c="";l.next=function(){var u=l.b,d=l.c,p=l.d,f=l.a;return u=u<<25^u>>>7^d,d=d-p|0,p=p<<24^p>>>8^f,f=f-u|0,l.b=u=u<<20^u>>>12^d,l.c=d=d-p|0,l.d=p<<16^d>>>16^f,l.a=f-u|0},l.a=0,l.b=0,l.c=2654435769|0,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var h=0;h<c.length+20;h++)l.b^=c.charCodeAt(h)|0,l.next()}function i(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var c=new r(a),h=l&&l.state,u=function(){return(c.next()>>>0)/4294967296};return u.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},u.int32=c.next,u.quick=u,h&&(typeof h=="object"&&i(h,c),u.state=function(){return i(c,{})}),u}n&&n.exports?n.exports=o:s&&s.amd?s(function(){return o}):this.tychei=o})(uu,e,!1)})(uz);var hz={exports:{}};(function(e){(function(t,n,s){var r=256,i=6,o=52,a="random",l=s.pow(r,i),c=s.pow(2,o),h=c*2,u=r-1,d;function p(x,w,S){var C=[];w=w==!0?{entropy:!0}:w||{};var _=y(m(w.entropy?[x,b(n)]:x==null?v():x,3),C),T=new f(C),E=function(){for(var A=T.g(i),D=l,O=0;A<c;)A=(A+O)*r,D*=r,O=T.g(1);for(;A>=h;)A/=2,D/=2,O>>>=1;return(A+O)/D};return E.int32=function(){return T.g(4)|0},E.quick=function(){return T.g(4)/4294967296},E.double=E,y(b(T.S),n),(w.pass||S||function(A,D,O,P){return P&&(P.S&&g(P,T),A.state=function(){return g(T,{})}),O?(s[a]=A,D):A})(E,_,"global"in w?w.global:this==s,w.state)}function f(x){var w,S=x.length,C=this,_=0,T=C.i=C.j=0,E=C.S=[];for(S||(x=[S++]);_<r;)E[_]=_++;for(_=0;_<r;_++)E[_]=E[T=u&T+x[_%S]+(w=E[_])],E[T]=w;(C.g=function(A){for(var D,O=0,P=C.i,L=C.j,B=C.S;A--;)D=B[P=u&P+1],O=O*r+B[u&(B[P]=B[L=u&L+D])+(B[L]=D)];return C.i=P,C.j=L,O})(r)}function g(x,w){return w.i=x.i,w.j=x.j,w.S=x.S.slice(),w}function m(x,w){var S=[],C=typeof x,_;if(w&&C=="object")for(_ in x)try{S.push(m(x[_],w-1))}catch{}return S.length?S:C=="string"?x:x+"\0"}function y(x,w){for(var S=x+"",C,_=0;_<S.length;)w[u&_]=u&(C^=w[u&_]*19)+S.charCodeAt(_++);return b(w)}function v(){try{var x;return d&&(x=d.randomBytes)?x=x(r):(x=new Uint8Array(r),(t.crypto||t.msCrypto).getRandomValues(x)),b(x)}catch{var w=t.navigator,S=w&&w.plugins;return[+new Date,t,S,t.screen,b(n)]}}function b(x){return String.fromCharCode.apply(0,x)}if(y(s.random(),n),e.exports){e.exports=p;try{d=require("crypto")}catch{}}else s["seed"+a]=p})(typeof self!="undefined"?self:uu,[],Math)})(hz);var Oye=iz.exports,Rye=oz.exports,Lye=az.exports,Fye=lz.exports,$ye=cz.exports,Bye=uz.exports,fh=hz.exports;fh.alea=Oye;fh.xor128=Rye;fh.xorwow=Lye;fh.xorshift7=Fye;fh.xor4096=$ye;fh.tychei=Bye;var Op=fh;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dz{constructor(t,n,s,r,i){this.mean=t,this.stdDev=n,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=Op.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let t,n,s=!1;for(;!s;){let r,i,o;do r=2*this.random()-1,i=2*this.random()-1,o=r*r+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*r*a,n=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class zye{constructor(t=0,n=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=n-t,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${n} <= 1 and dtype is not float`);this.random=Op.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uye(e,t=0,n=1,s,r){if(Il(e),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new dz(t,n,s,!1,r),o=jt(e,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const Vye=fe({randomNormal_:Uye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gye(e,t=0,n=1,s="float32",r){Il(e);const i=jt(e,s),o=new zye(t,n,null,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const a1=fe({randomUniform_:Gye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e0(e,t,n=1,s="float32"){if(n===0)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:s};return ae.runKernel(JT,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wye(e){const n={input:J(e,"input","real")};return ae.runKernel(eE,n)}const l1=fe({real_:Wye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hye(e){const n={x:J(e,"x","reciprocal")};return ae.runKernel(Ag,n)}const jye=fe({reciprocal_:Hye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qye(e){const n={x:J(e,"x","relu")};return ae.runKernel(Ig,n)}const mh=fe({relu_:qye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xye(e){const n={x:J(e,"x","relu6")};return ae.runKernel(Ng,n)}const pz=fe({relu6_:Xye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kye(e,t){const s={x:J(e,"x","reverse")},r={dims:t};return ae.runKernel(Pb,s,r)}const gh=fe({reverse_:Kye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yye(e){const n={x:J(e,"x","round")};return ae.runKernel(kg,n)}const fz=fe({round_:Yye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qye(e){const n={x:J(e,"x","rsqrt","float32")};return ae.runKernel(Dg,n)}const mz=fe({rsqrt_:Qye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zye(e){const n={x:J(e,"x","selu")};return ae.runKernel(Mg,n)}const gz=fe({selu_:Zye});function Jye(e,t,n,s,r,i=[1,1],o="NHWC"){const a=J(e,"x","separableConv2d"),l=J(t,"depthwiseFilter","separableConv2d"),c=J(n,"pointwiseFilter","separableConv2d");let h=a,u=!1;if(a.rank===3&&(u=!0,h=pe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");W(h.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),W(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),W(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),W(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),W(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const d=l.shape[2],p=l.shape[3];W(c.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${c.shape[2]}.`);const f=LE(h,l,s,r,o,i),m=hh(f,c,1,"valid",o);return u?pe(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const yz=fe({separableConv2d_:Jye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eve(e){const n={x:J(e,"x","sign")};return ae.runKernel(Rg,n)}const tve=fe({sign_:eve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nve(e){const n={x:J(e,"x","sin","float32")};return ae.runKernel(Pg,n)}const vz=fe({sin_:nve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sve(e){const n={x:J(e,"x","sinh")};return ae.runKernel(Og,n)}const xz=fe({sinh_:sve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rve(e,t,n){const s=J(e,"x","slice1d");return W(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),kn(s,[t],[n])}const XE=fe({slice1d_:rve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ive(e,t,n){const s=J(e,"x","slice2d");return W(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),kn(s,t,n)}const bz=fe({slice2d_:ive});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ove(e,t,n){const s=J(e,"x","slice3d");return W(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),kn(s,t,n)}const KE=fe({slice3d_:ove});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ave(e,t,n){const s=J(e,"x","slice4d");return W(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),kn(s,t,n)}const c1=fe({slice4d_:ave});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lve(e,t=-1){const n=J(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const s={logits:n},r={dim:t};return ae.runKernel(Bb,s,r)}const YE=fe({softmax_:lve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cve(e){W(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);const t={input:e};return ae.runKernel(VT,t)}const wz=fe({fft_:cve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uve(e){W(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);const t={input:e};return ae.runKernel(HT,t)}const QE=fe({ifft_:uve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hve(e){const t=e.shape[e.shape.length-1],n=e.size/t;let s;if(t<=2){const r=pe(e,[n,t]);s=QE(r)}else{const r=[n,2*(t-1)],i=pe(l1(e),[n,t]),o=pe(BE(e),[n,t]),a=gh(kn(i,[0,1],[n,t-2]),1),l=le(gh(kn(o,[0,1],[n,t-2]),1),fn(-1)),c=jr([i,a],1),h=jr([o,l],1),u=pe(Ep(c,h),[r[0],r[1]]);s=QE(u)}if(s=l1(s),e.rank===3&&e.shape[0]!==0){const r=s,i=e.shape[0];s=pe(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const dve=fe({irfft_:hve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pve(e,t,n=0){const r={x:J(e,"x","split")},i={numOrSizeSplits:t,axis:n};return ae.runKernel($b,r,i)}const Li=fe({split_:pve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fve(e,t){W(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const s=e.size/n;let r;if(t!=null&&t<n){const f=e.shape.map(m=>0),g=e.shape.map(m=>m);g[e.shape.length-1]=t,r=kn(e,f,g),n=t}else if(t!=null&&t>n){const f=e.shape.map(g=>g);f[e.shape.length-1]=t-n,r=jr([e,Bs(f)],e.shape.length-1),n=t}else r=e;const i=Jt(r),o=pe(Ep(r,i),[s,n]),a=wz(o),l=Math.floor(n/2)+1,c=l1(a),h=BE(a),u=Li(c,[l,n-l],c.shape.length-1),d=Li(h,[l,n-l],h.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,pe(Ep(u[0],d[0]),p)}const mve=fe({rfft_:fve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gve(e,t){let n=J(e,"a","squaredDifference"),s=J(t,"b","squaredDifference");[n,s]=ls(n,s),Ft(n.shape,s.shape);const r={a:n,b:s},i={};return ae.runKernel(Bg,r,i)}const yve=fe({squaredDifference_:gve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vve(e,t){const n=J(e,"x","squeeze","string_or_numeric");return pe(n,kc(n.shape,t).newShape)}const t0=fe({squeeze_:vve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xve(e,t=0){const n=IB(e,"tensors","stack","string_or_numeric");W(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&W(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const s=n,r={axis:t};return ae.runKernel(Eb,s,r)}const Bc=fe({stack_:xve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bve(e,t=0){const s={x:J(e,"x","step")},r={alpha:t};return ae.runKernel(Wg,s,r)}const n0=fe({step_:bve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wve(e,t,n,s,r=0,i=0,o=0,a=0,l=0){const h={x:J(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:s,beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return ae.runKernel(rE,h,u)}const Sve=fe({stridedSlice_:wve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ve(e){const n={x:J(e,"x","tan","float32")};return ae.runKernel(Ug,n)}const Cve=fe({tan_:_ve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fi(e,t){C$(e);const n=Qb(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Zb(e,null,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZE(e,t,n){if(C$(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Qb(e,n);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Zb(e,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tve(e,t=1,n=!0){const s=J(e,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const i={x:s},o={k:t,sorted:n},[a,l]=ae.runKernel(iE,i,o);return{values:a,indices:l}}const Eve=fe({topk_:Tve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ave(e,t=0,n=1,s,r){if(Il(e),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new dz(t,n,s,!0,r),o=jt(e,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const Sz=fe({truncatedNormal_:Ave});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ive(e,t=0){const n=J(e,"x","unique","string_or_numeric");W(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:t},[i,o]=ae.runKernel(aE,s,r);return{values:i,indices:o}}const Nve=fe({unique_:Ive});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kve(e,t,n){const s=J(e,"x","unsortedSegmentSum"),r=J(t,"segmentIds","unsortedSegmentSum","int32");W(yp(n),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},o={numSegments:n};return ae.runKernel(Ub,i,o)}const _z=fe({unsortedSegmentSum_:kve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dve(e,t=0){const n=J(e,"x","unstack","string_or_numeric");W(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);const s={value:n},r={axis:t};return ae.runKernel(zb,s,r)}const yh=fe({unstack_:Dve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mve(e,t=!0,n,s){return ae.makeVariable(e,t,n,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cz(e,t){const n=[];for(let i=0;i<t.length;i++)t[i]&&n.push(i);const s=jt(e,"int32"),r=jt([n.length,e.length],"int32");for(let i=0;i<n.length;i++){const o=s.indexToLoc(n[i]),a=i*e.length;r.values.set(o,a)}return r.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pve(e,t,n){const s=J(e,"x","transpose");if(t==null&&(t=s.shape.map((o,a)=>a).reverse()),W(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(o=>{W(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:t};return s.dtype==="complex64"?ye(()=>{let o=l1(s),a=BE(s);return o=ae.runKernel(wp,{x:o},i),a=ae.runKernel(wp,{x:a},i),n&&(a=xs(a)),Ep(o,a)}):ae.runKernel(wp,r,i)}const Zt=fe({transpose_:Pve});function Tz(e,t,n){const s=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(i+` update.rank < ${r}. `);if(e.length<s+(n.rank-r))throw new Error(i+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+e.length-s)throw new Error(i+` update.rank != ${r+e.length-s}`);for(let o=0;o<r;++o)if(n.shape[o]!==t.shape[o])throw new Error(i+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<n.rank-r;++o)if(n.shape[o+r]!==e[o+s])throw new Error(i+` updates.shape[${o+r}] (${n.shape[o+r]}) != shape[${o+r}] (${e[o+r]})`)}function Ove(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Tz(n,t,e)}function s0(e,t,n){const s=t.shape.length,r=s>1?t.shape[s-1]:1,i=n.length;let o=1;for(let u=r;u<i;++u)o*=n[u];const a=r<1?1:r,l=Ae(t.shape)/a,c=[...gt(n.slice(0,r)),1],h=Ae(n);return{sliceRank:r,numUpdates:l,sliceSize:o,strides:c,outputSize:h}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rve(e,t){if(t==null)return e.shape.slice();if(dn(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let s=0;s<e.shape.length;s++)t[s]==null&&e.shape[s]!=null?n.push(e.shape[s]):n.push(t[s]);return n}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lve(e,t,n,s){const r=J(e,"x","dropout");if(W(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),W(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof ys?r.clone():r;const i=Rve(r,n),o=1-t,a=St(i1(ze(a1(i,0,1,"float32",s),o)),o);return le(r,a)}const Fve=fe({dropout_:Lve});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ve(e,t,n,s,r,i="NHWC",o){let a=e;e.rank===3&&(a=pe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=pe(t,[1,t.shape[0],t.shape[1],t.shape[2]])),W(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),W(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),W(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c=i==="NHWC"?a.shape[3]:a.shape[1],h=i==="NHWC"?l.shape[3]:l.shape[1];W(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),W(h===n[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${n[3]}).`),Hr("conv2dDerFilter",r,o);const u={x:a,dy:l},d={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:n};return ae.runKernel(kT,u,d)}const JE=fe({conv2DBackpropFilter_:$ve});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eA(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return le(e,n0(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function tA(e,t){let n=t;const s=Ts(e.shape,t.shape);return s.length>0&&(n=xt(n,s)),pe(n,e.shape)}function nA(e,t,n,s){if(t==="linear")return e;if(t==="relu")return mh(e);if(t==="elu")return n1(e);if(t==="relu6")return pz(e);if(t==="prelu")return qE(e,n);if(t==="leakyrelu")return zE(e,s);if(t==="sigmoid")return Np(e);throw new Error(`Unknown fused activation ${t}.`)}const sA=(e,t)=>!(e>0)||t==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bve({x:e,filter:t,strides:n,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(l=l||"linear",sA(ae.state.gradientDepth,l)===!1){W(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let S=hh(e,t,n,s,r,i,o);return a!=null&&(S=ze(S,a)),nA(S,l,c,h)}const u=J(e,"x","conv2d","float32"),d=J(t,"filter","conv2d","float32");let p=u,f=!1;u.rank===3&&(f=!0,p=pe(u,[1,u.shape[0],u.shape[1],u.shape[2]])),W(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),W(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),Hr("fused conv2d",s,o);const g=r==="NHWC"?p.shape[3]:p.shape[1];W(d.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${d.shape[2]}.`),W(cr(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);const m=Qs(p.shape,d.shape,n,i,s,o);let y;a!=null&&(y=J(a,"bias","fused conv2d"),[y]=ls(y,u),r==="NHWC"?Ft(m.outShape,y.shape):(W(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),W(y.shape.length===0||y.shape[0]===m.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${m.outChannels})`)));let v;if(c!=null){const S=c.shape;if(W(S.length<=1||S.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${S.length}.`),S.length===1)W(S[0]===1||S[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the number of output channels (${m.outChannels}).`);else if(S.length===3)try{Ft(S,m.outShape)}catch{const _=`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the output shape of the conv2d (${m.outShape}).`;throw Error(_)}v=J(c,"prelu weights","fused conv2d")}const b=(S,C)=>{W(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[_,T,E,A]=C,D=eA(S,E,l);W(ch(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const O=PE(T.shape,D,_,n,s),P=JE(T,D,_.shape,n,s),L=[O,P];if(A!=null){const B=tA(A,D);L.push(B)}return L},x={x:p,filter:d,bias:y,preluActivationWeights:v},w={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:h};return a==null?Pp((C,_,T)=>{let E=ae.runKernel(Wb,x,w);return T([_,C,E]),f&&(E=pe(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:b}})(p,d):Pp((C,_,T,E)=>{let A=ae.runKernel(Wb,x,w);return E([_,C,A,T]),f&&(A=pe(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:b}})(p,d,y)}const zve=fe({fusedConv2d_:Bve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uve(e,t,n,s,r,i=[1,1],o){let a=e;e.rank===3&&(a=pe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=pe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={x:a,dy:l},h={strides:s,pad:r,dimRoundingMode:o,dilations:i,filterShape:n};return ae.runKernel(FT,c,h)}const Vve=fe({depthwiseConv2dNativeBackpropFilter_:Uve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gve(e,t,n,s,r,i=[1,1],o){let a=t,l=!1;t.rank===3&&(l=!0,a=pe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={dy:a,filter:n},h={strides:s,pad:r,dimRoundingMode:o,dilations:i,inputShape:e},u=ae.runKernel($T,c,h);return l?pe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const Wve=fe({depthwiseConv2dNativeBackpropInput_:Gve});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hve({a:e,b:t,transposeA:n=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(sA(ae.state.gradientDepth,i)===!1){let A=pn(e,t,n,s);return r!=null&&(A=ze(A,r)),nA(A,i,o,a)}let l=J(e,"a","fused matMul"),c=J(t,"b","fused matMul");[l,c]=ls(l,c);const h=n?l.shape[l.rank-2]:l.shape[l.rank-1],u=s?c.shape[c.rank-1]:c.shape[c.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?c.shape[c.rank-2]:c.shape[c.rank-1],f=l.shape.slice(0,-2),g=c.shape.slice(0,-2),m=Ae(f),y=Ae(g);W(h===u,()=>`Error in fused matMul: inner shapes (${h}) and (${u}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${n} and transposeB=${s} must match.`);const b=Ft(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([d,p]),x=n?pe(l,[m,h,d]):pe(l,[m,d,h]),w=s?pe(c,[y,p,u]):pe(c,[y,u,p]);let S;r!=null&&(S=J(r,"bias","fused matMul"),[S]=ls(S,l),Ft(b,S.shape));let C;o!=null&&(C=J(o,"prelu weights","fused matMul"));const _=(A,D)=>{const[O,P,L,B]=D,F=eA(pe(A,L.shape),L,i);let M,U;if(!n&&!s?(M=pn(F,P,!1,!0),U=pn(O,F,!0,!1)):!n&&s?(M=pn(F,P,!1,!1),U=pn(F,O,!0,!1)):n&&!s?(M=pn(P,F,!1,!0),U=pn(O,F,!1,!1)):(M=pn(P,F,!0,!0),U=pn(F,O,!0,!0)),r!=null){const z=tA(B,F);return[M,U,z]}else return[M,U]},T={a:x,b:w,bias:S,preluActivationWeights:C},E={transposeA:n,transposeB:s,activation:i,leakyreluAlpha:a};return r==null?Pp((D,O,P)=>{const L=ae.runKernel(Gb,T,E);return P([D,O,L]),{value:pe(L,b),gradFunc:_}})(x,w):Pp((D,O,P,L)=>{const B=ae.runKernel(Gb,T,E);return L([D,O,B,P]),{value:pe(B,b),gradFunc:_}})(x,w,S)}const Ez=fe({fusedMatMul_:Hve});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jve(e,t,n,s,r="bilinear",i=0){const o=J(e,"image","cropAndResize"),a=J(t,"boxes","cropAndResize","float32"),l=J(n,"boxInd","cropAndResize","int32"),c=a.shape[0];W(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),W(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),W(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),W(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),W(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),W(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const h={image:o,boxes:a,boxInd:l},u={method:r,extrapolationValue:i,cropSize:s};return ae.runKernel(OT,h,u)}const qve=fe({cropAndResize_:jve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xve(e){const t=J(e,"image","flipLeftRight","float32");W(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const n={image:t};return ae.runKernel(WT,n,{})}const Kve=fe({flipLeftRight_:Xve});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yve(e){const t=J(e,"image","grayscaleToRGB"),n=t.rank-1,s=t.shape[n];W(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),W(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,Xo(t,r)}const Qve=fe({grayscaleToRGB_:Yve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zve(e,t,n=0,s=.5){const r=J(e,"image","rotateWithOffset","float32");W(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},o={radians:t,fillValue:n,center:s};return ae.runKernel(lE,i,o)}const Jve=fe({rotateWithOffset_:Zve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rp(e,t,n,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=e.shape[0];return n=Math.min(n,o),W(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),W(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),W(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),W(t.rank===1,()=>"scores must be a 1D tensor"),W(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),W(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function exe(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY){const i=J(e,"boxes","nonMaxSuppression","float32"),o=J(t,"scores","nonMaxSuppression","float32"),a=Rp(i,o,n,s,r);n=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l={maxOutputSize:n,iouThreshold:s,scoreThreshold:r};return ae.runKernel(YT,{boxes:i,scores:o},l)}const txe=fe({nonMaxSuppression_:exe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nxe(e,t,n){const s=sxe(e,t,n),r=s<0?-(s+1):s;e.splice(r,0,t)}function sxe(e,t,n){return ixe(e,t,n||rxe)}function rxe(e,t){return e>t?1:e<t?-1:0}function ixe(e,t,n){let s=0,r=e.length,i=0,o=!1;for(;s<r;){i=s+(r-s>>>1);const a=n(t,e[i]);a>0?s=i+1:(r=i,o=!a)}return o?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rA(e,t,n,s,r){return aA(e,t,n,s,r,0)}function iA(e,t,n,s,r,i){return aA(e,t,n,s,r,0,!1,i,!0)}function oA(e,t,n,s,r,i){return aA(e,t,n,s,r,i,!0)}function aA(e,t,n,s,r,i,o=!1,a=!1,l=!1){const c=[];for(let m=0;m<t.length;m++)t[m]>r&&c.push({score:t[m],boxIndex:m,suppressBeginIndex:0});c.sort(Az);const h=i>0?-.5/i:0,u=[],d=[];for(;u.length<n&&c.length>0;){const m=c.pop(),{score:y,boxIndex:v,suppressBeginIndex:b}=m;if(y<r)break;let x=!1;for(let w=u.length-1;w>=b;--w){const S=oxe(e,v,u[w]);if(S>=s){x=!0;break}if(m.score=m.score*axe(s,h,S),m.score<=r)break}m.suppressBeginIndex=u.length,x||(m.score===y?(u.push(v),d.push(m.score)):m.score>r&&nxe(c,m,Az))}const p=u.length,f=n-p;a&&f>0&&(u.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:u};return o&&(g.selectedScores=d),l&&(g.validOutputs=p),g}function oxe(e,t,n){const s=e.subarray(t*4,t*4+4),r=e.subarray(n*4,n*4+4),i=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(r[0],r[2]),h=Math.min(r[1],r[3]),u=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(a-i)*(l-o),f=(u-c)*(d-h);if(p<=0||f<=0)return 0;const g=Math.max(i,c),m=Math.max(o,h),y=Math.min(a,u),v=Math.min(l,d),b=Math.max(y-g,0)*Math.max(v-m,0);return b/(p+f-b)}function axe(e,t,n){const s=Math.exp(t*n*n);return n<=e?s:0}function Az(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function lxe(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY){const i=J(e,"boxes","nonMaxSuppressionAsync"),o=J(t,"scores","nonMaxSuppressionAsync"),a=Rp(i,o,n,s,r);n=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),c=l[0],h=l[1],{selectedIndices:u}=rA(c,h,n,s,r);return i!==e&&i.dispose(),o!==t&&o.dispose(),Fi(u,"int32")}const cxe=lxe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uxe(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=J(e,"boxes","nonMaxSuppression"),a=J(t,"scores","nonMaxSuppression"),l=Rp(o,a,n,s,r,i);n=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c={boxes:o,scores:a},h={maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},u=ae.runKernel(ZT,c,h);return{selectedIndices:u[0],selectedScores:u[1]}}const hxe=fe({nonMaxSuppressionWithScore_:uxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function dxe(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=J(e,"boxes","nonMaxSuppressionAsync"),a=J(t,"scores","nonMaxSuppressionAsync"),l=Rp(o,a,n,s,r,i);n=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),h=c[0],u=c[1],{selectedIndices:d,selectedScores:p}=oA(h,u,n,s,r,i);return o!==e&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:Fi(d,"int32"),selectedScores:Fi(p)}}const pxe=dxe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fxe(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=J(e,"boxes","nonMaxSuppression"),a=J(t,"scores","nonMaxSuppression"),l=Rp(o,a,n,s,r,null),c=l.maxOutputSize,h=l.iouThreshold,u=l.scoreThreshold,d={boxes:o,scores:a},p={maxOutputSize:c,iouThreshold:h,scoreThreshold:u,padToMaxOutputSize:i},f=ae.runKernel(QT,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}const mxe=fe({nonMaxSuppressionPadded_:fxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function gxe(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=J(e,"boxes","nonMaxSuppressionAsync"),a=J(t,"scores","nonMaxSuppressionAsync"),l=Rp(o,a,n,s,r,null),c=l.maxOutputSize,h=l.iouThreshold,u=l.scoreThreshold,[d,p]=await Promise.all([o.data(),a.data()]),{selectedIndices:f,validOutputs:g}=iA(d,p,c,h,u,i);return o!==e&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:Fi(f,"int32"),validOutputs:fn(g,"int32")}}const yxe=gxe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vxe(e,t,n=!1,s=!1){const r=J(e,"images","resizeBilinear");W(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),W(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),W(s===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=pe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:n,halfPixelCenters:s,size:t},c=ae.runKernel(Mb,a,l);return o?pe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Iz=fe({resizeBilinear_:vxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xxe(e,t,n=!1,s=!1){const r=J(e,"images","resizeNearestNeighbor");W(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),W(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),W(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),W(s===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=pe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:n,halfPixelCenters:s,size:t},c=ae.runKernel(Db,a,l);return o?pe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Nz=fe({resizeNearestNeighbor_:xxe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bxe(e,t="binary",n=!1,s=.5){const r=J(e,"image","threshold"),i=.2989,o=.587,a=.114,l=r.shape[0]*r.shape[1];let c=le(Fi([s]),255),h,u,d,p;if(W(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),W(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),W(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),W(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[h,u,d]=Li(r,[1,1,1],-1);const m=le(h,i),y=le(u,o),v=le(d,a);p=ze(ze(m,y),v)}else p=e;if(t==="otsu"){const m=kge(rt(fz(p),"int32"),NB([]),256);c=wxe(m,l)}const f=n?Mp(p,c):Ri(p,c);return rt(le(f,255),"int32")}function wxe(e,t){let n=Fi([-1]),s=Fi([0]),r=Fi([0]),i,o,a,l,c,h;for(let u=0;u<e.size-1;u++){i=kn(e,0,u+1),o=kn(e,u+1),c=St(xt(i),t),h=St(xt(o),t);const d=xt(le(i,e0(0,i.size)));a=St(d,xt(i));const p=t1(o.shape,i.size),f=ze(e0(0,o.size),p),g=le(o,f);l=St(xt(g),xt(o));const m=Nt(a,l),y=Nt(a,l),v=le(c,h);r=le(le(v,m),y);const b=Ri(r,s);s=ci(b,r,s),n=ci(b,Fi([u]),n)}return n}const Sxe=fe({threshold_:bxe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _xe(e,t,n="nearest",s="constant",r=0,i){const o=J(e,"image","transform","float32"),a=J(t,"transforms","transform","float32");W(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),W(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),W(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:o,transforms:a},c={interpolation:n,fillMode:s,fillValue:r,outputShape:i};return ae.runKernel(oE,l,c)}const Cxe=fe({transform_:_xe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Txe(e,t,n){W(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),W(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const s=J(e,"a","bandPart");W(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,o]=s.shape.slice(-2);if(!(t<=i))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);t<0&&(t=i),n<0&&(n=o);const a=pe(e0(0,i,1,"int32"),[-1,1]),l=e0(0,o,1,"int32"),c=Nt(a,l),h=Pl(Mp(c,fn(+t,"int32")),dh(c,fn(-n,"int32"))),u=Bs([i,o],s.dtype);return pe(Bc(yh(pe(s,[-1,i,o])).map(d=>ci(h,d,u))),r)}const Exe=fe({bandPart_:Txe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Axe(e){let t;if(Array.isArray(e)){t=!1,W(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=e[0].shape[0];for(let i=1;i<e.length;++i)W(e[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[i].shape[0]} vs. ${r})`)}else t=!0,e=Li(e,e.shape[0],0).map(r=>t0(r,[0]));W(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],s=e;for(let r=0;r<e.length;++r)n.push(ae.tidy(()=>{let i=s[r];if(r>0)for(let o=0;o<r;++o){const a=le(xt(le(n[o],i)),n[o]);i=Nt(i,a)}return St(i,r1(i,"euclidean"))}));return t?Bc(n,0):n}const Ixe=fe({gramSchmidt_:Axe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nxe(e,t=!1){if(W(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return kz(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((l,c)=>l*c),s=yh(pe(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],i=[];s.forEach(l=>{const[c,h]=kz(l,t);r.push(c),i.push(h)});const o=pe(Bc(r,0),e.shape),a=pe(Bc(i,0),e.shape);return[o,a]}}function kz(e,t=!1){return ae.tidy(()=>{W(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],s=e.shape[1];let r=JB(n),i=lh(e);const o=ZE([[1]],[1,1]);let a=lh(o);const l=n>=s?s:n;for(let c=0;c<l;++c){const h=i,u=a,d=r;[a,i,r]=ae.tidy(()=>{const p=kn(i,[c,c],[n-c,1]),f=r1(p),g=kn(i,[c,c],[1,1]),m=ci(Ri(g,0),ZE([[-1]]),ZE([[1]])),y=Nt(g,le(m,f)),v=St(p,y);v.shape[0]===1?a=lh(o):a=jr([o,kn(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);const b=xs(St(pn(m,y),f)),x=kn(i,[c,0],[n-c,s]),w=le(b,a),S=Zt(a);if(c===0)i=Nt(x,pn(w,pn(S,x)));else{const T=Nt(x,pn(w,pn(S,x)));i=jr([kn(i,[0,0],[c,s]),T],0)}const C=Zt(w),_=kn(r,[0,c],[n,r.shape[1]-c]);if(c===0)r=Nt(_,pn(pn(_,a),C));else{const T=Nt(_,pn(pn(_,a),C));r=jr([kn(r,[0,0],[n,c]),T],1)}return[a,i,r]}),qt([h,u,d])}return!t&&n>s&&(r=kn(r,[0,0],[n,s]),i=kn(i,[0,0],[s,s])),[r,i]})}const kxe=fe({qr_:Nxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Dz;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Dz||(Dz={}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vh={flipLeftRight:Kve,grayscaleToRGB:Qve,resizeNearestNeighbor:Nz,resizeBilinear:Iz,rotateWithOffset:Jve,cropAndResize:qve,nonMaxSuppression:txe,nonMaxSuppressionAsync:cxe,nonMaxSuppressionWithScore:hxe,nonMaxSuppressionWithScoreAsync:pxe,nonMaxSuppressionPadded:mxe,nonMaxSuppressionPaddedAsync:yxe,threshold:Sxe,transform:Cxe},Dxe={bandPart:Exe,gramSchmidt:Ixe,qr:kxe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lp{getClassName(){return this.constructor.className}static fromConfig(t,n){return new t(n)}}class po{constructor(){this.classNameMap={}}static getMap(){return po.instance==null&&(po.instance=new po),po.instance}static register(t){po.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function Fe(e){W(e.className!=null,()=>"Class being registered does not have the static className property defined."),W(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),W(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),po.register(e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zc extends Lp{minimize(t,n=!1,s){const{value:r,grads:i}=this.computeGradients(t,s);if(s!=null){const o=s.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return qt(i),n?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,n){return Q0e(t,n)}dispose(){this.iterations_!=null&&qt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:fn(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(zc,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mz extends zc{constructor(t,n,s=null){super();this.learningRate=t,this.rho=n,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=ae.backend.epsilon())}static get className(){return"Adadelta"}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=ae.registeredVariables[s],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:ye(()=>Jt(i).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:ye(()=>Jt(i).variable(o))});const a=Array.isArray(t)?t[r].tensor:t[s];if(a==null)return;const l=this.accumulatedGrads[r].variable,c=this.accumulatedUpdates[r].variable;ye(()=>{const h=ze(le(l,this.rho),le(zn(a),1-this.rho)),u=le(St(_r(ze(c,this.epsilon)),_r(ze(l,this.epsilon))),a),d=ze(le(c,this.rho),le(zn(u),1-this.rho));l.assign(h),c.assign(d);const p=ze(le(u,-this.learningRate),i);i.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(qt(this.accumulatedGrads.map(t=>t.variable)),qt(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=t.length/2,s=!1;this.accumulatedGrads=t.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=t.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pz extends zc{constructor(t,n=.1){super();this.learningRate=t,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}static get className(){return"Adagrad"}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=ae.registeredVariables[s];if(this.accumulatedGrads[r]==null){const l=!1;this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:ye(()=>t1(i.shape,this.initialAccumulatorValue).variable(l))}}const o=Array.isArray(t)?t[r].tensor:t[s];if(o==null)return;const a=this.accumulatedGrads[r].variable;ye(()=>{const l=ze(a,zn(o));a.assign(l);const c=ze(le(St(o,_r(ze(l,ae.backend.epsilon()))),-this.learningRate),i);i.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&qt(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oz extends zc{constructor(t,n,s,r=null){super();this.learningRate=t,this.beta1=n,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ye(()=>{this.accBeta1=fn(n).variable(),this.accBeta2=fn(s).variable()}),r==null&&(this.epsilon=ae.backend.epsilon())}static get className(){return"Adam"}applyGradients(t){const n=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);ye(()=>{const s=Nt(1,this.accBeta1),r=Nt(1,this.accBeta2);n.forEach((i,o)=>{const a=ae.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:ye(()=>Jt(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:ye(()=>Jt(a).variable(l))});const c=Array.isArray(t)?t[o].tensor:t[i];if(c==null)return;const h=this.accumulatedFirstMoment[o].variable,u=this.accumulatedSecondMoment[o].variable,d=ze(le(h,this.beta1),le(c,1-this.beta1)),p=ze(le(u,this.beta2),le(zn(c),1-this.beta2)),f=St(d,s),g=St(p,r);h.assign(d),u.assign(p);const m=ze(le(St(f,ze(_r(g),this.epsilon)),-this.learningRate),a);a.assign(m)}),this.accBeta1.assign(le(this.accBeta1,this.beta1)),this.accBeta2.assign(le(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&qt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&qt(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t),ye(()=>{this.accBeta1.assign(Dp(this.beta1,this.iterations_+1)),this.accBeta2.assign(Dp(this.beta2,this.iterations_+1))});const n=t.length/2,s=!1;this.accumulatedFirstMoment=t.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=t.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rz extends zc{constructor(t,n,s,r=null,i=0){super();this.learningRate=t,this.beta1=n,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ye(()=>{this.iteration=fn(0).variable(),this.accBeta1=fn(n).variable()}),r==null&&(this.epsilon=ae.backend.epsilon())}static get className(){return"Adamax"}applyGradients(t){const n=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);ye(()=>{const s=Nt(1,this.accBeta1),r=St(-this.learningRate,ze(le(this.iteration,this.decay),1));n.forEach((i,o)=>{const a=ae.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:Jt(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:Jt(a).variable(l)});const c=Array.isArray(t)?t[o].tensor:t[i];if(c==null)return;const h=this.accumulatedFirstMoment[o].variable,u=this.accumulatedWeightedInfNorm[o].variable,d=ze(le(h,this.beta1),le(c,1-this.beta1)),p=le(u,this.beta2),f=Sr(c),g=$c(p,f);h.assign(d),u.assign(g);const m=ze(le(St(r,s),St(d,ze(g,this.epsilon))),a);a.assign(m)}),this.iteration.assign(ze(this.iteration,1)),this.accBeta1.assign(le(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&qt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&qt(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lA extends zc{constructor(t){super();this.learningRate=t,this.setLearningRate(t)}static get className(){return"SGD"}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=Array.isArray(t)?t[r].tensor:t[s];if(i==null)return;const o=ae.registeredVariables[s];ye(()=>{const a=ze(le(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Ha(fn(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lz extends lA{constructor(t,n,s=!1){super(t);this.learningRate=t,this.momentum=n,this.useNesterov=s,this.accumulations=[],this.m=fn(this.momentum)}static get className(){return"Momentum"}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=ae.registeredVariables[s];if(this.accumulations[r]==null){const l=!1;this.accumulations[r]={originalName:`${s}/momentum`,variable:ye(()=>Jt(i).variable(l))}}const o=this.accumulations[r].variable,a=Array.isArray(t)?t[r].tensor:t[s];a!=null&&ye(()=>{let l;const c=ze(le(this.m,o),a);this.useNesterov?l=ze(le(this.c,ze(a,le(c,this.m))),i):l=ze(le(this.c,c),i),o.assign(c),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&qt(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fz extends zc{constructor(t,n=.9,s=0,r=null,i=!1){super();if(this.learningRate=t,this.decay=n,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=ae.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}static get className(){return"RMSProp"}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=ae.registeredVariables[s],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:ye(()=>Jt(i).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:ye(()=>Jt(i).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:ye(()=>Jt(i).variable(o))});const a=Array.isArray(t)?t[r].tensor:t[s];if(a==null)return;const l=this.accumulatedMeanSquares[r].variable,c=this.accumulatedMoments[r].variable;ye(()=>{const h=ze(le(l,this.decay),le(zn(a),1-this.decay));if(this.centered){const u=this.accumulatedMeanGrads[r].variable,d=ze(le(u,this.decay),le(a,1-this.decay)),p=St(le(a,this.learningRate),_r(Nt(h,ze(zn(d),this.epsilon)))),f=ze(le(c,this.momentum),p);l.assign(h),u.assign(d),c.assign(f);const g=Nt(i,f);i.assign(g)}else{const u=ze(le(l,this.decay),le(zn(a),1-this.decay)),d=ze(le(c,this.momentum),St(le(a,this.learningRate),_r(ze(u,this.epsilon))));l.assign(u),c.assign(d);const p=Nt(i,d);i.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&qt(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&qt(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&qt(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=this.centered?t.length/3:t.length/2,s=!1;this.accumulatedMeanSquares=t.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=t.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=t.slice(n*2,n*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mxe=[Mz,Pz,Oz,Rz,Lz,Fz,lA];function Pxe(){for(const e of Mxe)Fe(e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oxe="model",Rxe=".json",Lxe=".weights.bin";function $z(e){return new Promise(t=>setTimeout(t)).then(e)}class xh{constructor(t){if(!xe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(xh.URL_SCHEME)&&(t=t.slice(xh.URL_SCHEME.length)),(t==null||t.length===0)&&(t=Oxe),this.modelJsonFileName=t+Rxe,this.weightDataFileName=t+Lxe}async save(t){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],r=OB(t,s),i=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await $z(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){const a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=n,await $z(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Jb(t)}}}}xh.URL_SCHEME="downloads://";const Fxe=e=>xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(xh.URL_SCHEME)?$xe(e.slice(xh.URL_SCHEME.length)):null;Fs.registerSaveRouter(Fxe);function $xe(e="model"){return new xh(e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bz(e,t,n,s){o(e),n=n==null?0:n,s=s==null?1:s,a(n,s);let r=0;const i=l=>(l.then(c=>{const h=n+ ++r/e.length*(s-n);return t(h),c}),l);function o(l){W(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){W(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),W(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),W(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(e.map(i))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Bxe(e,t){t==null&&(t={});const n=t.fetchFunc==null?xe().platform.fetch:t.fetchFunc,s=e.map(u=>n(u,t.requestInit,{isBinary:!0})),r=0,i=.5,a=(t.onProgress==null?await Promise.all(s):await Bz(s,t.onProgress,r,i)).map(u=>u.arrayBuffer()),l=.5,c=1;return t.onProgress==null?await Promise.all(a):await Bz(a,t.onProgress,l,c)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zxe="application/octet-stream",Uxe="application/json";class cA{constructor(t,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.onProgress=n.onProgress,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(W(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=xe().platform.fetch,W(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&W(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r=OB(t,s);n.body.append("model.json",new Blob([JSON.stringify(r)],{type:Uxe}),"model.json"),t.weightData!=null&&n.body.append("model.weights.bin",new Blob([t.weightData],{type:zxe}),"model.weights.bin");const i=await this.fetch(this.path,n);if(i.ok)return{modelArtifactsInfo:Jb(t),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await t.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=n.modelTopology,r=n.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return mme(n,i=>this.loadWeights(i))}async loadWeights(t){const n=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=Vxe(n),i=this.weightPathPrefix||s,o=gme(t),a=[],l=[];for(const h of t)for(const u of h.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(u)):a.push(i+u+r);this.weightUrlConverter&&a.push(...await Promise.all(l));const c=await Bxe(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,PB(c)]}}cA.URL_SCHEME_REGEX=/^https?:\/\//;function Vxe(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),s=e.substring(0,t),r=n>t?e.substring(n):"";return[s+"/",r]}function zz(e){return e.match(cA.URL_SCHEME_REGEX)!=null}const Uz=(e,t)=>{if(typeof fetch=="undefined"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(s=>zz(s)):n=zz(e),n)return Gxe(e,t)}return null};Fs.registerSaveRouter(Uz);Fs.registerLoadRouter(Uz);function Gxe(e,t){return new cA(e,t)}function uA(e,t){const n=e.shape.length,s=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${n}`);if(Ae(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const r=t.shape,i=r[r.length-1];let o=1;for(let u=0;u<r.length-1;++u)o*=r[u];const a=e.shape,l=r.slice();l.pop();let c=1;for(let u=i;u<n;++u)c*=a[u],l.push(a[u]);const h=[...gt(e.shape).map(u=>u/c),1].slice(0,i);return[l,o,c,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hA=-2,Wxe=-1;function dA(e,t,n){const s=e.shape.length;W(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),W(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)W(t[r]+n[r]<=e.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`)}function Hxe(e){const t=[];let n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function pA(e,t,n){const s=[];for(let r=0;r<e.length;r++)s[r]=Math.ceil((t[r]-e[r])/n[r]);return s}function Vz(e,t,n,s){const r=[...e];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<n;i++)i===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function Gz(e,t,n){return n<=e?n:n-(t-1)}function Wz(e,t){const n=[];for(let s=0;s<e;s++)n.push(t+s);return n}function jxe(e,t,n,s,r,i,o,a,l){const c=e.length;let h=new Array(c),u=new Array(c),d=new Array(c);if(t.length&&n>0){const p=t[0],f=n+1;h=Hz(o,p,f,s,e),u=jz(a,p,f,r,e),d=Vz(i,p,f,e)}else for(let p=0;p<c;p++)h[p]=Xz(o,s,i,e,p,l),u[p]=Kz(a,r,i,e,p,l),d[p]=qz(i,p,l);return{begin:h,end:u,strides:d}}function Hz(e,t,n,s,r){const i=[...r],o=Wz(n,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=Gz(t,n,a);let c=s[l];e&1<<l&&(c=0),i[a]=c}return i}function jz(e,t,n,s,r){const i=[...r],o=Wz(n,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=Gz(t,n,a);let c=s[l];e&1<<l&&(c=Number.MAX_SAFE_INTEGER),i[a]=c}for(let a=0;a<i.length;a++){const l=r[a];i[a]<0&&(i[a]+=l),i[a]=Zu(0,i[a],r[a])}return i}function qz(e,t,n){let s=e[t];return(n&1<<t||s==null)&&(s=1),s}function Xz(e,t,n,s,r,i){let o=t[r];const a=n[r]||1;(e&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),o=Zu(0,o,l-1),o}function Kz(e,t,n,s,r,i){let o=t[r];const a=n[r]||1;(e&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),a>0?o=Zu(0,o,l):o=Zu(-1,o,l-1),o}function fA(e,t,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function mA(e,t){let n=e.length>0?e[e.length-1]:1;for(let s=0;s<e.length-1;s++)n+=e[s]*t[s];return n}function u1(e,t,n){let s;const r=e.shape.length;typeof t=="number"?s=[t,...new Array(r-1).fill(0)]:t.length<r?s=t.concat(new Array(r-t.length).fill(0)):s=t.slice(),s.forEach(o=>{W(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return n==null?i=new Array(r).fill(-1):typeof n=="number"?i=[n,...new Array(r-1).fill(-1)]:n.length<r?i=n.concat(new Array(r-n.length).fill(-1)):i=n,i=i.map((o,a)=>o>=0?o:(W(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),e.shape[a]-s[a])),[s,i]}function gA(e,t,n,s,r,i,o,a,l){let c;if(s==null?(c=new Array(t.length),c.fill(1)):c=s,o!=null&&(o&o-1)!=0)throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const u={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:c.slice(),beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let b=0;b<u.dims;b++)h&&(1<<b&a)!=0&&u.numAddAxisAfterEllipsis++,1<<b&o&&(h=!0);h||(u.ellipsisMask|=1<<u.dims,u.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};qxe(u,d);let p=!0,f=!0,g=!0;const m=[],y=[];for(let b=0;b<e.length;++b){if(d.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);const x=!!(d.shrinkAxisMask&1<<b),w=e[b];if(w===-1){m.push(x?1:-1);continue}const S=[d.beginMask&1<<b,d.endMask&1<<b],C=[d.strides[b]>0?0:-1,d.strides[b]>0?w:w-1];if(x&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&d.strides[b]===1;const _=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(x){const D=d.begin[b]<0?w+d.begin[b]:d.begin[b];if(d.begin[b]=D,d.end[b]=d.begin[b]+1,D<0||D>=w)throw Error(`slice index ${d.begin[b]} of dimension ${b} out of bounds.`)}else d.begin[b]=Yz(d.begin[b],0,d.strides[b],w,S,C),d.end[b]=Yz(d.end[b],1,d.strides[b],w,S,C);const A=d.strides[b]===1&&d.begin[b]===0&&d.end[b]===w;p=p&&A,f=f&&(b===0&&d.strides[b]===1||A)}else p=p&&d.strides[b]===1&&_,f=f&&(b===0&&d.strides[b]===1||_);let T,E=!1;if(d.beginValid&&d.endValid?(T=d.end[b]-d.begin[b],E=!0):x?(T=1,E=!0):_&&w>=0&&(d.strides[b]<0?T=-w:T=w,E=!0),E){let A;T===0||T<0!=d.strides[b]<0?A=0:A=Math.trunc(T/d.strides[b])+(T%d.strides[b]!=0?1:0),m.push(A)}else m.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){const x=d.finalShapeGatherIndices[b];x>=0?y.push(m[x]):x===hA&&y.push(1)}return{finalShapeSparse:y.filter((b,x)=>d.finalShapeGatherIndices[x]!==hA),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:d.begin,end:d.end,strides:d.strides}}function qxe(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<e.dims;s++)if(1<<s&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-s)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=s}else if(1<<s&e.newAxisMask)t.finalShapeGatherIndices.push(hA),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[s]),e.end!=null&&(t.end[n]=e.end[s]),t.strides[n]=e.strides[s],e.beginMask&1<<s&&(t.beginMask|=1<<n),e.endMask&1<<s&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<s?(t.finalShapeGatherIndices.push(Wxe),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(s)),t.inputShapeGatherIndicesSparse[n]=s,n++}}function Yz(e,t,n,s,r,i){if(r[t])return n>0?i[t]:i[t+1&1];{const o=e<0?s+e:e;return o<i[0]?i[0]:o>i[1]?i[1]:o}}var Xxe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",assertParamsValid:dA,maskToAxes:Hxe,computeOutShape:pA,stridesWithElidedDims:Vz,getNormalizedAxes:jxe,startIndicesWithElidedDims:Hz,stopIndicesWithElidedDims:jz,stridesForAxis:qz,startForAxis:Xz,stopForAxis:Kz,isSliceContinous:fA,computeFlatOffset:mA,parseSliceParams:u1,sliceInfo:gA});/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kxe{static sgd(t){return new lA(t)}static momentum(t,n,s=!1){return new Lz(t,n,s)}static rmsprop(t,n=.9,s=0,r=null,i=!1){return new Fz(t,n,s,r,i)}static adam(t=.001,n=.9,s=.999,r=null){return new Oz(t,n,s,r)}static adadelta(t=.001,n=.95,s=null){return new Mz(t,n,s)}static adamax(t=.002,n=.9,s=.999,r=null,i=0){return new Rz(t,n,s,r,i)}static adagrad(t,n=.1){return new Pz(t,n)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fp=Kxe;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yxe=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:e=>e())();function Qz(){return new Promise(e=>Yxe(()=>e()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yA(e,t){const n=e[0].length;e.forEach((r,i)=>{W(r.length===n,()=>`Error in concat${n}D: rank of tensors[${i}] must be the same as the rank of the rest (${n})`)}),W(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=e[0];e.forEach((r,i)=>{for(let o=0;o<n;o++)W(o===t||r[o]===s[o],()=>`Error in concat${n}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function Xa(e,t){const n=e[0].slice();for(let s=1;s<e.length;s++)n[t]+=e[s][t];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ko;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(Ko||(Ko={}));function Zz(e,t,n){let s=new Array;if(n==null&&t==null)return s;if(t==null)for(;s.length<e+n.length;)s.push(-1);else s=t.slice();if(n==null)return s;if(e+n.length!==s.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${s.length}`);for(let r=1;r<n.length;++r){const i=n[r],o=s[s.length-n.length+r],a=s[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+e}] = ${i} but shape[${r+e}] = ${a}`)}else s[o]=i}return s}function Jz(e){const t={FIRST_DIM_SIZE:Ko.FIRST_DIM_SIZE,VALUE_ROWIDS:Ko.VALUE_ROWIDS,ROW_LENGTHS:Ko.ROW_LENGTHS,ROW_SPLITS:Ko.ROW_SPLITS,ROW_LIMITS:Ko.ROW_LIMITS,ROW_STARTS:Ko.ROW_STARTS},n=[];for(const s of e)if(s in t)n.push(t[s]);else break;return n}function e4(e){return e.length===0?0:e[0]===Ko.FIRST_DIM_SIZE?e.length-1:e.length}function t4(e,t){if(e==null||t==null)return;const n=e.length,s=t.length;if(n>=s)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(n,s-1);++r){const i=e[r],o=t[r+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-e.length}] = ${i} but ragged tensor input.flatValues.shape[${r-e.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vA=30;function h1(e){return e<=vA?e:vT(e,Math.floor(Math.sqrt(e)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xA(e,t,n){const s=n*(typeof e=="number"?e:e[0]),r=t*(typeof e=="number"?e:e[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r0(e,t,n,s=!0){let r=[];if(s)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const i=t.length;for(let o=0;o<i;++o)r=r.concat([e[o+1]/t[o],t[o]]);r=r.concat(e.slice(i+1))}return r}function i0(e,t,n=!0){const s=[];if(n){s.push(t);for(let r=t+1;r<e;++r)r<=2*t?(s.push(r),s.push(r-(t+1))):s.push(r)}else{const r=[],i=[];for(let o=1;o<e;++o)o>=t*2+1||o%2==1?i.push(o):r.push(o);s.push(...r),s.push(0),s.push(...i)}return s}function o0(e,t,n,s=!0){const r=[];s?r.push(e[0]/n):r.push(e[0]*n);for(let i=1;i<e.length;++i)i<=t.length?s?r.push(t[i-1]*e[i]):r.push(e[i]/t[i-1]):r.push(e[i]);return r}function bA(e,t){const n=[0];for(let s=0;s<t;++s)n.push(e[s][0]);return n}function wA(e,t,n){const s=e.slice(0,1);for(let r=0;r<n;++r)s.push(e[r+1]-t[r][0]-t[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d1=1.7580993408473768,p1=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SA=.3275911,_A=.254829592,CA=-.284496736,TA=1.421413741,EA=-1.453152027,AA=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ol(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(e.length*2);for(let s=0;s<n.length;s+=2)n[s]=e[s/2],n[s+1]=t[s/2];return n}function n4(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let s=0;s<e.length;s+=2)t[s/2]=e[s],n[s/2]=e[s+1];return{real:t,imag:n}}function s4(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],s[Math.floor(r/4)]=e[r+1];return{real:n,imag:s}}function r4(e){const t=Math.floor(e.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],s[Math.floor(r/4)]=e[r+1];return{real:n,imag:s}}function IA(e,t){const n=e[t*2],s=e[t*2+1];return{real:n,imag:s}}function i4(e,t,n,s){e[s*2]=t,e[s*2+1]=n}function o4(e,t){const n=new Float32Array(e/2),s=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const i=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:n,imag:s}}function a4(e,t,n){const s=(n?2:-2)*Math.PI*(e/t),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NA="->",Qxe=/->/g,l4=",",c4="...";function kA(e,t){e=e.replace(/\s/g,"");const n=(e.length-e.replace(Qxe,"").length)/NA.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${NA}").`);const[s,r]=e.split(NA);W(s.indexOf(c4)===-1,()=>`The ellipsis notation ("${c4}") is not supported yet.`);const i=s.split(l4),o=i.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let d=0;d<r.length;++d){const p=r[d];if(!i.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);a.indexOf(p)===-1&&a.push(p)}for(let d=0;d<s.length;++d){const p=s[d];a.indexOf(p)===-1&&p!==l4&&a.push(p)}const l=new Array(i.length);for(let d=0;d<o;++d){if(new Set(i[d].split("")).size!==i[d].length)throw new Error(`Found duplicate axes in input component ${i[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let p=0;p<i[d].length;++p)l[d].push(a.indexOf(i[d][p]))}const c=a.length,h=r.length,u=[];for(let d=h;d<c;++d)u.push(d);return{allDims:a,summedDims:u,idDims:l}}function DA(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const s=[];for(let r=0;r<e;++r)n[r]===-1&&s.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:s}}function MA(e,t,n){const s=new Array(e);for(let r=0;r<n.length;++r){const i=n[r].shape;for(let o=0;o<t[r].length;++o)s[t[r][o]]===void 0?s[t[r][o]]=i[o]:W(s[t[r][o]]===i[o],()=>`Expected dimension ${s[t[r][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function PA(e,t){const n=e,s=[];let r=0;e.length===0&&n.push(-1),r=e.length+1;for(let o=0;o<r;++o)s.push([]);const i=[];for(let o=0;o<n.length;++o){const a=n[o],l=Zxe(t,a);for(const c of l)i.indexOf(c)===-1&&(s[o].push(c),i.push(c))}return{path:n,steps:s}}function OA(e){return e.every((t,n)=>t===n)}function Zxe(e,t){const n=[];for(let s=0;s<e.length;++s)(e[s].length===0||e[s].indexOf(t)!==-1||t===-1)&&n.push(s);return n}function RA(e,t,n=0){let s=[];if(typeof t=="number")W(e.shape[n]%t==0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(e.shape[n]/t);else{const r=t.reduce((o,a)=>(a===-1&&(o+=1),o),0);W(r<=1,()=>"There should be only one negative value in split array.");const i=t.indexOf(-1);if(i!==-1){const o=t.reduce((a,l)=>l>0?a+l:a);t[i]=e.shape[n]-o}W(e.shape[n]===t.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u4(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function h4(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function d4(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p4(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function f4(e,t){return`size ${e} must be non-negative, not ${t}`}function m4(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function g4(e,t){const n=Ae(e),s=Ae(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${e} outputShape= ${t}`}function y4(e,t){const n=Ae(e),s=Ae(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${s}. inputShape=${e} outputShape=${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LA(){return"segment ids must be >= 0"}function v4(){return"segment ids are not increasing"}function x4(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function b4(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w4(e,t){let n=!1,s;for(e<=vA?(s=e,n=!0):s=vT(e,Math.floor(Math.sqrt(e)));!n;)s>t||s===e?n=!0:s=vT(e,s+1);return s}function S4(e,t,n){const s=[],r=e.length;for(let i=0;i<r;i++)i!==t?s.push(e[i]):s.push(n);return s}function FA(e,t,n,s){const r=t.shape.length,i=e.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let u=0;u<s;++u)if(e.shape[u]!==t.shape[u])throw new Error(`x.shape[${u}]: ${e.shape[u]} should be equal to indices.shape[${u}]: ${t.shape[u]}.`);const o=e.shape[n],a=[];let l=1,c=1,h=1;for(let u=0;u<s;++u)a.push(e.shape[u]),l*=e.shape[u];for(let u=s;u<n;u++)a.push(e.shape[u]),c*=e.shape[u];for(let u=s;u<r;u++)a.push(t.shape[u]);for(let u=n+1;u<i;u++)a.push(e.shape[u]),h*=e.shape[u];return{batchSize:l,sliceSize:h,outerSize:c,dimSize:o,outputShape:a}}var Jxe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",segOpComputeOptimalWindowSize:w4,computeOutShape:S4,collectGatherOpShapeInfo:FA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bh(e){try{return e.map(t=>Oc(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function _4(e){return e.map(t=>Pc(t))}var ebe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",slice_util:Xxe,segment_util:Jxe,fromUint8ToStringArray:bh,fromStringArrayToUint8:_4,upcastType:li,axesAreInnerMostDims:FE,combineLocations:QB,computeOutAndReduceShapes:$s,expandShapeToKeepDim:vs,assertAxesAreInnerMostDims:Zs,getAxesPermutation:Yn,getUndoAxesPermutation:Fc,getInnerMostAxes:cs,getBroadcastDims:kp,getReductionAxes:Ts,assertAndGetBroadcastShape:Ft,assertParamsConsistent:yA,computeOutShape:Xa,computeDilation2DInfo:Kg,computePool2DInfo:uo,computePool3DInfo:kl,computeConv2DInfo:Qs,computeConv3DInfo:Lc,computeDefaultPad:IE,tupleValuesAreOne:ch,eitherStridesOrDilationsAreOne:cr,stridesOrDilationsArePositive:uh,convertConv2DDataFormat:Dl,checkPadOnDimRoundingMode:Hr,getFusedDyActivation:eA,getFusedBiasGradient:tA,applyActivation:nA,shouldFuse:sA,get RowPartitionType(){return Ko},combineRaggedTensorToTensorShapes:Zz,getRowPartitionTypesHelper:Jz,getRaggedRank:e4,validateDefaultValueShape:t4,PARALLELIZE_THRESHOLD:vA,computeOptimalWindowSize:h1,getImageCenter:xA,getReshaped:r0,getPermuted:i0,getReshapedPermuted:o0,getSliceBeginCoords:bA,getSliceSize:wA,prepareAndValidate:uA,validateUpdateShape:Tz,validateInput:Ove,calculateShapes:s0,SELU_SCALEALPHA:d1,SELU_SCALE:p1,ERF_P:SA,ERF_A1:_A,ERF_A2:CA,ERF_A3:TA,ERF_A4:EA,ERF_A5:AA,warn:Mi,log:Bfe,mergeRealAndImagArrays:Ol,splitRealAndImagArrays:n4,complexWithEvenIndex:s4,complexWithOddIndex:r4,getComplexWithIndex:IA,assignToTypedArray:i4,exponents:o4,exponent:a4,decodeEinsumEquation:kA,getEinsumPermutation:DA,checkEinsumDimSizes:MA,getEinsumComputePath:PA,isIdentityPermutation:OA,prepareSplitSize:RA,getSparseFillEmptyRowsIndicesDenseShapeMismatch:u4,getSparseFillEmptyRowsNegativeIndexErrorMessage:h4,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:d4,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:p4,getSparseReshapeNegativeOutputDimErrorMessage:f4,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:m4,getSparseReshapeInputOutputMultipleErrorMessage:g4,getSparseReshapeInputOutputMismatchErrorMessage:y4,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:LA,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:v4,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:x4,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:b4});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Pxe();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C4={kernelName:Gx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(e,n0(rt(n,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tbe={kernelName:Ym,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const s=zn(rt(n,"float32")),r=_r(Nt(fn(1),s));return xs(St(e,r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nbe={kernelName:Qm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const s=_r(Nt(zn(rt(n,"float32")),1));return St(e,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sbe={kernelName:bp,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=Ft(n.shape,s.shape);return{a:()=>{let a=e;const l=Ts(n.shape,r);return l.length>0&&(a=xt(a,l)),pe(a,n.shape)},b:()=>{let a=e;const l=Ts(s.shape,r);return l.length>0&&(a=xt(a,l)),pe(a,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rbe={kernelName:_T,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach((s,r)=>{n[r]=()=>e.clone()}),n}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ibe={kernelName:Wx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Jt(n)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const obe={kernelName:Hx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Jt(n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const abe={kernelName:Zm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>St(e,_r(Nt(fn(1),zn(rt(n,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lbe={kernelName:Jm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const s=_r(ze(fn(1),zn(rt(n,"float32"))));return St(e,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cbe={kernelName:ng,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=Ft(n.shape,s.shape);return{a:()=>{const a=ze(zn(n),zn(s));let l=le(e,St(s,a));const c=Ts(n.shape,r);return c.length>0&&(l=xt(l,c)),pe(l,n.shape)},b:()=>{const a=ze(zn(n),zn(s));let l=xs(le(e,St(n,a)));const c=Ts(s.shape,r);return c.length>0&&(l=xt(l,c)),pe(l,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ube={kernelName:eg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>St(e,ze(zn(rt(n,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hbe={kernelName:tg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>St(e,Nt(fn(1),zn(rt(n,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dbe(e,t,n,s,r,i){const o=J(e,"dy","avgPool3dGrad"),a=J(t,"input","avgPool3dGrad");let l=o,c=a,h=!1;a.rank===4&&(h=!0,l=pe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=pe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),W(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),W(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),Hr("avgPool3dGrad",r,i);const u={dy:l,input:c},d={filterSize:n,strides:s,pad:r,dimRoundingMode:i},p=ae.runKernel(AT,u,d);return h?pe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const pbe=fe({avgPool3dGrad_:dbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fbe={kernelName:qx,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:a}=n;return{x:()=>pbe(e,s,r,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mbe(e,t,n,s,r){const i=J(e,"dy","avgPoolGrad"),o=J(t,"input","avgPoolGrad");W(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,c=!1;o.rank===3&&(c=!0,a=pe(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=pe(i,[1,i.shape[0],i.shape[1],i.shape[2]])),W(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),W(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h={dy:l,input:a},u={filterSize:n,strides:s,pad:r},d=ae.runKernel(ET,h,u);return c?pe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const gbe=fe({avgPoolGrad_:mbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ybe={kernelName:jx,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{filterSize:r,strides:i,pad:o}=n;return{x:()=>gbe(e,s,r,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vbe={kernelName:Xx,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[s,r]=t,{transposeA:i,transposeB:o}=n;return!i&&!o?{a:()=>pn(e,r,!1,!0),b:()=>pn(s,e,!0,!1)}:!i&&o?{a:()=>pn(e,r,!1,!1),b:()=>pn(e,s,!0,!1)}:i&&!o?{a:()=>pn(r,e,!1,!0),b:()=>pn(s,e,!1,!1)}:{a:()=>pn(r,e,!0,!0),b:()=>pn(e,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xbe={kernelName:Kx,gradFunc:(e,t,n)=>{const{blockShape:s,crops:r}=n;return{x:()=>jE(e,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bbe={kernelName:Lfe,gradFunc:(e,t,n)=>{const s=n,r=s.inputShape,i=s.shape,o=Array.from(i);for(let l=r.length-1;l>=0;l--)if(r[l]===i[l])o[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>xt(e,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wbe={kernelName:sg,gradFunc:e=>({x:()=>e.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sbe={kernelName:rg,gradFunc:e=>({x:()=>Jt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _be={kernelName:ig,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{clipValueMin:r,clipValueMax:i}=n;return{x:()=>ci(Pl(dh(s,r),Mp(s,i)),e,Jt(e))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cbe={kernelName:Yx,inputsToSave:["x"],gradFunc:C4.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tbe={kernelName:Qx,saveAllInputs:!0,gradFunc:(e,t,n)=>{const s=t.map(l=>l.shape),{axis:r}=n,i=Ht(r,t[0].shape)[0],o=s.map(l=>l[i]);return Li(e,o,i).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ebe={kernelName:Zx,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[s,r]=t,{dilations:i,strides:o,pad:a,dataFormat:l}=n;return W(ch(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>PE(s.shape,e,r,o,a,l),filter:()=>JE(s,e,r.shape,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Abe={kernelName:Jx,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[s,r]=t,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=n;return{dy:()=>hh(e,r,i,o,a,1,l),filter:()=>JE(e,s,r.shape,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ibe(e,t,n,s,r){let i=e;e.rank===4&&(i=pe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let o=t;o.rank===4&&(o=pe(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),W(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),W(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),W(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),W(i.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`),W(o.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`);const a={x:i,dy:o},l={strides:s,pad:r,filterShape:n};return ae.runKernel(DT,a,l)}const Nbe=fe({conv3DBackpropFilter_:Ibe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kbe={kernelName:eb,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:s,strides:r,pad:i}=n;W(ch(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,a]=t;return{x:()=>qB(o.shape,e,a,r,i),filter:()=>Nbe(o,e,a.shape,r,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dbe={kernelName:og,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(xs(vz(rt(n,"float32"))),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mbe={kernelName:ag,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(xz(rt(n,"float32")),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pbe={kernelName:tb,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{axis:r,exclusive:i,reverse:o}=n;return{x:()=>{const a=Yn([r],s.rank);let l=KB(e,r,i,!o);return a!=null&&(l=Zt(l,a)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Obe={kernelName:nb,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:o}=n,a=s==null?[1,1]:s;W(ch(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=t;return W(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),W(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),W(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),W(cr(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),Hr("depthwiseConv2d",i,o),{x:()=>Wve(l.shape,e,c,r,i,a,o),filter:()=>Vve(l,e,c.shape,r,i,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rbe={kernelName:sb,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[s,r]=t,i={x:s,filter:r,dy:e},o={x:s,filter:r,dy:e};return{x:()=>ae.runKernel(BT,i,n),filter:()=>ae.runKernel(zT,o,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lbe={kernelName:cg,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,s={dy:e,y:n};return{x:()=>ae.runKernel(UT,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fbe={kernelName:ug,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,s=le(Ml(xs(zn(n))),2/Math.sqrt(Math.PI));return{x:()=>le(e,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $be={kernelName:hg,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(e,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bbe={kernelName:ib,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>pe(e,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zbe={kernelName:dg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(e,Ml(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ube={kernelName:pg,gradFunc:e=>({x:()=>Jt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vbe={kernelName:fg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=Ft(n.shape,s.shape);return{a:()=>{const a=St(e,rt(s,"float32")),l=Ts(n.shape,r);return l.length>0?pe(xt(a,l),n.shape):a},b:()=>{let a=le(e,rt(n,"float32"));const l=Ts(s.shape,r);l.length>0&&(a=pe(xt(a,l),s.shape));const c=zn(s);return xs(St(a,rt(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gbe={kernelName:ob,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:s}=n,[r,i,o,a]=t,l=a==null?fn(1):a,c=Ts(i.shape,r.shape),h=[];if(i.rank===1){for(let x=0;x<r.shape.length-1;++x)h.push(r.shape[x]);h.push(1)}const u=Nt(r,i),d=le(e,l),p=mz(ze(o,fn(s))),f=le(le(le(p,p),p),fn(-.5));return{x:()=>i.rank===1?pe(le(le(e,Xo(pe(p,[1,1,1,i.shape[0]]),h)),l),r.shape):pe(le(le(e,p),l),r.shape),mean:()=>{let x=le(le(p,fn(-1)),d);return i.rank===1&&(x=xt(x,c)),pe(x,i.shape)},variance:()=>{let x=le(le(f,u),d);return i.rank===1&&(x=xt(x,c)),pe(x,i.shape)},scale:()=>{const x=le(u,p);let w=le(e,x);return i.rank===1&&(w=xt(w,c)),pe(w,i.shape)},offset:()=>{let x=e;return i.rank===1&&(x=xt(x,c)),pe(x,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wbe={kernelName:ab,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[s,r]=t,{axis:i}=n,o=Ht(i,s.shape)[0];return{x:()=>{const l=s.shape,c=r.size,h=l.slice(0,o),u=h.length,d=l.slice(i,l.length).slice(1),p=d.length,f=T4(0,u),g=T4(u+1,u+1+p),m=E4([h,[c],d]),y=pe(e,m),v=pe(r,[c]),b=E4([[u],f,g]),x=Zt(y,b);let w=_z(x,v,s.shape[o]);const S=Fc(b);return w=Zt(w,S),w},indices:()=>r}}};function T4(e,t){const n=[];for(let s=e;s<t;++s)n.push(s);return n}function E4(e){const t=[];for(let n=0;n<e.length;++n)for(let s=0;s<e[n].length;++s)t.push(e[n][s]);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hbe={kernelName:mg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t;return{a:()=>Jt(n),b:()=>Jt(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jbe={kernelName:gg,gradFunc:e=>({x:()=>rt(e,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qbe={kernelName:yg,gradFunc:e=>({x:()=>Jt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xbe={kernelName:vg,gradFunc:e=>({x:()=>Jt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kbe={kernelName:xg,gradFunc:e=>({x:()=>Jt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ybe={kernelName:cb,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{alpha:r}=n,i=Ri(s,0);return{x:()=>ci(i,e,le(e,r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qbe={kernelName:wg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>St(e,ze(n,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zbe={kernelName:bg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>St(e,rt(n,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jbe={kernelName:Ffe,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s]=t,{axis:r}=n;return{logits:()=>{const i=!0,o=Ml(s);return Nt(e,le(xt(e,r,i),o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e1e(e,t,n,s=5,r=1,i=1,o=.5){const a={x:e,y:t,dy:n},l={depthRadius:s,bias:r,alpha:i,beta:o};return ae.runKernel(qT,a,l)}const t1e=fe({localResponseNormalizationBackprop_:e1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n1e={kernelName:mb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s,r]=t,{depthRadius:i,bias:o,alpha:a,beta:l}=n;return{x:()=>t1e(s,r,e,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A4(e,t,n,s){return t.rank<n.rank&&(t=pe(t,vs(t.shape,s))),e.rank<n.rank&&(e=pe(e,vs(e.shape,s))),{x:()=>le(e,rt(ja(n,t),e.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I4={kernelName:gb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const s=n,{reductionIndices:r}=s,i=t[0],o=t[1],a=Ht(r,i.shape),l=A4(e,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s1e={kernelName:Sg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t;return{a:()=>le(e,rt(dh(n,s),"float32")),b:()=>le(e,rt(ez(n,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r1e(e,t,n,s,r,i,o){const a=J(e,"dy","maxPool3dGrad"),l=J(t,"input","maxPool3dGrad"),c=J(n,"output","maxPool3dGrad");let h=a,u=l,d=c,p=!1;l.rank===4&&(p=!0,h=pe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=pe(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=pe(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),W(h.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`),W(u.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),W(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),Hr("maxPool3dGrad",i,o);const f={dy:h,input:u,output:d},g={filterSize:s,strides:r,pad:i,dimRoundingMode:o},m=ae.runKernel(KT,f,g);return p?pe(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const i1e=fe({maxPool3dGrad_:r1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o1e={kernelName:vb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s,r]=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=n;return{x:()=>i1e(e,s,r,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a1e(e,t,n,s,r,i,o){const a=J(e,"dy","maxPoolGrad"),l=J(t,"input","maxPoolGrad"),c=J(n,"output","maxPoolGrad");W(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),W(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),W(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Hr("maxPoolGrad",i,o);const h={dy:a,input:l,output:c},u={filterSize:s,strides:r,pad:i,dimRoundingMode:o};return ae.runKernel(XT,h,u)}const l1e=fe({maxPoolGrad_:a1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c1e={kernelName:yb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s,r]=t,{filterSize:i,strides:o,pad:a}=n;return{x:()=>l1e(e,s,r,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u1e={kernelName:xb,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{axis:r}=n,i=Ht(r,s.shape),a=$s(s.shape,i)[1],l=Ae(a);return{x:()=>{const h=s.shape.slice();i.forEach(p=>{h[p]=1});const u=pe(e,h);return St(le(u,ph(s.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h1e={kernelName:bb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const s=n,{axis:r}=s,[i,o]=t,a=Ht(r,i.shape),l=A4(e,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d1e={kernelName:_g,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t;return{a:()=>le(e,rt(Mp(n,s),"float32")),b:()=>le(e,rt(Ri(n,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p1e={kernelName:wb,inputsToSave:["x"],gradFunc:(e,t,n)=>{const s=t[0],{paddings:r}=n,i=r.map(o=>o[0]);return{x:()=>kn(e,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f1e={kernelName:Cg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=Ft(n.shape,s.shape);return{a:()=>{const a=Ts(n.shape,r);return a.length>0?pe(xt(e,a),n.shape):e},b:()=>{const a=le(e,xs(i1(St(n,s)))),l=Ts(s.shape,r);return l.length>0?pe(xt(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m1e={kernelName:Tg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=Ft(n.shape,s.shape);return{a:()=>{const a=le(e,rt(s,"float32")),l=Ts(n.shape,r);return l.length>0?pe(xt(a,l),n.shape):a},b:()=>{const a=le(e,rt(n,"float32")),l=Ts(s.shape,r);return l.length>0?pe(xt(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g1e={kernelName:Sb,gradFunc:e=>({x:()=>xs(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y1e={kernelName:Tb,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>Bs(n.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v1e={kernelName:Cb,gradFunc:e=>({x:()=>Jt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x1e={kernelName:Eb,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:s}=n;return yh(e,s).map(i=>()=>i)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N4={kernelName:Ab,inputsToSave:["x"],gradFunc:(e,t,n)=>{const s=t[0],{paddings:r}=n,i=r.map(o=>o[0]);return{x:()=>kn(e,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b1e={kernelName:Eg,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,s,r]=t,i=n,o=s,a=Ft(i.shape,o.shape);return{a:()=>{const h=rt(o,"float32");let u=le(e,le(h,Dp(i,Nt(h,fn(1)))));const d=Ts(i.shape,a);return d.length>0&&(u=xt(u,d)),pe(u,i.shape)},b:()=>{const h=Ri(i,0),u=ci(h,qa(i),Jt(i));let d=le(e,le(r,u));const p=Ts(o.shape,a);return p.length>0&&(d=xt(d,p)),pe(d,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w1e={kernelName:Ib,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,s]=t,r=Ri(n,0);return{x:()=>ci(r,e,le(e,s)),alpha:()=>{let i=ci(r,Jt(e),le(e,n));const o=Ts(s.shape,e.shape);return o.length>0&&(i=xt(i,o)),pe(i,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S1e(e,t,n){const s=e.shape.slice();s[n]=1;const r=pe(t,s),i=RE(e,n,!0,!1),o=RE(e,n,!0,!0),a=le(i,o);return le(r,a)}function _1e(e,t,n){const s=e.shape.length,r=s-n.length,i=Yn(n,s);let o=e;i!=null&&(o=Zt(e,i));const a=o.shape.slice(),c=a.splice(s-n.length,n.length).reduce((d,p)=>d*p,1);a.push(c);const h=o.reshape(a);let u=S1e(h,t,r);if(u=u.reshape(o.shape),i!=null){const d=Fc(i);u=Zt(u,d)}return u}const C1e={kernelName:Nb,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{axis:r}=n;let i=[];return r==null?i=s.shape.map((o,a)=>a):typeof r=="number"?i=[r]:i=r,{x:()=>_1e(s,e,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T1e={kernelName:lg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=Ft(n.shape,s.shape);return{a:()=>{const a=St(e,rt(s,"float32")),l=Ts(n.shape,r);return l.length>0?pe(xt(a,l),n.shape):a},b:()=>{let a=le(e,rt(n,"float32"));const l=Ts(s.shape,r);l.length>0&&(a=pe(xt(a,l),s.shape));const c=zn(s);return xs(St(a,rt(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E1e={kernelName:Ag,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>St(e,xs(zn(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A1e={kernelName:Ng,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,s=le(Mp(n,6),n0(n));return{x:()=>le(e,rt(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I1e={kernelName:Ig,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(e,rt(n0(n),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N1e={kernelName:kb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>pe(e,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k1e={kernelName:Mb,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[s]=t,r={dy:e,images:s};return{images:()=>ae.runKernel(nE,r,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D1e={kernelName:Db,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[s]=t,r={dy:e,images:s};return{images:()=>ae.runKernel(tE,r,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M1e={kernelName:Pb,gradFunc:(e,t,n)=>{const{dims:s}=n,r=Ht(s,e.shape);return{x:()=>gh(e,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P1e={kernelName:kg,gradFunc:e=>({x:()=>Jt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O1e={kernelName:Dg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>xs(St(e,le(Dp(n,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R1e={kernelName:Ob,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>rt(Jt(n),"float32"),t:()=>le(e,rt(n,e.dtype)),e:()=>le(e,rt(UE(n),e.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L1e={kernelName:Mg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const s=Ri(n,fn(0)),r=fn(d1),i=fn(p1),o=le(e,i),a=le(le(e,r),Ml(rt(n,"float32")));return ci(s,o,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F1e={kernelName:Lg,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(e,le(n,Nt(fn(1),n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $1e={kernelName:Rg,gradFunc:e=>({x:()=>Jt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B1e={kernelName:Pg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(OE(rt(n,"float32")),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z1e={kernelName:Og,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(XB(rt(n,"float32")),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U1e={kernelName:Rb,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{begin:r,size:i}=n,o=s.shape,[a,l]=u1(s,r,i),c=[];for(let h=0;h<e.rank;h++)c.push([a[h],o[h]-a[h]-l[h]]);return{x:()=>HE(e,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V1e={kernelName:Bb,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s]=t,{dim:r}=n,i=!0,o=le(e,s);return{logits:()=>Nt(o,le(xt(o,[r],i),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G1e={kernelName:Fg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(e,Np(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k4={kernelName:Fb,gradFunc:(e,t,n)=>{const{blockShape:s,paddings:r}=n;return{x:()=>ME(e,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D4={kernelName:$b,gradFunc:(e,t,n)=>{const{axis:s}=n;return{x:()=>jr(e,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W1e={kernelName:$g,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>St(e,le(_r(rt(n,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H1e={kernelName:sE,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(e,le(rt(n,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j1e={kernelName:Bg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=fn(2);return{a:()=>le(e,le(r,Nt(n,s))),b:()=>le(e,le(r,Nt(s,n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q1e={kernelName:Wg,gradFunc:e=>({x:()=>Jt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X1e={kernelName:zg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=Ft(n.shape,s.shape);return{a:()=>{let a=e;const l=Ts(n.shape,r);return l.length>0&&(a=xt(a,l)),pe(a,n.shape)},b:()=>{let a=e;const l=Ts(s.shape,r);return l.length>0&&(a=xt(a,l)),pe(xs(a),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K1e={kernelName:Lb,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,r=s.shape.slice(),{axis:i}=n;Ht(i,s.shape).forEach(c=>{r[c]=1});const a=pe(e,r),l=le(a,ph(s.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y1e={kernelName:Ug,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>St(e,zn(OE(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q1e={kernelName:Vg,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>le(Nt(fn(1),zn(n)),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z1e={kernelName:Gg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{reps:r}=n;return{x:()=>{let o=Jt(s);if(s.rank===1)for(let a=0;a<r[0];++a)o=ze(o,kn(e,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)o=ze(o,kn(e,[a*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)o=ze(o,kn(e,[a*s.shape[0],l*s.shape[1],c*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let c=0;c<r[2];++c)for(let h=0;h<r[3];++h)o=ze(o,kn(e,[a*s.shape[0],l*s.shape[1],c*s.shape[2],h*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J1e={kernelName:wp,gradFunc:(e,t,n)=>{const s=n,{perm:r}=s,i=Fc(r);return{x:()=>Zt(e,i)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ewe={kernelName:zb,gradFunc:(e,t,n)=>{const s=n,{axis:r}=s;return{value:()=>Bc(e,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const twe={kernelName:Ub,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nwe(e,n)}}};function nwe(e,t){const n=$c(t,Jt(t)),s=$E(e,n);let r=dh(t,fn(0,"int32"));const i=s.rank-r.rank;for(let a=0;a<i;++a)r=ui(r,a+1);r=Pl(r,ph(s.shape,"bool"));const o=Jt(s);return ci(r,s,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const swe={kernelName:Vb,gradFunc:e=>({x:()=>Jt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rwe=[C4,tbe,nbe,sbe,rbe,ibe,obe,abe,lbe,cbe,ube,hbe,fbe,ybe,vbe,xbe,bbe,wbe,Sbe,_be,Cbe,Tbe,Abe,Ebe,kbe,Dbe,Mbe,Pbe,Obe,Rbe,T1e,Lbe,Fbe,$be,Bbe,zbe,Vbe,Ube,Gbe,Wbe,Hbe,jbe,qbe,Xbe,Kbe,Ybe,Qbe,Zbe,Jbe,n1e,I4,I4,s1e,o1e,c1e,u1e,h1e,d1e,p1e,f1e,m1e,g1e,y1e,v1e,x1e,N4,N4,b1e,w1e,C1e,E1e,A1e,I1e,N1e,k1e,D1e,M1e,P1e,O1e,R1e,L1e,F1e,$1e,B1e,z1e,U1e,V1e,G1e,k4,k4,D4,D4,W1e,j1e,H1e,q1e,X1e,K1e,Y1e,Q1e,Z1e,J1e,ewe,twe,swe];for(const e of rwe)zfe(e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.abs=function(){return this.throwIfDisposed(),Sr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.acos=function(){return this.throwIfDisposed(),Gme(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.acosh=function(){return this.throwIfDisposed(),Hme(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.add=function(e){return this.throwIfDisposed(),ze(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.all=function(e,t){return this.throwIfDisposed(),WB(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.any=function(e,t){return this.throwIfDisposed(),AE(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.argMax=function(e){return this.throwIfDisposed(),Xg(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.argMin=function(e){return this.throwIfDisposed(),Yme(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.asScalar=function(){return this.throwIfDisposed(),W(this.size===1,()=>"The array must have only 1 element."),pe(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.asType=function(e){return this.throwIfDisposed(),rt(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.as1D=function(){return this.throwIfDisposed(),pe(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.as2D=function(e,t){return this.throwIfDisposed(),pe(this,[e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),pe(this,[e,t,n])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.as4D=function(e,t,n,s){return this.throwIfDisposed(),pe(this,[e,t,n,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.as5D=function(e,t,n,s,r){return this.throwIfDisposed(),pe(this,[e,t,n,s,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.asin=function(){return this.throwIfDisposed(),Zme(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.asinh=function(){return this.throwIfDisposed(),ege(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.atan=function(){return this.throwIfDisposed(),nge(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.atan2=function(e){return this.throwIfDisposed(),rge(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.atanh=function(){return this.throwIfDisposed(),oge(this)};Ee().prototype.avgPool=function(e,t,n,s){return this.throwIfDisposed(),kE(this,e,t,n,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),ME(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.batchNorm=function(e,t,n,s,r){return this.throwIfDisposed(),e1(this,e,t,n,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Zg(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.cast=function(e){return this.throwIfDisposed(),rt(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.ceil=function(){return this.throwIfDisposed(),Pge(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Oi(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof ys&&(e=[e]),jr([this,...e],t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.conv1d=function(e,t,n,s,r,i){return this.throwIfDisposed(),HB(this,e,t,n,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.conv2dTranspose=function(e,t,n,s,r){return this.throwIfDisposed(),jB(this,e,t,n,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.conv2d=function(e,t,n,s,r,i){return this.throwIfDisposed(),hh(this,e,t,n,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.cos=function(){return this.throwIfDisposed(),OE(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.cosh=function(){return this.throwIfDisposed(),XB(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),RE(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),KB(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),r0e(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.depthwiseConv2d=function(e,t,n,s,r,i){return this.throwIfDisposed(),LE(this,e,t,n,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.dilation2d=function(e,t,n,s,r){return this.throwIfDisposed(),a0e(this,e,t,n,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.divNoNan=function(e){return this.throwIfDisposed(),d0e(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.div=function(e){return this.throwIfDisposed(),St(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.dot=function(e){return this.throwIfDisposed(),f0e(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.elu=function(){return this.throwIfDisposed(),n1(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.equal=function(e){return this.throwIfDisposed(),ja(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.erf=function(){return this.throwIfDisposed(),y0e(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),E0e(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.exp=function(){return this.throwIfDisposed(),Ml(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.expandDims=function(e){return this.throwIfDisposed(),ui(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.expm1=function(){return this.throwIfDisposed(),k0e(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.fft=function(){return this.throwIfDisposed(),wz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.flatten=function(){return this.throwIfDisposed(),pe(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.floor=function(){return this.throwIfDisposed(),i1(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.floorDiv=function(e){return this.throwIfDisposed(),GB(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.gather=function(e,t){return this.throwIfDisposed(),$E(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.greaterEqual=function(e){return this.throwIfDisposed(),dh(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.greater=function(e){return this.throwIfDisposed(),Ri(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.ifft=function(){return this.throwIfDisposed(),QE(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.irfft=function(){return this.throwIfDisposed(),dve(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.isFinite=function(){return this.throwIfDisposed(),B0e(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.isInf=function(){return this.throwIfDisposed(),U0e(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.isNaN=function(){return this.throwIfDisposed(),G0e(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.leakyRelu=function(e){return this.throwIfDisposed(),zE(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.lessEqual=function(e){return this.throwIfDisposed(),Mp(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.less=function(e){return this.throwIfDisposed(),ez(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.localResponseNormalization=function(e,t,n,s){return this.throwIfDisposed(),X0e(this,e,t,n,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.logSigmoid=function(){return this.throwIfDisposed(),tye(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.logSoftmax=function(e){return this.throwIfDisposed(),nz(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),iye(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.log=function(){return this.throwIfDisposed(),qa(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.log1p=function(){return this.throwIfDisposed(),tz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Pl(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.logicalNot=function(){return this.throwIfDisposed(),UE(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.logicalOr=function(e){return this.throwIfDisposed(),sz(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.logicalXor=function(e){return this.throwIfDisposed(),uye(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),pn(this,e,t,n)};Ee().prototype.maxPool=function(e,t,n,s){return this.throwIfDisposed(),VE(this,e,t,n,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.max=function(e,t){return this.throwIfDisposed(),qo(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.maximum=function(e){return this.throwIfDisposed(),$c(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.mean=function(e,t){return this.throwIfDisposed(),bs(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.min=function(e,t){return this.throwIfDisposed(),s1(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.minimum=function(e){return this.throwIfDisposed(),GE(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),vye(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.mod=function(e){return this.throwIfDisposed(),bye(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.mul=function(e){return this.throwIfDisposed(),le(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.neg=function(){return this.throwIfDisposed(),xs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.norm=function(e,t,n){return this.throwIfDisposed(),r1(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.notEqual=function(e){return this.throwIfDisposed(),o1(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),rz(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.onesLike=function(){return this.throwIfDisposed(),ho(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.pad=function(e,t){return this.throwIfDisposed(),HE(this,e,t)};Ee().prototype.pool=function(e,t,n,s,r,i){return this.throwIfDisposed(),kye(this,e,t,n,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.pow=function(e){return this.throwIfDisposed(),Dp(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.prelu=function(e){return this.throwIfDisposed(),qE(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.prod=function(e,t){return this.throwIfDisposed(),Pye(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.reciprocal=function(){return this.throwIfDisposed(),jye(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.relu=function(){return this.throwIfDisposed(),mh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.relu6=function(){return this.throwIfDisposed(),pz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.reshapeAs=function(e){return this.throwIfDisposed(),pe(this,e.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.reshape=function(e){return this.throwIfDisposed(),pe(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Iz(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),Nz(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.reverse=function(e){return this.throwIfDisposed(),gh(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.rfft=function(){return this.throwIfDisposed(),mve(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.round=function(){return this.throwIfDisposed(),fz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.rsqrt=function(){return this.throwIfDisposed(),mz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.selu=function(){return this.throwIfDisposed(),gz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.separableConv2d=function(e,t,n,s,r,i){return this.throwIfDisposed(),yz(this,e,t,n,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.sigmoid=function(){return this.throwIfDisposed(),Np(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.sign=function(){return this.throwIfDisposed(),tve(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.sin=function(){return this.throwIfDisposed(),vz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.sinh=function(){return this.throwIfDisposed(),xz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.slice=function(e,t){return this.throwIfDisposed(),kn(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.softmax=function(e){return this.throwIfDisposed(),YE(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.softplus=function(){return this.throwIfDisposed(),Jg(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),jE(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.split=function(e,t){return this.throwIfDisposed(),Li(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.sqrt=function(){return this.throwIfDisposed(),_r(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.square=function(){return this.throwIfDisposed(),zn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.squaredDifference=function(e){return this.throwIfDisposed(),yve(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.squeeze=function(e){return this.throwIfDisposed(),t0(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof ys?[this,e]:[this,...e];return Bc(n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.step=function(e){return this.throwIfDisposed(),n0(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.stridedSlice=function(e,t,n,s,r,i,o,a){return this.throwIfDisposed(),Sve(this,e,t,n,s,r,i,o,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.sub=function(e){return this.throwIfDisposed(),Nt(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.sum=function(e,t){return this.throwIfDisposed(),xt(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.tan=function(){return this.throwIfDisposed(),Cve(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.tanh=function(){return this.throwIfDisposed(),DE(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.tile=function(e){return this.throwIfDisposed(),Xo(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.toBool=function(){return this.throwIfDisposed(),rt(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.toFloat=function(){return this.throwIfDisposed(),rt(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.toInt=function(){return this.throwIfDisposed(),rt(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.topk=function(e,t){return this.throwIfDisposed(),Eve(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.transpose=function(e){return this.throwIfDisposed(),Zt(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.unique=function(e){return this.throwIfDisposed(),Nve(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),_z(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.unstack=function(e){return this.throwIfDisposed(),yh(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.where=function(e,t){return this.throwIfDisposed(),ci(e,this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ee().prototype.zerosLike=function(){return this.throwIfDisposed(),Jt(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ka extends Error{constructor(t){super(t);Object.setPrototypeOf(this,Ka.prototype)}}class fo extends Error{constructor(t){super(t);Object.setPrototypeOf(this,fo.prototype)}}class re extends Error{constructor(t){super(t);Object.setPrototypeOf(this,re.prototype)}}class $t extends Error{constructor(t){super(t);Object.setPrototypeOf(this,$t.prototype)}}class $A extends Error{constructor(t){super(t);Object.setPrototypeOf(this,$A.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class M4{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let n;return this.cache.has(t)&&(n=this.cache.get(t),this.cache.delete(t),this.cache.set(t,n)),n}put(t,n){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(t,n)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let n=0;n<this.maxEntries-t;n++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=t}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wh(e,t){if(Array.isArray(e)){let n=[];for(let s=0;s<t;s++)n=n.concat(e);return n}else{const n=new Array(t);return n.fill(e),n}}function Ya(e,t){if(!e)throw new $A(t)}function P4(e,t){let n=0;for(const s of e)s===t&&n++;return n}function qr(e){return e.length===1?e[0]:e}function Un(e){return Array.isArray(e)?e:[e]}function Rl(e){const n=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function Sh(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}let mo={};function BA(e){if(e==null)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function zA(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>zA(t));else{const t=Object.keys(e);for(const n of t){const s=e[n];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?e[n]=s.value:zA(s))}}}function a0(e,t={},n={},s="object",r=!1){if(typeof e=="string"){const i=e;let o;if(i in n)o=n[i];else if(i in mo)o=mo[i];else if(o=t[i],o==null)throw new re(`Unknown ${s}: ${e}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=e;if(i.className==null||i.config==null)throw new re(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let a,l;if(o in n?[a,l]=n[o]:o in mo?[a,l]=mo.className:o in t&&([a,l]=t[o]),a==null)throw new re(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const p of Object.keys(mo))c[p]=mo[p];for(const p of Object.keys(n))c[p]=n[p];const h=i.config;h.customObjects=c;const u=Object.assign({},mo);for(const p of Object.keys(n))mo[p]=n[p];zA(i.config);const d=l(a,i.config,n,r);return mo=Object.assign({},u),d}else{const c=Object.assign({},mo);for(const u of Object.keys(n))mo[u]=n[u];const h=new a(i.config);return mo=Object.assign({},c),h}}}function iwe(e,t){return e<t?-1:e>t?1:0}function f1(e,t){return-1*iwe(e,t)}function Uc(e){if(e==null)return e;const t=[];for(const n of e)t.indexOf(n)===-1&&t.push(n);return t}function owe(e){if(e==null)throw new re(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function _h(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new re(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function UA(e,t,n=0,s=1/0){return Ya(n>=0),Ya(s>=n),Array.isArray(e)&&e.length>=n&&e.length<=s&&e.every(r=>typeof r===t)}function zs(e,t){Array.isArray(e)?(W(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,s)=>zs(n,`element ${s+1} of ${t}`))):W(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${O4(e)}.`)}function O4(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>O4(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function awe(e,t,n){let s=n!=null?n():Wr(),r;return(...o)=>{const a=n!=null?n():Wr();return a-s<t||(s=a,r=e(...o)),r}}function R4(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let lwe=0;function L4(){return lwe++}const m1={};function g1(e=""){return e in m1||(m1[e]=0),m1[e]+=1,e+m1[e].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const cwe=["channelsFirst","channelsLast"],uwe=["nearest","bilinear"],hwe=["valid","same","causal"],dwe=["max","avg"],pwe=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const $p=new Map;function us(e){_h(cwe,"DataFormat",e)}function fwe(e){_h(uwe,"InterpolationFormat",e)}function $i(e){_h(hwe,"PaddingMode",e)}function F4(e){_h(dwe,"PoolMode",e)}const l0=[],$4="/";function Ch(e,t){l0.push(e);try{const n=t();return l0.pop(),n}catch(n){throw l0.pop(),n}}function mwe(){return l0.length===0?"":l0.join($4)+$4}function B4(e){if(!U4(e))throw new Error("Not a valid tensor name: '"+e+"'");return mwe()+e}function z4(e){if(!U4(e))throw new Error("Not a valid tensor name: '"+e+"'");$p.has(e)||$p.set(e,0);const t=$p.get(e);if($p.set(e,$p.get(e)+1),t>0){const n=`${e}_${t}`;return $p.set(n,1),n}else return e}const gwe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function U4(e){return!!e.match(gwe)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ywe(e){return e===parseInt(e.toString(),10)}function Vc(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let s=1;for(let r=t;r<n;++r)s*=e[r];return s}function Bp(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const s=e[n];s<t&&(t=s)}return t}function Gc(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const s=e[n];s>t&&(t=s)}return t}function Yo(e,t){if(t<e)throw new re(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let s=e;s<t;++s)n.push(s);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let VA;function Es(){return VA==null&&(VA=Lme().epsilon()),VA}function Qo(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Qa(e,t){return rt(e,t)}function c0(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),pe(e,n)}function vwe(e,t){return ye(()=>{if(e.shape.length!==2)throw new re(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);const n=c0(e,1);return HA(n,[1,t,1])})}function xwe(e){const t=[Vc(e.shape)];return pe(e,t)}function bwe(e){if(e.rank<=1)throw new re(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],Vc(e.shape,1)];return pe(e,t)}function Th(e,t,n){return ye(()=>{switch(e.rank){case 1:return XE(e,t,n);case 2:return bz(e,[t,0],[n,e.shape[1]]);case 3:return KE(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return c1(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return kn(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return kn(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new re(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function GA(e,t,n){return ye(()=>{switch(e.rank){case 1:return XE(e,t,n);case 2:return bz(e,[0,t],[e.shape[0],n]);case 3:return KE(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return c1(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new re(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function y1(e,t,n,s){return ye(()=>{switch(e.rank){case 1:return XE(e,t,n);case 2:switch(s){case 1:return Th(e,t,n);case 2:return GA(e,t,n);default:throw new re(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Th(e,t,n);case 2:return KE(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return GA(e,t,n);default:throw new re(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Th(e,t,n);case 2:return c1(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return c1(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return GA(e,t,n);default:throw new re(`The axis is not within the rank of the tensor ${s}`)}default:throw new re(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function WA(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),jr(e,t)}function V4(e,t){switch(e.rank){case 1:return Lge([e,t]);case 2:return $ge([e,t],0);case 3:return zge([e,t],0);case 4:return Vge([e,t],0);default:throw new re(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function HA(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new re(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Xo(e,t)}function v1(e,t=0,n=1,s,r){return Vye(e,t,n,s,r)}function Za(e,t,n,s){if(e.rank<2||t.rank<2)throw new $t(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){const r=e.shape.slice(-1)[0],i=t.shape.slice(-2)[0];if(r!==i)throw new $t(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return Ez({a:e,b:t,transposeA:!1,transposeB:!1,bias:s?jA(e.rank,s,Qo()):null,activation:n});{const r=e.shape.slice(),i=r.pop();e=pe(e,[-1,i]);const o=t.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],h=Array.from({length:t.rank},(f,g)=>g===0?t.rank-2:g<=t.rank-2?g-1:g);t=pe(Zt(t,h),[l,-1]);const u=[...r,...c];return pe(Ez({a:e,b:t,transposeA:!1,transposeB:!1,bias:s?jA(e.rank,s,Qo()):null,activation:n}),u)}}function G4(e,t,n){return ye(()=>(Array.isArray(t)?t=Fi(t,"int32"):t=rt(t,"int32"),$E(e,t,n)))}function u0(e){return le(e,e)}function jA(e,t,n){const s=t.shape;if(t.rank!==1&&t.rank!==e)throw new re(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return s.length===1?pe(t,[1,s[0],1,1,1]):pe(t,[1,s[3],s[0],s[1],s[2]]);if(n==="channelsLast")return s.length===1?pe(t,[1,1,1,1,s[0]]):pe(t,[1].concat(s))}else if(e===4){if(n==="channelsFirst")return s.length===1?pe(t,[1,s[0],1,1]):pe(t,[1,s[2],s[0],s[1]]);if(n==="channelsLast")return s.length===1?pe(t,[1,1,1,s[0]]):pe(t,[1].concat(s))}else if(e===3){if(n==="channelsFirst")return s.length===1?pe(t,[1,s[0],1]):pe(t,[1,s[1],s[0]]);if(n==="channelsLast")return s.length===1?pe(t,[1,1,s[0]]):pe(t,[1].concat(s))}else if(e<3)return t;throw new re(`Unsupported input rank by biasAdd: ${t.rank}`)}function Zo(e,t,n){return ye(()=>(n==null&&(n=Qo()),us(n),ze(e,jA(e.rank,t,n))))}function wwe(e,t=1){if(t!==1)throw new $t(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return n1(e)}function Swe(e){return ye(()=>St(e,ze(Sr(e),1)))}function W4(e,t,n,s){return ye(()=>Fve(e,t,n,s))}function _we(e){return ye(()=>{const t=ze(.5,le(.2,e));return Oi(t,0,1)})}function h0(e,t,n=!1){return n?e():t()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Cwe=["fanIn","fanOut","fanAvg"],Twe=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ewe(e){_h(Cwe,"FanMode",e)}function Awe(e){_h(Twe,"Distribution",e)}class go extends Lp{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class H4 extends go{apply(t,n){return Bs(t,n)}}H4.className="Zeros";Fe(H4);class qA extends go{apply(t,n){return ph(t,n)}}qA.className="Ones";Fe(qA);class j4 extends go{constructor(t){super();if(typeof t!="object")throw new re(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new re(`config must have value set but got ${t}`);this.value=t.value}apply(t,n){return ye(()=>le(fn(this.value),ph(t,n)))}getConfig(){return{value:this.value}}}j4.className="Constant";Fe(j4);class q4 extends go{constructor(t){super();this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,n){return a1(t,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}q4.className="RandomUniform";Fe(q4);class X4 extends go{constructor(t){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new $t(`randomNormal does not support dType ${n}.`);return v1(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}X4.className="RandomNormal";Fe(X4);class K4 extends go{constructor(t){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new $t(`truncatedNormal does not support dType ${n}.`);return Sz(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}K4.className="TruncatedNormal";Fe(K4);class Y4 extends go{constructor(t){super();this.gain=t.gain!=null?t.gain:1}apply(t,n){return ye(()=>{if(t.length!==2||t[0]!==t[1])throw new re("Identity matrix initializer can only be used for 2D square matrices.");return le(this.gain,JB(t[0]))})}getConfig(){return{gain:this.gain}}}Y4.className="Identity";Fe(Y4);function Iwe(e,t="channelsLast"){let n,s;if(us(t),e.length===2)n=e[0],s=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){const r=Vc(e,2);n=e[1]*r,s=e[0]*r}else if(t==="channelsLast"){const r=Vc(e,0,e.length-2);n=e[e.length-2]*r,s=e[e.length-1]*r}}else{const r=Vc(e);n=Math.sqrt(r),s=Math.sqrt(r)}return[n,s]}class hi extends go{constructor(t){super();if(t.scale<0)throw new re(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,Ewe(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,Awe(this.distribution),this.seed=t.seed}apply(t,n){const s=Iwe(t),r=s[0],i=s[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,r):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(r+i)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new $t(`${this.getClassName()} does not support dType ${n}.`);return Sz(t,0,a,n,this.seed)}else{const a=Math.sqrt(3*o);return a1(t,-a,a,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}hi.className="VarianceScaling";Fe(hi);class XA extends hi{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return hi.className}}XA.className="GlorotUniform";Fe(XA);class KA extends hi{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return hi.className}}KA.className="GlorotNormal";Fe(KA);class YA extends hi{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return hi.className}}YA.className="HeNormal";Fe(YA);class QA extends hi{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return hi.className}}QA.className="HeUniform";Fe(QA);class ZA extends hi{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return hi.className}}ZA.className="LeCunNormal";Fe(ZA);class JA extends hi{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return hi.className}}JA.className="LeCunUniform";Fe(JA);class Q4 extends go{constructor(t){super();if(this.DEFAULT_GAIN=1,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,this.seed!=null)throw new $t("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,n){return ye(()=>{if(t.length<2)throw new $t("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);const s=t[0]>t[1]?[t[1],t[0]]:t,r=v1(s,0,1,"float32");let i=Dxe.gramSchmidt(r);return t[0]>t[1]&&(i=Zt(i)),le(this.gain,i)})}getConfig(){return{gain:this.gain,seed:this.seed}}}Q4.className="Orthogonal";Fe(Q4);const Z4={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function J4(e,t={}){return a0(e,po.getMap().classNameMap,t,"initializer")}function Qn(e){return BA(e)}function jn(e){if(typeof e=="string"){const t=e in Z4?Z4[e]:e;if(t==="GlorotNormal")return new KA;if(t==="GlorotUniform")return new XA;if(t==="HeNormal")return new YA;if(t==="HeUniform")return new QA;if(t==="LeCunNormal")return new ZA;if(t==="LeCunUniform")return new JA;{const n={};return n.className=t,n.config={},J4(n)}}else return e instanceof go?e:J4(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function eI(e){return Array.isArray(e)&&Array.isArray(e[0])}function x1(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function kt(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new re(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function ln(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new re(`Expected exactly 1 Shape; got ${e.length}`)}else return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function b1(e){let t=0;for(const n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((s,r)=>s*r);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const eU="Variable";class Nwe{constructor(t,n="float32",s=eU,r=!0,i=null){this.dtype=n==null?"float32":n,this.shape=t.shape,this.id=L4(),s=s==null?eU:s,this.originalName=B4(s),this.name=z4(this.originalName),this.trainable_=r,this.constraint=i,this.val=Mve(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),kwe(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function kwe(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function tI(e){return e.map(t=>t.read())}function nI(e){e.forEach(t=>{t[0].write(t[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class As{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class Ja{constructor(t,n,s,r,i,o,a){this.dtype=t,this.shape=n,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=a,this.id=L4(),o!=null&&(this.originalName=B4(o),this.name=z4(this.originalName)),this.rank=n.length}}let Dwe=0;class w1{constructor(t,n){this.callArgs=n,this.id=Dwe++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const s of t.inboundLayers)s!=null&&s.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const n of this.inboundLayers)n!=null?t.push(n.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Mwe=0;class Xt extends Lp{constructor(t={}){super();this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Mwe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=t.name;if(!n){const s=this.getClassName();n=Rl(s)+"_"+g1(s)}if(this.name=n,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let s;if(t.batchInputShape!=null)s=t.batchInputShape;else if(t.inputShape!=null){let i=null;t.batchSize!=null&&(i=t.batchSize),s=[i].concat(t.inputShape)}this.batchInputShape=s;let r=t.dtype;r==null&&(r=t.inputDType),r==null&&(r="float32"),this.dtype=r}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,n){return t.name+"_ib-"+n.toString()}getNodeAtIndex(t,n){if(this.inboundNodes.length===0)throw new fo(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=t)throw new re(`Asked to get ${n} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return qr(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return qr(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ka(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Ka(`Layer ${this.name} is not connected, no input to return.`);return qr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Ka(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ka(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return qr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(n=>n.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=Un(t),this.inputSpec==null||this.inputSpec.length===0)return;const n=Un(this.inputSpec);if(t.length!==n.length)throw new re(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let s=0;s<t.length;s++){const r=t[s],i=n[s];if(i==null)continue;const o=r.rank;if(i.ndim!=null&&o!==i.ndim)throw new re(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(i.maxNDim!=null&&o>i.maxNDim)throw new re(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(i.minNDim!=null&&o<i.minNDim)throw new re(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(i.dtype!=null&&r.dtype!==i.dtype)throw new re(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${r.dtype}.`);if(i.axes){const a=r.shape;for(const l in i.axes){const c=Number(l),h=i.axes[l],u=c>=0?a[c]:a[a.length+c];if(h!=null&&[h,null].indexOf(u)===-1)throw new re(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${a}.`)}}if(i.shape!=null)for(let a=0;a<i.shape.length;++a){const l=i.shape[a],c=r.shape[a];if(l!=null&&c!=null&&l!==c)throw new re(`Input ${s} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${r.shape}.`)}}}call(t,n){return t}invokeCallHook(t,n){this._callHook!=null&&this._callHook(t,n)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,n){n=n||{},this.assertNotDisposed();const s=Un(t);let r=!0;for(const o of s)if(!(o instanceof Ja)){r=!1;break}let i=!0;for(const o of s)if(o instanceof Ja){i=!1;break}if(r===i)throw new re("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ch(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const a of Un(t))o.push(a.shape);this.build(qr(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let o=this.call(t,n);const a=Un(o),l=[];for(let c of a)s.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(o=qr(l),this.activityRegularizer!=null)throw new $t("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=Pwe(t),a=this.computeOutputShape(o);let l;const c=Owe(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((h,u)=>new Ja(c,h,this,Un(t),n,this.name,u)):l=new Ja(c,a,this,Un(t),n,this.name),this.addInboundNode(t,l,null,null,o,a,n),this._refCount++,this.activityRegularizer!=null)throw new $t("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&t[r]!=null&&t[r]!==s&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Ka(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const n of this.inboundNodes){const s=JSON.stringify(n.outputShapes);t.indexOf(s)===-1&&t.push(s)}if(t.length===1){const n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&n.length===1?n[0]:n}else throw new Ka(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new fo(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return b1(this.weights)}build(t){this.built=!0}getWeights(t=!1){return tI(t?this.trainableWeights:this.weights)}setWeights(t){ye(()=>{const n=this.weights;if(n.length!==t.length)throw new re(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${n.length} weights. Provided weights: ${t}...`);if(n.length===0)return;const s=[],r=tI(n);for(let i=0;i<r.length;++i){const o=r[i],a=n[i],l=t[i];if(!dn(o.shape,l.shape))throw new re(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);s.push([a,l])}nI(s)})}addWeight(t,n,s,r,i,o,a,l){if(this._addedWeightNames.indexOf(t)!==-1)throw new re(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():jn("zeros"));const c=r.apply(n,s),h=new Nwe(c,s,t,o,a);return c.dispose(),i!=null&&this.addLoss(()=>i.apply(h.read())),o==null&&(o=!0),o?this._trainableWeights.push(h):this._nonTrainableWeights.push(h),h}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=Un(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,n){if(!this.supportsMasking){if(n!=null)if(Array.isArray(n))n.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return n}addInboundNode(t,n,s,r,i,o,a=null){const l=Un(t);n=Un(n),s=Un(s),r=Un(r),i=x1(i),o=x1(o);const c=[],h=[],u=[];for(const d of l)c.push(d.sourceLayer),h.push(d.nodeIndex),u.push(d.tensorIndex);new w1({outboundLayer:this,inboundLayers:c,nodeIndices:h,tensorIndices:u,inputTensors:l,outputTensors:n,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:o},a);for(let d=0;d<n.length;d++)n[d].sourceLayer=this,n[d].nodeIndex=this.inboundNodes.length-1,n[d].tensorIndex=d}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount==0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function Pwe(e){e=Un(e);const t=[];for(const n of e)t.push(n.shape);return qr(t)}function Owe(e){return"float32"}function tU(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{const s=t.inboundNodes[n];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const o=s.inputTensors[i],a=s.inboundLayers[i],l=s.nodeIndices[i],c=tU(o,a,l);for(const h of c)r.indexOf(h)===-1&&r.push(h)}return r}}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class d0 extends Xt{constructor(t){super({dtype:t.dtype,name:t.name!=null?t.name:g1("input").toString()});if(t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new re("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=t.batchInputShape;if(n==null){if(t.inputShape==null)throw new re("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new re("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=t.dtype||"float32";this.batchInputShape=n,this.dtype=s,this.inputSpec=[{shape:n}];const r=new Ja(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new w1({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(t,n){throw new re(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}d0.className="InputLayer";Fe(d0);function Rwe(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new re("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new d0({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Lwe(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return rt(t,e.dtype)}catch{throw new re(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}class Wc{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Wc)for(const n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(const n of t)this.add(n.key,n.value)}}add(t,n,s){if(this.id2Value[t.id]==null)this.id2Value[t.id]=Lwe(t,n),this.name2Id[t.name]=t.id,s!=null&&(this.id2Mask[t.id]=s);else throw new re(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Ja){if(this.id2Value[t.id]==null)throw new re(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const n=this.name2Id[t];if(n==null)throw new re(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof Ja){if(this.id2Value[t.id]==null)throw new re(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const n=this.name2Id[t];if(n==null)throw new re(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&qt(this.id2Mask)}}const S1=new M4,_1=new M4;function Fwe(e){S1!=null&&S1.setMaxEntries(e),_1!=null&&_1.setMaxEntries(e)}function p0(e,t,n,s){const r=n==null?!1:n.training,i=Array.isArray(e),o=i?e:[e],a=o.map(f=>f.name),l=[],c=t.names();for(const f of a)c.indexOf(f)!==-1?l.push(t.getValue(f)):l.push(null);s!=null&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const h=a.join(",")+"|"+t.names().sort().join(",");let u=S1.get(h),d;if(u==null){const f=$we(o,t);u=f.sorted,d=f.recipientCounts,S1.put(h,u),_1.put(h,d)}d={},r||Object.assign(d,_1.get(h));const p=new Wc(t);for(let f=0;f<u.length;++f){if(s!=null){const T=EE().numTensors;T>s.maxNumTensors&&(s.maxNumTensors=T),T<s.minNumTensors&&(s.minNumTensors=T)}const g=u[f],m=g.sourceLayer;if(m instanceof d0)continue;const y=[],v=[],b=[];let x=!1;for(const T of g.inputs){const E=p.getValue(T),A=p.getMask(T);y.push(E),v.push(A),A!=null&&(x=!0),r||(d[T.name]--,d[T.name]===0&&!t.hasKey(T)&&a.indexOf(T.name)===-1&&!E.isDisposed&&T.sourceLayer.stateful!==!0&&b.push(E))}x&&(n=n||{},n.mask=v[0]);const w=Un(m.apply(y,n));let S=null;m.supportsMasking&&(S=m.computeMask(y,v));const C=zwe(g),_=Array.isArray(C)?C:[C];for(let T=0;T<_.length;++T){p.hasKey(_[T])||p.add(_[T],w[T],Array.isArray(S)?S[0]:S);const E=a.indexOf(_[T].name);E!==-1&&(l[E]=w[T])}r||qt(b)}return p.disposeMasks(),i?l:l[0]}function $we(e,t){W(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],s={};if(e.length===1){const r=nU(e[0],t);n=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of e){const{sorted:o,recipientMap:a}=nU(i,t);for(const l of o)r.has(l.name)||(n.push(l),r.add(l.name));for(const l in a)s[l]==null&&(s[l]=new Set),a[l].forEach(c=>s[l].add(c))}}return{sorted:n,recipientCounts:Bwe(s)}}function Bwe(e){const t={};for(const n in e)t[n]=e[n].size;return t}function nU(e,t){const n=new Set,s=[],r={};for(const a of t.names())n.add(a);const i=[],o=[];for(i.push(e);i.length>0;){const a=i[i.length-1];if(n.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(a.inputs.length===0||l)i.pop(),s.push(a),n.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const c of a.inputs)r[c.name]==null&&(r[c.name]=new Set),r[c.name].add(a.name),!n.has(c.name)&&i.push(c)}}return{sorted:s,recipientMap:r}}function zwe(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let s=0;s<e.sourceLayer.inboundNodes.length;++s)for(const r of e.sourceLayer.inboundNodes[s].outputTensors)if(r.id===e.id){n=s;break}t=e.sourceLayer.getOutputAt(n)}return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uwe=xe();Uwe.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Fwe);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sI(e,t){return ye(()=>_r(xt(le(e,e),t,!0)))}class f0 extends Lp{getConfig(){return{}}}class sU extends f0{constructor(t){super();this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return ye(()=>{const n=sI(t,this.axis),s=Oi(n,0,this.maxValue);return le(t,St(s,ze(Es(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}sU.className="MaxNorm";Fe(sU);class rU extends f0{constructor(t){super();this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return ye(()=>St(t,ze(Es(),sI(t,this.axis))))}getConfig(){return{axis:this.axis}}}rU.className="UnitNorm";Fe(rU);class iU extends f0{apply(t){return mh(t)}}iU.className="NonNeg";Fe(iU);class oU extends f0{constructor(t){super();this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return ye(()=>{const n=sI(t,this.axis),s=ze(le(this.rate,Oi(n,this.minValue,this.maxValue)),le(1-this.rate,n));return le(t,St(s,ze(Es(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}oU.className="MinMaxNorm";Fe(oU);const aU={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Is(e){return BA(e)}function lU(e,t={}){return a0(e,po.getMap().classNameMap,t,"constraint")}function Ns(e){if(e==null)return null;if(typeof e=="string"){const n={className:e in aU?aU[e]:e,config:{}};return lU(n)}else return e instanceof f0?e:lU(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Eh(e){if(e==null)return;const t=[],n=[],s=[];for(const r in e){const i=e[r];if(typeof i!="number"){const o=i;t.push(o.data()),n.push(r),s.push(o)}}if(t.length>0){const r=await Promise.all(t);for(let i=0;i<r.length;++i)e[n[i]]=r[i][0];qt(s)}}function cU(e){if(e!=null)for(const t in e){const n=e[t];typeof n!="number"&&n.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var uU;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(uU||(uU={}));const Vwe=125;class m0{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,n){}async onEpochEnd(t,n){}async onBatchBegin(t,n){}async onBatchEnd(t,n){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class Gwe{constructor(t,n=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=n}append(t){this.callbacks.push(t)}setParams(t){for(const n of this.callbacks)n.setParams(t)}setModel(t){for(const n of this.callbacks)n.setModel(t)}async onEpochBegin(t,n){n==null&&(n={});for(const s of this.callbacks)await s.onEpochBegin(t,n)}async onEpochEnd(t,n){n==null&&(n={});for(const s of this.callbacks)await s.onEpochEnd(t,n)}async onBatchBegin(t,n){n==null&&(n={});for(const s of this.callbacks)await s.onBatchBegin(t,n)}async onBatchEnd(t,n){n==null&&(n={});for(const s of this.callbacks)await s.onBatchEnd(t,n)}async onTrainBegin(t){t==null&&(t={});for(const n of this.callbacks)await n.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const n of this.callbacks)await n.onTrainEnd(t)}}class Wwe extends m0{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,n){n==null&&(n={});const s=n.size==null?0:n.size;this.seen+=s;for(const r in n){const i=n[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let o;r in this.totals?o=this.totals[r]:this.totals[r]=0;const a=ye(()=>ze(this.totals[r],le(i,s)));this.totals[r]=a,o!=null&&o.dispose()}}}async onEpochEnd(t,n){if(n!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?n[s]=this.totals[s]/this.seen:ye(()=>{const r=le(St(1,this.seen),this.totals[s]);n[s]=r,this.totals[s].dispose(),Ha(n[s])}))}}class Hwe extends m0{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,n){n==null&&(n={}),this.epoch.push(t);for(const s in n)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(n[s])}async syncData(){const t=[],n=[],s=[];for(const i in this.history){const o=this.history[i];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];t.push(l.data()),n.push(i),s.push(a)}}const r=await Promise.all(t);for(let i=0;i<r.length;++i)this.history[n[i]][s[i]].dispose(),this.history[n[i]][s[i]]=r[i][0]}}class jwe extends m0{constructor(t,n){super();if(this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||Qz,this.yieldEvery=n||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Vwe),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");gT(this.yieldEvery)&&(this.maybeWait=awe(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,n,s){const r=[];this.yield!=null&&(await Eh(s),r.push(this.yield(t,n,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,n){this.currentEpoch=t,this.epochBegin!=null&&(await Eh(n),await this.epochBegin(t,n))}async onEpochEnd(t,n){const s=[];this.epochEnd!=null&&(await Eh(n),s.push(this.epochEnd(t,n))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(t,n){this.batchBegin!=null&&(await Eh(n),await this.batchBegin(t,n))}async onBatchEnd(t,n){const s=[];this.batchEnd!=null&&(await Eh(n),s.push(this.batchEnd(t,n))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):gT(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,t,n)),await Promise.all(s)}async onTrainBegin(t){this.trainBegin!=null&&(await Eh(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await Eh(t),await this.trainEnd(t))}}function hU(e,t){return e==null&&(e={}),e instanceof m0?[e]:Array.isArray(e)&&e[0]instanceof m0?e:Un(e).map(s=>new jwe(s,t))}class yo{constructor(){}static registerCallbackConstructor(t,n){W(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),yo.checkForDuplicate(n),yo.constructors[t]==null&&(yo.constructors[t]=[]),yo.constructors[t].push(n)}static checkForDuplicate(t){for(const n in yo.constructors)yo.constructors[+n].forEach(r=>{if(r===t)throw new re("Duplicate callback constructor.")})}static clear(){yo.constructors={}}static createCallbacks(t){const n=[];for(const s in yo.constructors){const r=+s;t>=r&&n.push(...yo.constructors[r])}return n.map(s=>new s)}}yo.constructors={};function dU(e,t,n,s,r,i,o,a,l){const c=new Hwe,h=[new Wwe,...yo.createCallbacks(t)];e!=null&&h.push(...e),h.push(c);const u=new Gwe(h);return u.setParams({epochs:n,initialEpoch:s,samples:r,steps:i,batchSize:o,verbose:t,doValidation:a,metrics:l}),{callbackList:u,history:c}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ll(e,t={},n=!1){return a0(e,po.getMap().classNameMap,t,"layer",n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function C1(e,t){return ye(()=>{e.dtype!=="float32"&&(e=rt(e,"float32"));const n=xt(u0(e),t,!0),s=t1(n.shape,Es()),r=_r($c(n,s));return St(e,r)})}function T1(e,t){return ye(()=>bs(u0(Nt(t,e)),-1))}function rI(e,t){return ye(()=>bs(Sr(Nt(t,e)),-1))}function iI(e,t){return ye(()=>{const n=Nt(e,t),s=Oi(Sr(e),Es(),Number.MAX_VALUE),r=Sr(St(n,s));return le(100,bs(r,-1))})}function qwe(e,t){return ye(()=>{const n=Oi(t,Es(),Number.MAX_VALUE),s=qa(ze(1,n)),r=Oi(e,Es(),Number.MAX_VALUE),i=qa(ze(1,r));return bs(u0(Nt(s,i)),-1)})}function Xwe(e,t){return ye(()=>{const n=$c(0,Nt(1,le(e,t)));return bs(u0(n),-1)})}function Kwe(e,t){return ye(()=>{const n=$c(0,Nt(1,le(e,t)));return bs(n,-1)})}function Ywe(e,t){return ye(()=>{const n=xt(le(e,t),-1),s=qo(le(Nt(1,e),t),-1);return $c(0,ze(1,Nt(s,n)))})}function Qwe(e,t){return ye(()=>{const n=Math.log(2),s=Nt(t,e),r=Nt(ze(s,Jg(le(-2,s))),n);return bs(r,-1)})}function g0(e,t,n=!1){return ye(()=>{if(n)t=YE(t);else{const s=xt(t,t.shape.length-1,!0);t=St(t,s)}return t=Oi(t,Es(),1-Es()),xs(xt(le(rt(e,"float32"),qa(t)),t.shape.length-1))})}function E1(e,t,n=!1){return ye(()=>{const s=rt(i1(xwe(e)),"int32");t=Oi(t,Es(),1-Es());const r=t.shape,i=pe(rz(s,r[r.length-1]),r);return g0(i,t,n)})}function Zwe(e,t){if(!dn(e.shape,t.shape))throw new re(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return ye(()=>{const n=mh(t),s=xs(Sr(t));return ze(Nt(n,le(t,e)),tz(Ml(s)))})}function A1(e,t){return ye(()=>{let n;return n=Oi(t,Es(),1-Es()),n=qa(St(n,Nt(1,n))),bs(Zwe(e,n),-1)})}function Jwe(e,t){return ye(()=>{const n=Oi(e,Es(),1),s=Oi(t,Es(),1);return xt(le(e,qa(St(n,s))),-1)})}function eSe(e,t){return ye(()=>{const n=qa(ze(Es(),t));return bs(Nt(t,le(e,n)),-1)})}function pU(e,t){return ye(()=>{const n=C1(e,-1),s=C1(t,-1),r=le(n,s);return xs(xt(r,-1))})}const I1={meanSquaredError:T1,meanAbsoluteError:rI,meanAbsolutePercentageError:iI,meanSquaredLogarithmicError:qwe,squaredHinge:Xwe,hinge:Kwe,categoricalHinge:Ywe,logcosh:Qwe,categoricalCrossentropy:g0,sparseCategoricalCrossentropy:E1,binaryCrossentropy:A1,kullbackLeiblerDivergence:Jwe,poisson:eSe,cosineProximity:pU};function oI(e){if(typeof e=="string"){if(e in I1)return I1[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new re(t)}else return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fU(e,t){return ye(()=>{const n=le(.5,ho(t)),s=Qa(Ri(t,n),e.dtype);return bs(ja(e,s),-1)})}function mU(e,t){return ye(()=>Qa(ja(Xg(e,-1),Xg(t,-1)),"float32"))}function tSe(e,t){return ye(()=>rt(xt(Pl(ja(e,1),ja(t,1))),"float32"))}function nSe(e,t){return ye(()=>rt(xt(Pl(ja(e,0),ja(t,1))),"float32"))}function sSe(e,t){return ye(()=>{const n=tSe(e,t),s=nSe(e,t),r=ze(n,s);return rt(ci(Ri(r,0),St(n,r),0),"float32")})}function rSe(e,t){return A1(e,t)}function iSe(e,t){return e.rank===t.rank&&(e=t0(e,[e.rank-1])),t=Xg(t,-1),t.dtype!==e.dtype&&(t=rt(t,e.dtype)),rt(ja(e,t),"float32")}const oSe=T1,aSe=T1,lSe=rI,cSe=rI,uSe=iI,hSe=iI,gU=g0,dSe=pU,yU=E1,N1={binaryAccuracy:fU,categoricalAccuracy:mU,precision:sSe,categoricalCrossentropy:gU,sparseCategoricalCrossentropy:yU,mse:oSe,MSE:aSe,mae:lSe,MAE:cSe,mape:uSe,MAPE:hSe,cosine:dSe};function pSe(e){if(typeof e=="string"&&e in N1)return N1[e];if(typeof e!="string"&&e!=null)return e;throw new re(`Unknown metric ${e}`)}function k1(e){if(Ya(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(const n of Object.keys(I1))if(I1[n]===e){t=n;break}if(t!==void 0)return t;for(const n of Object.keys(N1))if(N1[n]===e){t=n;break}return t!==void 0?t:e.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fSe(e){const t={Adagrad:()=>Fp.adagrad(.01),Adadelta:()=>Fp.adadelta(1,.95,Es()),Adam:()=>Fp.adam(.001,.9,.999,Es()),Adamax:()=>Fp.adamax(.002,.9,.999,Es(),0),RMSProp:()=>Fp.rmsprop(.001,.9,0,Es()),SGD:()=>Fp.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new re(`Unknown Optimizer ${e}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const vU=1*1024*1024;function xU(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!aI(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const s=JSON.stringify(e);s.length>vU&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${vU}.`)}}function aI(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t)if(typeof n!="string"||!aI(e[n]))return!1;return!0}else if(Array.isArray(e)){for(const t of e)if(!aI(t))return!1;return!0}else return!1;else{const t=typeof e;return t==="string"||t==="number"||t==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function mSe(e,t,n,s=console.log){const r=ySe(e),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(h=>Math.floor(t*h)));let o;if(!r){i.push("Receives inputs"),o=[];for(const h in e.nodesByDepth)o.push(...e.nodesByDepth[h])}s("_".repeat(t)),D1(i,n,s),s("=".repeat(t));const a=e.layers;for(let h=0;h<a.length;++h)r?vSe(a[h],n,s):xSe(a[h],n,o,s),s((h===a.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=gSe(e),c=b1(e.nonTrainableWeights);s(`Total params: ${l+c}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${c}`),s("_".repeat(t))}function gSe(e){let t;return e.collectedTrainableWeights!=null?t=b1(e.collectedTrainableWeights):t=b1(e.trainableWeights),t}function ySe(e){let t=!0;const n=[],s=[];for(const r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(const r of n){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){t=!1;break}s.push(...r)}if(t)for(const r of e.layers){let i=!1;for(const o of r.inboundNodes)if(s.indexOf(o)!==-1)if(i){t=!1;break}else i=!0;if(!t)break}return t}function D1(e,t,n=console.log){let s="";for(let r=0;r<e.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=e[r],s=s.slice(0,t[r]),s+=" ".repeat(t[r]-s.length);n(s)}function vSe(e,t,n){let s,r;try{r=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(e.outputShape)}catch{s="multiple"}const i=e.name,o=e.getClassName(),a=[`${i} (${o})`,r,s,e.countParams().toString()];D1(a,t,n)}function xSe(e,t,n,s){let r,i;try{i=e.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}const o=[];for(const u of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(u)===-1))for(let d=0;d<u.inboundLayers.length;++d){const p=u.inboundLayers[d].name,f=u.nodeIndices[d],g=u.tensorIndices[d];o.push(`${p}[${f}][${g}]`)}const a=e.name,l=e.getClassName(),c=o.length===0?"":o[0],h=[`${a} (${l})`,i,r,e.countParams().toString(),c];D1(h,t,s);for(let u=1;u<o.length;++u)D1(["","","","",o[u]],t,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bU(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function lI(e,t){if(e===null)return null;if(typeof e=="string")return Sh(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){const n=[],s=e.length;for(let r=0;r<s;++r){const i=e[r];bU(t,r,i)?n.push(i):n.push(lI(i,t))}return n}else{const n={};for(const s of Object.keys(e)){const r=e[s];if(s==="name"&&typeof r=="string")n[s]=r;else{const i=Sh(s);n[i]=lI(r,i)}}return n}}function cI(e,t){if(e==null)return null;if(typeof e=="string")return Rl(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){const n=[],s=e.length;for(let r=0;r<s;++r){const i=e[r];bU(t,r,i)?n.push(i):n.push(cI(i,t))}return n}else{const n={};for(const s of Object.keys(e)){const r=e[s],i=Rl(s);(s==="name"||s==="className")&&typeof r=="string"?n[i]=r:n[i]=cI(r,s)}return n}}/** @license See the LICENSE file. */const wU="4.2.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Jo extends Xt{constructor(t){super({});if(this.containerNodes=new Set,this.name=t.name,this.name==null){const v=this.getClassName().toLowerCase();this.name=g1(v)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Uc(this.inputs).length!==this.inputs.length)throw new re(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(v=>v.name)}`);Uc(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(v=>v.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const v of this.outputs){const b=v.sourceLayer,x=v.nodeIndex,w=v.tensorIndex;this.outputLayers.push(b),this.outputLayersNodeIndices.push(x),this.outputLayersTensorIndices.push(w)}for(const v of this.inputs){const b=v.sourceLayer,x=v.nodeIndex,w=v.tensorIndex;Ya(x===0,"input layer has >1 nodes"),Ya(w===0,"input layer has >1 tensors"),this.inputLayers.push(b),this.inputLayersNodeIndices.push(x),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let v=0;v<this.inputLayers.length;v++){const b=this.inputLayers[v];if(!(b instanceof d0))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${v} (0-based) originates from layer type ${b.getClassName()}.`);this.inputNames.push(b.name),this.feedInputShapes.push(b.batchInputShape),this.feedInputNames.push(b.name)}for(const v of this.outputLayers)this.outputNames.push(v.name);this.internalInputShapes=this.inputs.map(v=>v.shape),this.internalOutputShapes=this.outputs.map(v=>v.shape);const n={},s={},r={},i={},o={},a=[],l=(v,b,x,w,S,C)=>{(w==null||S==null||C==null)&&(w=v.sourceLayer,S=v.nodeIndex,C=v.tensorIndex);const _=w.inboundNodes[S];if(x.indexOf(_)!==-1)throw new fo(`The tensor ${v.name} at layer "${w.name}" is part of a cycle.`);if(b.indexOf(_)!==-1)return;this.containerNodes.add(Jo.nodeKey(w,S)),w.id in o||(o[w.id]=Object.keys(o).length),x.indexOf(_)===-1&&x.push(_);const T=_.inboundLayers.length;for(let E=0;E<T;E++){const A=_.inputTensors[E],D=_.inboundLayers[E],O=_.nodeIndices[E],P=_.tensorIndices[E];l(A,b,x,D,O,P)}for(b.push(_);x.indexOf(_)>=0;)x.splice(x.indexOf(_),1);a.push(_)},c=[],h=[];for(const v of this.outputs)l(v,c,h);const u=a.slice().reverse();for(const v of u){s[v.id]=v,v.id in n||(n[v.id]=0);let b=n[v.id];const x=r[v.outboundLayer.id]==null?0:r[v.outboundLayer.id];b=Math.max(b,x),r[v.outboundLayer.id]=b,i[v.outboundLayer.id]=v.outboundLayer,n[v.id]=b;for(let w=0;w<v.inboundLayers.length;w++){const S=v.inboundLayers[w],C=v.nodeIndices[w],_=S.inboundNodes[C],T=n[_.id]==null?0:n[_.id];n[_.id]=Math.max(b+1,T),s[_.id]=_}}const d={};for(const v in n){const b=n[v];b in d||(d[b]=[]),d[b].push(s[v])}const p={};for(const v in r){const b=r[v];b in p||(p[b]=[]),p[b].push(i[v])}let f=Object.keys(p).map(v=>parseInt(v,10)).sort(f1);this.layers=[];for(const v of f){const b=p[v];b.sort((x,w)=>{const S=o[x.id],C=o[w.id];return S<C?-1:S>C?1:0});for(const x of b)x instanceof Jo&&this.internalContainerRefs.push(x),this.layers.push(x)}this.layersByDepth=p,f=Object.keys(d).map(v=>parseInt(v,10)).sort(f1);const g=this.inputs.slice(),m=[];for(const v of f)for(const b of d[v]){const x=b.outboundLayer;if(x!=null){for(const w of b.inputTensors)if(g.indexOf(w)===-1)throw new fo(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${x.name}". The following previous layers were accessed without issue: ${m}`);for(const w of b.outputTensors)g.push(w);m.push(x.name)}}this.nodesByDepth=d;const y=this.layers.map(v=>v.name);for(const v of y){const b=y.filter(x=>x===v).length;if(b!==1)throw new fo(`The name "${v}" is used ${b} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new w1({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(v=>null),outputMasks:this.outputs.map(v=>null),inputShapes:this.inputs.map(v=>v.shape),outputShapes:this.outputs.map(v=>v.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount==0){for(const n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(const n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(s=>s.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new re("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const s of this.layers)n.push(...s.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){const s={};let r=0;for(const o of this.layers)for(const a of o.weights){if(s[a.originalName]!=null)throw new re(`Duplicate weight name: ${a.originalName}`);s[a.originalName]=a,r++}const i=[];for(const o in t){let a=o;if(s[o]==null){const l=o.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(s[a]!=null)i.push([s[a],t[o]]);else if(n)throw new re(`Provided weight data has no target variable: ${o}`);delete s[a]}if(n){const o=[];for(const a in s)o.push(a);if(o.length>0)throw new re(`${o.length} of ${r} weights are not set: ${o}`)}nI(i)}updatedConfig(){const t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${wU}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){const s=cI(this.updatedConfig());return n?JSON.stringify(s):s}call(t,n){return ye(()=>{t=Un(t);const s=new Wc;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],t[r]);return p0(this.outputs,s,n)})}computeMask(t,n){return ye(()=>{t=Un(t);let s;return n==null?s=wh(null,t.length):s=Un(n),this.runInternalGraph(t,s)[1]})}computeOutputShape(t){const n=x1(t);if(n.length!==this.inputLayers.length)throw new re(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<n.length;a++){const l=this.inputLayers[a],c=n[a],h=l.name+"_0_0";s[h]=c}const r=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(f1);if(r.length>1)for(const a of r){const l=this.nodesByDepth[a];for(const c of l){const h=c.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(h.id)!==-1)continue;const u=[];for(let g=0;g<c.inboundLayers.length;g++){const m=c.inboundLayers[g],y=c.nodeIndices[g],v=c.tensorIndices[g],b=`${m.name}_${y}_${v}`,x=s[b];u.push(x)}const d=h.computeOutputShape(qr(u)),p=x1(d),f=h.inboundNodes.indexOf(c);for(let g=0;g<p.length;g++){const m=`${h.name}_${f}_${g}`;s[m]=p[g]}}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],c=this.outputLayersNodeIndices[a],h=this.outputLayersTensorIndices[a],u=`${l.name}_${c}_${h}`;o.push(u)}for(let a=0;a<o.length;a++){const l=o[a];Ya(l in s),i.push(s[l])}return qr(i)}runInternalGraph(t,n){n==null&&(n=wh(null,t.length));const s={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],h=t[l],u=n[l];s[c.id]=[h,u]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(f1);for(const l of r){const c=this.nodesByDepth[l];for(const h of c){const u=h.outboundLayer,d=h.inputTensors,p=h.outputTensors,f=new Array;for(const g of d)g.id in s&&f.push(s[g.id]);if(f.length===d.length){let g={},m,y,v,b;if(h.callArgs!=null&&(g=h.callArgs),f.length===1){const[x,w]=f[0];g.mask==null&&(g.mask=w),v=Un(u.call(x,g)),b=Un(u.computeMask(x,w)),m=[x],y=[w]}else m=f.map(x=>x[0]),y=f.map(x=>x[1]),g.mask==null&&(g.mask=y),v=Un(u.call(m,g)),b=Un(u.computeMask(m,y));if(u.activityRegularizer)throw new $t("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let x=0;x<p.length;++x){const w=p[x],S=v[x],C=b[x];s[w.id]=[S,C]}}}}const i=[],o=[],a=[];for(const l of this.outputs){Ya(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[c,h]=s[l.id];a.push(c.shape),i.push(c),o.push(h)}return[i,o,a]}buildNodeConversionMap(t){const n={};let s;for(const r of this.layers){s=r instanceof Jo?1:0;for(let i=0;i<r.inboundNodes.length;i++){const o=Jo.nodeKey(r,i);this.containerNodes.has(o)&&(n[o]=s,s+=1)}}return n}getLayer(t,n){if(n!=null){if(this.layers.length<=n)throw new re(`Was asked to retrieve layer at index ${n}, but model only has ${this.layers.length} layer(s).`);return this.layers[n]}else if(t==null)throw new re("Provide either a layer name or layer index");for(const s of this.layers)if(s.name===t)return s;throw new re(`No such layer: ${t}`)}calculateLosses(){return ye(()=>{const t=[];for(const n of this.layers)for(let s=0;s<n.inboundNodes.length;++s){const r=Jo.nodeKey(n,s);this.containerNodes.has(r)&&t.push(...n.calculateLosses())}return t})}getConfig(){const t={name:this.name},n=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let u=0;u<o.inboundNodes.length;u++){const d=o.inboundNodes[u],p=Jo.nodeKey(o,u);let f={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),f=d.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(d.inboundLayers.length>0){const g=[];for(let m=0;m<d.inboundLayers.length;m++){const y=d.inboundLayers[m],v=d.nodeIndices[m],b=d.tensorIndices[m],x=Jo.nodeKey(y,v);let w=n[x];w==null&&(w=0),g.push([y.name,w,b,f])}c.push(g)}}}const h={};h.name=o.name,h.className=a,h.config=l,h.inboundNodes=c,s.push(h)}t.layers=s;const r=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],c=Jo.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let h=n[c];h==null&&(h=0);const u=this.inputLayersTensorIndices[o];r.push([a.name,h,u])}t.inputLayers=r;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],c=Jo.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let h=n[c];h==null&&(h=0);const u=this.outputLayersTensorIndices[o];i.push([a.name,h,u])}return t.outputLayers=i,t}static fromConfig(t,n,s={},r=!1){const i={},o={};function a(m,y){m.name in o?o[m.name].push(y):o[m.name]=[y]}function l(m,y){const v=[];let b;for(const x of y){const w=x[0],S=x[1],C=x[2];if(b=x[3]==null?{}:x[3],!(w in i)){a(m,y);return}const _=i[w];if(_.inboundNodes.length<=S){a(m,y);return}const T=_.inboundNodes[S];v.push(T.outputTensors[C])}v.length>0&&m.apply(qr(v),b)}function c(m){const y=m.name,v=Ll(m,n.customObjects!=null?n.customObjects:{});v.setFastWeightInitDuringBuild(r),i[y]=v,m.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new re(`Corrupted configuration, expected array for nodeData: ${x}`);a(v,x)})}const h=n.name,u=n.layers;for(const m of u)c(m);for(;!owe(o);)for(const m of u){const y=i[m.name];if(y.name in o){const v=o[y.name];delete o[y.name];for(const b of v)l(y,b)}}const d=[],p=[],f=n.inputLayers;for(const m of f){const y=m[0],v=m[1],b=m[2];Ya(y in i);const w=i[y].inboundNodes[v].outputTensors;d.push(w[b])}const g=n.outputLayers;for(const m of g){const y=m[0],v=m[1],b=m[2];Ya(y in i);const w=i[y].inboundNodes[v].outputTensors;p.push(w[b])}return new t({inputs:d,outputs:p,name:h})}get stateful(){if(this._stateful)throw new re("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){ye(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bSe(e,t,n){const s=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>null);if(s===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==s)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){const r=[];return t.forEach(i=>{i in e?r.push(e[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${n} must be either an array with ${s} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function SU(e,t){return bSe(e,t,"classWeight")}async function _U(e,t,n,s){if(t!=null||s!=null)throw new Error("Support sampleWeight is not implemented yet");if(n!=null){const r=ye(()=>{if(e.shape.length===1)return lh(e);if(e.shape.length===2){if(e.shape[1]>1)return Xg(e,1);if(e.shape[1]===1)return pe(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());qt(r);const o=[];return i.forEach(a=>{if(n[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(n[a])}),Fi(o,"float32")}else return null}function wSe(e,t){return le(e,t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const SSe=32;function CU(e,t){let n,s;const r=t;n=r.xs,s=r.ys,W(n!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const i=TU("input",e.inputNames,n),o=TU("output",e.outputNames,s),a=i[0].shape[0];W(i.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),W(o.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<i.length;l++)W(i[l].shape[0]===a,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${e.inputNames[0]}.`);for(let l=0;l<o.length;l++)W(o[l].shape[0]===a,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${e.inputNames[0]}.`);return{xs:i,ys:o}}function TU(e,t,n){if(n instanceof ys)return[n];if(Array.isArray(n))return W(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{const s=[];for(const r of t){if(n[r]==null)throw new re(`The feature data generated by the dataset lacks the required ${e} key '${r}'.`);s.push(n[r])}return s}}function _Se(e){if(e.length===3)throw new $t("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function CSe(e,t,n){const s=n.batchesPerEpoch!=null;if(W(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),W(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),W(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),W(!s||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),W(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const r=n.validationData!=null;let i,o;if(r)if(EU(n.validationData))W(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const m=_Se(n.validationData);i=m.xs,o=m.ys}const a=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let c;r?c=l.slice().concat(l.map(m=>"val_"+m)):c=l.slice();const h=hU(n.callbacks,n.yieldEvery),u=n.verbose==null?1:n.verbose,{callbackList:d,history:p}=dU(h,u,n.epochs,null,null,TSe(t,n),null,r,c);d.setModel(e),e.history=p,await d.onTrainBegin(),e.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,g=await t.iterator();for(;f<n.epochs;){const m={};await d.onEpochBegin(f);let y=0,v=0;for(s||(g=await t.iterator());s?y<n.batchesPerEpoch:!0;){const b=await g.next();if(s&&b.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(b.value!=null){const{xs:x,ys:w}=CU(e,b.value),S={};S.batch=v,S.size=x[0].shape[0],await d.onBatchBegin(v,S);const C=[];if(n.classWeight!=null){const E=SU(n.classWeight,e.outputNames);for(let A=0;A<E.length;++A)C.push(await _U(w[A],null,E[A]))}const _=x.concat(w).concat(C),T=a(_);qt(_);for(let E=0;E<l.length;++E){const A=l[E],D=T[E];S[A]=D,Ha(D)}await d.onBatchEnd(v,S),cU(S),v++,y++}if(s?y>=n.batchesPerEpoch:b.done){if(r){let x;EU(n.validationData)?x=Un(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):x=Un(e.evaluate(i,o,{batchSize:n.validationBatchSize==null?SSe:n.validationBatchSize,verbose:0}));for(let w=0;w<e.metricsNames.length;++w)m[`val_${e.metricsNames[w]}`]=x[w]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,m),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function TSe(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function EU(e){return typeof e.iterator=="function"}function ESe(e){return typeof e.next=="function"}async function ASe(e,t,n){n=n||{};const s=n.batches!=null,r=e.testFunction;let i=[];if(n.verbose>0)throw new $t("Verbose mode is not implemented yet.");W(!s||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const o=ESe(t)?t:await t.iterator();let a=0,l=0;for(;s?l<n.batches:!0;){const c=await o.next();if(i=ye(()=>{if(c.value){const{xs:h,ys:u}=CU(e,c.value),d=h.concat(u),p=ye(()=>r(d));if(qt(d),l===0)for(let g=0;g<p.length;++g)i.push(fn(0));const f=d[0].shape[0];for(let g=0;g<p.length;++g){const m=p[g],y=i[g];i[g]=ye(()=>ze(i[g],le(f,m))),l>0&&qt(y)}qt(p),a+=f,++l}return i}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<i.length;++c){const h=i[c];i[c]=St(i[c],a),qt(h)}return qr(i)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function uI(e){W(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function y0(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(s=>Th(s,t,n-t)):Th(e,t,n-t)}function hI(e,t){return ye(()=>e==null?null:Array.isArray(e)?e.map(n=>hI(n,t)):G4(e,t.dtype==="int32"?t:rt(t,"int32")))}function dI(e,t){const n=[];let s=0,r=null;for(;s<e;)r=s+t,r>=e&&(r=e),n.push([s,r]),s=r;return n}function AU(e){const t=[];e instanceof ys&&(e=[e]);for(let n=0;n<e.length;++n){const s=e[n];if(s.rank===1)t.push(c0(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function ea(e,t){if(e==null)return;const n=[];if(t instanceof ys)n.push(t.id);else if(Array.isArray(t))t.forEach(r=>n.push(r.id));else if(t!=null)for(const r in t){const i=t[r];n.push(i.id)}const s=[];if(e instanceof ys)n.indexOf(e.id)===-1&&s.push(e);else if(Array.isArray(e))e.forEach(r=>{n.indexOf(r.id)===-1&&s.push(r)});else if(e!=null)for(const r in e){const i=e[r];n.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ISe(e){return e instanceof ys}function pI(e){return Array.isArray(e)}function IU(e){return!ISe(e)&&!pI(e)}function NU(e,t,n,s=!0,r=""){if(t==null||t.length===0){if(e!=null){let o=!1;if(pI(e)&&e.length>0)o=!0;else if(IU(e)){for(const a in e)if(e.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new re(`Error when checking model ${r} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(o=>null);let i;if(IU(e)){e=e,i=[];for(const o of t){if(e[o]==null)throw new re(`No data provided for "${o}". Need data for each key in: ${t}`);i.push(e[o])}}else if(pI(e)){if(e=e,e.length!==t.length)throw new re(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);i=e}else{if(e=e,t.length>1)throw new re(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);i=[e]}if(i=AU(i),n!=null)for(let o=0;o<t.length;++o){if(n[o]==null)continue;const a=i[o];if(a.shape.length!==n[o].length)throw new re(`Error when checking ${r}: expected ${t[o]} to have ${n[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<n[o].length;++l){if(l===0&&!s)continue;const c=a.shape[l],h=n[o][l];if(h!=null&&h>=0&&c!==h)throw new re(`${r} expected a batch of elements where each example has shape [${n[o].slice(1,n[o].length)}] (i.e.,tensor shape [*,${n[o].slice(1,n[o].length)}]) but the ${r} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function NSe(e,t,n){const s=Uc(e.map(i=>i.shape[0]));s.sort();const r=Uc(t.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new re(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(r.length>1)throw new re(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!dn(s,r))throw new re(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function kSe(e,t,n){const s=[T1,A1,g0];for(let r=0;r<e.length;++r){const i=e[r],o=t[r],a=n[r];if(o!=null){if(o===g0&&i.shape[i.shape.length-1]===1)throw new re(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){const l=i.shape.slice(1),c=a.slice(1);for(let h=0;h<l.length;++h){const u=l[h],d=c[h];if(d!=null&&u!==d)throw new re(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function kU(e,t,n,s=!0,r=""){let i;if(Array.isArray(e)){if(e.length!==t.length)throw new re(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);i=e}else{if(t.length>1)throw new re(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);i=[e]}if(n!=null)for(let o=0;o<t.length;++o){if(n[o]==null)continue;const a=i[o];if(a.shape.length!==n[o].length)throw new re(`Error when checking ${r}: expected ${t[o]} to have ${n[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<n[o].length;++l){if(l===0&&!s)continue;const c=a.shape[l],h=n[o][l];if(h!=null&&h!==c)throw new re(`Error when checking ${r}: expected ${t[o]} to have shape ${JSON.stringify(n[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function DSe(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(s=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(s=>n);{const s=[];for(const r of t){let i=n.hasOwnProperty(r)?n[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const MSe="layers-model";class zp extends Jo{constructor(t){super(t);this.isTraining=!1}summary(t,n,s=console.log){if(!this.built)throw new re("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");mSe(this,t,n,s)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=fSe(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof zc))throw new re("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const o in t.loss)if(this.outputNames.indexOf(o)===-1)throw new re(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)t.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),n.push(oI(t.loss[o]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new re(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);n=t.loss.map(a=>oI(a))}else{const o=oI(t.loss);this.outputs.forEach(a=>{n.push(o)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const s=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ch("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const r=DSe(t.metrics,this.outputNames),i=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};Ch("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=r[o];(c=>{const h="";let u,d,p;for(const f of c){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){const m=this.internalOutputShapes[o];m[m.length-1]===1||this.lossFunctions[o]===A1?["accuracy","acc"].indexOf(f)!==-1?d=fU:["crossentropy","ce"].indexOf(f)!==-1&&(d=rSe):this.lossFunctions[o]===E1?["accuracy","acc"].indexOf(f)!==-1?d=iSe:["crossentropy","ce"].indexOf(f)!==-1&&(d=yU):["accuracy","acc"].indexOf(f)!==-1?d=mU:["crossentropy","ce"].indexOf(f)!==-1&&(d=gU);let y;["accuracy","acc"].indexOf(f)!==-1?y="acc":["crossentropy","ce"].indexOf(f)!==-1&&(y="ce"),p=d,u=h+y}else p=pSe(f),u=h+k1(f);let g;Ch(u,()=>{g=p}),i(o,u,g)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,n,s={}){const r=s.batchSize==null?32:s.batchSize;uI(r);const i=!0,o=this.standardizeUserDataXY(t,n,i,r);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,a,r,s.verbose,s.steps);return qr(c)}finally{ea(o[0],t),ea(o[1],n)}}async evaluateDataset(t,n){return this.makeTestFunction(),ASe(this,t,n)}checkNumSamples(t,n,s,r="steps"){let i;if(s!=null){if(i=null,n!=null)throw new re(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(t!=null)Array.isArray(t)?i=t[0].shape[0]:i=t.shape[0];else throw new re(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(t,n){if(Array.isArray(n)&&n.length===0)throw new re("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(n),r=s?n:[n],i=this.retrieveSymbolicTensors(r),o=new Wc;if(t instanceof ys&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new re(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],t[l])}else for(const l of this.inputs){const c=t[l.name];if(c==null)throw new re(`No value is provided for the model's input ${l.name}`);o.add(l,c)}const a=p0(i,o);return s?a:a[0]}retrieveSymbolicTensors(t){const n=wh(null,t.length);let s=t.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],o=i.map(a=>a.name);for(let a=0;a<t.length;++a){const l=o.indexOf(t[a]);if(l!==-1&&(n[a]=i[l],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw n.forEach((i,o)=>{i==null&&r.push(t[o])}),new re(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return n}predictLoop(t,n=32,s=!1){return ye(()=>{const r=this.checkNumSamples(t);if(s)throw new $t("Verbose predictLoop() is not implemented yet.");const i=dI(r,n),o=this.outputs.map(a=>[]);for(let a=0;a<i.length;++a)ye(()=>{const c=i[a][0],h=i[a][1],u=y0(t,c,h),d=[];if(Array.isArray(u))for(let f=0;f<u.length;++f)d.push({key:this.inputs[f],value:u[f]});else d.push({key:this.inputs[0],value:u});const p=new Wc(d);return p0(this.outputs,p)}).forEach((c,h)=>o[h].push(c));return qr(o.map(a=>jr(a,0)))})}predict(t,n={}){const s=AU(t);kU(s,this.inputNames,this.feedInputShapes,!1);try{const r=n.batchSize==null?32:n.batchSize;return uI(r),this.predictLoop(s,r)}finally{ea(s,t)}}predictOnBatch(t){kU(t,this.inputNames,this.feedInputShapes,!0);const n=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,n)}standardizeUserDataXY(t,n,s=!0,r){if(this.optimizer_==null)throw new fo("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===E1?i.push(a.slice(0,a.length-1).concat([1])):i.push(a)}if(t=NU(t,this.feedInputNames,this.feedInputShapes,!1,"input"),n=NU(n,this.feedOutputNames,i,!1,"target"),NSe(t,n),kSe(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&t[0].shape[0]%r!=0)throw new re(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${t[0].shape[0]} sample(s).`);return[t,n]}async standardizeUserData(t,n,s,r,i=!0,o){const[a,l]=this.standardizeUserDataXY(t,n,i,o);if(s!=null)throw new Error("sample weight is not supported yet.");let c=null;if(r!=null){const h=SU(r,this.outputNames);c=[];for(let u=0;u<h.length;++u)c.push(await _U(l[u],null,h[u]))}return[a,l,c]}testLoop(t,n,s,r=0,i){return ye(()=>{const o=this.checkNumSamples(n,s,i,"steps"),a=[];if(r>0)throw new $t("Verbose mode is not implemented yet.");if(i!=null)throw new $t("steps mode in testLoop() is not implemented yet");{const l=dI(o,s),c=Fi(Yo(0,o));for(let h=0;h<l.length;++h){const u=l[h][0],d=l[h][1],p=Th(c,u,d-u),f=hI(n,p),g=t(f);if(h===0)for(let m=0;m<g.length;++m)a.push(fn(0));for(let m=0;m<g.length;++m){const y=g[m];a[m]=ze(a[m],le(d-u,y))}}for(let h=0;h<a.length;++h)a[h]=St(a[h],o)}return a})}getDedupedMetricsNames(){const t=this.metricsNames,n=[];for(let s=0;s<t.length;++s){const r=t[s];let i=r;P4(t,r)>1&&(i+=`_${P4(t.slice(0,s),r)}`),n.push(i)}return n}makeTrainFunction(){return t=>{const n=[],s=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const u=[];for(let g=0;g<this.inputs.length;++g)u.push({key:this.inputs[g],value:s[g]});const d=new Wc(u),p=p0(this.outputs,d,{training:!0});let f;for(let g=0;g<this.lossFunctions.length;++g){let y=this.lossFunctions[g](r[g],p[g]);i[g]!=null&&(y=wSe(y,i[g]));const v=bs(y);n.push(v),g===0?f=y:f=ze(f,y)}for(let g=0;g<this.metricsTensors.length;++g){let m;if(this.outputs.length>1&&g<this.outputs.length)m=n[g];else{const y=this.metricsTensors[g][0],v=this.metricsTensors[g][1];m=bs(y(r[v],p[v]))}Ha(m),o.push(m)}return f=bs(f),this.calculateLosses().forEach(g=>{f=ze(f,g)}),f},l=this.collectedTrainableWeights.map(u=>u.read()),c=!0;return[this.optimizer_.minimize(a,c,l)].concat(o)}}makeTestFunction(){this.testFunction=t=>ye(()=>{const n=[];let s;const r=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let c=0;c<this.inputs.length;++c)o.push({key:this.inputs[c],value:r[c]});const a=new Wc(o),l=p0(this.outputs,a);for(let c=0;c<this.lossFunctions.length;++c){const h=this.lossFunctions[c],u=bs(h(i[c],l[c]));c===0?s=u:s=ze(s,u),n.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const h=this.metricsTensors[c][0],u=this.metricsTensors[c][1],d=bs(h(i[u],l[u]));n.push(d)}return n})}async fit(t,n,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,o,a,l,c,h,u,d;try{const p=s.batchSize==null?32:s.batchSize;uI(p);const f=!1,g=await this.standardizeUserData(t,n,s.sampleWeight,s.classWeight,f,p);r=g[0],i=g[1],d=g[2];let m=!1,y;if(s.validationData!=null&&s.validationData.length>0){if(m=!0,s.validationData.length===2)l=s.validationData[0],c=s.validationData[1];else throw s.validationData.length===3?new $t("validationData including sample weights is not supported yet."):new re(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const T=!0,E=await this.standardizeUserData(l,c,null,null,T,p);h=E[0],u=E[1],y=h.concat(u)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){m=!0;const T=Math.floor(r[0].shape[0]*(1-s.validationSplit)),E=r[0].shape[0];h=y0(r,T,E),o=r,r=y0(r,0,T),u=y0(i,T,E),a=i,i=y0(i,0,T),y=h.concat(u)}else s.validationSteps!=null&&(m=!0);const v=r.concat(i).concat(d);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),x=this.getDedupedMetricsNames();let w,S;m?(this.makeTestFunction(),w=this.testFunction,S=x.slice().concat(x.map(T=>"val_"+T))):(w=null,y=[],S=x.slice());const C=hU(s.callbacks,s.yieldEvery);return await this.fitLoop(b,v,x,p,s.epochs,s.verbose,C,w,y,s.shuffle,S,s.initialEpoch,null,null)}finally{this.isTraining=!1,ea(r,t),ea(i,n),ea(o,t),ea(a,n),ea(h,l),ea(u,c),d!=null&&qt(d)}}async fitLoop(t,n,s,r,i,o,a,l,c,h,u,d,p,f){r==null&&(r=32),i==null&&(i=1),h==null&&(h=!0),d==null&&(d=0);let g=!1;if(l!=null&&c!=null&&(g=!0),f!=null&&(g=!0,p==null))throw new re("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(n,r,p,"steps_per_epoch");let y;m!=null&&(y=Yo(0,m)),o==null&&(o=1);const{callbackList:v,history:b}=dU(a,o,i,d,m,p,r,g,u);v.setModel(this),this.history=b,await v.onTrainBegin(),this.stopTraining_=!1;for(let x=d;x<i;++x){await v.onEpochBegin(x);const w={};if(p!=null)throw new $t("stepsPerEpoch mode is not implemented yet.");{if(h==="batch")throw new $t("batch shuffling is not implemneted yet");h&&_fe(y);const S=Fi(y),C=dI(m,r);for(let _=0;_<C.length;++_){const T={};if(await v.onBatchBegin(_,T),ye(()=>{const E=C[_][0],A=C[_][1],D=Th(S,E,A-E);T.batch=_,T.size=A-E;const O=hI(n,D),P=t(O);for(let L=0;L<s.length;++L){const B=s[L],F=P[L];T[B]=F,Ha(F)}if(_===C.length-1&&g){const L=this.testLoop(l,c,r);for(let B=0;B<s.length;++B){const F=s[B],M=L[B];Ha(M),w["val_"+F]=M}}}),await v.onBatchEnd(_,T),cU(T),this.stopTraining_)break}S.dispose()}if(await v.onEpochEnd(x,w),this.stopTraining_)break}return await v.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,n){return CSe(this,t,n)}async trainOnBatch(t,n){const s=await this.standardizeUserData(t,n),r=s[0],i=s[1],a=this.makeTrainFunction()(r.concat(i)),l=[];for(const c of a){const h=await c.data();l.push(h[0])}return qt(a),ea(s[0],t),ea(s[1],n),qr(l)}getNamedWeights(t){const n=[],s=t!=null&&t.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let o=0;o<r.length;++o)s&&!r[o].trainable||n.push({name:r[o].originalName,tensor:i[o]});return n}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const n=EE().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=n-EE().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=Rl(this.loss);else if(Array.isArray(this.loss)){for(const n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(n=>Rl(n))}else{const n=Object.keys(this.loss);t={};const s=this.loss;for(const r of n)if(typeof s[r]=="string")t[r]=Rl(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Rl(k1(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Rl(k1(t)));{const t={};for(const n in this.metrics)t[n]=Rl(k1(this.metrics[n]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const n=lI(t.optimizer_config),s=Ll(n);let r;if(typeof t.loss=="string")r=Sh(t.loss);else if(Array.isArray(t.loss))r=t.loss.map(o=>Sh(o));else if(t.loss!=null){r={};for(const o in t.loss)r[o]=Sh(t.loss[o])}let i;if(Array.isArray(t.metrics))i=t.metrics.map(o=>Sh(o));else if(t.metrics!=null){i={};for(const o in t.metrics)i[o]=Sh(t.metrics[o])}this.compile({loss:r,metrics:i,optimizer:s})}async save(t,n){if(typeof t=="string"){const c=yme(t);if(c.length===0)throw new re(`Cannot find any save handlers for URL '${t}'`);if(c.length>1)throw new re(`Found more than one (${c.length}) save handlers for URL '${t}'`);t=c[0]}if(t.save==null)throw new re("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await DB(this.getNamedWeights(n)),r=!1,i=null,a={modelTopology:this.toJSON(i,r),format:MSe,generatedBy:`TensorFlow.js tfjs-layers v${wU}`,convertedBy:null};if((n==null?!1:n.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:h,specs:u}=await DB(await this.optimizer.getWeights(),c);s.specs.push(...u),s.data=PB([s.data,h])}if(this.userDefinedMetadata!=null){const c=!0;xU(this.userDefinedMetadata,this.name,c),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=s.data,a.weightSpecs=s.specs,t.save(a)}setUserDefinedMetadata(t){xU(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}zp.className="Model";Fe(zp);class DU extends zp{}DU.className="Functional";Fe(DU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class v0 extends zp{constructor(t){super({inputs:[],outputs:[]});if(t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:g1("sequential_"),t.layers!=null)for(const n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new re(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const n=t instanceof v0||t instanceof zp;let s;if(n){if(s=t,s.outputs.length!==1)throw new re("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new re("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new re("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=Rwe({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(r)}if(n)this.outputs=s.outputs,this.inputs=s.inputs;else{if(t.inboundNodes.length!==1)throw new re(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new re("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=tU(this.outputs[0])}this.inboundNodes=[],new w1({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:wh(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=t.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(ln(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new zp({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,s=console.log){this.built||this.build(),super.summary(t,n,s)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,s={}){if(!this.built)throw new fo("The model needs to be compiled before being used.");return this.model.evaluate(t,n,s)}async evaluateDataset(t,n){if(!this.built)throw new fo("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,s={}){if(!this.built)throw new fo("The model needs to be compiled before being used.");return this.model.fit(t,n,s)}async fitDataset(t,n){if(!this.built)throw new fo("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,s={},r=!1){let i,o={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new re("Legacy serialization format not supported yet.");i=n}else W(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=n.layers,delete n.layers,o=n;const a=new t(o);if(!(a instanceof v0))throw new $t(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of i){const h=Ll(l,void 0,r);r&&h.setFastWeightInitDuringBuild(!0),a.add(h)}return a}set stopTraining(t){if(this.model==null)throw new re("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new re("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const n of this.layers){const s={};s.className=n.getClassName(),s.config=n.getConfig(),t.push(s)}return{name:this.name,layers:t}}}v0.className="Sequential";Fe(v0);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Xr extends Lp{getConfig(){return{}}}class MU extends Xr{apply(t,n=1){return wwe(t,n)}}MU.className="elu";Fe(MU);class PU extends Xr{apply(t){return gz(t)}}PU.className="selu";Fe(PU);class OU extends Xr{apply(t){return mh(t)}}OU.className="relu";Fe(OU);class RU extends Xr{apply(t){return ye(()=>GE(6,mh(t)))}}RU.className="relu6";Fe(RU);class LU extends Xr{apply(t){return t}}LU.className="linear";Fe(LU);class FU extends Xr{apply(t){return Np(t)}}FU.className="sigmoid";Fe(FU);class $U extends Xr{apply(t){return _we(t)}}$U.className="hardSigmoid";Fe($U);class BU extends Xr{apply(t){return Jg(t)}}BU.className="softplus";Fe(BU);class zU extends Xr{apply(t){return Swe(t)}}zU.className="softsign";Fe(zU);class UU extends Xr{apply(t){return DE(t)}}UU.className="tanh";Fe(UU);class fI extends Xr{apply(t,n=-1){return YE(t,n)}}fI.className="softmax";Fe(fI);class VU extends Xr{apply(t,n=-1){return nz(t,n)}}VU.className="logSoftmax";Fe(VU);class GU extends Xr{apply(t,n=1){return ye(()=>le(Np(le(t,n)),t))}}GU.className="swish";Fe(GU);class WU extends Xr{apply(t){return ye(()=>le(t,DE(Jg(t))))}}WU.className="mish";Fe(WU);function Hc(e){return e.getClassName()}function mI(e,t={}){return a0(e,po.getMap().classNameMap,t,"activation")}function jc(e){if(e==null){const t={};return t.className="linear",t.config={},mI(t)}if(typeof e=="string"){const t={};return t.className=e,t.config={},mI(t)}else return e instanceof Xr?e:mI(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function PSe(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}class HU extends Lp{}class jU extends HU{constructor(t){super();PSe(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return ye(()=>{let n=Bs([1]);return this.hasL1&&(n=ze(n,xt(le(this.l1,Sr(t))))),this.hasL2&&(n=ze(n,xt(le(this.l2,u0(t))))),pe(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,n){return new t({l1:n.l1,l2:n.l2})}}jU.className="L1L2";Fe(jU);const qU={l1l2:"L1L2"};function An(e){return BA(e)}function XU(e,t={}){return a0(e,po.getMap().classNameMap,t,"regularizer")}function qn(e){if(e==null)return null;if(typeof e=="string"){const n={className:e in qU?qU[e]:e,config:{}};return XU(n)}else return e instanceof HU?e:XU(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class KU extends Xt{constructor(t){super(t==null?{}:t);this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,n){t=kt(t);let s=mh(t);return this.maxValue!=null&&(s=Oi(s,0,this.maxValue)),s}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},n=super.getConfig();return Object.assign(t,n),t}}KU.className="ReLU";Fe(KU);class YU extends Xt{constructor(t){super(t==null?{}:t);this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const s=kt(t);return zE(s,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}}YU.className="LeakyReLU";Fe(YU);class QU extends Xt{constructor(t){super(t==null?{}:t);if(this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=jn(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=qn(t.alphaRegularizer),this.alphaConstraint=Ns(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new re(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=ln(t);const n=t.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)n[r-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<t.length;++r)s[r]=t[r];this.inputSpec=[new As({ndim:t.length,axes:s})],this.built=!0}call(t,n){return t=kt(t),qE(t,this.alpha.read())}getConfig(){const t={alphaInitializer:Qn(this.alphaInitializer),alphaRegularizer:An(this.alphaRegularizer),alphaConstraint:Is(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(t,n),t}}QU.className="PReLU";Fe(QU);class ZU extends Xt{constructor(t){super(t==null?{}:t);if(this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new $t(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const s=kt(t);return n1(s)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}}ZU.className="ELU";Fe(ZU);class JU extends Xt{constructor(t){super(t==null?{}:t);this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,n){const s=kt(t);return le(s,rt(Ri(s,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},n=super.getConfig();return Object.assign(t,n),t}}JU.className="ThresholdedReLU";Fe(JU);class eV extends Xt{constructor(t){super(t==null?{}:t);this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new fI().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,n){const s=kt(t);return this.softmax(s,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}}eV.className="Softmax";Fe(eV);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Up(e,t,n){if(typeof e=="number")return wh(e,t);if(e.length!==t)throw new re(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let s=0;s<t;++s){const r=e[s];if(!ywe(r))throw new re(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${r}`)}return e}function ta(e,t,n,s,r=1){if(e==null)return e;const i=t+(t-1)*(r-1);let o;return n==="same"?o=e:o=e-i+1,Math.floor((o+s-1)/s)}function el(e,t,n,s){if(e==null)return null;if(s==="valid")e=e*t+Gc([n-t,0]);else if(s==="same")e=e*t;else throw new re(`Unsupport padding mode: ${s}.`);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gI(e,t){return ye(()=>(us(t),t==="channelsFirst"?Zt(e,[0,2,3,1]):e))}function tV(e,t){return ye(()=>(us(t),t==="channelsFirst"?Zt(e,[0,2,3,4,1]):e))}function OSe(e,t,n,s=1,r="valid",i,o=1){return ye(()=>{if(i==null&&(i=Qo()),us(i),e.shape.length!==3)throw new re(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new re(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new re(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(i==="channelsFirst"&&(e=Zt(e,[0,2,1])),r==="causal")throw new $t("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=HB(e,t,s,r==="same"?"same":"valid","NWC",o);return n!=null&&(a=Zo(a,n)),a})}function nV(e,t,n,s=[1,1],r="valid",i,o,a=null){return ye(()=>{if(i==null&&(i=Qo()),us(i),e.rank!==3&&e.rank!==4)throw new re(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new re(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=gI(e,i);if(r==="causal")throw new $t("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=zve({x:l,filter:t,strides:s,pad:r==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:a}),i==="channelsFirst"&&(l=Zt(l,[0,3,1,2])),l})}function RSe(e,t,n,s=[1,1,1],r="valid",i,o){return ye(()=>{if(i==null&&(i=Qo()),us(i),e.rank!==4&&e.rank!==5)throw new re(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new re(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let a=tV(e,i);if(r==="causal")throw new $t("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=Xge(a,t,s,r==="same"?"same":"valid","NDHWC",o),n!=null&&(a=Zo(a,n)),i==="channelsFirst"&&(a=Zt(a,[0,4,1,2,3])),a})}class M1 extends Xt{constructor(t,n){super(n);if(this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",M1.verifyArgs(n),this.rank=t,zs(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new $t(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Up(n.kernelSize,t,"kernelSize"),this.strides=Up(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,$i(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,us(this.dataFormat),this.activation=jc(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=jn(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ns(n.biasConstraint),this.biasRegularizer=qn(n.biasRegularizer),this.activityRegularizer=qn(n.activityRegularizer),this.dilationRate=Up(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new re(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new re(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new re(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Ya("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!UA(t.kernelSize,"number",1,3))throw new re(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Hc(this.activation),useBias:this.useBias,biasInitializer:Qn(this.biasInitializer),biasRegularizer:An(this.biasRegularizer),activityRegularizer:An(this.activityRegularizer),biasConstraint:Is(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}}class Vp extends M1{constructor(t,n){super(t,n);this.kernel=null,Vp.verifyArgs(n),this.filters=n.filters,zs(this.filters,"filters"),this.kernelInitializer=jn(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ns(n.kernelConstraint),this.kernelRegularizer=qn(n.kernelRegularizer)}build(t){t=ln(t);const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new re(`The channel dimension of the input should be defined. Found ${t[n]}`);const s=t[n],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:s}}],this.built=!0}call(t,n){return ye(()=>{t=kt(t);let s;const r=this.bias==null?null:this.bias.read(),i=R4(this.activation.getClassName());if(i!=null&&this.rank===2)s=nV(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=OSe(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=nV(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=RSe(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new $t("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(t){t=ln(t);const n=[],s=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<s.length;++i){const o=ta(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);n.push(o)}let r=[t[0]];return this.dataFormat==="channelsLast"?(r=r.concat(n),r.push(this.filters)):(r.push(this.filters),r=r.concat(n)),r}getConfig(){const t={filters:this.filters,kernelInitializer:Qn(this.kernelInitializer),kernelRegularizer:An(this.kernelRegularizer),kernelConstraint:Is(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new re(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class x0 extends Vp{constructor(t){super(2,t);x0.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!UA(t.kernelSize,"number",1,2))throw new re(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}x0.className="Conv2D";Fe(x0);class b0 extends Vp{constructor(t){super(3,t);b0.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new re(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}b0.className="Conv3D";Fe(b0);class sV extends x0{constructor(t){super(t);if(this.inputSpec=[new As({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new re(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=ln(t),t.length!==4)throw new re("Input should have rank 4; Received input shape: "+JSON.stringify(t));const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new re("The channel dimension of the inputs should be defined. Found `None`.");const s=t[n],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new As({ndim:4,axes:{[n]:s}})],this.built=!0}call(t,n){return ye(()=>{let s=kt(t);if(s.shape.length!==4)throw new re(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=r[o],c=r[a],h=this.kernelSize[0],u=this.kernelSize[1],d=this.strides[0],p=this.strides[1],f=el(l,d,h,this.padding),g=el(c,p,u,this.padding),m=[i,f,g,this.filters];this.dataFormat!=="channelsLast"&&(s=Zt(s,[0,2,3,1]));let y=jB(s,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=Zt(y,[0,3,1,2])),this.bias!=null&&(y=Zo(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(t){t=ln(t);const n=t.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return n[s]=this.filters,n[r]=el(n[r],l,o,this.padding),n[i]=el(n[i],c,a,this.padding),n}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}sV.className="Conv2DTranspose";Fe(sV);class rV extends b0{constructor(t){super(t);if(this.inputSpec=[new As({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new re(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=ln(t),t.length!==5)throw new re("Input should have rank 5; Received input shape: "+JSON.stringify(t));const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new re("The channel dimension of the inputs should be defined. Found `None`.");const s=t[n],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new As({ndim:5,axes:{[n]:s}})],this.built=!0}call(t,n){return ye(()=>{let s=kt(t);if(s.shape.length!==5)throw new re(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const c=r[l],h=r[o],u=r[a],d=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],g=this.strides[0],m=this.strides[1],y=this.strides[2],v=el(c,g,d,this.padding),b=el(h,m,p,this.padding),x=el(u,y,f,this.padding),w=[i,v,b,x,this.filters];this.dataFormat!=="channelsLast"&&(s=Zt(s,[0,2,3,4,1]));let S=Qge(s,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(S=Zt(S,[0,4,1,2,3])),this.bias!==null&&(S=Zo(S,this.bias.read(),this.dataFormat)),this.activation!==null&&(S=this.activation.apply(S)),S})}computeOutputShape(t){t=ln(t);const n=t.slice();let s,r,i,o;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,o=4):(s=4,r=1,i=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],h=this.strides[0],u=this.strides[1],d=this.strides[2];return n[s]=this.filters,n[r]=el(n[r],h,a,this.padding),n[i]=el(n[i],u,l,this.padding),n[o]=el(n[o],d,c,this.padding),n}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}rV.className="Conv3DTranspose";Fe(rV);class iV extends Vp{constructor(t,n){super(t,n);if(this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,n.filters==null)throw new re("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new re("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new re(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=jn(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=qn(n.depthwiseRegularizer),this.depthwiseConstraint=Ns(n.depthwiseConstraint),this.pointwiseInitializer=jn(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=qn(n.pointwiseRegularizer),this.pointwiseConstraint=Ns(n.pointwiseConstraint)}build(t){if(t=ln(t),t.length<this.rank+2)throw new re(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null||t[n]<0)throw new re(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[n])}`);const s=t[n],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let a=0;a<this.rank;++a)i.push(1);i.push(s*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new As({ndim:this.rank+2,axes:{[n]:s}})],this.built=!0}call(t,n){return ye(()=>{t=kt(t);let s;if(this.rank===1)throw new $t("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=Zt(t,[0,2,3,1])),s=yz(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Zo(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=Zt(s,[0,3,1,2])),s})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Qn(this.depthwiseInitializer),t.pointwiseInitializer=Qn(this.pointwiseInitializer),t.depthwiseRegularizer=An(this.depthwiseRegularizer),t.pointwiseRegularizer=An(this.pointwiseRegularizer),t.depthwiseConstraint=Is(this.depthwiseConstraint),t.pointwiseConstraint=Is(this.pointwiseConstraint),t}}iV.className="SeparableConv";class oV extends iV{constructor(t){super(2,t)}}oV.className="SeparableConv2D";Fe(oV);class P1 extends Vp{constructor(t){super(1,t);P1.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!UA(t.kernelSize,"number",1,1))throw new re(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}P1.className="Conv1D";Fe(P1);class aV extends Xt{constructor(t){super(t);typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,n){return ye(()=>{if(t=kt(t),this.dataFormat==="channelsLast"){const s=y1(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return y1(s,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=y1(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return y1(s,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}aV.className="Cropping2D";Fe(aV);class lV extends Xt{constructor(t){super(t);this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,us(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,fwe(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const n=t[2]==null?null:this.size[0]*t[2],s=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],n,s]}else{const n=t[1]==null?null:this.size[0]*t[1],s=t[2]==null?null:this.size[1]*t[2];return[t[0],n,s,t[3]]}}call(t,n){return ye(()=>{let s=kt(t);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=Zt(s,[0,2,3,1]);const i=this.size[0]*r[2],o=this.size[1]*r[3],a=this.interpolation==="nearest"?vh.resizeNearestNeighbor(s,[i,o]):vh.resizeBilinear(s,[i,o]);return Zt(a,[0,3,1,2])}else{const i=this.size[0]*r[1],o=this.size[1]*r[2];return this.interpolation==="nearest"?vh.resizeNearestNeighbor(s,[i,o]):vh.resizeBilinear(s,[i,o])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(t,n),t}}lV.className="UpSampling2D";Fe(lV);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function LSe(e,t,n=[1,1],s="valid",r,i){return ye(()=>{r==null&&(r=Qo()),us(r);let o=gI(e,r);if(e.rank!==4)throw new re(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new re(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=LE(o,t,n,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(o=Zt(o,[0,3,1,2])),o})}class cV extends M1{constructor(t){super(2,t);this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=jn(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ns(t.depthwiseConstraint),this.depthwiseRegularizer=qn(t.depthwiseRegularizer)}build(t){if(t=ln(t),t.length<4)throw new re(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const n=this.dataFormat==="channelsFirst"?1:3;if(t[n]==null||t[n]<0)throw new re(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[n]}).`);const s=t[n],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return ye(()=>{t=kt(t);let s=LSe(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Zo(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(t){t=ln(t);const n=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,i=ta(n,this.kernelSize[0],this.padding,this.strides[0]),o=ta(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],r,i,o]:[t[0],i,o,r]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Qn(this.depthwiseInitializer),t.depthwiseRegularizer=An(this.depthwiseRegularizer),t.depthwiseConstraint=Is(this.depthwiseRegularizer),t}}cV.className="DepthwiseConv2D";Fe(cV);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function uV(e,t,n,s){if(Array.isArray(e)){if(t!=null||n!=null)throw new re("When inputs is an array, neither initialState or constants should be provided");s!=null&&(n=e.slice(e.length-s,e.length),e=e.slice(0,e.length-s)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return t=r(t),n=r(n),{inputs:e,initialState:t,constants:n}}function hV(e,t,n,s=!1,r,i,o=!1,a=!1){return ye(()=>{const l=t.shape.length;if(l<3)throw new re(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(Yo(2,l));if(t=Zt(t,c),i!=null)throw new $t("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=rt(rt(r,"bool"),"float32"),r.rank===l-1&&(r=ui(r,-1)),r=Zt(r,c)),s&&(t=gh(t,0),r!=null&&(r=gh(r,0)));const h=[];let u,d=n;const p=t.shape[0],f=yh(t);let g;r!=null&&(g=yh(r));for(let y=0;y<p;++y){const v=f[y],b=ye(()=>e(v,d));if(r==null)u=b[0],d=b[1];else{const x=ye(()=>{const w=g[y],S=Nt(ho(w),w),C=ze(le(b[0],w),le(d[0],S)),_=d.map((T,E)=>ze(le(b[1][E],w),le(T,S)));return{output:C,newStates:_}});u=x.output,d=x.newStates}a&&h.push(u)}let m;return a&&(m=Bc(h,1)),[u,m,d]})}class qc extends Xt{constructor(t){super(t);let n;if(t.cell==null)throw new re("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new xI({cells:t.cell}):n=t.cell,n.stateSize==null)throw new re("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new As({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Yo(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){eI(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);const s=n[0];let r;if(this.returnSequences?r=[t[0],t[1],s]:r=[t[0],s],this.returnState){const i=[];for(const o of n)i.push([t[0],o]);return[r].concat(i)}else return r}computeMask(t,n){return ye(()=>{Array.isArray(n)&&(n=n[0]);const s=this.returnSequences?n:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let s=0;s<t;++s)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new $t("Constants support is not implemented in RNN yet.");eI(t)&&(t=t[0]),t=t;const n=this.stateful?t[0]:null,s=t.slice(2);this.inputSpec[0]=new As({shape:[n,null,...s]});const r=[t[0]].concat(t.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!dn(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new re(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new As({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){ye(()=>{if(!this.stateful)throw new Ka("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new re("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Bs([s,r])):this.states_=[Bs([s,this.cell.stateSize])];else if(t==null)qt(this.states_),this.keptStates!=null&&(qt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Bs([s,r])):this.states_[0]=Bs([s,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new re(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):qt(this.states_);for(let r=0;r<this.states_.length;++r){const i=t[r],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,a=[s,o];if(!dn(i.shape,a))throw new re(`State ${r} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>Ha(r.clone()))})}apply(t,n){let s=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});const i=uV(t,s,r,this.numConstants);t=i.inputs,s=i.initialState,r=i.constants;let o=[],a=[];if(s!=null){n.initialState=s,o=o.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new As({shape:c.shape}));a=a.concat(this.stateSpec)}if(r!=null&&(n.constants=r,o=o.concat(r),this.numConstants=r.length),o[0]instanceof Ja){const c=[t].concat(o),h=this.inputSpec.concat(a),u=this.inputSpec;this.inputSpec=h;const d=super.apply(c,n);return this.inputSpec=u,d}else return super.apply(t,n)}call(t,n){return ye(()=>{const s=n==null?null:n.mask,r=n==null?null:n.training;let i=n==null?null:n.initialState;t=kt(t),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(t));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new re(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},c=hV((f,g)=>{const m=this.cell.call([f].concat(g),a);return[m[0],m.slice(1)]},t,i,this.goBackwards,s,null,this.unroll,this.returnSequences),h=c[0],u=c[1],d=c[2];this.stateful&&this.resetStates(d,r);const p=this.returnSequences?u:h;return this.returnState?[p].concat(d):p})}getInitialState(t){return ye(()=>{let n=Bs(t.shape);return n=xt(n,[1,2]),n=c0(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?HA(n,[1,s]):n):this.cell.stateSize>1?[HA(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===qc.className&&(n.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),t),n)}static fromConfig(t,n,s={}){const r=n.cell,i=Ll(r,s);return new t(Object.assign(n,{cell:i}))}}qc.className="RNN";Fe(qc);class O1 extends Xt{}class yI extends O1{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,zs(this.units,"units"),this.activation=jc(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=jn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=qn(t.kernelRegularizer),this.recurrentRegularizer=qn(t.recurrentRegularizer),this.biasRegularizer=qn(t.biasRegularizer),this.kernelConstraint=Ns(t.kernelConstraint),this.recurrentConstraint=Ns(t.recurrentConstraint),this.biasConstraint=Ns(t.biasConstraint),this.dropout=Bp([1,Gc([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Bp([1,Gc([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=ln(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return ye(()=>{if(t=t,t.length!==2)throw new re(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let s=t[1];t=t[0];const r=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Xc({ones:()=>ho(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Xc({ones:()=>ho(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?i=Za(le(t,o),this.kernel.read()):i=Za(t,this.kernel.read()),this.bias!=null&&(i=Zo(i,this.bias.read())),a!=null&&(s=le(s,a));let l=ze(i,Za(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:Hc(this.activation),useBias:this.useBias,kernelInitializer:Qn(this.kernelInitializer),recurrentInitializer:Qn(this.recurrentInitializer),biasInitializer:Qn(this.biasInitializer),kernelRegularizer:An(this.kernelRegularizer),recurrentRegularizer:An(this.recurrentRegularizer),biasRegularizer:An(this.biasRegularizer),activityRegularizer:An(this.activityRegularizer),kernelConstraint:Is(this.kernelConstraint),recurrentConstraint:Is(this.recurrentConstraint),biasConstraint:Is(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),n)}}yI.className="SimpleRNNCell";Fe(yI);class dV extends qc{constructor(t){t.cell=new yI(t);super(t)}call(t,n){return ye(()=>{this.cell.dropoutMask!=null&&(qt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(qt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}static fromConfig(t,n){return new t(n)}}dV.className="SimpleRNN";Fe(dV);class vI extends O1{constructor(t){super(t);if(this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new re("GRUCell does not support reset_after parameter set to true.");this.units=t.units,zs(this.units,"units"),this.activation=jc(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=jc(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=jn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=qn(t.kernelRegularizer),this.recurrentRegularizer=qn(t.recurrentRegularizer),this.biasRegularizer=qn(t.biasRegularizer),this.kernelConstraint=Ns(t.kernelConstraint),this.recurrentConstraint=Ns(t.recurrentConstraint),this.biasConstraint=Ns(t.biasConstraint),this.dropout=Bp([1,Gc([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Bp([1,Gc([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=ln(t);const n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return ye(()=>{if(t=t,t.length!==2)throw new re(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const s=n.training==null?!1:n.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Xc({ones:()=>ho(t),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Xc({ones:()=>ho(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,c;0<this.dropout&&this.dropout<1&&(t=le(t,i[0]));let h=Za(t,this.kernel.read());this.useBias&&(h=Zo(h,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=le(r,o[0]));const u=this.recurrentKernel.read(),[d,p]=Li(u,[2*this.units,this.units],u.rank-1),f=Za(r,d),[g,m,y]=Li(h,3,h.rank-1),[v,b]=Li(f,2,f.rank-1);a=this.recurrentActivation.apply(ze(g,v)),l=this.recurrentActivation.apply(ze(m,b));const x=Za(le(l,r),p);c=this.activation.apply(ze(y,x));const w=ze(le(a,r),le(ze(1,xs(a)),c));return[w,w]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:Hc(this.activation),recurrentActivation:Hc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Qn(this.kernelInitializer),recurrentInitializer:Qn(this.recurrentInitializer),biasInitializer:Qn(this.biasInitializer),kernelRegularizer:An(this.kernelRegularizer),recurrentRegularizer:An(this.recurrentRegularizer),biasRegularizer:An(this.biasRegularizer),activityRegularizer:An(this.activityRegularizer),kernelConstraint:Is(this.kernelConstraint),recurrentConstraint:Is(this.recurrentConstraint),biasConstraint:Is(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),n)}}vI.className="GRUCell";Fe(vI);class pV extends qc{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new vI(t);super(t)}call(t,n){return ye(()=>{this.cell.dropoutMask!=null&&(qt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(qt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}static fromConfig(t,n){return n.implmentation===0&&(n.implementation=1),new t(n)}}pV.className="GRU";Fe(pV);class R1 extends O1{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,zs(this.units,"units"),this.activation=jc(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=jc(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=jn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=qn(t.kernelRegularizer),this.recurrentRegularizer=qn(t.recurrentRegularizer),this.biasRegularizer=qn(t.biasRegularizer),this.kernelConstraint=Ns(t.kernelConstraint),this.recurrentConstraint=Ns(t.recurrentConstraint),this.biasConstraint=Ns(t.biasConstraint),this.dropout=Bp([1,Gc([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Bp([1,Gc([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var n;t=ln(t);const s=t[t.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;r=new(n=class extends go{apply(l,c){const h=i.apply([o]),u=new qA().apply([o]),d=i.apply([o*2]);return V4(V4(h,u),d)}},n.className="CustomInit",n)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,n){return ye(()=>{const s=n.training==null?!1:n.training;if(t=t,t.length!==3)throw new re(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let r=t[1];const i=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Xc({ones:()=>ho(t),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Xc({ones:()=>ho(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,c,h,u;0<this.dropout&&this.dropout<1&&(t=le(t,o[0]));let d=Za(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=le(r,a[0])),d=ze(d,Za(r,this.recurrentKernel.read())),this.useBias&&(d=Zo(d,this.bias.read()));const[p,f,g,m]=Li(d,4,d.rank-1);l=this.recurrentActivation.apply(p),c=this.recurrentActivation.apply(f),h=ze(le(c,i),le(l,this.activation.apply(g))),u=this.recurrentActivation.apply(m);const y=le(u,this.activation.apply(h));return[y,y,h]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:Hc(this.activation),recurrentActivation:Hc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Qn(this.kernelInitializer),recurrentInitializer:Qn(this.recurrentInitializer),biasInitializer:Qn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:An(this.kernelRegularizer),recurrentRegularizer:An(this.recurrentRegularizer),biasRegularizer:An(this.biasRegularizer),activityRegularizer:An(this.activityRegularizer),kernelConstraint:Is(this.kernelConstraint),recurrentConstraint:Is(this.recurrentConstraint),biasConstraint:Is(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),n)}}R1.className="LSTMCell";Fe(R1);class fV extends qc{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new R1(t);super(t)}call(t,n){return ye(()=>{this.cell.dropoutMask!=null&&(qt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(qt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}static fromConfig(t,n){return n.implmentation===0&&(n.implementation=1),new t(n)}}fV.className="LSTM";Fe(fV);class xI extends O1{constructor(t){super(t);this.cells=t.cells}get stateSize(){const t=[];for(const n of this.cells.slice().reverse())Array.isArray(n.stateSize)?t.push(...n.stateSize):t.push(n.stateSize);return t}call(t,n){return ye(()=>{t=t;let s=t.slice(1);const r=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?r.push(s.splice(0,a.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];s=r[a],a===0?o=[t[0]].concat(s):o=[o[0]].concat(s),o=l.call(o,n),i.push(o.slice(1))}s=[];for(const a of i.slice().reverse())s.push(...a);return[o[0]].concat(s)})}build(t){eI(t)&&(t=t[0]),t=t;let n;this.cells.forEach((s,r)=>{Ch(`RNNCell_${r}`,()=>{s.build(t),Array.isArray(s.stateSize)?n=s.stateSize[0]:n=s.stateSize,t=[t[0],n]})}),this.built=!0}getConfig(){const t=super.getConfig(),n=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(n)};return Object.assign(Object.assign({},t),r)}static fromConfig(t,n,s={}){const r=[];for(const i of n.cells)r.push(Ll(i,s));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const n of this.cells)t.push(...n.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const n of this.cells)t.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const s of this.cells)n.push(...s.trainableWeights);return n.concat(t)}return t}getWeights(){const t=[];for(const n of this.cells)t.push(...n.weights);return tI(t)}setWeights(t){const n=[];for(const s of this.cells){const r=s.weights.length,i=t.splice(r);for(let o=0;o<s.weights.length;++o)n.push([s.weights[o],i[o]])}nI(n)}}xI.className="StackedRNNCells";Fe(xI);function Xc(e){const{ones:t,rate:n,training:s=!1,count:r=1,dropoutFunc:i}=e,o=()=>i!=null?i(t(),n):W4(t(),n),a=()=>h0(o,t,s);return!r||r<=1?Ha(a().clone()):Array(r).fill(void 0).map(a).map(c=>Ha(c.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var FSe=globalThis&&globalThis.__rest||function(e,t){var n={};for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&t.indexOf(s)<0&&(n[s]=e[s]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(e);r<s.length;r++)t.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(e,s[r])&&(n[s[r]]=e[s[r]]);return n};class mV extends qc{constructor(t){if(t.unroll)throw new $t("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new $t("It is not possible at the moment to stack convolutional cells.");super(t);this.inputSpec=[new As({ndim:5})]}call(t,n){return ye(()=>{if(this.cell.dropoutMask!=null&&(qt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(qt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new re("ConvRNN2D cell does not support constants");const s=n==null?null:n.mask,r=n==null?null:n.training,i=n==null?null:n.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}computeOutputShape(t){let n=this.computeSingleOutputShape(t);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([t[0],...n.slice(-3)])]),n}getInitialState(t){return ye(()=>{const{stateSize:n}=this.cell,s=t.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],o=Bs(i);return Array.isArray(n)?Array(n.length).fill(o):[o]})}resetStates(t,n=!1){ye(()=>{if(!this.stateful)throw new Ka("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new re("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Bs(i)):this.states_=[Bs(i)];else if(t==null)qt(this.states_),this.keptStates!=null&&(qt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Bs(i)):this.states_[0]=Bs(i);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new re(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n?this.keptStates.push(this.states_.slice()):qt(this.states_);for(let a=0;a<this.states_.length;++a){const l=t[a],c=i;if(!dn(l.shape,c))throw new re(`State ${a} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>Ha(a.clone()))})}computeSingleOutputShape(t){const{dataFormat:n,filters:s,kernelSize:r,padding:i,strides:o,dilationRate:a}=this.cell,l=n==="channelsFirst",c=t[l?3:2],h=t[l?4:3],u=ta(c,r[0],i,o[0],a[0]),d=ta(h,r[1],i,o[1],a[1]);return[...t.slice(0,2),...l?[s,u,d]:[u,d,s]]}}mV.className="ConvRNN2D";class bI extends R1{constructor(t){const{filters:n,kernelSize:s,strides:r,padding:i,dataFormat:o,dilationRate:a}=t;super(Object.assign(Object.assign({},t),{units:n}));this.filters=n,zs(this.filters,"filters"),this.kernelSize=Up(s,2,"kernelSize"),this.kernelSize.forEach(l=>zs(l,"kernelSize")),this.strides=Up(r||1,2,"strides"),this.strides.forEach(l=>zs(l,"strides")),this.padding=i||"valid",$i(this.padding),this.dataFormat=o||"channelsLast",us(this.dataFormat),this.dilationRate=Up(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>zs(l,"dilationRate"))}build(t){var n;t=ln(t);const s=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[s]==null)throw new re(`The channel dimension of the input should be defined. Found ${t[s]}`);const r=t[s],i=4,o=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,h=this.filters;l=new(n=class extends go{apply(d,p){const f=c.apply([h]),g=ph([h]),m=c.apply([h*2]);return WA([f,g,m])}},n.className="CustomInit",n)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,n){return ye(()=>{if(t.length!==3)throw new re(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const s=n.training||!1,r=t[0],i=t[1],o=t[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Xc({ones:()=>ho(r),rate:this.dropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(z,$,R)=>!$||!$[R]?z:le($[R],z);let h=c(r,l,0),u=c(r,l,1),d=c(r,l,2),p=c(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Xc({ones:()=>ho(i),rate:this.recurrentDropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let g=c(i,f,0),m=c(i,f,1),y=c(i,f,2),v=c(i,f,3);const b=3,[x,w,S,C]=Li(this.kernel.read(),a,b),[_,T,E,A]=this.useBias?Li(this.bias.read(),a):[null,null,null,null];h=this.inputConv(h,x,_,this.padding),u=this.inputConv(u,w,T,this.padding),d=this.inputConv(d,S,E,this.padding),p=this.inputConv(p,C,A,this.padding);const[D,O,P,L]=Li(this.recurrentKernel.read(),a,b);g=this.recurrentConv(g,D),m=this.recurrentConv(m,O),y=this.recurrentConv(y,P),v=this.recurrentConv(v,L);const B=this.recurrentActivation.apply(ze(h,g)),F=this.recurrentActivation.apply(ze(u,m)),M=ze(le(F,o),le(B,this.activation.apply(ze(d,y)))),U=le(this.recurrentActivation.apply(ze(p,v)),this.activation.apply(M));return[U,U,M]})}getConfig(){const t=super.getConfig(),n=FSe(t,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),s)}inputConv(t,n,s,r){const i=hh(t,n,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Zo(i,s,this.dataFormat):i}recurrentConv(t,n){return hh(t,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}bI.className="ConvLSTM2DCell";Fe(bI);class gV extends mV{constructor(t){const n=new bI(t);super(Object.assign(Object.assign({},t),{cell:n}))}static fromConfig(t,n){return new t(n)}}gV.className="ConvLSTM2D";Fe(gV);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class wI extends Xt{constructor(t){super(t);this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const n=t.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?n[r]:this.noiseShape[r]);return s}call(t,n){return ye(()=>{this.invokeCallHook(t,n);const s=kt(t);if(0<this.rate&&this.rate<1){const r=n.training==null?!1:n.training,i=this.getNoiseShape(s);return h0(()=>W4(s,this.rate,i,this.seed),()=>s,r)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(t,n),t}dispose(){return super.dispose()}}wI.className="Dropout";Fe(wI);class yV extends wI{constructor(t){super(t);this.inputSpec=[{ndim:3}]}getNoiseShape(t){const n=t.shape;return[n[0],1,n[2]]}}yV.className="SpatialDropout1D";Fe(yV);class vV extends Xt{constructor(t){super(t);if(this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let n=null;t.batchSize!=null&&(n=t.batchSize),this.batchInputShape=[n,t.inputDim]}this.units=t.units,zs(this.units,"units"),this.activation=jc(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=jn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=jn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ns(t.kernelConstraint),this.biasConstraint=Ns(t.biasConstraint),this.kernelRegularizer=qn(t.kernelRegularizer),this.biasRegularizer=qn(t.biasRegularizer),this.activityRegularizer=qn(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=ln(t);const n=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(t){t=ln(t);const n=t.slice();return n[n.length-1]=this.units,n}call(t,n){return ye(()=>{this.invokeCallHook(t,n);const s=kt(t),r=R4(this.activation.getClassName());let i;return r!=null?i=Za(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=Za(s,this.kernel.read()),this.bias!=null&&(i=Zo(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const t={units:this.units,activation:Hc(this.activation),useBias:this.useBias,kernelInitializer:Qn(this.kernelInitializer),biasInitializer:Qn(this.biasInitializer),kernelRegularizer:An(this.kernelRegularizer),biasRegularizer:An(this.biasRegularizer),activityRegularizer:An(this.activityRegularizer),kernelConstraint:Is(this.kernelConstraint),biasConstraint:Is(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}}vV.className="Dense";Fe(vV);class xV extends Xt{constructor(t){t=t||{};super(t);this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=ln(t);for(const n of t.slice(1))if(n==null)throw new re(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],Vc(t,1)]}call(t,n){return ye(()=>{this.invokeCallHook(t,n);let s=kt(t);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=Zt(s,r)}return bwe(s)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const n=super.getConfig();return Object.assign(t,n),t}}xV.className="Flatten";Fe(xV);class bV extends Xt{constructor(t){super(t);this.supportsMasking=!0,this.activation=jc(t.activation)}call(t,n){return ye(()=>{this.invokeCallHook(t,n);const s=kt(t);return this.activation.apply(s)})}getConfig(){const t={activation:Hc(this.activation)},n=super.getConfig();return Object.assign(t,n),t}}bV.className="Activation";Fe(bV);class wV extends Xt{constructor(t){super(t);this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,n){return ye(()=>(t=kt(t),vwe(t,this.n)))}getConfig(){const t={n:this.n},n=super.getConfig();return Object.assign(t,n),t}}wV.className="RepeatVector";Fe(wV);class SV extends Xt{constructor(t){super(t);this.targetShape=t.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,n){const s="Total size of new array must be unchanged.",r=n.slice();let i=1,o=null;for(let l=0;l<r.length;++l){const c=r[l];if(this.isUnknown(c))if(o===null)o=l;else throw new re("Can only specifiy one unknown dimension.");else i*=c}const a=Vc(t);if(o!==null){if(i===0||a%i!=0)throw new re(s);r[o]=a/i}else if(a!==i)throw new re(s);return r}computeOutputShape(t){let n=!1;for(let s=0;s<t.length;++s)if(this.isUnknown(t[s])){n=!0;break}return n?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,n){return ye(()=>{this.invokeCallHook(t,n);const s=kt(t),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return pe(s,i)})}getConfig(){const t={targetShape:this.targetShape},n=super.getConfig();return Object.assign(t,n),t}}SV.className="Reshape";Fe(SV);class _V extends Xt{constructor(t){super(t);if(t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const n=Yo(1,t.dims.length+1);if(!dn(t.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new As({ndim:this.dims.length+1})]}computeOutputShape(t){t=ln(t);const n=t.slice();return this.dims.forEach((s,r)=>{n[r+1]=t[s]}),n}call(t,n){return Zt(kt(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},n=super.getConfig();return Object.assign(t,n),t}}_V.className="Permute";Fe(_V);class CV extends Xt{constructor(t){super(t==null?{}:t);this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,t),n}computeMask(t,n){const s=kt(t),r=-1;return AE(o1(s,this.maskValue),r)}call(t,n){return ye(()=>{this.invokeCallHook(t,n);const s=kt(t),r=-1,i=!0,o=AE(o1(s,this.maskValue),r,i);return le(s,rt(o,s.dtype))})}}CV.className="Masking";Fe(CV);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class TV extends Xt{constructor(t){super(t);if(this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let n=null;t.batchSize!=null&&(n=t.batchSize),t.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat(Un(t.inputLength))}this.inputDim=t.inputDim,zs(this.inputDim,"inputDim"),this.outputDim=t.outputDim,zs(this.outputDim,"outputDim"),this.embeddingsInitializer=jn(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=qn(t.embeddingsRegularizer),this.activityRegularizer=qn(t.activityRegularizer),this.embeddingsConstraint=Ns(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,n){return ye(()=>this.maskZero?(t=kt(t),o1(t,Jt(t))):null)}computeOutputShape(t){if(t=ln(t),this.inputLength==null)return[...t,this.outputDim];const n=Un(this.inputLength);if(n.length!==t.length-1)throw new re(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let s=0;for(let r=0;r<n.length;++r){const i=n[r],o=t[r+1];if(i!=null&&o!=null&&i!==o)throw new re(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);i==null&&(n[s]=o),s++}}return[t[0],...n,this.outputDim]}call(t,n){return ye(()=>{this.invokeCallHook(t,n);let s=kt(t);s.dtype!=="int32"&&(s=Qa(s,"int32"));const r=G4(this.embeddings.read(),pe(s,[s.size]));return pe(r,ln(this.computeOutputShape(s.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Qn(this.embeddingsInitializer),embeddingsRegularizer:An(this.embeddingsRegularizer),activityRegularizer:An(this.activityRegularizer),embeddingsConstraint:Is(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(t,n),t}}TV.className="Embedding";Fe(TV);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ah extends Xt{constructor(t){super(t||{});this.supportsMasking=!0}mergeFunction(t){throw new $t}computeElementwiseOpOutputShape(t,n){if(t==null||n==null)return null;if(t.length<n.length)return this.computeElementwiseOpOutputShape(n,t);if(n.length===0)return t;const s=t.slice(0,t.length-n.length);for(let r=0;r<n.length;++r){const i=t[t.length-n.length+r],o=n[r];if(i==null||o==null||i<0||o<0)s.push(null);else if(i===1)s.push(o);else if(o===1)s.push(i);else{if(i!==o)throw new re("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(n));s.push(i)}}return s}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[ln(t)]),t=t,t.length<2)throw new re(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let n=[];for(const i of t)i!=null&&i[0]!==null&&n.push(i[0]);if(n=Uc(n),n.length>1)throw new re(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let s=t[0]==null?null:t[0].slice(1);for(let i=1;i<t.length;++i){const o=t[i]==null?null:t[i].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const r=t.map(i=>i.length);t.indexOf(null)===-1&&Uc(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,n){return ye(()=>{if(t=t,this.reshapeRequired){const s=[],r=t.map(i=>i.rank);if(r.indexOf(null)===-1){const i=Gc(r);for(let o of t){const a=o.rank;for(let l=0;l<i-a;++l)o=c0(o,1);s.push(o)}return this.mergeFunction(s)}else{let i=!1;for(const l of t){const c=l.rank;if(c==null){const h=l.shape,u=h[0],d=h.slice(1).concat([u]);let p=pe(l,[u].concat(Vc(h.slice(1))));p=Zt(p,[1,0]),p=pe(p,d),s.push(p),i=!0}else if(c>1){const h=Yo(1,c).concat([0]);s.push(Zt(l,h)),i=!0}else s.push(l)}let o=this.mergeFunction(s);const a=o.rank;if(i){if(a==null){const l=o.shape,c=l.length,h=l[c-1],u=[h].concat(l.slice(0,l.length-1));o=pe(Zt(pe(o,[-1,h]),[1,0]),u)}else if(a>1){const l=[a-1].concat(Yo(0,a-1));o=Zt(o,l)}}return o}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let n;t[0]==null?n=null:n=t[0].slice(1);for(let r=1;r<t.length;++r){const i=t[r]==null?null:t[r].slice(1);n=this.computeElementwiseOpOutputShape(n,i)}let s=[];for(const r of t)r!=null&&r[0]!==null&&s.push(r[0]);return s=Uc(s),s.length===1?n=s.concat(n):n=[null].concat(n),n}computeMask(t,n){return ye(()=>{if(n==null)return null;if(!Array.isArray(n))throw new re("`mask` should be an Array");if(!Array.isArray(t))throw new re("`inputs` should be an Array");if(n.length!==t.length)throw new re(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${n.length})`);if(n.every(r=>r==null))return null;n=n.map(r=>r==null?r:ui(r,0));let s=n[0];for(let r=1;r<n.length-1;++r)s=Pl(s,n[r]);return s})}}class EV extends Ah{constructor(t){super(t)}mergeFunction(t){return ye(()=>{let n=t[0].clone();for(let s=1;s<t.length;++s)n=ze(n,t[s]);return n})}}EV.className="Add";Fe(EV);class AV extends Ah{constructor(t){super(t)}mergeFunction(t){return ye(()=>{let n=t[0].clone();for(let s=1;s<t.length;++s)n=le(n,t[s]);return n})}}AV.className="Multiply";Fe(AV);class IV extends Ah{constructor(t){super(t)}mergeFunction(t){return ye(()=>{let n=t[0].clone();for(let s=1;s<t.length;++s)n=ze(n,t[s]);return le(1/t.length,n)})}}IV.className="Average";Fe(IV);class NV extends Ah{constructor(t){super(t)}mergeFunction(t){return ye(()=>{let n=t[0];for(let s=1;s<t.length;++s)n=$c(n,t[s]);return n})}}NV.className="Maximum";Fe(NV);class kV extends Ah{constructor(t){super(t)}mergeFunction(t){return ye(()=>{let n=t[0];for(let s=1;s<t.length;++s)n=GE(n,t[s]);return n})}}kV.className="Minimum";Fe(kV);class DV extends Ah{constructor(t){super(t);this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new re("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let n=!0;for(const r of t)if(r!=null){n=!1;break}if(n)return;const s=[];for(let r=0;r<t.length;++r){const i=t[r].slice();i.splice(this.axis,1);let o=!1;for(const a of s)if(dn(a,i)){o=!0;break}o||s.push(i)}if(s.length>1)throw new re("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return ye(()=>WA(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new re("A `Concatenate` layer should be called on a list of inputs.");const n=t,s=n[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of n.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(t,n){if(n==null)return null;if(!Array.isArray(n))throw new re("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new re("`inputs` should be an array for Concatenate");if(n.length!==t.length)throw new re(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${t.length})`);return ye(()=>{let s=!0;if(n.forEach(o=>{if(o!=null){s=!1;return}}),s)return null;const r=[];for(let o=0;o<t.length;++o)n[o]==null?r.push(rt(ho(t[o]),"bool")):n[o].rank<t[o].rank?r.push(ui(n[o],-1)):r.push(n[o]);const i=jr(r,this.axis);return WB(i,-1,!1)})}getConfig(){const t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}}DV.className="Concatenate";Fe(DV);function w0(e,t){for(;e<0;)e+=t;return e}function $Se(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new $t("batchDot is not implemented for tensors of 4D or higher rank yet");if(W(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),W(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new $t("batchDot is not implemented for complex64-type Tensors yet.");const s=e.shape.length,r=t.shape.length;n==null&&(n=[s-1,r-2]);const i=n;return ye(()=>{let o;if(s>r){o=s-r;const l=[];for(let c=0;c<o;++c)l.push(1);t=pe(t,t.shape.concat(l))}else if(r>s){o=r-s;const l=[];for(let c=0;c<o;++c)l.push(1);e=pe(e,e.shape.concat(l))}else o=0;let a;if(e.shape.length===2&&t.shape.length===2)i[0]===i[1]?a=xt(le(e,t),i[0]):a=xt(le(Zt(e,[1,0]),t),i[1]);else{const l=i[0]!==e.shape.length-1,c=i[1]===t.shape.length-1;a=pn(e,t,l,c)}if(o>0){let l;s>r?l=s+r-3:l=s-1;const c=[];for(let h=l;h<l+o;++h)c.push(h);a=t0(a,c)}return a.shape.length===1&&(a=ui(a,1)),a})}class MV extends Ah{constructor(t){super(t);this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){W(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=t[0],s=t[1];if(n.length>3||s.length>3)throw new $t("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(n,s);if(n[r[0]]!==s[r[1]])throw new re(`Dimension incompatibility: ${n[r[0]]} !== ${s[r[1]]}`)}mergeFunction(t){if(t.length!==2)throw new re(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let n=t[0],s=t[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,o)=>w0(i,t[o].shape.length)):r=[w0(this.axes,n.shape.length),w0(this.axes,s.shape.length)],this.normalize&&(n=C1(n,r[0]),s=C1(s,r[1])),$Se(n,s,r)}interpretAxes(t,n){let s;return Array.isArray(this.axes)?s=this.axes:s=[w0(this.axes,t.length),w0(this.axes,n.length)],s}computeOutputShape(t){W(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=t[0].slice(),s=t[1].slice();if(n.length>3||s.length>3)throw new $t("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(n,s);n.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=n.concat(s);return i.length===1&&i.push(1),i}computeMask(t,n){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(t,n),t}}MV.className="Dot";Fe(MV);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class PV extends Xt{constructor(t){super(t);this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,t),n}call(t,n){return ye(()=>{this.invokeCallHook(t,n);const s=kt(t);return h0(()=>ze(v1(s.shape,0,this.stddev),s),()=>s,n.training||!1)})}}PV.className="GaussianNoise";Fe(PV);class OV extends Xt{constructor(t){super(t);this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return ye(()=>{this.invokeCallHook(t,n);const s=kt(t);return this.rate>0&&this.rate<1?h0(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return le(s,v1(s.shape,1,i))},()=>s,n.training||!1):s})}}OV.className="GaussianDropout";Fe(OV);class RV extends Xt{constructor(t){super(t);this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||kt(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return ye(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(t);return h0(()=>{const i=kt(t),o=1.6732632423543772,a=1.0507009873554805,l=-o*a;let c=dh(a1(s),this.rate);c=Qa(c,"float32");const h=((1-this.rate)*(1+this.rate*l**2))**-.5,u=-h*l*this.rate,d=ze(le(i,c),le(ze(c,-1),l));return ze(le(d,h),u)},()=>kt(t),n.training||!1)}return t})}}RV.className="AlphaDropout";Fe(RV);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function S0(e,t,n,s,r,i=.001){let o;if(e.rank===2)o=Cge(e,t,n,s,r,i);else if(e.rank===3)o=Ege(e,t,n,s,r,i);else if(e.rank===4)o=Ige(e,t,n,s,r,i);else throw new $t(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return o}function BSe(e,t,n,s,r=.001){return ye(()=>{const i=WE(e,s),o=i.mean,a=i.variance;return[S0(e,o,a,n,t,r),o,a]})}function zSe(e,t,n,s,r=.001){return ye(()=>{const i=WE(e,s),o=i.mean,a=i.variance,l=[];for(const f of Yo(0,e.rank))s.indexOf(f)!==-1?l.push(1):l.push(e.shape[f]);const c=pe(o,l),h=pe(a,l),u=t==null?null:pe(t,l),d=n==null?null:pe(n,l);return[S0(e,c,h,d,u,r),o,a]})}function USe(e,t,n,s,r=.001){return dn(s.slice().sort(),Yo(0,e.rank-1))?BSe(e,t,n,s,r):zSe(e,t,n,s,r)}class LV extends Xt{constructor(t){t==null&&(t={});super(t);this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=jn(t.betaInitializer||"zeros"),this.gammaInitializer=jn(t.gammaInitializer||"ones"),this.movingMeanInitializer=jn(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=jn(t.movingVarianceInitializer||"ones"),this.betaConstraint=Ns(t.betaConstraint),this.gammaConstraint=Ns(t.gammaConstraint),this.betaRegularizer=qn(t.betaRegularizer),this.gammaRegularizer=qn(t.gammaRegularizer)}build(t){t=ln(t);const n=this.axis>=0?this.axis:this.axis+t.length,s=t[n];if(s==null)throw new re(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new As({ndim:t.length,axes:{[n]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,n){return ye(()=>{const s=n.training==null?!1:n.training,r=kt(t),i=r.shape,o=i.length,a=Yo(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const c=wh(1,o);c[l]=i[l];const h=a.slice();h.sort();const u=!dn(h,Yo(0,o).slice(0,o-1)),d=()=>{if(u){const v=pe(this.movingMean.read(),c),b=pe(this.movingVariance.read(),c),x=this.center?pe(this.beta.read(),c):null,w=this.scale?pe(this.gamma.read(),c):null;return S0(r,v,b,x,w,this.epsilon)}else return S0(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return d();const[p,f,g]=USe(r,this.gamma.read(),this.beta.read(),a,this.epsilon),m=(v,b,x)=>{ye(()=>{const w=1-x,S=v.read(),C=le(Nt(S,b),w);v.write(Nt(S,C))})};return(()=>{m(this.movingMean,f,this.momentum),m(this.movingVariance,g,this.momentum)})(),p})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Qn(this.betaInitializer),gammaInitializer:Qn(this.gammaInitializer),movingMeanInitializer:Qn(this.movingMeanInitializer),movingVarianceInitializer:Qn(this.movingVarianceInitializer),betaRegularizer:An(this.betaRegularizer),gammaRegularizer:An(this.gammaRegularizer),betaConstraint:Is(this.betaConstraint),gammaConstraint:Is(this.gammaConstraint)},n=super.getConfig();return Object.assign(t,n),t}}LV.className="BatchNormalization";Fe(LV);class FV extends Xt{constructor(t){t==null&&(t={});super(t);if(this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=jn(t.betaInitializer||"zeros"),this.gammaInitializer=jn(t.gammaInitializer||"ones"),this.betaRegularizer=qn(t.betaRegularizer),this.gammaRegularizer=qn(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=ln(t);const n=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=n);for(const i of this.axis)if(i<0||i>=n)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Uc(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>t[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(t,n){const s=kt(t),r=s.shape,i=r.length;return ye(()=>{const o=!0;let{mean:a,variance:l}=WE(s,this.axis,o);const c=wh(1,i);for(const g of this.axis)c[g]=r[g];const h=g=>g!=null&&g.shape.length!==i?pe(g,c):g;let u=this.scale?h(this.gamma.read()):null,d=this.center?h(this.beta.read()):null;const p=[],f=[];for(let g=0;g<i;++g)this.axis.indexOf(g)!==-1?(p.push(r[g]),f.push(1)):(p.push(1),f.push(r[g]));return a=Xo(a,p),l=Xo(l,p),u!=null&&(u=Xo(u,f)),d!=null&&(d=Xo(d,f)),S0(s,a,l,d,u,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Qn(this.betaInitializer),gammaInitializer:Qn(this.gammaInitializer),betaRegularizer:An(this.betaRegularizer),gammaRegularizer:An(this.gammaRegularizer)},n=super.getConfig();return Object.assign(t,n),t}}FV.className="LayerNormalization";Fe(FV);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function VSe(e,t,n){return ye(()=>{if(e.rank!==4)throw new re(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new re("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Qo()),n!=="channelsLast"&&n!=="channelsFirst")throw new re(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return n==="channelsFirst"?s=[[0,0],[0,0],t[0],t[1]]:s=[[0,0],t[0],t[1],[0,0]],HE(e,s)})}class $V extends Xt{constructor(t){t==null&&(t={});super(t);if(this.dataFormat=t.dataFormat==null?Qo():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new re(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let n,s;if(typeof t.padding[0]=="number")n=[t.padding[0],t.padding[0]],s=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new re(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(n=t.padding[0],t.padding[1].length!==2)throw new re(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);s=t.padding[1]}this.padding=[n,s]}this.inputSpec=[new As({ndim:4})]}computeOutputShape(t){t=ln(t);let n,s;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?n=t[2]+this.padding[0][0]+this.padding[0][1]:n=null,t[3]!=null&&t[3]>=0?s=t[3]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],t[1],n,s]):(t[1]!=null&&t[1]>=0?n=t[1]+this.padding[0][0]+this.padding[0][1]:n=null,t[2]!=null&&t[2]>=0?s=t[2]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],n,s,t[3]])}call(t,n){return ye(()=>VSe(kt(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}$V.className="ZeroPadding2D";Fe($V);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function L1(e,t,n,s,r,i){return ye(()=>{us(r),F4(i),$i(s),n==null&&(n=[1,1]),s==null&&(s="valid"),r==null&&(r=Qo()),i==null&&(i="max"),e=gI(e,r);let o;const a=s==="same"?"same":"valid";return i==="max"?o=VE(e,t,n,a):o=kE(e,t,n,a),r==="channelsFirst"&&(o=Zt(o,[0,3,1,2])),o})}function BV(e,t,n,s,r,i){return ye(()=>{us(r),F4(i),$i(s),n==null&&(n=[1,1,1]),s==null&&(s="valid"),r==null&&(r=Qo()),i==null&&(i="max"),e=tV(e,r);let o;const a=s==="same"?"same":"valid";return i==="max"?o=pye(e,t,n,a):o=fge(e,t,n,a),r==="channelsFirst"&&(o=Zt(o,[0,4,1,2,3])),o})}class zV extends Xt{constructor(t){t.poolSize==null&&(t.poolSize=2);super(t);if(typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new re(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(zs(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new re(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);zs(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,$i(this.padding),this.inputSpec=[new As({ndim:3})]}computeOutputShape(t){t=ln(t);const n=ta(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],n,t[2]]}call(t,n){return ye(()=>{this.invokeCallHook(t,n),t=c0(kt(t),2);const s=this.poolingFunction(kt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return t0(s,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(t,n),t}}class UV extends zV{constructor(t){super(t)}poolingFunction(t,n,s,r,i){return us(i),$i(r),L1(t,n,s,r,i,"max")}}UV.className="MaxPooling1D";Fe(UV);class VV extends zV{constructor(t){super(t)}poolingFunction(t,n,s,r,i){return us(i),$i(r),L1(t,n,s,r,i,"avg")}}VV.className="AveragePooling1D";Fe(VV);class GV extends Xt{constructor(t){t.poolSize==null&&(t.poolSize=[2,2]);super(t);if(this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new re(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];zs(this.poolSize,"poolSize"),zs(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,us(this.dataFormat),$i(this.padding),this.inputSpec=[new As({ndim:4})]}computeOutputShape(t){t=ln(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2];return n=ta(n,this.poolSize[0],this.padding,this.strides[0]),s=ta(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],n,s]:[t[0],n,s,t[3]]}call(t,n){return ye(()=>(this.invokeCallHook(t,n),this.poolingFunction(kt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class WV extends GV{constructor(t){super(t)}poolingFunction(t,n,s,r,i){return us(i),$i(r),L1(t,n,s,r,i,"max")}}WV.className="MaxPooling2D";Fe(WV);class HV extends GV{constructor(t){super(t)}poolingFunction(t,n,s,r,i){return us(i),$i(r),L1(t,n,s,r,i,"avg")}}HV.className="AveragePooling2D";Fe(HV);class jV extends Xt{constructor(t){t.poolSize==null&&(t.poolSize=[2,2,2]);super(t);if(this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new re(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];zs(this.poolSize,"poolSize"),zs(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,us(this.dataFormat),$i(this.padding),this.inputSpec=[new As({ndim:5})]}computeOutputShape(t){t=ln(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[4]:t[3];return n=ta(n,this.poolSize[0],this.padding,this.strides[0]),s=ta(s,this.poolSize[1],this.padding,this.strides[1]),r=ta(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],n,s,r]:[t[0],n,s,r,t[4]]}call(t,n){return ye(()=>(this.invokeCallHook(t,n),this.poolingFunction(kt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class qV extends jV{constructor(t){super(t)}poolingFunction(t,n,s,r,i){return us(i),$i(r),BV(t,n,s,r,i,"max")}}qV.className="MaxPooling3D";Fe(qV);class XV extends jV{constructor(t){super(t)}poolingFunction(t,n,s,r,i){return us(i),$i(r),BV(t,n,s,r,i,"avg")}}XV.className="AveragePooling3D";Fe(XV);class KV extends Xt{constructor(t){super(t);this.inputSpec=[new As({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,n){throw new $t}}class YV extends KV{constructor(t){super(t||{})}call(t,n){return ye(()=>{const s=kt(t);return bs(s,1)})}}YV.className="GlobalAveragePooling1D";Fe(YV);class QV extends KV{constructor(t){super(t||{})}call(t,n){return ye(()=>{const s=kt(t);return qo(s,1)})}}QV.className="GlobalMaxPooling1D";Fe(QV);class ZV extends Xt{constructor(t){super(t);this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,us(this.dataFormat),this.inputSpec=[new As({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,n){throw new $t}getConfig(){const t={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class JV extends ZV{call(t,n){return ye(()=>{const s=kt(t);return this.dataFormat==="channelsLast"?bs(s,[1,2]):bs(s,[2,3])})}}JV.className="GlobalAveragePooling2D";Fe(JV);class eG extends ZV{call(t,n){return ye(()=>{const s=kt(t);return this.dataFormat==="channelsLast"?qo(s,[1,2]):qo(s,[2,3])})}}eG.className="GlobalMaxPooling2D";Fe(eG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class tG extends Xt{constructor(t){super(t);this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(t,n),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,n,s={}){const r=n.layer,i=Ll(r,s);delete n.layer;const o={layer:i};return Object.assign(o,n),new t(o)}}class nG extends tG{constructor(t){super(t);this.supportsMasking=!0}build(t){if(t=ln(t),t.length<3)throw new re(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const n=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=ln(t);const n=[t[0]].concat(t.slice(2)),s=this.layer.computeOutputShape(n),r=t[1];return[s[0],r].concat(s.slice(1))}call(t,n){return ye(()=>(t=kt(t),hV((o,a)=>[kt(this.layer.call(o,n)),[]],t,[],!1,null,null,!1,!0)[1]))}}nG.className="TimeDistributed";Fe(nG);function GSe(e){_h(pwe,"BidirectionalMergeMode",e)}const WSe="concat";class sG extends tG{constructor(t){super(t);const n=t.layer.getConfig(),s={};s.className=t.layer.getClassName(),s.config=n,this.forwardLayer=Ll(s),n.goBackwards=n.goBackwards!==!0;const r={};if(r.className=t.layer.getClassName(),r.config=n,this.backwardLayer=Ll(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?WSe:t.mergeMode,GSe(this.mergeMode),t.weights)throw new $t("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const n=t.length,s=Math.floor(n/2);this.forwardLayer.setWeights(t.slice(0,s)),this.backwardLayer.setWeights(t.slice(s))}computeOutputShape(t){let n=this.forwardLayer.computeOutputShape(t);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let s,r,i;return this.returnState&&(i=n.slice(1)),s=n[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):qr(r)}apply(t,n){let s=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});const i=uV(t,s,r,this.numConstants);if(t=i.inputs,s=i.initialState,r=i.constants,Array.isArray(t)&&(s=t.slice(1),t=t[0]),(s==null||s.length===0)&&r==null)return super.apply(t,n);const o=[],a=[];if(s!=null){const c=s.length;if(c%2>0)throw new re("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=s,o.push(...s);const h=s.map(u=>new As({shape:u.shape}));this.forwardLayer.stateSpec=h.slice(0,c/2),this.backwardLayer.stateSpec=h.slice(c/2),a.push(...h)}if(r!=null)throw new $t("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof Ja;for(const c of o)if(c instanceof Ja!==l)throw new re("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[t].concat(o),h=this.inputSpec.concat(a),u=this.inputSpec;this.inputSpec=h;const d=super.apply(c,n);return this.inputSpec=u,d}else return super.apply(t,n)}call(t,n){return ye(()=>{const s=n.initialState;let r,i;if(s==null)r=this.forwardLayer.call(t,n),i=this.backwardLayer.call(t,n);else{const l=s.slice(0,s.length/2),c=s.slice(s.length/2);r=this.forwardLayer.call(t,Object.assign(n,{initialState:l})),i=this.backwardLayer.call(t,Object.assign(n,{initialState:c}))}let o;this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=gh(i,1));let a;return this.mergeMode==="concat"?a=WA([r,i]):this.mergeMode==="sum"?a=ze(r,i):this.mergeMode==="ave"?a=le(.5,ze(r,i)):this.mergeMode==="mul"?a=le(r,i):this.mergeMode==null&&(a=[r,i]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Ch(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Ch(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,n){Array.isArray(n)&&(n=n[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[n,n]:s=n:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(t,n),t}static fromConfig(t,n){const s=Ll(n.layer);if(delete n.layer,n.numConstants!=null)throw new $t("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=n;return r.layer=s,new t(r)}}sG.className="Bidirectional";Fe(sG);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class rG extends Xt{constructor(t){super(t);this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},n=super.getConfig();return Object.assign(t,n),t}call(t,n){return ye(()=>(t=kt(t),t.dtype!=="float32"&&(t=Qa(t,"float32")),ze(le(t,this.scale),this.offset)))}}rG.className="Rescaling";Fe(rG);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:HSe,cropAndResize:jSe}=vh;class iG extends Xt{constructor(t){super(t);this.height=t.height,this.width=t.width}centerCrop(t,n,s,r,i,o,a,l){return ye(()=>{let c,h=!1;const u=n/o,d=s/a,p=(r+n)/o,f=(i+s)/a,g=[u,d,p,f],m=[];t.rank===3?(h=!0,c=Bc([t])):c=t;for(let w=0;w<c.shape[0];w++)m.push(g);const y=NB(m,[m.length,4]),v=e0(0,m.length,1,"int32"),x=jSe(c,y,v,[r,i],"nearest");return Qa(h?kt(yh(x)):x,l)})}upsize(t,n,s,r){return ye(()=>{const i=HSe(t,[n,s]);return Qa(i,r)})}call(t,n){return ye(()=>{const s=kt(t),r=s.dtype,i=s.shape,o=i[i.length-3],a=i[i.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let c=0;return a!==this.width&&(c=Math.floor((a-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(s,l,c,this.height,this.width,o,a,r):this.upsize(t,this.height,this.width,r)})}getConfig(){const t={height:this.height,width:this.width},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){t=ln(t);const n=t.length-3,s=t.length-2;return t[n]=this.height,t[s]=this.width,t}}iG.className="CenterCrop";Fe(iG);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qSe(e,t,n,s){let r=kt(e);if(r.dtype!=="int32"&&(r=Qa(r,"int32")),t==="int")return r;const i=r.shape;if(r.rank===0&&(r=ui(r,-1)),t==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=ui(r,-1)),r.rank>2)throw new re(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(t),a=r;let l;if(typeof s!="undefined"&&t==="count"?l=YB(a,s,n,o):l=YB(a,[],n,o),t!=="tfIdf")return l;if(s)return le(l,s);throw new re("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class oG extends Xt{constructor(t){super(t);this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){return t=ln(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,n){return ye(()=>{t=kt(t),t.dtype!=="int32"&&(t=Qa(t,"int32"));let s;if(typeof n.countWeights!="undefined"){if(this.outputMode!=="count")throw new re(`countWeights is not used when outputMode !== count.
              Received countWeights=${n.countWeights}`);s=kt(n.countWeights)}const r=qo(t),i=s1(t),o=Ri(this.numTokens,r).bufferSync().get(0),a=dh(i,0).bufferSync().get(0);if(!(o&&a))throw new re(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return qSe(t,this.outputMode,this.numTokens,s)})}}oG.className="CategoryEncoding";Fe(oG);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const XSe=["bilinear","nearest"],aG=new Set(XSe);class lG extends Xt{constructor(t){super(t);if(this.height=t.height,this.width=t.width,t.interpolation)if(aG.has(t.interpolation))this.interpolation=t.interpolation;else throw new re(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(t.cropToAspectRatio)}computeOutputShape(t){t=ln(t);const n=t[2];return[this.height,this.width,n]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},n=super.getConfig();return Object.assign(t,n),t}call(t,n){return ye(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return vh.resizeBilinear(t,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return vh.resizeNearestNeighbor(t,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...aG]} are supported`)})}}lG.className="Resizing";Fe(lG);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KSe=xe();KSe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var cG;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(cG||(cG={}));var uG;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(uG||(uG={}));/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var hG;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(hG||(hG={}));/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function at(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&W(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YSe=Cz;class F1 extends dT{constructor(){super();this.blockSize=48,this.firstUse=!0,this.data=new _$(this,Wa())}nextDataId(){return F1.nextDataId++}write(t,n,s){this.firstUse&&(this.firstUse=!1,xe().get("IS_NODE")&&Mi(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:s,refCount:1}),r}makeTensorInfo(t,n,s){let r;if(n==="string"&&s!=null&&s.length>0&&Xm(s[0])){const i=s.map(o=>Pc(o));r=this.write(i,t,n)}else r=this.write(s,t,n);return{dataId:r,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){const n=this.data.get(t);n.refCount--}}move(t,n,s,r,i){this.data.set(t,{values:n,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:n,complexTensorInfos:s}=this.data.get(t);if(n==="complex64"){const r=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return Ol(r,i)}return Nfe(this.data.get(t).values,n)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string")try{const s=n.map(r=>Oc(r));return jt(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return jt(t.shape,t.dtype,n)}makeOutput(t,n,s){return Wa().makeTensorFromTensorInfo(this.makeTensorInfo(n,s,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(t);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const n=Wr();return t(),{kernelMs:Wr()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){at([t],"where");const n=this.readSync(t.dataId);return YSe(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}F1.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dG(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const QSe=e=>{const{x:t}=e.inputs,n=e.backend;at(t,"abs");let s=new Float32Array(Ae(t.shape));const r=n.data.get(t.dataId).values;return s=dG(r),n.makeOutput(s,t.shape,t.dtype)},ZSe={kernelName:Gx,backendName:"cpu",kernelFunc:QSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ws(e){return(t,n,s,r,i)=>{const o=Ft(t,n),a=o.length,l=gt(o),c=Ae(o),h=Ys(i,c),u=t.length,d=n.length,p=gt(t),f=gt(n),g=kp(t,o),m=kp(n,o);if(g.length+m.length===0)for(let y=0;y<h.length;++y)h[y]=e(s[y%s.length],r[y%r.length]);else for(let y=0;y<h.length;++y){const v=xp(y,a,l),b=v.slice(-u);g.forEach(C=>b[C]=0);const x=Va(b,u,p),w=v.slice(-d);m.forEach(C=>w[C]=0);const S=Va(w,d,f);h[y]=e(s[x],r[S])}return[h,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function di(e){const{inputs:t,backend:n}=e,{real:s,imag:r}=t,i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,a=n.makeTensorInfo(s.shape,"complex64"),l=n.data.get(a.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",i),imag:n.makeTensorInfo(r.shape,"float32",o)},a}const JSe={kernelName:NT,backendName:"cpu",kernelFunc:di};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $1(e,t,n="float32"){if(n==="complex64"){const r=$1(e,t,"float32"),i=$1(e,t,"float32");return di({inputs:{real:r,imag:i},backend:e})}const s=ar(Ae(t),n);return e.makeTensorInfo(t,n,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tl(e){const{inputs:t,backend:n}=e,{x:s}=t;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const e_e={kernelName:gg,backendName:"cpu",kernelFunc:tl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ih(e){const{inputs:t,backend:n}=e,{input:s}=t,r=n.data.get(s.dataId).complexTensorInfos.real,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}const t_e={kernelName:eE,backendName:"cpu",kernelFunc:Ih};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pG(e,t,n,s){if(s==="int32"){const r=Int32Array.from(e);return[t,"int32",r]}if(s==="bool"){const r=sh([0],n),[i,o]=ws((a,l)=>a!==l?1:0)(t,[],e,r,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${n} to ${s}`)}function Kc(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return tl({inputs:{x:r},backend:n});const h=$1(n,r.shape,r.dtype),u=Kc({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),d=di({inputs:{real:u,imag:h},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(u),d}if(r.dtype==="complex64"){const h=Ih({inputs:{input:r},backend:n}),u=Kc({inputs:{x:h},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(h),u}if(!A$(r.dtype,i)){const h=tl({inputs:{x:r},backend:n});return{dataId:h.dataId,shape:h.shape,dtype:i}}const o=n.data.get(r.dataId).values,[a,l,c]=pG(o,r.shape,r.dtype,i);return n.makeTensorInfo(a,l,c)}const n_e={kernelName:sg,backendName:"cpu",kernelFunc:Kc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Us(e,t,n,s){return n==null?({inputs:r,backend:i})=>{const{a:o,b:a}=r,l=i;at([o,a],e);const c=l.data.get(o.dataId).values,h=l.data.get(a.dataId).values,u=o.dtype==="string"?bh(c):c,d=o.dtype==="string"?bh(h):h,p=s||o.dtype,[f,g]=t(o.shape,a.shape,u,d,p);return l.makeTensorInfo(g,p,f)}:({inputs:r,backend:i})=>{const{a:o,b:a}=r,l=i;if(o.dtype==="complex64"||a.dtype==="complex64"){const c=Kc({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),h=l.data.get(c.dataId),u=h.complexTensorInfos.real,d=h.complexTensorInfos.imag,p=l.data.get(u.dataId).values,f=l.data.get(d.dataId).values,g=Kc({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),m=l.data.get(g.dataId),y=m.complexTensorInfos.real,v=m.complexTensorInfos.imag,b=l.data.get(y.dataId).values,x=l.data.get(v.dataId).values,[w,S,C]=n(o.shape,a.shape,p,f,b,x),_=l.makeTensorInfo(C,"float32",w),T=l.makeTensorInfo(C,"float32",S),E=di({inputs:{real:_,imag:T},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(_),l.disposeIntermediateTensorInfo(T),E}else{const c=l.data.get(o.dataId).values,h=l.data.get(a.dataId).values,u=s||o.dtype,[d,p]=t(o.shape,a.shape,c,h,u);return l.makeTensorInfo(p,u,d)}}}function SI(e){return(t,n,s,r,i,o)=>{const a=Ft(t,n),l=Ae(a),c=a.length,h=gt(a),u=Ys("float32",l),d=Ys("float32",l),p=kp(t,a),f=kp(n,a),g=Ol(s,r),m=Ol(i,o),y=t.length,v=gt(t),b=n.length,x=gt(n);if(p.length+f.length===0)for(let w=0;w<u.length;w++){const S=w%g.length,C=w%m.length,_=e(g[S*2],g[S*2+1],m[C*2],m[C*2+1]);u[w]=_.real,d[w]=_.imag}else for(let w=0;w<u.length;w++){const S=xp(w,c,h),C=S.slice(-y);p.forEach(D=>C[D]=0);const _=Va(C,y,v),T=S.slice(-b);f.forEach(D=>T[D]=0);const E=Va(T,b,x),A=e(g[_*2],g[_*2+1],m[E*2],m[E*2+1]);u[w]=A.real,d[w]=A.imag}return[u,d,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fG=ws((e,t)=>e+t),s_e=SI((e,t,n,s)=>({real:e+n,imag:t+s})),Gp=Us(bp,fG,s_e),r_e={kernelName:bp,backendName:"cpu",kernelFunc:Gp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _I(e,t,n,s,r){const i=Ae(s),o=ar(r,n);for(let a=0;a<e.length;a++){const l=e[a];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(i>0?o[l]+=t[a]:o[l]+=1)}return o}function mG(e,t,n,s=!1){const r=e.shape[0],i=e.shape[1],o=jt([r,n],t.dtype);for(let a=0;a<r;a++)for(let l=0;l<i;l++){const c=e.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(s?o.set(1,a,c):t.size>0?o.set(o.get(a,c)+t.get(a,l),a,c):o.set(o.get(a,c)+1,a,c))}return o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yc(e){return(t,n,s)=>{const r=Ys(n,t.length);for(let i=0;i<t.length;++i)r[i]=e(t[i],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wn(e,t,n){return({inputs:s,attrs:r,backend:i})=>{const{x:o}=s;if(at(o,e),o.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");const a=i,l=a.data.get(o.dataId).values,c=Ae(o.shape),h=n||o.dtype,u=gs(h,c);for(let d=0;d<c;++d)u[d]=t(l[d],r);return a.makeTensorInfo(o.shape,h,u)}}function Wp(e,t,n){return({inputs:s,attrs:r,backend:i})=>{const{x:o}=s;if(at(o,e),o.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");const a=i,l=a.data.get(o.dataId).values,c=n||o.dtype,h=t(l,c,r);return a.makeTensorInfo(o.shape,c,h)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gG=Yc(e=>Math.ceil(e)),i_e=Wp(rg,gG),o_e={kernelName:rg,backendName:"cpu",kernelFunc:i_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yG(e,t,n,s){const r=gs(n,Ae(t));if(s&&n!=="string"){let i=0;e.forEach(o=>{const a=Ae(o.shape);r.set(o.vals,i),i+=a})}else{let i=0;e.forEach(o=>{const a=n==="string"?bh(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const h=c*t[1]+i;for(let u=0;u<o.shape[1];++u)r[h+u]=a[l++]}i+=o.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vG=ws((e,t)=>e===t?1:0),xG=Us(rb,vG,null,"bool"),a_e={kernelName:rb,backendName:"cpu",kernelFunc:xG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bG=Yc(e=>Math.exp(e)),wG=Wp(hg,bG,"float32"),l_e={kernelName:hg,backendName:"cpu",kernelFunc:wG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SG=Yc(e=>Math.expm1(e)),c_e=Wp(dg,SG),u_e={kernelName:dg,backendName:"cpu",kernelFunc:c_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _G=Yc(e=>Math.floor(e)),h_e=Wp(pg,_G),d_e={kernelName:pg,backendName:"cpu",kernelFunc:h_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CG(e,t,n,s,r,i,o,a,l){const c=jt([s,i],n);for(let h=0;h<s;h++){const u=[];let d=0;for(let p=0;p<r;p++){const f=e[h*r+p];d+=f*o[p],u.push(f)}if(d<0||d>=l/i)throw new Error(`Invalid indices: ${u} does not index into ${a}`);for(let p=0;p<i;p++)c.values[h*i+p]=t.get(...t.indexToLoc(d*i+p))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TG(e,t,n){const s=jt(n,e.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r).slice(),a=o[0],l=o[2],c=t.locToIndex([a,l]);o[2]=t.values[c];const h=e.locToIndex(o);0<=h&&h<e.values.length&&(s.values[r]=e.values[h])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EG=ws((e,t)=>e>t?1:0),p_e=Us(lb,EG,null,"bool"),f_e={kernelName:lb,backendName:"cpu",kernelFunc:p_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AG=ws((e,t)=>e>=t?1:0),m_e=Us(mg,AG,null,"bool"),g_e={kernelName:mg,backendName:"cpu",kernelFunc:m_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IG=ws((e,t)=>e<t?1:0),y_e=Us(ub,IG,null,"bool"),v_e={kernelName:ub,backendName:"cpu",kernelFunc:y_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NG=ws((e,t)=>e<=t?1:0),x_e=Us(hb,NG,null,"bool"),b_e={kernelName:hb,backendName:"cpu",kernelFunc:x_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kG(e,t,n){const s=(t-e)/(n-1),r=ar(n,"float32");r[0]=e;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DG=Yc(e=>Math.log(e)),w_e=Wp(bg,DG),S_e={kernelName:bg,backendName:"cpu",kernelFunc:w_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MG(e,t,n,s){const r=Ys(s,Ae(n));for(let i=0;i<r.length;++i){const o=i*t;let a=e[o];for(let l=0;l<t;++l){const c=e[o+l];(Number.isNaN(c)||c>a)&&(a=c)}r[i]=a}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PG=ws((e,t)=>Math.max(e,t)),__e=Us(Sg,PG),C_e={kernelName:Sg,backendName:"cpu",kernelFunc:__e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OG=ws((e,t)=>Math.min(e,t)),T_e=Us(_g,OG),E_e={kernelName:_g,backendName:"cpu",kernelFunc:T_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CI=ws((e,t)=>e*t),A_e=SI((e,t,n,s)=>({real:e*n-t*s,imag:e*s+t*n})),B1=Us(Tg,CI,A_e),I_e={kernelName:Tg,backendName:"cpu",kernelFunc:B1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RG(e,t,n){const s=Mc(-1,n);return CI([],t,s,e,n)}function N_e(e){const{inputs:t,backend:n}=e,{x:s}=t;at(s,"neg");const r=n.data.get(s.dataId).values,[i,o]=RG(r,s.shape,s.dtype);return n.makeTensorInfo(o,s.dtype,i)}const k_e={kernelName:Sb,backendName:"cpu",kernelFunc:N_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LG=ws((e,t)=>e!==t?1:0),D_e=Us(_b,LG,null,"bool"),M_e={kernelName:_b,backendName:"cpu",kernelFunc:D_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TI(e,t,n,s,r){const i=t.length,o=Ae(t),a=gt(t),l=gt(r),c=Ys(n,Ae(r));for(let h=0;h<o;++h){const u=xp(h,i,a),d=new Array(u.length);for(let f=0;f<d.length;f++)d[f]=u[s[f]];const p=Va(d,i,l);c[p]=e[h]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kr(e){const{inputs:t,attrs:n,backend:s}=e,{x:r}=t,{perm:i}=n;at(r,"transpose");const o=r.shape.length,a=new Array(o);for(let u=0;u<a.length;u++)a[u]=r.shape[i[u]];const l=s.data.get(r.dataId).values,c=TI(l,r.shape,r.dtype,i,a);return{dataId:s.write(c,a,r.dtype),shape:a,dtype:r.dtype}}const P_e={kernelName:wp,backendName:"cpu",kernelFunc:Kr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FG(e,t,n,s){const[r,i]=$s(e,s),o=li(t,"int32"),a=ar(Ae(r),o),l=Ae(i);for(let c=0;c<a.length;++c){const h=c*l;let u=1;for(let d=0;d<l;++d)u*=n[h+d];a[c]=u}return{outVals:a,outShape:r,outDtype:o}}function O_e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:o}=s;at(r,"prod");const a=r.shape.length,l=Ht(i,r.shape),c=Yn(l,a);let h=l,u=r;const d=[];c!=null&&(u=Kr({inputs:{x:r},backend:n,attrs:{perm:c}}),d.push(u),h=cs(h.length,a));const p=n.data.get(u.dataId).values,{outVals:f,outShape:g,outDtype:m}=FG(u.shape,u.dtype,p,h);let y=g;return o&&(y=vs(g,l)),d.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(y,m,f)}const R_e={kernelName:Nb,backendName:"cpu",kernelFunc:O_e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L_e(e,t,n){e.forEach((s,r)=>{if(s<0||s>=n){const i=xp(r,t.length,gt(t)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${n})`)}})}function F_e(e,t){for(let n=0;n<e.length;++n){const s=e[n],r=n===e.length-1?t:e[n+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function $_e(e,t,n,s){const r=[];let i=0;const o=t.length-1+n.length,a=new Array(o).fill(null).map(()=>[0]);F_e(n,s);let l=1;for(let c=0;c<t.length-1;++c){l*=t[c];const h=t[c+1];for(let u=1;u<l+1;++u)a[c].push(u*h)}for(let c=0;c<e.length;++c){let h=e[c],u=e[c]+1;for(let d=0;d<n.length;++d){const p=n[d],f=d+t.length-1;if(f>=0){const g=a[f],m=g[g.length-1]-p[h];for(let y=h;y<u;++y)a[f].push(p[y+1]+m)}h=p[h],u=p[u]}u!==h&&(r.push([h,u]),i+=u-h)}return{outSplits:a,valueSlices:r,numValues:i}}function B_e(e){const t=[];for(let n=0;n<e.length;++n){const s=e[n].length,r=gs("int32",s);t.push(r),e[n].forEach((i,o)=>r[o]=i)}return t}function $G(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let s=t;s<e.length;s++)n[t-1]*=e[s];return n}function z_e(e,t,n,s,r,i){const o=$G(t,2)[1],a=$G(i,2)[1];let l=0;for(const c of n)for(let h=c[0];h<c[1];++h){for(let u=0;u<s;++u)r[l*a+u]=e[h*o+u];++l}}function U_e(e,t,n,s,r){const i=t.slice();i[0]=r;const o=gs(n,Ae(i)),a=e.length,l=a===0?0:a/t[0];return z_e(e,t,s,l,o,i),[o,i]}function BG(e,t,n,s,r,i,o,a){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const l=t[0][0]-1;if(L_e(i,o,l),s.length===0)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:h,valueSlices:u,numValues:d}=$_e(i,o,e,c),p=B_e(h),f=U_e(n,s,r,u,d);return[p,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zG=2147483647;function UG(e,t,n,s,r,i,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=t.length===0,l=r.length===0,c=o.length===0,h=[];a||h.push(t[0]),l||h.push(r[0]),c||h.push(o[0]);for(let m=1;m<h.length;++m)if(h[m]!==h[m-1])throw new Error("starts, limits, and deltas must have the same shape");const u=h.length===0?1:h[0],d=gs("int32",u+1);d[0]=0;for(let m=0;m<u;++m){const y=a?e[0]:e[m],v=l?s[0]:s[m],b=c?i[0]:i[m];if(b===0)throw new Error("Requires delta != 0");let x;if(b>0&&v<y||b<0&&v>y)x=0;else if(x=Math.ceil(Math.abs((v-y)/b)),x>zG)throw new Error(`Requires ((limit - start) / delta) <= ${zG}`);d[m+1]=d[m]+x}const p=d[u],f=gs(n,p);let g=0;for(let m=0;m<u;++m){const y=d[m+1]-d[m];let v=a?e[0]:e[m];const b=c?i[0]:i[m];for(let x=0;x<y;++x)f[g++]=v,v+=b}return[d,f]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var vo=Ko;class z1{constructor(t,n,s,r,i,o,a,l,c,h){this.shape=t,this.shapeShape=n,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=Jz(h),this.raggedRank=e4(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===vo.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===vo.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case vo.VALUE_ROWIDS:return z1.getMaxWidthValueRowID(n);case vo.ROW_SPLITS:return z1.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${vo[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const n=t.length;if(n===0||n===1)return 0;let s=0;for(let r=0;r<n-1;++r){const i=t[r+1]-t[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(t){const n=t.length;if(n===0)return 0;let s=0,r=t[0],i=0;for(let o=1;o<n;++o){const a=t[o];a!==r&&(r=a,i=Math.max(o-s,i),s=o)}return Math.max(n-s,i)}tensorShapeFromTensor(t,n,s=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return GG(t,s)}calculateOutputSize(t){const n=this.valuesShape,s=this.defaultValueShape;t4(s,n);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=Zz(this.raggedRank,r,n);o[0]<0&&(o[0]=t);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(t,n,s){const r=Math.min(t,s),i=[];let o=0;for(let a=0;a<r;++a,o+=n)i.push(o);for(let a=r;a<t;++a)i.push(-1);return W(i.length===t,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(t,n,s,r){const i=t.length,o=[];for(let a=0;a<i-1;++a){const l=t[a+1]-t[a];let c=Math.min(r,l),h=n[a];h===-1&&(c=0);for(let u=0;u<c;++u)o.push(h),h+=s;for(let u=0;u<l-c;++u)o.push(-1)}if(i>0&&o.length!==t[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,n,s,r){const i=t.length,o=[];if(i===0)return[];let a=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let c=n[l];o.push(c);for(let h=1;h<i;++h){const u=t[h];if(u===l)c>=0&&(++a,a<r?c+=s:c=-1);else{if(a=0,l=u,u>=n.length)throw new Error(`Got nextValueRowId=${u} which is not less than ${n.length}`);c=n[u]}o.push(c)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,n,s,r){const i=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case vo.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,n,s,r);case vo.ROW_SPLITS:if(i.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(i,n,s,r);default:throw new Error(`Unsupported partition type: ${vo[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case vo.FIRST_DIM_SIZE:return t[0];case vo.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case vo.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${vo[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),s=this.calculateOutputSize(n),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*s[l+1];const i=GG(s,!1),o=gs(this.valuesDType,Ae(i));if(r[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(n,r[0],s[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,r[c],s[c]);this.setOutput(this.raggedRank,l,o,i)}return[i,o]}setOutput(t,n,s,r){if(s.length===0)return;const i=this.values,o=s;let a=r.slice();a=a.slice(t+1);const l=Ae(a),c=n.length;let h=this.defaultValue;if(h.length!==l&&h.length!==1){const f=this.defaultValueShape;ye(()=>{const g=pe(h,f);h=Zg(g,a).dataSync()})}let u=0,d=0,p=0;for(let f=0;f<=c;++f){let g=f<c?n[f]:-1;if(g===p){++p;continue}if(d<p){const m=i.subarray(u*l),y=o.subarray(d*l),v=(p-d)*l;VG(y,m,v)}if(f>=c){const m=s.length;g=Math.floor(m/l)}if(g>p)if(this.defaultValue.length===1)o.subarray(p*l,g*l).fill(this.defaultValue[0]),p=g;else for(;g>p;){const m=o.slice(p*l);VG(m,h,l),++p}g<0?(u=f+1,d=p):(u=f,d=p,p=d+1)}}}function VG(e,t,n){for(let s=0;s<n;s++)e[s]=t[s]}function GG(e,t){const n=[];for(let s of e){if(s<0){if(!t)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}n.push(s)}return n}function WG(e,t,n,s,r,i,o,a,l,c){return new z1(e,t,n,s,r,i,o,a,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HG(e,t,n,s){const r=e===t,i=e<t&&n<0,o=t<e&&n>1;if(r||i||o)return ar(0,s);const a=Math.abs(Math.ceil((t-e)/n)),l=ar(a,s);t<e&&n===1&&(n=-1),l[0]=e;for(let c=1;c<l.length;c++)l[c]=l[c-1]+n;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jG=Yc(e=>1/Math.sqrt(e)),V_e=Wp(Dg,jG),G_e={kernelName:Dg,backendName:"cpu",kernelFunc:V_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hp(e,t,n,s,r,i,o,a,l,c){const h=[s/r,r],u=e.values,d=t.values;if(s===0)return jt(n,t.dtype);const p=jt(h,t.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<i;f++){const g=[];let m=0;for(let y=0;y<o;y++){const v=u[f*o+y];g.push(v),m+=v*a[y]}if(m<0||m>=s/r)throw new Error(`Invalid indices: ${g} does not index into ${n}`);for(let y=0;y<r;y++)c?p.values[m*r+y]+=d[f*r+y]:p.values[m*r+y]=t.rank===0?d[0]:d[f*r+y]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W_e=Yc(e=>1/(1+Math.exp(-e))),qG=wn(Lg,e=>1/(1+Math.exp(-e))),H_e={kernelName:Lg,backendName:"cpu",kernelFunc:qG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XG(e,t,n,s,r){const i=fA(s,t,n),o=Ae(n),a=gt(s);if(i){const u=mA(t,a);return r==="string"?e.slice(u,u+o):e.subarray(u,u+o)}const l=r==="string"?bh(e):e,c=jt(s,r,l),h=jt(n,r);for(let u=0;u<h.size;++u){const d=h.indexToLoc(u),p=d.map((f,g)=>f+t[g]);h.set(c.get(...p),...d)}return r==="string"?_4(h.values):h.values}function Nh(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:i,size:o}=s;at(r,"slice");const[a,l]=u1(r,i,o);dA(r,a,l);const c=n.data.get(r.dataId).values,h=XG(c,a,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,h)}const j_e={kernelName:Rb,backendName:"cpu",kernelFunc:Nh};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KG(e,t,n,s,r,i,o){const a=t[0],l=i[0],c=new Array(l),h=new Array(a),u=t[1];if(l===0){if(a!==0)throw new Error(u4(a));const m=gs(n,0),y=gs(r,0);return[m,[0,u],y,c,h]}let d=!0,p=0;const f=new Array(l).fill(0);for(let m=0;m<a;++m){const y=e[m*u];if(y<0)throw new Error(h4(m,y));if(y>=l)throw new Error(d4(m,y,l));++f[y],d=d&&y>=p,p=y}let g=!0;for(let m=0;m<l;++m){const y=f[m]===0;c[m]=y,g=g&&!y,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(g&&d){const m=e,y=s;for(let v=0;v<a;++v)h[v]=v;return[m,[a,u],y,c,h]}else{const m=f[l-1],y=gs(n,m*u),v=gs(r,m),b=new Array(l).fill(0);for(let x=0;x<a;++x){const w=e[x*u],S=b[w],C=(w===0?0:f[w-1])+S;b[w]++;for(let _=0;_<u;++_)y[C*u+_]=e[x*u+_];v[C]=s[x],h[x]=C}for(let x=0;x<l;++x)if(b[x]===0){const S=x===0?0:f[x-1];y[S*u+0]=x;for(let C=1;C<u;++C)y[S*u+C]=0;v[S]=o}return[y,[m,u],v,c,h]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YG(e,t,n,s,r){const i=Ae(s),o=t[0],a=r.length,l=[];let c=1,h=-1;for(let m=0;m<a;++m){const y=r[m];if(y===-1){if(h!==-1)throw new Error(p4(h,m));h=m,l.push(1)}else{if(y<0)throw new Error(f4(m,y));c*=y,l.push(y)}}if(h!==-1){if(c<=0)throw new Error(m4());const m=Math.trunc(i/c);if(c*m!==i)throw new Error(g4(s,l));l[h]=m}if(Ae(l)!==i)throw new Error(y4(s,l));const d=s.length,p=[];if(d>0){p[d-1]=1;for(let m=d-2;m>=0;--m)p[m]=p[m+1]*s[m+1]}const f=[];if(a>0){f[a-1]=1;for(let m=a-2;m>=0;--m)f[m]=f[m+1]*l[m+1]}const g=gs(n,o*a);for(let m=0;m<o;++m){let y=0;for(let v=0;v<d;++v)y+=e[m*d+v]*p[v];for(let v=0;v<a;++v)g[m*a+v]=Math.trunc(y/f[v]),y%=f[v]}return[g,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EI(e,t,n,s,r,i=!1,o=0){const a=s.length,l=[t[0],e.length/t[0]],c=l[1],u=a>0?r[a-1]+1:0;if(u<0)throw new Error(LA());const d=t.slice();d[0]=u;const p=d.reduce((b,x)=>b*x,1),f=gs(n,p);if(a===0)return u>0&&f.fill(o),[f,d];if(u<=0)throw new Error(LA());let g=0,m=1,y=0,v=r[g];for(;;){let b=0;if(m<a){if(b=r[m],v===b){++m;continue}if(v>=b)throw new Error(v4())}if(v<0||v>=u)throw new Error(x4(v,u));v>y&&f.fill(o,y*c,v*c);for(let x=g;x<m;++x){const w=s[x];if(w<0||w>=l[0])throw new Error(b4(x,s[x],l[0]));for(let S=0;S<c;S++)f[v*c+S]+=e[w*c+S]}if(i)for(let x=0;x<c;x++)f[v*c+x]/=m-g;if(g=m,++m,y=v+1,v=b,m>a)break}return y<u&&f.fill(o,y*c,u*c),[f,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q_e=Yc(e=>Math.sqrt(e)),X_e=wn($g,e=>Math.sqrt(e)),K_e={kernelName:$g,backendName:"cpu",kernelFunc:X_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QG=ws((e,t)=>{const n=e-t;return n*n}),Y_e=Us(Bg,QG),Q_e={kernelName:Bg,backendName:"cpu",kernelFunc:Y_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZG(e,t,n,s){const r=jt(e,t.dtype);for(let i=0;i<r.size;i++){const o=r.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*n[l]+s[l];r.set(t.get(...a),...o)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z_e{constructor(t,n,s,r,i,o){this.separator=Pc(t),this.nGramWidths=n,this.leftPad=Pc(s),this.rightPad=Pc(r),this.padWidth=i,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,n){const s=this.getPadWidth(n);return Math.max(0,t+2*s-n+1)}createNGrams(t,n,s,r,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),h=Math.max(0,l-(i-(a+1))),u=o-(c+h),d=n+(c>0?0:a-l);let p=0;p+=c*this.leftPad.length;for(let v=0;v<u;++v)p+=t[d+v].length;p+=h*this.rightPad.length,p+=(c+h+u-1)*this.separator.length,s[r+a]=new Uint8Array(p);const g=s[r+a];let m=0;const y=v=>v.forEach(b=>g[m++]=b);for(let v=0;v<c;++v)y(this.leftPad),y(this.separator);for(let v=0;v<u-1;++v)y(t[d+v]),y(this.separator);if(u>0){y(t[d+u-1]);for(let v=0;v<h;++v)y(this.separator),y(this.rightPad)}else{for(let v=0;v<h-1;++v)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,n){const s=t.length,r=n.length;if(r>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<r;++c){let h=n[c]>=l;if(h=h&&n[c]<=s,!h)throw new Error(`Invalid split value ${n[c]}, must be in [${l}, ${s}]`);l=n[c]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const i=r-1,o=gs("int32",r);if(s===0||r===0){const l=new Array(s);for(let c=0;c<=i;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const c=n[l]-n[l-1];let h=0;this.nGramWidths.forEach(u=>{h+=this.getNumNGrams(c,u)}),this.preserveShort&&c>0&&h===0&&(h=1),o[l]=o[l-1]+h}const a=new Array(o[i]);for(let l=0;l<i;++l){const c=n[l];let h=o[l];if(this.nGramWidths.forEach(u=>{const d=n[l+1]-n[l],p=this.getNumNGrams(d,u);this.createNGrams(t,c,a,h,p,u),h+=p}),this.preserveShort&&h===o[l]){const u=n[l+1]-n[l];if(u===0)continue;const d=u+2*this.padWidth,p=1;this.createNGrams(t,c,a,h,p,d)}}return[a,o]}}function JG(e,t,n,s,r,i,o,a){return new Z_e(n,s,r,i,o,a).compute(e,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J_e(e,t,n,s){if(!e.length)return;if(t.length===0){for(let i=0;i<e.length;++i)s.push(e.subarray(i,i+1));return}if(t.length===1){const i=t[0];let o=e.indexOf(i);for(;o!==-1;){const a=e.subarray(0,o);(!n||a.length!==0)&&s.push(a),e=e.subarray(o+1),o=e.indexOf(i)}(!n||e.length!==0)&&s.push(e);return}let r=0;for(let i=0;i<e.length+1;i++)if(i===e.length||t.indexOf(e[i])!==-1){const o=e.subarray(r,i);(!n||o.length!==0)&&s.push(o),r=i+1}}function eW(e,t,n){const s=e.length,r=[];let i=0,o=0;const a=new Array(s);for(let d=0;d<s;++d){const p=r.length;J_e(e[d],t,n,r);const f=r.length-p;a[d]=f,i+=f,o=Math.max(o,f)}const l=gs("int32",i*2),c=new Array(i),h=[s,o];let u=0;for(let d=0;d<s;++d)for(let p=0;p<a[d];++p)l[u*2]=d,l[u*2+1]=p,c[u]=r[u],++u;return[l,c,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tW(e,t){const n=gs("int32",e.length);for(let s=0;s<e.length;++s)n[s]=qfe(e[s]).modulo(t).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nW=ws((e,t)=>e-t),e2e=SI((e,t,n,s)=>({real:e-n,imag:t-s})),AI=Us(zg,nW,e2e),t2e={kernelName:zg,backendName:"cpu",kernelFunc:AI};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sW(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const s=jt(n,e.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),o=new Array(e.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%e.shape[l];const a=e.locToIndex(o);s.values[r]=e.values[a]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _0=(e,t)=>{const n=t.value-e.value;return n===0?e.index-t.index:n};function rW(e,t,n=0,s=e.length-1){for(;s>n;){if(s-n>600){const a=s-n+1,l=t-n+1,c=Math.log(a),h=.5*Math.exp(2*c/3),u=.5*Math.sqrt(c*h*(a-h)/a)*Math.sign(l-a/2),d=Math.max(n,Math.floor(t-l*h/a+u)),p=Math.min(s,Math.floor(t+(a-l)*h/a+u));rW(e,t,d,p)}const r=e[t];let i=n,o=s;for(gp(e,n,t),_0(e[s],r)>0&&gp(e,n,s);i<o;){for(gp(e,i,o),i++,o--;_0(e[i],r)<0;)i=i+1;for(;_0(e[o],r)>0;)o=o-1}_0(e[n],r)===0?gp(e,n,o):(o=o+1,gp(e,o,s)),o<=t&&(n=o+1),t<=o&&(s=o-1)}}function iW(e,t,n,s,r){const i=t[t.length-1],[o,a]=[e.length/i,i],l=Ys(n,o*s),c=Ys("int32",o*s);for(let u=0;u<o;u++){const d=u*a,p=e.subarray(d,d+a);let f=new Array(p.length);p.forEach((v,b)=>f[b]={value:v,index:b}),s<f.length&&(rW(f,s),f=f.slice(0,s)),r&&f.sort(_0);const g=u*s,m=l.subarray(g,g+s),y=c.subarray(g,g+s);for(let v=0;v<s;v++)m[v]=f[v].value,y[v]=f[v].index}const h=t.slice();return h[h.length-1]=s,[jt(h,n,l),jt(h,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oW(e,t,n,s){const r=Ht(t,n)[0],i=[1,n[0],1];for(let f=0;f<r;f++)i[0]*=n[f];i[1]=n[r];for(let f=r+1;f<n.length;f++)i[2]*=n[f];const o={},a=new Int32Array(n[r]),l=new lr(i,s,e),c=[],h=i[0]===1&&i[2]===1;for(let f=0;f<n[r];f++){let g;if(h)g=e[f].toString();else{const m=[];for(let y=0;y<i[0];y++)for(let v=0;v<i[2];v++)m.push(l.get(y,f,v));g=m.join(",")}if(o[g]!==void 0)a[f]=o[g];else{const m=Object.keys(o).length;o[g]=m,a[f]=m,c.push(f)}}const u=i.slice();u[1]=Object.keys(o).length;const d=new lr(u,s);c.forEach((f,g)=>{for(let m=0;m<i[0];m++)for(let y=0;y<i[2];y++)d.set(l.get(m,f,y),m,g,y)});const p=n.slice();return p[r]=u[1],{outputValues:d.values,outputShape:p,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var n2e=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",simpleAbsImpl:dG,addImpl:fG,bincountImpl:_I,bincountReduceImpl:mG,castImpl:pG,ceilImpl:gG,concatImpl:yG,equalImpl:vG,expImpl:bG,expm1Impl:SG,floorImpl:_G,gatherNdImpl:CG,gatherV2Impl:TG,greaterImpl:EG,greaterEqualImpl:AG,lessImpl:IG,lessEqualImpl:NG,linSpaceImpl:kG,logImpl:DG,maxImpl:MG,maximumImpl:PG,minimumImpl:OG,multiplyImpl:CI,negImpl:RG,notEqualImpl:LG,prodImpl:FG,raggedGatherImpl:BG,raggedRangeImpl:UG,raggedTensorToTensorImpl:WG,rangeImpl:HG,rsqrtImpl:jG,scatterImpl:Hp,sigmoidImpl:W_e,sliceImpl:XG,sparseFillEmptyRowsImpl:KG,sparseReshapeImpl:YG,sparseSegmentReductionImpl:EI,sqrtImpl:q_e,squaredDifferenceImpl:QG,stridedSliceImpl:ZG,stringNGramsImpl:JG,stringSplitImpl:eW,stringToHashBucketFastImpl:tW,subImpl:nW,tileImpl:sW,topKImpl:iW,transposeImpl:TI,uniqueImpl:oW});/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */VB("cpu",()=>new F1,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aW=wn(cg,e=>e>=0?e:Math.exp(e)-1),s2e={kernelName:cg,backendName:"cpu",kernelFunc:aW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lW(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{alpha:i}=s;at([r],"leakyRelu");const o=Ae(r.shape),a=n.data.get(r.dataId).values,l=Ys("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?i*a[c]:a[c];return n.makeTensorInfo(r.shape,"float32",l)}const r2e={kernelName:cb,backendName:"cpu",kernelFunc:lW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i2e=ws((e,t)=>e<0?t*e:e);function cW(e){const{inputs:t,backend:n}=e,{x:s,alpha:r}=t;at([s,r],"prelu");const i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,[a,l]=i2e(s.shape,r.shape,i,o,"float32");return n.makeTensorInfo(l,"float32",a)}const o2e={kernelName:Ib,backendName:"cpu",kernelFunc:cW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uW=wn(Ig,e=>Math.max(0,e)),a2e={kernelName:Ig,backendName:"cpu",kernelFunc:uW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hW=wn(Ng,e=>Math.min(Math.max(0,e),6)),l2e={kernelName:Ng,backendName:"cpu",kernelFunc:hW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U1(e,t,n,s,r){if(n==="linear")return tl({inputs:{x:t},backend:e});if(n==="relu")return uW({inputs:{x:t},backend:e});if(n==="elu")return aW({inputs:{x:t},backend:e});if(n==="relu6")return hW({inputs:{x:t},backend:e});if(n==="prelu")return cW({inputs:{x:t,alpha:s},backend:e});if(n==="leakyrelu")return lW({inputs:{x:t},backend:e,attrs:{alpha:r}});if(n==="sigmoid")return qG({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dn(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{shape:i}=s,o=Ae(r.shape),a=E$(i,o),l=Ae(a);W(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);const c=n.data.get(r.dataId);if(c.complexTensorInfos!=null){const h=c.complexTensorInfos.real,u=c.complexTensorInfos.imag;h.shape=a,u.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const c2e={kernelName:kb,backendName:"cpu",kernelFunc:Dn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dW(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:i}=t,{transposeA:o,transposeB:a}=s;at([r,i],"matMul");const l=r.shape.length,c=i.shape.length,h=o?r.shape[l-2]:r.shape[l-1],u=a?i.shape[c-1]:i.shape[c-2],d=o?r.shape[l-1]:r.shape[l-2],p=a?i.shape[c-2]:i.shape[c-1],f=r.shape.slice(0,-2),g=i.shape.slice(0,-2),m=Ae(f),y=Ae(g),b=Ft(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([d,p]);W(h===u,()=>`Error in matMul: inner shapes (${h}) and (${u}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const x=o?[m,h,d]:[m,d,h],w=a?[y,p,u]:[y,u,p],S=Dn({inputs:{x:r},backend:n,attrs:{shape:x}}),C=Dn({inputs:{x:i},backend:n,attrs:{shape:w}}),_=o?S.shape[1]:S.shape[2],T=o?S.shape[2]:S.shape[1],E=a?C.shape[1]:C.shape[2],A=Math.max(m,y),D=n.data.get(S.dataId).values,O=n.data.get(C.dataId).values,P=gt(S.shape),L=gt(C.shape),[B,F,M]=o?[P[0],1,P[1]]:[P[0],P[1],1],[U,z,$]=a?[1,L[1],L[0]]:[L[1],1,L[0]],R=T*E,H=jt([A,T,E],S.dtype),K=H.values,Y=n.blockSize;for(let X=0;X<A;X++){const oe=X%m,ie=X%y;for(let Z=0;Z<T;Z+=Y){const ce=Math.min(Z+Y,T);for(let ge=0;ge<E;ge+=Y){const _e=Math.min(ge+Y,E);for(let be=0;be<_;be+=Y){const Me=Math.min(be+Y,_);for(let Ie=Z;Ie<ce;Ie++)for(let Le=ge;Le<_e;Le++){let Ue=0;for(let $e=be;$e<Me;$e++){const We=D[oe*B+Ie*F+$e*M],Rt=O[$e*U+Le*z+ie*$];Ue+=We*Rt}K[X*R+(Ie*E+Le)]+=Ue}}}}}return n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(C),n.makeTensorInfo(b,H.dtype,H.values)}const u2e={kernelName:Xx,backendName:"cpu",kernelFunc:dW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2e(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:u}=s;let d,p,f;const g=[];d=dW({inputs:{a:r,b:i},attrs:{transposeA:l,transposeB:c},backend:n}),o&&(p=Gp({inputs:{a:d,b:o},backend:n}),g.push(d),d=p),h&&(f=U1(n,d,h,a,u),g.push(d),d=f);for(const y of g)n.disposeIntermediateTensorInfo(y);return d}const d2e={kernelName:Gb,backendName:"cpu",kernelFunc:h2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p2e=wn(Ym,e=>Math.acos(e)),f2e={kernelName:Ym,backendName:"cpu",kernelFunc:p2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m2e=wn(Qm,e=>Math.acosh(e)),g2e={kernelName:Qm,backendName:"cpu",kernelFunc:m2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y2e(e){const{inputs:t,backend:n}=e,s=t;at(t,"addN");const r=s.map(a=>n.data.get(a.dataId).values),i=jt(s[0].shape,s[0].dtype),o=i.values;for(let a=0;a<s.length;a++){const l=r[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}const v2e={kernelName:_T,backendName:"cpu",kernelFunc:y2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x2e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:o}=s;at(r,"all");const a=Ht(i,r.shape);let l=a;const c=Yn(l,r.shape.length);let h=r;c!=null&&(h=Kr({inputs:{x:r},backend:n,attrs:{perm:c}}),l=cs(l.length,r.shape.length)),Zs("all",l,h.shape.length);const[u,d]=$s(h.shape,l),p=Ae(d),f=ar(Ae(u),h.dtype),g=n.data.get(h.dataId).values;for(let y=0;y<f.length;++y){const v=y*p;let b=g[v];for(let x=0;x<p;++x){const w=g[v+x];b=b&&w}f[y]=b}c!=null&&n.disposeIntermediateTensorInfo(h);const m=n.makeTensorInfo(u,h.dtype,f);if(o){const y=vs(u,a),v=Dn({inputs:{x:m},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(m),v}return m}const b2e={kernelName:CT,backendName:"cpu",kernelFunc:x2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w2e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:o}=s;at(r,"any");const a=Ht(i,r.shape);let l=a;const c=Yn(l,r.shape.length);let h=r;c!=null&&(h=Kr({inputs:{x:r},backend:n,attrs:{perm:c}}),l=cs(l.length,r.shape.length)),Zs("any",l,h.shape.length);const[u,d]=$s(h.shape,l),p=Ae(d),f=ar(Ae(u),h.dtype),g=n.data.get(h.dataId).values;for(let y=0;y<f.length;++y){const v=y*p;let b=g[v];for(let x=0;x<p;++x){const w=g[v+x];b=b||w}f[y]=b}c!=null&&n.disposeIntermediateTensorInfo(h);const m=n.makeTensorInfo(u,h.dtype,f);if(o){const y=vs(u,a),v=Dn({inputs:{x:m},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(m),v}return m}const S2e={kernelName:TT,backendName:"cpu",kernelFunc:w2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _2e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i}=s;at(r,"argMax");let o=Ht(i,r.shape);const a=Yn(o,r.shape.length);let l=r;const c=[];a!=null&&(l=Kr({inputs:{x:r},backend:n,attrs:{perm:a}}),c.push(l),o=cs(o.length,l.shape.length)),o=[o[0]],Zs("argMax",o,l.shape.length);const[h,u]=$s(l.shape,o),d=Ae(h),p=ar(d,"int32"),f=Ae(u),g=n.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const y=m*f;let v=g[y],b=0;for(let x=0;x<f;++x){const w=g[y+x];w>v&&(v=w,b=x)}p[m]=b}return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),n.makeTensorInfo(h,"int32",p)}const C2e={kernelName:Wx,backendName:"cpu",kernelFunc:_2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T2e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i}=s;at(r,"argMin");let o=Ht(i,r.shape);const a=Yn(o,r.shape.length);let l=r;const c=[];a!=null&&(l=Kr({inputs:{x:r},backend:n,attrs:{perm:a}}),c.push(l),o=cs(o.length,l.shape.length)),o=[o[0]],Zs("argMin",o,l.shape.length);const[h,u]=$s(l.shape,o),d=Ae(h),p=ar(d,"int32"),f=Ae(u),g=n.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const y=m*f;let v=g[y],b=0;for(let x=0;x<f;++x){const w=g[y+x];w<v&&(v=w,b=x)}p[m]=b}return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),n.makeTensorInfo(h,"int32",p)}const E2e={kernelName:Hx,backendName:"cpu",kernelFunc:T2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A2e=wn(Zm,e=>Math.asin(e)),I2e={kernelName:Zm,backendName:"cpu",kernelFunc:A2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N2e=wn(Jm,e=>Math.asinh(e)),k2e={kernelName:Jm,backendName:"cpu",kernelFunc:N2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D2e=wn(eg,e=>Math.atan(e)),M2e={kernelName:eg,backendName:"cpu",kernelFunc:D2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P2e=ws((e,t)=>Math.atan2(e,t)),O2e=Us(ng,P2e),R2e={kernelName:ng,backendName:"cpu",kernelFunc:O2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L2e=wn(tg,e=>Math.atanh(e)),F2e={kernelName:tg,backendName:"cpu",kernelFunc:L2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function II(e,t,n,s,r,i){const o=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,u=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=jt(r.outShape,n),m=g.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],v=r.outShape[2]*r.outShape[3],b=r.outShape[3];for(let x=0;x<r.batchSize;++x){const w=x*y,S=x*s[0];for(let C=0;C<r.inChannels;++C)for(let _=0;_<r.outHeight;++_){const T=_*o-d,E=Math.max(0,T),A=Math.min(r.inHeight,h+T),D=w+_*v;for(let O=0;O<r.outWidth;++O){const P=O*a-p,L=Math.max(0,P),B=Math.min(r.inWidth,u+P);let F=f,M=0,U=0;for(let $=E;$<A;$+=l){const R=S+$*s[1];for(let H=L;H<B;H+=c){const K=R+H*s[2],Y=e[K+C];i==="max"&&Y>F?F=Y:i==="avg"&&(M+=Y,U++)}if(isNaN(F))break}const z=D+O*b+C;m[z]=i==="avg"?M/U:F}}}return g}function pW(e,t,n,s,r=!1,i=!1){const o=jt(s.outShape,"int32"),a=s.strideHeight,l=s.strideWidth,c=s.dilationHeight,h=s.dilationWidth,u=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,g=jt(t,n,e);for(let m=0;m<s.batchSize;++m)for(let y=0;y<s.inChannels;++y)for(let v=0;v<s.outHeight;++v){const b=v*a-p;let x=b;for(;x<0;)x+=c;const w=Math.min(s.inHeight,u+b);for(let S=0;S<s.outWidth;++S){const C=S*l-f;let _=C;for(;_<0;)_+=h;const T=Math.min(s.inWidth,d+C);let E=Number.NEGATIVE_INFINITY,A=-1;for(let D=x;D<w;D+=c){const O=D-b;for(let P=_;P<T;P+=h){const L=P-C,B=g.get(m,D,P,y);B>E&&(E=B,r?A=i?((m*s.inHeight+D)*s.inWidth+P)*s.inChannels+y:(D*s.inWidth+P)*s.inChannels+y:A=O*d+L)}}o.set(A,m,v,S,y)}}return o}function fW(e,t,n,s,r,i){const o=r.strideDepth,a=r.strideHeight,l=r.strideWidth,c=r.dilationDepth,h=r.dilationHeight,u=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,g=r.padInfo.front,m=r.padInfo.top,y=r.padInfo.left,v=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=jt(r.outShape,n),x=b.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],S=r.outShape[2]*r.outShape[3]*r.outShape[4],C=r.outShape[3]*r.outShape[4],_=r.outShape[4];for(let T=0;T<r.batchSize;++T){const E=T*w,A=T*s[0];for(let D=0;D<r.inChannels;++D)for(let O=0;O<r.outDepth;++O){const P=O*o-g;let L=P;for(;L<0;)L+=c;const B=Math.min(r.inDepth,d+P),F=E+O*S;for(let M=0;M<r.outHeight;++M){const U=M*a-m;let z=U;for(;z<0;)z+=h;const $=Math.min(r.inHeight,p+U),R=F+M*C;for(let H=0;H<r.outWidth;++H){const K=H*l-y;let Y=K;for(;Y<0;)Y+=u;const X=Math.min(r.inWidth,f+K),oe=R+H*_;let ie=v,Z=0,ce=0;for(let _e=L;_e<B;_e+=c){const be=A+_e*s[1];for(let Me=z;Me<$;Me+=h){const Ie=be+Me*s[2];for(let Le=Y;Le<X;Le+=u){const Ue=Ie+Le*s[3],$e=e[Ue+D];if(i==="max"&&$e>ie?ie=$e:i==="avg"&&(Z+=$e,ce++),isNaN(ie))break}if(isNaN(ie))break}if(isNaN(ie))break}const ge=oe+D;x[ge]=i==="avg"?Z/Math.max(ce,1):ie}}}}return b}function $2e(e,t){const n=jt(t.outShape,"int32"),s=t.strideDepth,r=t.strideHeight,i=t.strideWidth,o=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,h=t.effectiveFilterHeight,u=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let m=0;m<t.inChannels;++m)for(let y=0;y<t.outDepth;++y){const v=y*s-d;let b=v;for(;b<0;)b+=o;const x=Math.min(t.inDepth,c+v);for(let w=0;w<t.outHeight;++w){const S=w*r-p;let C=S;for(;C<0;)C+=a;const _=Math.min(t.inHeight,h+S);for(let T=0;T<t.outWidth;++T){const E=T*i-f;let A=E;for(;A<0;)A+=l;const D=Math.min(t.inWidth,u+E);let O=Number.NEGATIVE_INFINITY,P=-1;for(let L=b;L<x;L+=o){const B=L-v;for(let F=C;F<_;F+=a){const M=F-S;for(let U=A;U<D;U+=l){const z=U-E,$=e.get(g,L,F,U,m);$>=O&&(O=$,P=B*h*u+M*h+z)}}}n.set(P,g,y,w,T,m)}}}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B2e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;at(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=1;W(cr(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=uo(r.shape,i,o,c,a,l);let u;if(h.filterWidth===1&&h.filterHeight===1&&dn(h.inShape,h.outShape))u=tl({inputs:{x:r},backend:n});else{const d=n.data.get(r.dataId).values,p=gt(r.shape),f=II(d,r.shape,r.dtype,p,h,"avg");u=n.makeTensorInfo(h.outShape,r.dtype,f.values)}return u}const z2e={kernelName:jx,backendName:"cpu",kernelFunc:B2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U2e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s;at(r,"avgPool3d");const h=kl(r.shape,i,o,1,a,l,c),u=n.data.get(r.dataId).values,d=fW(u,r.shape,r.dtype,gt(r.shape),h,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}const V2e={kernelName:qx,backendName:"cpu",kernelFunc:U2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G2e(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=s;at([r,i],"avgPool3DGrad");const h=kl(i.shape,o,a,1,l,c),u=h.strideDepth,d=h.strideHeight,p=h.strideWidth,f=h.filterDepth,g=h.filterHeight,m=h.filterWidth,y=h.dilationDepth,v=h.dilationHeight,b=h.dilationWidth,x=h.effectiveFilterDepth,w=h.effectiveFilterHeight,S=h.effectiveFilterWidth,C=x-1-h.padInfo.front,_=S-1-h.padInfo.left,T=w-1-h.padInfo.top,E=jt(i.shape,"float32"),A=1/(f*g*m),D=n.bufferSync(r);for(let O=0;O<h.batchSize;++O)for(let P=0;P<h.inChannels;++P)for(let L=0;L<h.inDepth;++L)for(let B=0;B<h.inHeight;++B)for(let F=0;F<h.inWidth;++F){const M=L-C,U=B-T,z=F-_;let $=0;for(let R=0;R<x;R+=y){const H=(M+R)/u;if(!(H<0||H>=h.outDepth||Math.floor(H)!==H))for(let K=0;K<w;K+=v){const Y=(U+K)/d;if(!(Y<0||Y>=h.outHeight||Math.floor(Y)!==Y))for(let X=0;X<S;X+=b){const oe=(z+X)/p;if(oe<0||oe>=h.outWidth||Math.floor(oe)!==oe)continue;$+=D.get(O,H,Y,oe,P)}}}E.set($*A,O,L,B,F,P)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}const W2e={kernelName:AT,backendName:"cpu",kernelFunc:G2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H2e(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i}=t,o=i;at([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s,h=uo(o.shape,a,l,1,c),u=h.strideHeight,d=h.strideWidth,p=h.filterHeight,f=h.filterWidth,g=h.dilationHeight,m=h.dilationWidth,y=h.effectiveFilterHeight,v=h.effectiveFilterWidth,b=v-1-h.padInfo.left,x=y-1-h.padInfo.top,w=jt(o.shape,"float32"),S=1/(p*f),C=n.data.get(r.dataId).values,_=jt(r.shape,"float32",C);for(let T=0;T<h.batchSize;++T)for(let E=0;E<h.inChannels;++E)for(let A=0;A<h.inHeight;++A)for(let D=0;D<h.inWidth;++D){const O=A-x,P=D-b;let L=0;for(let B=0;B<y;B+=g){const F=(O+B)/u;if(!(F<0||F>=h.outHeight||Math.floor(F)!==F))for(let M=0;M<v;M+=m){const U=(P+M)/d;if(U<0||U>=h.outWidth||Math.floor(U)!==U)continue;L+=_.get(T,F,U,E)}}w.set(L*S,T,A,D,E)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const j2e={kernelName:ET,backendName:"cpu",kernelFunc:H2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q2e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,scale:i,offset:o,mean:a,variance:l}=t;W(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),W(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),W(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),at([r,a,l,i,o],"batchNorm");let{varianceEpsilon:c}=s;c==null&&(c=.001);const h=n.data.get(r.dataId).values,u=n.data.get(a.dataId).values,d=n.data.get(l.dataId).values,p=i?n.data.get(i.dataId).values:new Float32Array([1]),f=o?n.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(h.length),m=f.length,y=p.length,v=d.length,b=u.length;let x=0,w=0,S=0,C=0;for(let _=0;_<h.length;++_)g[_]=f[x++]+(h[_]-u[w++])*p[S++]/Math.sqrt(d[C++]+c),x>=m&&(x=0),w>=b&&(w=0),S>=y&&(S=0),C>=v&&(C=0);return n.makeTensorInfo(r.shape,r.dtype,g)}const X2e={kernelName:ob,backendName:"cpu",kernelFunc:q2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K2e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:i,crops:o}=s;at([r],"batchToSpaceND");const a=i.reduce((y,v)=>y*v),l=r0(r.shape,i,a),c=i0(l.length,i.length),h=o0(r.shape,i,a),u=bA(o,i.length),d=wA(h,o,i.length),p=Dn({inputs:{x:r},backend:n,attrs:{shape:l}}),f=Kr({inputs:{x:p},backend:n,attrs:{perm:c}}),g=Dn({inputs:{x:f},backend:n,attrs:{shape:h}}),m=Nh({inputs:{x:g},backend:n,attrs:{begin:u,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}const Y2e={kernelName:Kx,backendName:"cpu",kernelFunc:K2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q2e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:i}=t,{size:o}=s,a=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,c=_I(a,l,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,c)}const Z2e={kernelName:IT,backendName:"cpu",kernelFunc:Q2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J2e(e){const{inputs:t,backend:n}=e,{s0:s,s1:r}=t,i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,a=Ft(Array.from(i),Array.from(o));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const eCe={kernelName:P$,backendName:"cpu",kernelFunc:J2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tCe=wn(ig,(e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),nCe={kernelName:ig,backendName:"cpu",kernelFunc:tCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sCe=e=>{const{x:t}=e.inputs,n=e.backend,s=new Float32Array(Ae(t.shape)),r=n.data.get(t.dataId),i=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,a=n.data.get(i.dataId).values,l=n.data.get(o.dataId).values;for(let c=0;c<a.length;c++){const h=a[c],u=l[c];s[c]=Math.hypot(h,u)}return n.makeOutput(s,t.shape,"float32")},rCe={kernelName:Yx,backendName:"cpu",kernelFunc:sCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jp(e){const{inputs:t,backend:n}=e,{input:s}=t,r=n.data.get(s.dataId).complexTensorInfos.imag,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}const iCe={kernelName:jT,backendName:"cpu",kernelFunc:jp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qp(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s,i=Ht(r,t[0].shape)[0],o=t.map(g=>g.shape);yA(o,i);let a=Xa(t.map(g=>g.shape),i);if(Ae(a)===0)return n.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(g=>Ae(g.shape)>0);if(l.length===1)return tl({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){const g=l.map(x=>Ih({inputs:{input:x},backend:n})),m=l.map(x=>jp({inputs:{input:x},backend:n})),y=qp({inputs:g,backend:n,attrs:{axis:i}}),v=qp({inputs:m,backend:n,attrs:{axis:i}}),b=di({inputs:{real:y,imag:v},backend:n});return g.forEach(x=>n.disposeIntermediateTensorInfo(x)),m.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(v),b}const c=l.map(g=>{const m=Ae(g.shape.slice(i));return Dn({inputs:{x:g},backend:n,attrs:{shape:[-1,m]}})}),h=c.map(g=>({vals:n.data.get(g.dataId).values,shape:g.shape}));a=Xa(c.map(g=>g.shape),1);const u=c[0].shape[0]===1,d=yG(h,a,t[0].dtype,u),p=Xa(l.map(g=>g.shape),i),f=n.makeTensorInfo(p,t[0].dtype,d);return c.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}const oCe={kernelName:Qx,backendName:"cpu",kernelFunc:qp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mW(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:h}=s;at([r,i],"conv2d");const u=Dl(l),d=Qs(r.shape,i.shape,o,c,a,h,!1,u),p=d.filterHeight,f=d.filterWidth,g=d.dilationHeight,m=d.dilationWidth,y=d.padInfo.left,v=d.padInfo.top,b=d.dataFormat==="channelsLast",x=new lr(d.outShape,r.dtype),w=gt(r.shape),S=gt(i.shape),C=w[0],_=b?w[1]:w[2],T=b?w[2]:1,E=b?1:w[1],A=x.strides[0],D=b?x.strides[1]:x.strides[2],O=b?x.strides[2]:1,P=b?1:x.strides[1],L=n.data.get(r.dataId).values,B=n.data.get(i.dataId).values,F=x.values;for(let M=0;M<d.batchSize;++M){const U=M*C,z=M*A;for(let $=0;$<d.outHeight;++$){const R=z+$*D,H=$*d.strideHeight-v;for(let K=0;K<p;++K){const Y=H+K*g;if(Y<0||Y>=d.inHeight)continue;const X=K*S[0],oe=U+Y*_;for(let ie=0;ie<d.outWidth;++ie){const Z=R+ie*O,ce=ie*d.strideWidth-y;for(let ge=0;ge<f;++ge){const _e=ce+ge*m;if(_e<0||_e>=d.inWidth)continue;const be=X+ge*S[1],Me=oe+_e*T;let Ie=be;for(let Le=0;Le<d.inChannels;++Le){const Ue=L[Me+Le*E];for(let $e=0;$e<d.outChannels;++$e)F[Z+$e*P]+=Ue*B[Ie+$e];Ie+=d.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,F)}const aCe={kernelName:Zx,backendName:"cpu",kernelFunc:mW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lCe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:h}=s;at([r,i],"conv2dBackpropFilter");const u=Dl(l),d=Qs(r.shape,h,o,1,a,c,!1,u),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:m}=d,y=d.dataFormat==="channelsLast",v=new lr(d.filterShape,"float32"),b=d.padInfo.left,x=d.padInfo.top,w=n.data.get(r.dataId).values,S=n.data.get(i.dataId).values,C=new lr(r.shape,r.dtype,w),_=new lr(i.shape,i.dtype,S);for(let T=0;T<g;++T){const E=Math.max(0,Math.ceil((x-T)/p)),A=Math.min(d.outHeight,(d.inHeight+x-T)/p);for(let D=0;D<m;++D){const O=Math.max(0,Math.ceil((b-D)/f)),P=Math.min(d.outWidth,(d.inWidth+b-D)/f);for(let L=0;L<d.inChannels;++L)for(let B=0;B<d.outChannels;++B){let F=0;for(let M=0;M<d.batchSize;++M)for(let U=E;U<A;++U){const z=T+U*p-x;for(let $=O;$<P;++$){const R=D+$*f-b;y?F+=C.get(M,z,R,L)*_.get(M,U,$,B):F+=C.get(M,L,z,R)*_.get(M,B,U,$)}}v.set(F,T,D,L,B)}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const cCe={kernelName:kT,backendName:"cpu",kernelFunc:lCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uCe(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:h}=s;at([r,i],"conv2dBackpropInput");const u=gt(i.shape),d=gt(r.shape);let p=Dl(c);const f=Qs(o,i.shape,a,1,l,h,!1,p),g=new lr(f.inShape,"float32"),m=g.values,y=n.data.get(r.dataId).values,v=n.data.get(i.dataId).values,[b,x,w]=u,{batchSize:S,filterHeight:C,filterWidth:_,inChannels:T,inHeight:E,inWidth:A,outChannels:D,outHeight:O,outWidth:P,strideHeight:L,strideWidth:B}=f;p=f.dataFormat;const F=C-1-f.padInfo.top,M=_-1-f.padInfo.left,U=p==="channelsLast",z=g.strides[0],$=U?g.strides[1]:g.strides[2],R=U?g.strides[2]:1,H=U?1:g.strides[1],K=d[0],Y=U?d[1]:d[2],X=U?d[2]:1,oe=U?1:d[1];for(let ie=0;ie<S;++ie)for(let Z=0;Z<T;++Z)for(let ce=0;ce<E;++ce){const ge=ce-F,_e=Math.max(0,Math.ceil(ge/L)),be=Math.min(O,(C+ge)/L);for(let Me=0;Me<A;++Me){const Ie=Me-M,Le=Math.max(0,Math.ceil(Ie/B)),Ue=Math.min(P,(_+Ie)/B);let $e=0;for(let Rt=_e;Rt<be;++Rt){const ct=Rt*L-ge;for(let j=Le;j<Ue;++j){const V=j*B-Ie,we=K*ie+Y*Rt+X*j,Pe=b*(C-1-ct)+x*(_-1-V)+w*Z;for(let Be=0;Be<D;++Be){const je=y[we+oe*Be],pt=v[Pe+Be];$e+=je*pt}}}const We=z*ie+$*ce+R*Me+H*Z;m[We]=$e}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}const hCe={kernelName:Jx,backendName:"cpu",kernelFunc:uCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dCe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l}=s;at([r,i],"conv3d");const c=Lc(r.shape,i.shape,o,l,a),{filterDepth:h,filterHeight:u,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:m}=c,y=m.front,v=m.left,b=m.top,x=new lr(c.outShape,r.dtype),w=n.data.get(r.dataId).values,S=n.data.get(i.dataId).values,C=x.values,_=gt(r.shape),T=gt(i.shape);for(let E=0;E<c.batchSize;++E){const A=E*_[0],D=E*x.strides[0];for(let O=0;O<c.outDepth;++O){const P=D+O*x.strides[1],L=O*c.strideDepth-y;for(let B=0;B<h;++B){const F=L+B*p;if(F<0||F>=c.inDepth)continue;const M=B*T[0],U=A+F*_[1];for(let z=0;z<c.outHeight;++z){const $=P+z*x.strides[2],R=z*c.strideHeight-b;for(let H=0;H<u;++H){const K=R+H*f;if(K<0||K>=c.inHeight)continue;const Y=M+H*T[1],X=U+K*_[2];for(let oe=0;oe<c.outWidth;++oe){const ie=$+oe*c.outChannels,Z=oe*c.strideWidth-v;for(let ce=0;ce<d;++ce){const ge=Z+ce*g;if(ge<0||ge>=c.inWidth)continue;const _e=Y+ce*T[2],be=X+ge*c.inChannels;let Me=_e;for(let Ie=0;Ie<c.inChannels;++Ie){const Le=w[be+Ie];for(let Ue=0;Ue<c.outChannels;++Ue)C[ie+Ue]+=Le*S[Me+Ue];Me+=c.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}const pCe={kernelName:eb,backendName:"cpu",kernelFunc:dCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fCe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:i}=t,{strides:o,pad:a,filterShape:l}=s;at([r,i],"conv3dBackpropFilterV2");const c=gt(r.shape),h=gt(i.shape),u=Lc(r.shape,l,o,1,a),d=u.strideDepth,p=u.strideHeight,f=u.strideWidth,g=u.filterDepth,m=u.filterHeight,y=u.filterWidth,v=new lr(u.filterShape,"float32"),b=v.values,[x,w,S,C]=v.strides,_=n.data.get(i.dataId).values,[T,E,A,D]=h,O=n.data.get(r.dataId).values,[P,L,B,F]=c,M=u.padInfo.front,U=u.padInfo.left,z=u.padInfo.top;for(let $=0;$<g;++$){const R=Math.max(0,Math.ceil((M-$)/d)),H=Math.min(u.outDepth,(u.inDepth+M-$)/d),K=$*x;for(let Y=0;Y<m;++Y){const X=Math.max(0,Math.ceil((z-Y)/p)),oe=Math.min(u.outHeight,(u.inHeight+z-Y)/p),ie=Y*w+K;for(let Z=0;Z<y;++Z){const ce=Math.max(0,Math.ceil((U-Z)/f)),ge=Math.min(u.outWidth,(u.inWidth+U-Z)/f),_e=Z*S+ie;for(let be=0;be<u.inChannels;++be){const Me=be*C+_e;for(let Ie=0;Ie<u.outChannels;++Ie){let Le=0;for(let Ue=0;Ue<u.batchSize;++Ue){const $e=Ue*P,We=Ue*T;for(let Rt=R;Rt<H;++Rt){const j=($+Rt*d-M)*L+$e,V=Rt*E+We;for(let we=X;we<oe;++we){const Be=(Y+we*p-z)*B+j,je=we*A+V;for(let pt=ce;pt<ge;++pt){const ut=(Z+pt*f-U)*F+Be,He=pt*D+je;Le+=O[ut+be]*_[He+Ie]}}}}b[Me+Ie]=Le}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const mCe={kernelName:DT,backendName:"cpu",kernelFunc:fCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gCe(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:i}=t,{pad:o,strides:a,inputShape:l}=s;at([r],"conv3dBackpropInputV2");const c=gt(r.shape),h=gt(i.shape),u=Lc(l,i.shape,a,1,o),d=new lr(u.inShape,"float32"),p=d.values,[f,g,m,y]=d.strides,v=n.data.get(r.dataId).values,[b,x,w,S]=c,C=n.data.get(i.dataId).values,[_,T,E,A]=h,{batchSize:D,filterDepth:O,filterHeight:P,filterWidth:L,inChannels:B,inDepth:F,inHeight:M,inWidth:U,outChannels:z,outDepth:$,outHeight:R,outWidth:H,strideDepth:K,strideHeight:Y,strideWidth:X}=u,oe=O-1-u.padInfo.front,ie=P-1-u.padInfo.top,Z=L-1-u.padInfo.left;for(let ce=0;ce<D;++ce)for(let ge=0;ge<B;++ge)for(let _e=0;_e<F;++_e){const be=_e-oe,Me=Math.max(0,Math.ceil(be/K)),Ie=Math.min($,(O+be)/K);for(let Le=0;Le<M;++Le){const Ue=Le-ie,$e=Math.max(0,Math.ceil(Ue/Y)),We=Math.min(R,(P+Ue)/Y);for(let Rt=0;Rt<U;++Rt){const ct=Rt-Z,j=Math.max(0,Math.ceil(ct/X)),V=Math.min(H,(L+ct)/X);let we=0;for(let Pe=Me;Pe<Ie;++Pe){const Be=Pe*K-be;for(let je=$e;je<We;++je){const pt=je*Y-Ue;for(let Te=j;Te<V;++Te){const ut=Te*X-ct,He=b*ce+x*Pe+w*je+S*Te,Xe=_*(O-1-Be)+T*(P-1-pt)+E*(L-1-ut)+A*ge;for(let te=0;te<z;++te){const Ke=v[He+te],qe=C[Xe+te];we+=Ke*qe}}}}p[f*ce+g*_e+m*Le+y*Rt+ge]=we}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}const yCe={kernelName:MT,backendName:"cpu",kernelFunc:gCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vCe=wn(og,e=>Math.cos(e)),xCe={kernelName:og,backendName:"cpu",kernelFunc:vCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bCe=wn(ag,e=>Math.cosh(e)),wCe={kernelName:ag,backendName:"cpu",kernelFunc:bCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SCe(e){const{inputs:t,backend:n,attrs:s}=e,{image:r,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=s,[h,u,d,p]=r.shape,f=i.shape[0],[g,m]=a,y=jt([f,g,m,p],"float32"),v=n.data.get(i.dataId).values,b=n.data.get(o.dataId).values,x=n.data.get(r.dataId).values,w=gt(r.shape),S=gt(y.shape);for(let C=0;C<f;C++){const _=C*4,T=v[_],E=v[_+1],A=v[_+2],D=v[_+3],O=b[C];if(O>=h)continue;const P=g>1?(A-T)*(u-1)/(g-1):0,L=m>1?(D-E)*(d-1)/(m-1):0;for(let B=0;B<g;B++){const F=g>1?T*(u-1)+B*P:.5*(T+A)*(u-1);if(F<0||F>u-1){for(let M=0;M<m;M++)for(let U=0;U<p;U++){const z=U+M*S[2]+B*S[1]+C*S[0];y.values[z]=c}continue}if(l==="bilinear"){const M=Math.floor(F),U=Math.ceil(F),z=F-M;for(let $=0;$<m;$++){const R=m>1?E*(d-1)+$*L:.5*(E+D)*(d-1);if(R<0||R>d-1){for(let X=0;X<p;X++){const oe=X+$*S[2]+B*S[1]+C*S[0];y.values[oe]=c}continue}const H=Math.floor(R),K=Math.ceil(R),Y=R-H;for(let X=0;X<p;X++){let oe=X+H*w[2]+M*w[1]+O*w[0];const ie=x[oe];oe=X+K*w[2]+M*w[1]+O*w[0];const Z=x[oe];oe=X+H*w[2]+U*w[1]+O*w[0];const ce=x[oe];oe=X+K*w[2]+U*w[1]+O*w[0];const ge=x[oe],_e=ie+(Z-ie)*Y,be=ce+(ge-ce)*Y;oe=X+$*S[2]+B*S[1]+C*S[0],y.values[oe]=_e+(be-_e)*z}}}else for(let M=0;M<m;++M){const U=m>1?E*(d-1)+M*L:.5*(E+D)*(d-1);if(U<0||U>d-1){for(let R=0;R<p;R++){const H=R+M*S[2]+B*S[1]+C*S[0];y.values[H]=c}continue}const z=Math.round(U),$=Math.round(F);for(let R=0;R<p;R++){const H=R+z*w[2]+$*w[1]+O*w[0],K=R+M*S[2]+B*S[1]+C*S[0];y.values[K]=x[H]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const _Ce={kernelName:OT,backendName:"cpu",kernelFunc:SCe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CCe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,exclusive:o,reverse:a}=s;at(r,"cumprod");const l=Yn([i],r.shape.length);let c=r;l!=null&&(c=Kr({inputs:{x:r},backend:n,attrs:{perm:l}}));const h=cs(1,r.shape.length)[0];if(h!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${h}`);const u=li(c.dtype,"int32"),d=xT(Ae(c.shape),u),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],g=a?(y,v)=>y+f-v-1:(y,v)=>y+v;for(let y=0;y<p.length;y+=f)for(let v=0;v<f;v++){const b=g(y,v);if(v===0)d[b]=o?1:p[b];else{const x=g(y,v-1);d[b]=o?p[x]*d[x]:p[b]*d[x]}}const m=n.makeTensorInfo(c.shape,u,d);if(l!=null){const y=Fc(l),v=Kr({inputs:{x:m},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(c),v}return m}const TCe={kernelName:PT,backendName:"cpu",kernelFunc:CCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ECe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,exclusive:o,reverse:a}=s;at(r,"cumsum");const l=Yn([i],r.shape.length);let c=r;l!=null&&(c=Kr({inputs:{x:r},backend:n,attrs:{perm:l}}));const h=cs(1,r.shape.length)[0];if(h!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${h}`);const u=li(c.dtype,"int32"),d=ar(Ae(c.shape),u),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],g=a?(y,v)=>y+f-v-1:(y,v)=>y+v;for(let y=0;y<p.length;y+=f)for(let v=0;v<f;v++){const b=g(y,v);if(v===0)d[b]=o?0:p[b];else{const x=g(y,v-1);d[b]=o?p[x]+d[x]:p[b]+d[x]}}const m=n.makeTensorInfo(c.shape,u,d);if(l!=null){const y=Fc(l),v=Kr({inputs:{x:m},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(c),v}return m}const ACe={kernelName:tb,backendName:"cpu",kernelFunc:ECe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ICe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:i}=t,{size:o,binaryOutput:a}=s;if(r.shape.length===1){const l=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values,h=_I(l,c,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,h)}else if(r.shape.length===2){const l=n.bufferSync(r),c=n.bufferSync(i),h=mG(l,c,o,a);return n.makeTensorInfo(h.shape,i.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const NCe={kernelName:RT,backendName:"cpu",kernelFunc:ICe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kCe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockSize:i,dataFormat:o}=s;W(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=r.shape[0],l=r.shape[1],c=r.shape[2],h=r.shape[3],u=l*i,d=c*i,p=h/(i*i),f=n.data.get(r.dataId).values,g=new Float32Array(a*u*d*p);let m=0;for(let y=0;y<a;++y)for(let v=0;v<u;++v){const b=Math.floor(v/i),x=v%i;for(let w=0;w<d;++w){const S=Math.floor(w/i),C=w%i,_=(x*i+C)*p;for(let T=0;T<p;++T){const A=T+_+h*(S+c*(b+l*y));g[m++]=f[A]}}}return n.makeTensorInfo([a,u,d,p],r.dtype,g)}const DCe={kernelName:LT,backendName:"cpu",kernelFunc:kCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gW(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=s;at([r,i],"depthwiseConv2DNative");const h=gt(r.shape),u=gt(i.shape);let d=l;d==null&&(d=[1,1]),W(cr(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const p=Qs(r.shape,i.shape,o,d,a,c,!0),{filterHeight:f,filterWidth:g,dilationHeight:m,dilationWidth:y,padInfo:v}=p,b=v.left,x=v.top,w=p.outChannels/p.inChannels,S=new lr(p.outShape,r.dtype),C=n.data.get(r.dataId).values,_=n.data.get(i.dataId).values,T=S.values;for(let E=0;E<p.batchSize;++E){const A=E*h[0],D=E*S.strides[0];for(let O=0;O<p.outHeight;++O){const P=D+O*S.strides[1],L=O*p.strideHeight-x;for(let B=0;B<f;++B){const F=L+B*m;if(F<0||F>=p.inHeight)continue;const M=B*u[0],U=A+F*h[1];for(let z=0;z<p.outWidth;++z){const $=P+z*S.strides[2],R=z*p.strideWidth-b;for(let H=0;H<g;++H){const K=R+H*y;if(K<0||K>=p.inWidth)continue;const Y=M+H*u[1],X=U+K*p.inChannels;let oe=$,ie=Y;for(let Z=0;Z<p.inChannels;++Z){const ce=C[X+Z];for(let ge=0;ge<w;++ge)T[oe+ge]+=ce*_[ie+ge];oe+=w,ie+=w}}}}}}return n.makeTensorInfo(S.shape,S.dtype,S.values)}const MCe={kernelName:nb,backendName:"cpu",kernelFunc:gW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PCe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:h}=s;at([r,i],"depthwiseConv2dNativeBackpropFilter");const u=Qs(r.shape,h,o,a,l,c,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:g}=u,m=new lr(u.filterShape,"float32"),y=u.padInfo.left,v=u.padInfo.top,b=u.outChannels/u.inChannels,x=n.data.get(r.dataId).values,w=new lr(r.shape,r.dtype,x),S=n.data.get(i.dataId).values,C=new lr(i.shape,i.dtype,S);for(let _=0;_<f;++_){const T=Math.max(0,Math.ceil((v-_)/d)),E=Math.min(u.outHeight,(u.inHeight+v-_)/d);for(let A=0;A<g;++A){const D=Math.max(0,Math.ceil((y-A)/p)),O=Math.min(u.outWidth,(u.inWidth+y-A)/p);for(let P=0;P<u.outChannels;++P){const L=Math.trunc(P/b),B=P%b;let F=0;for(let M=0;M<u.batchSize;++M)for(let U=T;U<E;++U){const z=_+U*d-v;for(let $=D;$<O;++$){const R=A+$*p-y;F+=w.get(M,z,R,L)*C.get(M,U,$,P)}}m.set(F,_,A,L,B)}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}const OCe={kernelName:FT,backendName:"cpu",kernelFunc:PCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RCe(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:h}=s;at([r,i],"depthwiseConv2DNativeBackpropInput");const u=gt(r.shape),d=gt(i.shape),p=Qs(h,i.shape,o,a,l,c,!0),f=new lr(p.inShape,"float32"),g=f.values,[m,y,v]=f.strides,b=n.data.get(r.dataId).values,[x,w,S]=u,C=n.data.get(i.dataId).values,[_,T,E]=d,{batchSize:A,filterHeight:D,filterWidth:O,inChannels:P,inHeight:L,inWidth:B,outChannels:F,outHeight:M,outWidth:U,strideHeight:z,strideWidth:$}=p,R=D-1-p.padInfo.top,H=O-1-p.padInfo.left,K=F/P;for(let Y=0;Y<A;++Y)for(let X=0;X<P;++X)for(let oe=0;oe<L;++oe){const ie=oe-R,Z=Math.max(0,Math.ceil(ie/z)),ce=Math.min(M,(D+ie)/z);for(let ge=0;ge<B;++ge){const _e=ge-H,be=Math.max(0,Math.ceil(_e/$)),Me=Math.min(U,(O+_e)/$);let Ie=0;for(let Le=Z;Le<ce;++Le){const Ue=Le*z-ie;for(let $e=be;$e<Me;++$e){const We=$e*$-_e,Rt=x*Y+w*Le+S*$e,ct=_*(D-1-Ue)+T*(O-1-We)+E*X;for(let j=0;j<K;++j){const V=X*K+j,we=b[Rt+V],Pe=C[ct+j];Ie+=we*Pe}}}g[m*Y+y*oe+v*ge+X]=Ie}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}const LCe={kernelName:$T,backendName:"cpu",kernelFunc:RCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FCe(e){const{inputs:t,backend:n}=e,{x:s}=t,r=Ae(s.shape),i=n.data.get(s.dataId).values,o=jt([r,r],s.dtype),a=o.values;for(let c=0;c<i.length;c++)a[c*r+c]=i[c];const l=[...s.shape,...s.shape];return n.makeTensorInfo(l,o.dtype,o.values)}const $Ce={kernelName:O$,backendName:"cpu",kernelFunc:FCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BCe={kernelName:sb,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:r}=e,{strides:i,pad:o,dilations:a}=n,l=t,c=l.data.get(s.dataId).values,h=s.shape.length,u=l.data.get(r.dataId).values,d=r.shape.length,{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:y,outWidth:v,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:S,filterWidth:C,dilationHeight:_,dilationWidth:T,outShape:E}=Kg(s.shape,r.shape,i,o,"NHWC",a),A=Ae(E),D=E.length,O=gs(s.dtype,A);for(let L=0;L<p;++L)for(let B=0;B<y;++B){const F=B*x-b.top;for(let M=0;M<v;++M){const U=M*w-b.left;for(let z=0;z<m;++z){let $=Number.MIN_SAFE_INTEGER;for(let H=0;H<S;++H){const K=F+H*_;if(K>=0&&K<f)for(let Y=0;Y<C;++Y){const X=U+Y*T;if(X>=0&&X<g){const oe=Va([L,K,X,z],h,gt(s.shape)),ie=Va([H,Y,z],d,gt(r.shape)),Z=c[oe]+u[ie];Z>$&&($=Z)}}}const R=Va([L,B,M,z],D,gt(E));O[R]=$}}}return{dataId:l.write(sh(O,s.dtype),E,s.dtype),shape:E,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zCe={kernelName:zT,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:r,dy:i}=e,{strides:o,pad:a,dilations:l}=n,c=t,h=Go(s.shape,c.data.get(s.dataId).values),u=Go(r.shape,c.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:g,outHeight:m,outWidth:y,padInfo:v,strideHeight:b,strideWidth:x,filterHeight:w,filterWidth:S,dilationHeight:C,dilationWidth:_,outShape:T}=Kg(s.shape,r.shape,o,a,"NHWC",l);W(i.rank===T.length,()=>`Error in ${zT}, dy must have the same rank as output ${T.length}, but got ${i.rank}`);const E=Go(T,c.data.get(i.dataId).values),A=N$(r.shape,r.dtype);for(let O=0;O<d;++O)for(let P=0;P<m;++P){const L=P*b-v.top;for(let B=0;B<y;++B){const F=B*x-v.left;for(let M=0;M<g;++M){let U=Number.MIN_SAFE_INTEGER,z=0,$=0;for(let R=0;R<w;++R){const H=L+R*C;if(H>=0&&H<p)for(let K=0;K<S;++K){const Y=F+K*_;if(Y>=0&&Y<f){const X=h[O][H][Y][M]+u[R][K][M];X>U&&(U=X,z=R,$=K)}}}A[z][$][M]+=E[O][P][B][M]}}}return{dataId:c.write(sh(A,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UCe={kernelName:BT,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:r,dy:i}=e,{strides:o,pad:a,dilations:l}=n,c=t,h=Go(s.shape,c.data.get(s.dataId).values),u=Go(r.shape,c.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:g,outHeight:m,outWidth:y,padInfo:v,strideHeight:b,strideWidth:x,filterHeight:w,filterWidth:S,dilationHeight:C,dilationWidth:_,outShape:T}=Kg(s.shape,r.shape,o,a,"NHWC",l);W(i.rank===T.length,()=>`Error in ${BT}, dy must have the same rank as output ${T.length}, but got ${i.rank}`);const E=Go(T,c.data.get(i.dataId).values),A=N$(s.shape,s.dtype);for(let O=0;O<d;++O)for(let P=0;P<m;++P){const L=P*b-v.top;for(let B=0;B<y;++B){const F=B*x-v.left;for(let M=0;M<g;++M){let U=Number.MIN_SAFE_INTEGER,z=L<0?0:L,$=F<0?0:F;for(let R=0;R<w;++R){const H=L+R*C;if(H>=0&&H<p)for(let K=0;K<S;++K){const Y=F+K*_;if(Y>=0&&Y<f){const X=h[O][H][Y][M]+u[R][K][M];X>U&&(U=X,z=H,$=Y)}}}A[O][z][$][M]+=E[O][P][B][M]}}}return{dataId:c.write(sh(A,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C0(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:o}=s;at(r,"sum");let a;r.dtype==="bool"?a=Kc({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):a=tl({inputs:{x:r},backend:n});const l=a.shape.length,c=Ht(i,a.shape),h=Yn(c,l);let u=c,d=a;h!=null&&(d=Kr({inputs:{x:a},backend:n,attrs:{perm:h}}),u=cs(u.length,l)),Zs("sum",u,d.shape.length);const[p,f]=$s(d.shape,u),g=li(d.dtype,"int32");let m=$1(n,p,g);const y=Ae(f),v=n.data.get(m.dataId).values,b=n.data.get(d.dataId).values;for(let x=0;x<v.length;++x){const w=x*y;let S=0;for(let C=0;C<y;++C)S+=b[w+C];v[x]=S}if(o){const x=vs(m.shape,c),w=m;m=Dn({inputs:{x:m},backend:n,attrs:{shape:x}}),n.disposeIntermediateTensorInfo(w)}return n.disposeIntermediateTensorInfo(a),h!=null&&n.disposeIntermediateTensorInfo(d),m}const VCe={kernelName:Lb,backendName:"cpu",kernelFunc:C0};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GCe(e){const{inputs:t,backend:n,attrs:s}=e,{equation:r}=s,i=t,{allDims:o,summedDims:a,idDims:l}=kA(r,i.length);MA(o.length,l,i);const{path:c,steps:h}=PA(a,l),u=h.length;let d=null,p=o.length;const f=[];for(let g=0;g<u;++g){for(const m of h[g]){const{permutationIndices:y,expandDims:v}=DA(p,l[m]);let b;OA(y)?b=i[m]:(b=Kr({inputs:{x:i[m]},backend:n,attrs:{perm:y}}),f.push(b));const x=b.shape.slice();for(let w=0;w<v.length;++w)x.splice(v[w],0,1);dn(b.shape,x)||(b=Dn({inputs:{x:b},backend:n,attrs:{shape:x}}),f.push(b)),d===null?d=b:(d=B1({inputs:{a:b,b:d},backend:n}),f.push(d))}g<u-1&&(c[g]>=0&&(d=C0({inputs:{x:d},backend:n,attrs:{axis:c[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}const WCe={kernelName:R$,backendName:"cpu",kernelFunc:GCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HCe(e){const{inputs:t,backend:n}=e,{dy:s,y:r}=t;at([s,r],"eluGrad");const i=new Float32Array(Ae(r.shape)),o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];c>=1?i[l]=a[l]:i[l]=a[l]*(c+1)}return n.makeTensorInfo(r.shape,"float32",i)}const jCe={kernelName:UT,backendName:"cpu",kernelFunc:HCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qCe=SA,XCe=_A,KCe=CA,YCe=TA,QCe=EA,ZCe=AA,JCe=wn(ug,e=>{const t=Math.sign(e),n=Math.abs(e),s=1/(1+qCe*n);return t*(1-((((ZCe*s+QCe)*s+YCe)*s+KCe)*s+XCe)*s*Math.exp(-n*n))}),eTe={kernelName:ug,backendName:"cpu",kernelFunc:JCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V1(e){const{inputs:t,backend:n,attrs:s}=e,{input:r}=t,{dim:i}=s,o=r.shape.length,a=r.shape.slice();let l=i;return i<0&&(W(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),Dn({inputs:{x:r},backend:n,attrs:{shape:a}})}const tTe={kernelName:ib,backendName:"cpu",kernelFunc:V1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nTe=ws((e,t)=>e/t),NI=Us(lg,nTe),kI={kernelName:lg,backendName:"cpu",kernelFunc:NI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yW(e,t,n){const s=e.shape,r=s[0],i=s[1],o=n.data.get(e.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[r,i],h=Ae(c),u=Ys("float32",h),d=Ys("float32",h);for(let m=0;m<r;m++){const y=Nh({inputs:{x:a},backend:n,attrs:{begin:[m,0],size:[1,i]}}),v=Nh({inputs:{x:l},backend:n,attrs:{begin:[m,0],size:[1,i]}}),b=di({inputs:{real:y,imag:v},backend:n}),{real:x,imag:w}=sTe(b,t,n),S=Ol(x,w);for(let C=0;C<i;C++){const _=IA(S,C);u[m*i+C]=_.real,d[m*i+C]=_.imag}n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(b)}const p=n.makeTensorInfo(c,"float32",u),f=n.makeTensorInfo(c,"float32",d),g=di({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}function sTe(e,t,n){const s=Ae(e.shape),r=n.data.get(e.dataId),i=n.data.get(r.complexTensorInfos.real.dataId).values,o=n.data.get(r.complexTensorInfos.imag.dataId).values;if(rTe(s)){const a=DI(i,o,s,t,n),l=[e.shape[0],e.shape[1]];if(t){const c=n.makeTensorInfo(l,"float32",a.real),h=n.makeTensorInfo(l,"float32",a.imag),u=n.makeTensorInfo([],"float32",Mc(s,"float32")),d=tl({inputs:{x:u},backend:n}),p=kI.kernelFunc({inputs:{a:c,b:u},backend:n}),f=kI.kernelFunc({inputs:{a:h,b:d},backend:n}),g=n.data.get(p.dataId).values,m=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),{real:g,imag:m}}return a}else{const a=Ol(i,o),l=iTe(a,s,t);return n4(l)}}function rTe(e){return(e&e-1)==0}function DI(e,t,n,s,r){if(n===1)return{real:e,imag:t};const i=Ol(e,t),o=n/2,a=s4(i),l=a.real,c=a.imag,h=[l.length],u=r.makeTensorInfo(h,"float32",l),d=r.makeTensorInfo(h,"float32",c),p=di({inputs:{real:u,imag:d},backend:r}),f=r4(i),g=f.real,m=f.imag,y=[g.length],v=r.makeTensorInfo(y,"float32",g),b=r.makeTensorInfo(y,"float32",m),x=di({inputs:{real:v,imag:b},backend:r}),w=DI(l,c,o,s,r),S=w.real,C=w.imag,_=[S.length],T=r.makeTensorInfo(_,"float32",S),E=r.makeTensorInfo(_,"float32",C),A=di({inputs:{real:T,imag:E},backend:r}),D=DI(g,m,o,s,r),O=D.real,P=D.imag,L=[O.length],B=r.makeTensorInfo(L,"float32",O),F=r.makeTensorInfo(L,"float32",P),M=di({inputs:{real:B,imag:F},backend:r}),U=o4(n,s),z=[U.real.length],$=r.makeTensorInfo(z,"float32",U.real),R=r.makeTensorInfo(z,"float32",U.imag),H=di({inputs:{real:$,imag:R},backend:r}),K=B1({inputs:{a:H,b:M},backend:r}),Y=Gp({inputs:{a:A,b:K},backend:r}),X=AI({inputs:{a:A,b:K},backend:r}),oe=Ih({inputs:{input:Y},backend:r}),ie=Ih({inputs:{input:X},backend:r}),Z=jp({inputs:{input:Y},backend:r}),ce=jp({inputs:{input:X},backend:r}),ge=qp({inputs:[oe,ie],backend:r,attrs:{axis:0}}),_e=qp({inputs:[Z,ce],backend:r,attrs:{axis:0}}),be=r.data.get(ge.dataId).values,Me=r.data.get(_e.dataId).values;return r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(M),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(R),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(Y),r.disposeIntermediateTensorInfo(X),r.disposeIntermediateTensorInfo(oe),r.disposeIntermediateTensorInfo(Z),r.disposeIntermediateTensorInfo(ie),r.disposeIntermediateTensorInfo(ce),r.disposeIntermediateTensorInfo(ge),r.disposeIntermediateTensorInfo(_e),{real:be,imag:Me}}function iTe(e,t,n){const s=new Float32Array(t*2);for(let r=0;r<t;r++){let i=0,o=0;for(let a=0;a<t;a++){const l=a4(r*a,t,n),c=IA(e,a);i+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}n&&(i/=t,o/=t),i4(s,i,o,r)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oTe(e){const{inputs:t,backend:n}=e,{input:s}=t,r=Ae(s.shape),i=s.shape[s.shape.length-1],o=r/i,a=Dn({inputs:{x:s},backend:n,attrs:{shape:[o,i]}}),l=yW(a,!1,n),c=Dn({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),c}const aTe={kernelName:VT,backendName:"cpu",kernelFunc:oTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MI(e){const{backend:t,attrs:n}=e,{shape:s,value:r,dtype:i}=n,o=i||Km(r),a=gs(o,Ae(s));return cTe(a,r,o),t.makeTensorInfo(s,o,a)}const lTe={kernelName:GT,backendName:"cpu",kernelFunc:MI};function cTe(e,t,n){e.fill(t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uTe={kernelName:WT,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:s}=e,r=n,i=Ys(s.dtype,Ae(s.shape)),[o,a,l,c]=s.shape,h=r.data.get(s.dataId).values;for(let d=0;d<o;d++){const p=d*l*a*c;for(let f=0;f<a;f++){const g=f*(l*c);for(let m=0;m<l;m++){const y=m*c;for(let v=0;v<c;v++){const b=Math.round(l-m-1),x=p+g+y+v;let w=h[x];if(b>=0&&b<l){const S=b*c,C=p+g+S+v;w=h[C]}i[x]=w}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hTe=ws((e,t)=>Math.floor(e/t)),dTe=Us(fg,hTe,null,"int32"),pTe={kernelName:fg,backendName:"cpu",kernelFunc:dTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fTe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:h,dilations:u,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let g=mW({inputs:{x:r,filter:i},backend:n,attrs:{strides:l,pad:c,dataFormat:h,dilations:u,dimRoundingMode:d}});if(o){const m=g;if(h==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const y=Dn({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});g=Gp({inputs:{a:g,b:y},backend:n}),n.disposeIntermediateTensorInfo(y)}else g=Gp({inputs:{a:g,b:o},backend:n});n.disposeIntermediateTensorInfo(m)}if(p){const m=g;if(h==="NCHW"&&p==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const y=Dn({inputs:{x:a},backend:n,attrs:{shape:[a.shape[0],1,1]}});g=U1(n,g,p,y,f),n.disposeIntermediateTensorInfo(y)}else g=U1(n,g,p,a,f);n.disposeIntermediateTensorInfo(m)}return g}const mTe={kernelName:Wb,backendName:"cpu",kernelFunc:fTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gTe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:h,dilations:u,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let g=gW({inputs:{x:r,filter:i},backend:n,attrs:{strides:l,pad:c,dataFormat:h,dilations:u,dimRoundingMode:d}});if(o){const m=g;g=Gp({inputs:{a:g,b:o},backend:n}),n.disposeIntermediateTensorInfo(m)}if(p){const m=g;g=U1(n,g,p,a,f),n.disposeIntermediateTensorInfo(m)}return g}const yTe={kernelName:J$,backendName:"cpu",kernelFunc:gTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vTe(e){const{inputs:t,backend:n}=e,{params:s,indices:r}=t,i=Ae(s.shape),o=r.shape,a=o[o.length-1],[l,c,h,u]=uA(s,r);if(c===0)return n.makeTensorInfo(l,s.dtype,[]);const d=n.data.get(r.dataId).values,p=n.bufferSync(s),f=CG(d,p,s.dtype,c,a,h,u,s.shape,i);return n.makeTensorInfo(l,s.dtype,f.values)}const xTe={kernelName:L$,backendName:"cpu",kernelFunc:vTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bTe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,indices:i}=t,{axis:o,batchDims:a}=s;at([r,i],"gatherV2");const l=Ht(o,r.shape)[0],c=n.data.get(i.dataId).values,h=r.shape[l];for(let x=0;x<c.length;++x){const w=c[x];W(w<=h-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${h-1}]`)}let u=a;a==null&&(u=0);const d=Ae(i.shape),p=FA(r,i,l,u),f=Dn({inputs:{x:r},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=Dn({inputs:{x:i},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),m=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],y=n.bufferSync(g),v=n.bufferSync(f),b=TG(v,y,m);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}const wTe={kernelName:ab,backendName:"cpu",kernelFunc:bTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function STe(e){const{inputs:t,backend:n}=e,{input:s}=t,r=Ae(s.shape),i=s.shape[s.shape.length-1],o=r/i,a=Dn({inputs:{x:s},backend:n,attrs:{shape:[o,i]}}),l=yW(a,!0,n),c=Dn({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),c}const _Te={kernelName:HT,backendName:"cpu",kernelFunc:STe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CTe=wn(yg,e=>Number.isFinite(e)?1:0,"bool"),TTe={kernelName:yg,backendName:"cpu",kernelFunc:CTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ETe=wn(vg,e=>Math.abs(e)===1/0?1:0,"bool"),ATe={kernelName:vg,backendName:"cpu",kernelFunc:ETe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ITe=wn(xg,e=>Number.isNaN(e)?1:0,"bool"),NTe={kernelName:xg,backendName:"cpu",kernelFunc:ITe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kTe(e){const{backend:t,attrs:n}=e,{start:s,stop:r,num:i}=n,o=kG(s,r,i);return t.makeTensorInfo([o.length],"float32",o)}const DTe={kernelName:F$,backendName:"cpu",kernelFunc:kTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MTe=wn(wg,e=>Math.log1p(e)),PTe={kernelName:wg,backendName:"cpu",kernelFunc:MTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OTe=ws((e,t)=>e&&t),RTe=Us(db,OTe,null,"bool"),LTe={kernelName:db,backendName:"cpu",kernelFunc:RTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FTe=wn(pb,e=>e?0:1,"bool"),$Te={kernelName:pb,backendName:"cpu",kernelFunc:FTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BTe=ws((e,t)=>e||t),zTe=Us(fb,BTe,null,"bool"),UTe={kernelName:fb,backendName:"cpu",kernelFunc:zTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VTe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=s;at(r,"LRN");const c=r.shape[3],h=c-1,u=n.data.get(r.dataId).values,d=Ae(r.shape),p=new Float32Array(d);function f(g){const m=g%c;let y=g-m+Math.max(0,m-i);const v=g-m+Math.min(m+i,h);let b=0;for(;y<=v;y++){const x=u[y];b+=x*x}return b}for(let g=0;g<d;g++){const m=f(g),y=u[g]*Math.pow(o+a*m,-l);p[g]=y}return n.makeTensorInfo(r.shape,r.dtype,p)}const GTe={kernelName:mb,backendName:"cpu",kernelFunc:VTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WTe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:h}=s;at(o,"LRNGrad");const u=Ae(o.shape),d=o.shape[3],p=n.data.get(o.dataId).values,f=n.data.get(r.dataId).values,g=n.data.get(i.dataId).values,m=new Float32Array(u),y=u;for(let v=0;v<y;v++){const b=v%d,x=v-b+Math.max(0,b-a),w=v-b+Math.min(d,b+a+1);let S=0;for(let C=x;C<w;C++)S+=Math.pow(f[C],2);S=c*S+l;for(let C=x;C<w;C++){let _=-2*c*h*f[C]*g[v]/S;v===C&&(_+=Math.pow(S,-h)),_*=p[v],m[C]+=_}}return n.makeTensorInfo(o.shape,r.dtype,m)}const HTe={kernelName:qT,backendName:"cpu",kernelFunc:WTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vW(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reductionIndices:i,keepDims:o}=s,a=n;let l=r.shape;const c=l.length,h=Ht(i,l);let u=h;const d=Yn(u,c);let p=a.data.get(r.dataId).values;if(d!=null){const x=new Array(c);for(let w=0;w<x.length;w++)x[w]=l[d[w]];p=TI(p,l,r.dtype,d,x),u=cs(u.length,c),l=x}at(r,"max"),Zs("max",u,c);const[f,g]=$s(l,u),m=Ae(g),y=MG(p,m,f,r.dtype),v=a.write(y,f,r.dtype);let b=f;return o&&(b=vs(f,h)),{dataId:v,shape:b,dtype:r.dtype}}const jTe={kernelName:gb,backendName:"cpu",kernelFunc:vW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qTe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;at(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=1;W(cr(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=uo(r.shape,i,o,c,a,l);let u;if(h.filterWidth===1&&h.filterHeight===1&&dn(h.inShape,h.outShape))u=tl({inputs:{x:r},backend:n});else{const d=n.data.get(r.dataId).values,p=gt(r.shape),f=II(d,r.shape,r.dtype,p,h,"max");u=n.makeTensorInfo(h.outShape,r.dtype,f.values)}return u}const XTe={kernelName:yb,backendName:"cpu",kernelFunc:qTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KTe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s;at(r,"maxPool3d");const h=kl(r.shape,i,o,1,a,l,c),u=n.data.get(r.dataId).values,d=fW(u,r.shape,r.dtype,gt(r.shape),h,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}const YTe={kernelName:vb,backendName:"cpu",kernelFunc:KTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QTe(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=s;at([r,i],"maxPool3DGrad");const h=kl(i.shape,o,a,1,l,c),u=n.bufferSync(i),d=$2e(u,h),p=h.strideDepth,f=h.strideHeight,g=h.strideWidth,m=h.dilationDepth,y=h.dilationHeight,v=h.dilationWidth,b=h.effectiveFilterDepth,x=h.effectiveFilterHeight,w=h.effectiveFilterWidth,S=b-1-h.padInfo.front,C=w-1-h.padInfo.left,_=x-1-h.padInfo.top,T=jt(i.shape,"float32"),E=n.bufferSync(r);for(let A=0;A<h.batchSize;++A)for(let D=0;D<h.inChannels;++D)for(let O=0;O<h.inDepth;++O)for(let P=0;P<h.inHeight;++P)for(let L=0;L<h.inWidth;++L){const B=O-S,F=P-_,M=L-C;let U=0;for(let z=0;z<b;z+=m){const $=(B+z)/p;if(!($<0||$>=h.outDepth||Math.floor($)!==$))for(let R=0;R<x;R+=y){const H=(F+R)/f;if(!(H<0||H>=h.outHeight||Math.floor(H)!==H))for(let K=0;K<w;K+=v){const Y=(M+K)/g;if(Y<0||Y>=h.outWidth||Math.floor(Y)!==Y)continue;const X=b*x*w-1-d.get(A,$,H,Y,D),oe=z*x*w+R*w+K,ie=X===oe?1:0;if(ie===0)continue;U+=E.get(A,$,H,Y,D)*ie}}}T.set(U,A,O,P,L,D)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}const ZTe={kernelName:KT,backendName:"cpu",kernelFunc:QTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JTe(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i,output:o}=t,a=i;at([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:h,dimRoundingMode:u}=s,d=uo(a.shape,l,c,1,h,u),p=n.data.get(a.dataId).values,f=jt(d.outShape,a.dtype,pW(p,a.shape,a.dtype,d).values),g=d.strideHeight,m=d.strideWidth,y=d.dilationHeight,v=d.dilationWidth,b=d.effectiveFilterHeight,x=d.effectiveFilterWidth,w=x-1-d.padInfo.left,S=b-1-d.padInfo.top,C=jt(a.shape,"float32"),_=n.data.get(r.dataId).values,T=jt(r.shape,"float32",_);for(let E=0;E<d.batchSize;++E)for(let A=0;A<d.inChannels;++A)for(let D=0;D<d.inHeight;++D)for(let O=0;O<d.inWidth;++O){const P=D-S,L=O-w;let B=0;for(let F=0;F<b;F+=y){const M=(P+F)/g;if(!(M<0||M>=d.outHeight||Math.floor(M)!==M))for(let U=0;U<x;U+=v){const z=(L+U)/m;if(z<0||z>=d.outWidth||Math.floor(z)!==z)continue;const $=b*x-1-f.get(E,M,z,A),R=F*x+U,H=$===R?1:0;if(H===0)continue;B+=T.get(E,M,z,A)*H}}C.set(B,E,D,O,A)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}const eEe={kernelName:XT,backendName:"cpu",kernelFunc:JTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tEe(e,t,n,s,r){const i=gt(t),o=II(e,t,n,i,r,"max"),a=pW(e,t,n,r,!0,s);return[o.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nEe={kernelName:$$,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:s}=e,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=t,l=n;at(s,"MaxPoolWithArgmax");const c=l.data.get(s.dataId).values,h=uo(s.shape,r,i,[1,1],o),[u,d]=tEe(c,s.shape,s.dtype,a,h),p=l.write(u,h.outShape,s.dtype),f=l.write(d,h.outShape,s.dtype);return[{dataId:p,shape:h.outShape,dtype:s.dtype},{dataId:f,shape:h.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sEe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:o}=s,a=Ht(i,r.shape),c=$s(r.shape,a)[1],h=Ae(c),u=[],d=n.makeTensorInfo([],"float32",new Float32Array([h]));u.push(d);const p=Kc({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});u.push(p);const f=NI({inputs:{a:p,b:d},backend:n});u.push(f);const g=C0({inputs:{x:f},backend:n,attrs:{axis:i,keepDims:o}});return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),g}const rEe={kernelName:xb,backendName:"cpu",kernelFunc:sEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iEe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:o}=s;at(r,"min");const a=Ht(i,r.shape);let l=a;const c=Yn(l,r.shape.length);let h=r;c!=null&&(h=Kr({inputs:{x:r},backend:n,attrs:{perm:c}}),l=cs(l.length,r.shape.length)),Zs("min",l,h.shape.length);const[u,d]=$s(h.shape,l),p=Ae(d),f=ar(Ae(u),h.dtype),g=n.data.get(h.dataId).values;for(let y=0;y<f.length;++y){const v=y*p;let b=g[v];for(let x=0;x<p;++x){const w=g[v+x];(Number.isNaN(w)||w<b)&&(b=w)}f[y]=b}c!=null&&n.disposeIntermediateTensorInfo(h);const m=n.makeTensorInfo(u,h.dtype,f);if(o){const y=vs(u,a),v=Dn({inputs:{x:m},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(m),v}return m}const oEe={kernelName:bb,backendName:"cpu",kernelFunc:iEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aEe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:i,mode:o}=s;at(r,"mirrorPad");const a=i.map((b,x)=>b[0]+r.shape[x]+b[1]),l=i.map(b=>b[0]),c=i.map((b,x)=>b[0]+r.shape[x]),h=o==="reflect"?0:1,u=n.data.get(r.dataId).values,d=r.shape.length,p=gt(r.shape),f=Ae(a),g=a.length,m=gt(a),y=Ys(r.dtype,f);for(let b=0;b<f;b++){let x=xp(b,g,m);for(let S=0;S<g;S++)x[S]<l[S]?x[S]=l[S]*2-x[S]-h:x[S]>=c[S]&&(x[S]=(c[S]-1)*2-x[S]+h);x=x.map((S,C)=>S-l[C]);const w=Va(x,d,p);y[b]=u[w]}return{dataId:n.write(y,a,r.dtype),shape:a,dtype:r.dtype}}const lEe={kernelName:wb,backendName:"cpu",kernelFunc:aEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cEe=ws((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),uEe=Us(Cg,cEe),hEe={kernelName:Cg,backendName:"cpu",kernelFunc:uEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xW(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{dim:i}=s,o=r.shape.length;let a=i;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=Ht([a],r.shape),c=vW({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),h=vs(c.shape,l),u=Dn({inputs:{x:c},backend:n,attrs:{shape:h}}),d=AI({inputs:{a:r,b:u},backend:n}),p=wG({inputs:{x:d},backend:n}),f=C0({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),g=Dn({inputs:{x:f},backend:n,attrs:{shape:h}}),m=NI({inputs:{a:p,b:g},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}const dEe={kernelName:Bb,backendName:"cpu",kernelFunc:xW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pEe(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{numSamples:i,seed:o,normalized:a}=s;at(r,"multinomial");const l=a?r:xW({inputs:{logits:r},backend:n,attrs:{dim:-1}}),c=l.shape[0],h=l.shape[1],u=n.data.get(l.dataId).values,d=[c,i],p=ar(Ae(d),"int32");for(let f=0;f<c;++f){const g=f*h,m=new Float32Array(h-1);m[0]=u[g];for(let b=1;b<m.length;++b)m[b]=m[b-1]+u[g+b];const y=Op.alea(o.toString()),v=f*i;for(let b=0;b<i;++b){const x=y();p[v+b]=m.length;for(let w=0;w<m.length;w++)if(x<m[w]){p[v+b]=w;break}}}return a||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}const fEe={kernelName:B$,backendName:"cpu",kernelFunc:pEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mEe=rA;function gEe(e){const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s;at(r,"NonMaxSuppression");const c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,{selectedIndices:u}=mEe(c,h,o,a,l);return n.makeTensorInfo([u.length],"int32",new Int32Array(u))}const yEe={kernelName:YT,backendName:"cpu",kernelFunc:gEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vEe=iA;function xEe(e){const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=s;at(r,"NonMaxSuppressionPadded");const h=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,{selectedIndices:d,validOutputs:p}=vEe(h,u,o,a,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}const bEe={kernelName:QT,backendName:"cpu",kernelFunc:xEe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wEe=oA;function SEe(e){const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s;at(r,"NonMaxSuppressionWithScore");const h=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,d=o,p=a,f=l,g=c,{selectedIndices:m,selectedScores:y}=wEe(h,u,d,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const _Ee={kernelName:ZT,backendName:"cpu",kernelFunc:SEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CEe(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r}=t,{dtype:i,depth:o,onValue:a,offValue:l}=s;at(r,"oneHot");const c=Ae(r.shape),h=new Float32Array(c*o);h.fill(l);const u=n.data.get(r.dataId).values;for(let d=0;d<c;++d)u[d]>=0&&u[d]<o&&(h[d*o+u[d]]=a);return n.makeTensorInfo([...r.shape,o],i,h)}const TEe={kernelName:Tb,backendName:"cpu",kernelFunc:CEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G1(e){const{inputs:t,backend:n}=e,{x:s}=t;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=Ih({inputs:{input:s},backend:n}),i=G1({inputs:{x:r},backend:n}),o=jp({inputs:{input:s},backend:n}),a=G1({inputs:{x:o},backend:n}),l=di({inputs:{real:i,imag:a},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}else return MI({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const EEe={kernelName:Vb,backendName:"cpu",kernelFunc:G1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bW(e){const{inputs:t,backend:n}=e,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=Ih({inputs:{input:s},backend:n}),i=bW({inputs:{x:r},backend:n}),o=jp({inputs:{input:s},backend:n}),a=G1({inputs:{x:o},backend:n}),l=di({inputs:{real:i,imag:a},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}else return MI({backend:n,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const AEe={kernelName:Cb,backendName:"cpu",kernelFunc:bW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wW(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s;if(t.length===1)return V1({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const i=t[0].shape,o=t[0].dtype;t.forEach(h=>{fT(i,h.shape,"All tensors passed to stack must have matching shapes"),W(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=t.map(h=>{const u=V1({inputs:{input:h},backend:n,attrs:{dim:r}});return a.push(u),u}),c=qp({inputs:l,backend:n,attrs:{axis:r}});return a.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}const IEe={kernelName:Eb,backendName:"cpu",kernelFunc:wW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NEe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:i,constantValue:o}=s;at(r,"pad");const a=i.map((v,b)=>v[0]+r.shape[b]+v[1]),l=i.map(v=>v[0]),c=n.data.get(r.dataId).values,h=Ae(r.shape),u=r.shape.length,d=gt(r.shape),p=Ae(a),f=a.length,g=gt(a),m=Ys(r.dtype,p);o!==0&&m.fill(o);for(let v=0;v<h;v++){const x=xp(v,u,d).map((S,C)=>S+l[C]),w=Va(x,f,g);m[w]=c[v]}return{dataId:n.write(m,a,r.dtype),shape:a,dtype:r.dtype}}const SW={kernelName:Ab,backendName:"cpu",kernelFunc:NEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kEe=ws((e,t)=>Math.pow(e,t)),DEe=Us(Eg,kEe),MEe={kernelName:Eg,backendName:"cpu",kernelFunc:DEe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PEe(e){const{inputs:t,backend:n,attrs:s}=e,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=t,a=r.map(m=>n.data.get(m.dataId).values),l=r.map(m=>m.shape),c=n.data.get(i.dataId).values,h=n.data.get(o.dataId).values,[u,d,p]=BG(a,l,c,i.shape,i.dtype,h,o.shape),f=u.map(m=>n.makeTensorInfo([m.length],"int32",m)),g=n.makeTensorInfo(p,i.dtype,d);return f.concat([g])}const OEe={kernelName:z$,backendName:"cpu",kernelFunc:PEe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function REe(e){const{inputs:t,backend:n}=e,{starts:s,limits:r,deltas:i}=t,o=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,[c,h]=UG(o,s.shape,s.dtype,a,r.shape,l,i.shape),u=n.makeTensorInfo([c.length],"int32",c),d=n.makeTensorInfo([h.length],s.dtype,h);return[u,d]}const LEe={kernelName:U$,backendName:"cpu",kernelFunc:REe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FEe(e){const{inputs:t,backend:n,attrs:s}=e,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=s,c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,u=n.data.get(o.dataId).values,d=a.map(m=>n.data.get(m.dataId).values),p=a.map(m=>m.shape),[f,g]=WG(c,r.shape,h,i.shape,i.dtype,u,o.shape,d,p,l);return n.makeTensorInfo(f,i.dtype,g)}const $Ee={kernelName:V$,backendName:"cpu",kernelFunc:FEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BEe(e){const{backend:t,attrs:n}=e,{start:s,stop:r,dtype:i,step:o}=n,a=HG(s,r,o,i);return t.makeTensorInfo([a.length],i,a)}const zEe={kernelName:JT,backendName:"cpu",kernelFunc:BEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UEe=wn(Ag,e=>1/e),VEe={kernelName:Ag,backendName:"cpu",kernelFunc:UEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GEe(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=s;at(r,"resizeBilinear");const l=gt(r.shape),[c,h]=a,[u,d,p,f]=r.shape,g=n.data.get(r.dataId).values,m=new Float32Array(Ae([u,c,h,f])),y=[i&&c>1?d-1:d,i&&h>1?p-1:p],v=[i&&c>1?c-1:c,i&&h>1?h-1:h];let b=0;const x=y[0]/v[0],w=y[1]/v[1];for(let S=0;S<u;S++)for(let C=0;C<c;C++){let _;o?_=x*(C+.5)-.5:_=x*C;const T=Math.max(0,Math.floor(_)),E=_-T,A=Math.min(d-1,Math.ceil(_)),D=S*l[0]+T*l[1],O=S*l[0]+A*l[1];for(let P=0;P<h;P++){let L;o?L=w*(P+.5)-.5:L=w*P;const B=Math.max(0,Math.floor(L)),F=L-B,M=Math.min(p-1,Math.ceil(L)),U=D+B*l[2],z=O+B*l[2],$=D+M*l[2],R=O+M*l[2];for(let H=0;H<f;H++){const K=g[U+H],Y=g[z+H],X=g[$+H],oe=g[R+H],ie=K+(X-K)*F,Z=Y+(oe-Y)*F,ce=ie+(Z-ie)*E;m[b++]=ce}}}return n.makeTensorInfo([u,c,h,f],"float32",m)}const WEe={kernelName:Mb,backendName:"cpu",kernelFunc:GEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HEe(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:i}=t,{alignCorners:o}=s;at([i,r],"resizeBilinearGrad");const a=gt(r.shape),[l,c,h,u]=r.shape,[,d,p]=i.shape,f=new Float32Array(l*c*h*u),g=[o&&d>1?c-1:c,o&&p>1?h-1:h],m=[o&&d>1?d-1:d,o&&p>1?p-1:p],y=g[0]/m[0],v=g[1]/m[1],b=n.data.get(i.dataId).values;let x=0;for(let w=0;w<l;w++){const S=w*a[0];for(let C=0;C<d;C++){const _=C*y,T=Math.floor(_),E=Math.min(Math.ceil(_),c-1),A=S+T*a[1],D=S+E*a[1],O=_-T,P=1-O;for(let L=0;L<p;L++){const B=L*v,F=Math.floor(B),M=Math.min(Math.ceil(B),h-1),U=B-F,z=1-U,$=A+F*a[2],R=A+M*a[2],H=D+F*a[2],K=D+M*a[2],Y=P*z,X=P*U,oe=O*z,ie=O*U;for(let Z=0;Z<u;Z++){const ce=b[x++];f[$+Z]+=ce*Y,f[R+Z]+=ce*X,f[H+Z]+=ce*oe,f[K+Z]+=ce*ie}}}}return n.makeTensorInfo([l,h,c,u],"float32",f)}const jEe={kernelName:nE,backendName:"cpu",kernelFunc:HEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qEe(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=s;at(r,"resizeNearestNeighbor");const l=gt(r.shape),[c,h]=a,[u,d,p,f]=r.shape,g=n.data.get(r.dataId).values,m=new Float32Array(u*c*h*f),y=[i&&c>1?d-1:d,i&&h>1?p-1:p],v=[i&&c>1?c-1:c,i&&h>1?h-1:h],b=y[0]/v[0],x=y[1]/v[1];let w=0;for(let S=0;S<u;S++){const C=S*l[0];for(let _=0;_<c;_++){const T=o?b*(_+.5):b*_;let E=Math.min(d-1,i?Math.round(T):Math.floor(T));o&&(E=Math.max(0,E));const A=C+E*l[1];for(let D=0;D<h;D++){const O=o?x*(D+.5):x*D;let P=Math.min(p-1,i?Math.round(O):Math.floor(O));o&&(P=Math.max(0,P));const L=A+P*l[2];for(let B=0;B<f;B++){const F=g[L+B];m[w++]=F}}}}return n.makeTensorInfo([u,c,h,f],r.dtype,m)}const XEe={kernelName:Db,backendName:"cpu",kernelFunc:qEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KEe(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:i}=t,{alignCorners:o}=s;at([i,r],"resizeNearestNeighborGrad");const a=gt(r.shape),l=gt(i.shape),[c,h,u,d]=r.shape,[,p,f]=i.shape,g=new Float32Array(c*h*u*d),m=n.data.get(i.dataId).values,y=[o&&p>1?h-1:h,o&&f>1?u-1:u],v=[o&&p>1?p-1:p,o&&f>1?f-1:f],b=y[0]/v[0],x=y[1]/v[1],w=1/b,S=1/x,C=Math.ceil(w)*2+2,_=Math.ceil(S)*2+2;for(let T=0;T<c;T++){const E=T*a[0];for(let A=0;A<h;A++){const D=E+A*a[1],O=Math.floor(A*w),P=Math.floor(O-C/2);for(let L=0;L<u;L++){const B=D+L*a[2],F=Math.floor(L*S),M=Math.floor(F-_/2);for(let U=0;U<d;U++){let z=0;for(let $=0;$<C;$++){const R=$+P;if(R<0||R>=p)continue;const H=E+R*l[1],K=R*b,Y=Math.min(h-1,o?Math.round(K):Math.floor(K));if(A===Y)for(let X=0;X<_;X++){const oe=X+M;if(oe<0||oe>=f)continue;const ie=H+oe*l[2],Z=oe*x,ce=Math.min(u-1,o?Math.round(Z):Math.floor(Z));L===ce&&(z+=m[ie+U])}}g[B+U]=z}}}}return n.makeTensorInfo(r.shape,r.dtype,g)}const YEe={kernelName:tE,backendName:"cpu",kernelFunc:KEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QEe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dims:i}=s;at(r,"reverse");const o=r.shape.length,a=Ht(i,r.shape);if(o===0)return tl({inputs:{x:r},backend:n});const l=new lr(r.shape,r.dtype),c=n.bufferSync(r);for(let h=0;h<l.size;h++){const u=l.indexToLoc(h),d=u.slice();a.forEach(p=>d[p]=r.shape[p]-1-d[p]),l.set(c.get(...d),...u)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}const ZEe={kernelName:Pb,backendName:"cpu",kernelFunc:QEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JEe={kernelName:lE,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:s}=e,{radians:r,fillValue:i,center:o}=t,a=n,l=Ys(s.dtype,Ae(s.shape)),[c,h,u,d]=s.shape,[p,f]=xA(o,h,u),g=255,m=Math.sin(r),y=Math.cos(r),v=a.data.get(s.dataId).values;for(let x=0;x<c;x++){const w=x*u*h*d;for(let S=0;S<h;S++){const C=S*(u*d);for(let _=0;_<u;_++){const T=_*d;for(let E=0;E<d;E++){const A=[c,S,_,E],D=A[2],O=A[1];let P=(D-p)*y-(O-f)*m,L=(D-p)*m+(O-f)*y;P=Math.round(P+p),L=Math.round(L+f);let B=i;if(typeof i!="number"&&(E===3?B=g:B=i[E]),P>=0&&P<u&&L>=0&&L<h){const M=L*(u*d),U=P*d,z=w+M+U+E;B=v[z]}const F=w+C+T+E;l[F]=B}}}}return{dataId:a.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eAe=wn(kg,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1}),tAe={kernelName:kg,backendName:"cpu",kernelFunc:eAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nAe(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r,updates:i}=t,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:c,strides:h,outputSize:u}=s0(i,r,o),d=!0,p=n.bufferSync(r),f=n.bufferSync(i),g=Hp(p,f,o,u,c,l,a,h,0,d);return n.makeTensorInfo(o,g.dtype,g.values)}const sAe={kernelName:G$,backendName:"cpu",kernelFunc:nAe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rAe(e,t){let n=0,s=e.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),e[r]<t?n=r+1:s=r;return s}function iAe(e,t){let n=0,s=e.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),e[r]<=t?n=r+1:s=r;return s}function oAe(e,t,n,s,r,i){const o=gs("int32",n*r);for(let a=0;a<n;++a){const l=e.slice(a*s,(a+1)*s),c=a*r;for(let h=0;h<r;++h)o[c+h]=i==="left"?rAe(l,t[h+c]):iAe(l,t[h+c])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aAe(e){const{inputs:t,backend:n,attrs:s}=e,{sortedSequence:r,values:i}=t,{side:o}=s,a=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,c=oAe(a,l,r.shape[0],r.shape[1],i.shape[1],o);return n.makeTensorInfo(i.shape,"int32",c)}const lAe={kernelName:W$,backendName:"cpu",kernelFunc:aAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cAe(e){const{inputs:t,backend:n}=e,{condition:s,t:r,e:i}=t;at([s,r,i],"select");const o=s.shape.length,a=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values,h=li(r.dtype,i.dtype),u=ar(Ae(r.shape),h);let d=0;const p=o===0||o>1||r.shape.length===1?1:Ae(r.shape.slice(1));for(let f=0;f<a.length;f++)for(let g=0;g<p;g++)a[f]===1?u[d++]=l[f]:u[d++]=c[f];return n.makeTensorInfo(r.shape,h,u)}const uAe={kernelName:Ob,backendName:"cpu",kernelFunc:cAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hAe=d1,dAe=p1,pAe=wn(Mg,e=>e>=0?dAe*e:hAe*(Math.exp(e)-1)),fAe={kernelName:Mg,backendName:"cpu",kernelFunc:pAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mAe=wn(Rg,e=>e<0?-1:e>0?1:0),gAe={kernelName:Rg,backendName:"cpu",kernelFunc:mAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yAe=wn(Pg,e=>Math.sin(e)),vAe={kernelName:Pg,backendName:"cpu",kernelFunc:yAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xAe=wn(Og,e=>Math.sinh(e)),bAe={kernelName:Og,backendName:"cpu",kernelFunc:xAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wAe=11920928955078125e-23,_W=Math.log(wAe)+2,SAe=wn(Fg,e=>{const t=e>-_W,n=e<_W,s=Math.exp(e);let r;return n?r=s:t?r=e:r=Math.log(1+s),r}),_Ae={kernelName:Fg,backendName:"cpu",kernelFunc:SAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CAe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:i,paddings:o}=s;at([r],"spaceToBatchND");const a=Ae(i),l=[[0,0]];l.push(...o);for(let S=1+i.length;S<r.shape.length;++S)l.push([0,0]);const c=SW.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),h=r0(c.shape,i,a,!1),u=i0(h.length,i.length,!1),d=o0(c.shape,i,a,!1),g=Dn({inputs:{x:c},backend:n,attrs:{shape:h}}),v=Kr({inputs:{x:g},backend:n,attrs:{perm:u}}),w=Dn({inputs:{x:v},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(v),w}const TAe={kernelName:Fb,backendName:"cpu",kernelFunc:CAe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EAe(e){const{inputs:t,backend:n}=e,{indices:s,values:r,denseShape:i,defaultValue:o}=t;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values,h=n.data.get(o.dataId).values[0],[u,d,p,f,g]=KG(a,s.shape,s.dtype,l,r.dtype,c,h);return[n.makeTensorInfo(d,s.dtype,u),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),n.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const AAe={kernelName:H$,backendName:"cpu",kernelFunc:EAe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IAe(e){const{inputs:t,backend:n}=e,{inputIndices:s,inputShape:r,newShape:i}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(n.data.get(r.dataId).values),a=n.data.get(s.dataId).values,l=Array.from(n.data.get(i.dataId).values),[c,h,u]=YG(a,s.shape,s.dtype,o,l);return[n.makeTensorInfo(h,s.dtype,c),n.makeTensorInfo([u.length],i.dtype,new Int32Array(u))]}const NAe={kernelName:j$,backendName:"cpu",kernelFunc:IAe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kAe(e){const{inputs:t,backend:n}=e,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,[c,h]=EI(o,s.shape,s.dtype,a,l,!0);return n.makeTensorInfo(h,s.dtype,c)}const DAe={kernelName:q$,backendName:"cpu",kernelFunc:kAe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MAe(e){const{inputs:t,backend:n}=e,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,[c,h]=EI(o,s.shape,s.dtype,a,l);return n.makeTensorInfo(h,s.dtype,c)}const PAe={kernelName:X$,backendName:"cpu",kernelFunc:MAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OAe(e){const{inputs:t,backend:n,attrs:s}=e,{sparseIndices:r,sparseValues:i,defaultValue:o}=t,{outputShape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:u,outputSize:d}=s0(i,r,a),p=!1,f=n.bufferSync(r);let g;switch(i.dtype){case"bool":{const m=n.bufferSync(i),y=Boolean(n.data.get(o.dataId).values[0]);g=Hp(f,m,a,d,h,c,l,u,y,p);break}case"float32":{const m=n.bufferSync(i),y=n.data.get(o.dataId).values[0];g=Hp(f,m,a,d,h,c,l,u,y,p);break}case"int32":{const m=n.bufferSync(i),y=n.data.get(o.dataId).values[0];g=Hp(f,m,a,d,h,c,l,u,y,p);break}case"string":{const m=n.bufferSync(i),y=Oc(n.data.get(o.dataId).values[0]);g=Hp(f,m,a,d,h,c,l,u,y,p);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return n.makeTensorInfo(a,g.dtype,g.values)}const RAe={kernelName:K$,backendName:"cpu",kernelFunc:OAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LAe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{numOrSizeSplits:i,axis:o}=s,a=Ht(o,r.shape)[0],l=RA(r,i,a),c=new Array(r.shape.length).fill(0),h=r.shape.slice();return l.map(u=>{const d=[...h];d[a]=u;const p=Nh({inputs:{x:r},backend:n,attrs:{begin:c,size:d}});return c[a]+=u,p})}const FAe={kernelName:$b,backendName:"cpu",kernelFunc:LAe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Ae={kernelName:sE,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,s=t;at(n,"square");const r=s.data.get(n.dataId).values,i=new Float32Array(r.length);for(let a=0;a<r.length;++a){const l=r[a];i[a]=l*l}return{dataId:s.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BAe=wn(Wg,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),zAe={kernelName:Wg,backendName:"cpu",kernelFunc:BAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UAe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:u,shrinkAxisMask:d}=s;at(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:v,end:b,strides:x}=gA(r.shape,i,o,a,l,c,h,u,d);let w;if(g)w=Dn({inputs:{x:r},backend:n,attrs:{shape:f}});else if(m||y){W(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const S=pA(v,b,x),C=Nh({inputs:{x:r},backend:n,attrs:{begin:v,size:S}});w=Dn({inputs:{x:C},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(C)}else{const S=n.bufferSync(r),C=ZG(p,S,x,v);w=n.makeTensorInfo(f,C.dtype,C.values)}return w}const VAe={kernelName:rE,backendName:"cpu",kernelFunc:UAe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GAe(e){const{inputs:t,backend:n,attrs:s}=e,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=s,{data:h,dataSplits:u}=t,d=n.data.get(h.dataId).values,p=n.data.get(u.dataId).values,[f,g]=JG(d,p,r,i,o,a,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(u.shape,"int32",g)]}const WAe={kernelName:Y$,backendName:"cpu",kernelFunc:GAe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HAe(e){const{inputs:t,backend:n,attrs:s}=e,{skipEmpty:r}=s,{input:i,delimiter:o}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=n.data.get(i.dataId).values,l=n.data.get(o.dataId).values[0],[c,h,u]=eW(a,l,r),d=h.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",h),n.makeTensorInfo([2],"int32",new Int32Array(u))]}const jAe={kernelName:Q$,backendName:"cpu",kernelFunc:HAe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qAe(e){const{inputs:t,backend:n,attrs:s}=e,{numBuckets:r}=s,{input:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=n.data.get(i.dataId).values,a=tW(o,r);return n.makeTensorInfo(i.shape,"int32",a)}const XAe={kernelName:Z$,backendName:"cpu",kernelFunc:qAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KAe=wn(Ug,e=>Math.tan(e)),YAe={kernelName:Ug,backendName:"cpu",kernelFunc:KAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QAe=wn(Vg,e=>Math.tanh(e)),ZAe={kernelName:Vg,backendName:"cpu",kernelFunc:QAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JAe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reps:i}=s;at(r,"tile");const o=sW(n.bufferSync(r),i);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const eIe={kernelName:Gg,backendName:"cpu",kernelFunc:JAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tIe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{k:i,sorted:o}=s;at(r,"topk");const a=n.data.get(r.dataId).values,[l,c]=iW(a,r.shape,r.dtype,i,o);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}const nIe={kernelName:iE,backendName:"cpu",kernelFunc:tIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sIe(e){const{inputs:t,attrs:n,backend:s}=e,{image:r,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=n,[h,u,d,p]=r.shape,[f,g]=c!=null?c:[u,d],m=[h,f,g,p],y=gt(r.shape),v=y[0],b=y[1],x=y[2],w=gt(m),S=w[0],C=w[1],_=w[2],T=Ys(r.dtype,Ae(m));T.fill(l);const E=s.data.get(r.dataId).values,A=s.data.get(i.dataId).values;for(let O=0;O<h;++O){const P=i.shape[0]===1?A:A.subarray(O*8,O*8+8);for(let L=0;L<f;++L)for(let B=0;B<g;++B)for(let F=0;F<p;++F){let M;const U=P[6]*B+P[7]*L+1;if(U===0)continue;const z=(P[0]*B+P[1]*L+P[2])/U,$=(P[3]*B+P[4]*L+P[5])/U,R=CW(z,d,a),H=CW($,u,a);switch(o){case"nearest":M=cIe(E,u,d,v,b,x,O,H,R,F,l);break;case"bilinear":M=uIe(E,u,d,v,b,x,O,H,R,F,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const K=O*S+L*C+B*_+F;T[K]=M}return s.makeTensorInfo(m,r.dtype,T)}return{dataId:s.write(T,m,r.dtype),shape:r.shape,dtype:r.dtype}}const rIe={kernelName:oE,backendName:"cpu",kernelFunc:sIe};function CW(e,t,n){switch(n){case"reflect":return iIe(e,t);case"wrap":return oIe(e,t);case"nearest":return lIe(e,t);case"constant":default:return aIe(e)}}function iIe(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const s=2*t;n<s&&(n=s*Math.trunc(-n/s)+n),n=n<-t?n+s:-n-1}else if(n>t-1)if(t<=1)n=0;else{const s=2*t;n-=s*Math.trunc(n/s),n>=t&&(n=s-n-1)}return Zu(0,n,t-1)}function oIe(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const s=t-1;n+=t*(Math.trunc(-n/s)+1)}else if(n>t-1)if(t<=1)n=0;else{const s=t-1;n-=t*Math.trunc(n/s)}return Zu(0,n,t-1)}function aIe(e,t){return e}function lIe(e,t){return Zu(0,e,t-1)}function T0(e,t,n,s,r,i,o,a,l,c,h){const u=o*s+a*r+l*i+c;return 0<=a&&a<t&&0<=l&&l<n?e[u]:h}function cIe(e,t,n,s,r,i,o,a,l,c,h){const u=Math.round(a),d=Math.round(l);return T0(e,t,n,s,r,i,o,u,d,c,h)}function uIe(e,t,n,s,r,i,o,a,l,c,h){const u=Math.floor(a),d=Math.floor(l),p=u+1,f=d+1,g=(f-l)*T0(e,t,n,s,r,i,o,u,d,c,h)+(l-d)*T0(e,t,n,s,r,i,o,u,f,c,h),m=(f-l)*T0(e,t,n,s,r,i,o,p,d,c,h)+(l-d)*T0(e,t,n,s,r,i,o,p,f,c,h);return(p-a)*g+(a-u)*m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hIe(e){const{inputs:t,attrs:n,backend:s}=e,{axis:r}=n,{x:i}=t;at(i,"unique");const o=s.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:c}=oW(o,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,a),s.makeTensorInfo([c.length],"int32",c)]}const dIe={kernelName:aE,backendName:"cpu",kernelFunc:hIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pIe(e){const{inputs:t,backend:n,attrs:s}=e,{value:r}=t;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r.shape.length,a=r.shape[i],l=new Array(o-1);let c=0;for(let p=0;p<o;p++)p!==i&&(l[c++]=r.shape[p]);const h=new Array(o).fill(0),u=r.shape.slice();u[i]=1;const d=new Array(a);for(let p=0;p<d.length;p++){h[i]=p;const f=Nh({inputs:{x:r},backend:n,attrs:{begin:h,size:u}});d[p]=Dn({inputs:{x:f},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(f)}return d}const fIe={kernelName:zb,backendName:"cpu",kernelFunc:pIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mIe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,segmentIds:i}=t,{numSegments:o}=s;at(r,"unsortedSegmentSum");const a=r.shape.length,l=i.shape.length,c=[],h=[],u=a-l;let d=i;for(let f=0;f<u;++f){const g=V1({inputs:{input:d},backend:n,attrs:{dim:f+1}});d=g,h.push(g)}for(let f=0;f<o;++f){const g=Mc(f,"int32"),m=n.makeTensorInfo([],"int32",g),y=xG({inputs:{a:m,b:d},backend:n}),v=Kc({inputs:{x:y},backend:n,attrs:{dtype:"float32"}}),b=B1({inputs:{a:v,b:r},backend:n}),x=C0({inputs:{x:b},backend:n,attrs:{axis:0,keepDims:!1}});c.push(x),h.push(m),h.push(y),h.push(v),h.push(b),h.push(x)}const p=wW({inputs:c,backend:n,attrs:{axis:0}});return h.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}const gIe={kernelName:Ub,backendName:"cpu",kernelFunc:mIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yIe=[d2e,ZSe,f2e,g2e,r_e,v2e,b2e,S2e,C2e,E2e,I2e,k2e,M2e,R2e,F2e,z2e,V2e,W2e,j2e,u2e,X2e,Y2e,Z2e,eCe,n_e,o_e,nCe,JSe,rCe,oCe,aCe,cCe,hCe,pCe,mCe,yCe,xCe,wCe,_Ce,TCe,ACe,NCe,DCe,MCe,OCe,LCe,$Ce,BCe,zCe,UCe,WCe,s2e,jCe,a_e,eTe,l_e,tTe,u_e,aTe,lTe,uTe,d_e,pTe,mTe,yTe,xTe,wTe,f_e,g_e,e_e,_Te,iCe,TTe,ATe,NTe,r2e,v_e,b_e,DTe,S_e,PTe,LTe,$Te,UTe,GTe,HTe,jTe,C_e,XTe,YTe,ZTe,eEe,nEe,rEe,oEe,E_e,lEe,hEe,fEe,I_e,k_e,yEe,bEe,_Ee,M_e,TEe,AEe,IEe,SW,MEe,o2e,R_e,OEe,LEe,$Ee,zEe,t_e,kI,VEe,a2e,l2e,c2e,WEe,jEe,XEe,YEe,ZEe,JEe,tAe,G_e,sAe,lAe,uAe,fAe,H_e,gAe,vAe,bAe,j_e,dEe,_Ae,TAe,AAe,NAe,DAe,PAe,RAe,FAe,K_e,$Ae,Q_e,zAe,VAe,WAe,jAe,XAe,t2e,VCe,YAe,ZAe,eIe,nIe,rIe,P_e,dIe,fIe,gIe,EEe];for(const e of yIe)sB(e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kh={},W1={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function vIe(e,t){kh[e]=t}function na(e,t){if(!(e in kh)||t!=null){const s=bIe(e,t);if(s!==null)kh[e]=s;else return console.log("Could not get context for WebGL version",e),null}const n=kh[e];return n==null||n.isContextLost()?(delete kh[e],na(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),kh[e])}function xIe(e){if(typeof OffscreenCanvas!="undefined"&&e===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function bIe(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=t==null?xIe(e):t;return n.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete kh[e]},!1),xe().getBool("SOFTWARE_WEBGL_ENABLED")&&(W1.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",W1)||n.getContext("experimental-webgl",W1):n.getContext("webgl2",W1)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var E0;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(E0||(E0={}));var Bi;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(Bi||(Bi={}));var Js;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Js||(Js={}));function A0(e,t){return[t,e]}function wIe(e,t){return e*t}function H1(e){const t=Ae(e),n=Math.ceil(t/4);return mT(n)}function Xp(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function SIe(e,t){const[n,s]=Xp(e,t);return n*s*4}function PI(e,t){const n=e;let s,r,i,o,a,l,c,h,u,d;return xe().getNumber("WEBGL_VERSION")===2?(s=n.R32F,r=n.R16F,i=n.RGBA16F,o=n.RGBA32F,a=n.RED,c=4,h=1,u=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(s=e.RGBA,r=e.RGBA,i=e.RGBA,o=n.RGBA,a=e.RGBA,c=4,h=4,u=t!=null?t.HALF_FLOAT_OES:null,d=e.FLOAT,l=e.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:h,textureTypeHalfFloat:u,textureTypeFloat:d}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tt(e,t){const n=t();return xe().getBool("DEBUG")&&_Ie(e),n}function _Ie(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+AIe(e,t))}const CIe=596e-10,TIe=65504;function EIe(e){return!!(xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||CIe<Math.abs(e)&&Math.abs(e)<TIe)}function AIe(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function j1(e,t){return Fl(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function IIe(e,t){const n=Fl(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(tt(e,()=>e.shaderSource(n,t)),tt(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function NIe(e,t){const n=Fl(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(tt(e,()=>e.shaderSource(n,t)),tt(e,()=>e.compileShader(n)),xe().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw TW(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const kIe=/ERROR: [0-9]+:([0-9]+):/g;function TW(e,t){const n=kIe.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}const s=+n[1],r=e.split(`
`),i=r.length.toString().length+2,o=r.map((u,d)=>vp((d+1).toString(),i)+u);let a=0;for(let u=0;u<o.length;u++)a=Math.max(o[u].length,a);const l=o.slice(0,s-1),c=o.slice(s-1,s),h=o.slice(s);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${vp(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join(`
`))}function DIe(e){return Fl(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function MIe(e,t){if(tt(e,()=>e.linkProgram(t)),!xe().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function OI(e,t){if(tt(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function PIe(e,t){const n=Fl(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return tt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),tt(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function OIe(e,t){const n=Fl(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return tt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),tt(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function RIe(e){return Fl(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function LIe(e,t){const n=xe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const s=`[${e}x${t}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(e>n||t>n){const s=`[${e}x${t}]`,r=`[${n}x${n}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function FIe(e){return Fl(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function EW(e,t,n,s,r,i,o){const a=e.getAttribLocation(t,n);return a===-1?!1:(tt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,s)),tt(e,()=>e.vertexAttribPointer(a,r,e.FLOAT,!1,i,o)),tt(e,()=>e.enableVertexAttribArray(a)),!0)}function $Ie(e,t,n){GIe(e,n),tt(e,()=>e.activeTexture(e.TEXTURE0+n)),tt(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function BIe(e,t,n){return Fl(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function zIe(e,t,n){return e.getUniformLocation(t,n)}function UIe(e,t,n,s){tt(e,()=>$Ie(e,t,s)),tt(e,()=>e.uniform1i(n,s))}function RI(e,t,n){tt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),tt(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function AW(e,t){tt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),tt(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function q1(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+VIe(e,t))}function VIe(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Fl(e,t,n){const s=tt(e,()=>t());if(s==null)throw new Error(n);return s}function GIe(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+e.TEXTURE0;if(s<e.TEXTURE0||s>n){const r=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${r}.`)}}function Kp(e,t=2){return Ae(e.slice(0,e.length-t))}function Yp(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function X1(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[Kp(e),...Yp(e)]),t}function WIe(e,t=!1){let n=xe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=xe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&xe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=n/2),t&&(n=n*2,s=s*2,e=e.map((a,l)=>l>=e.length-2?pT(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=kc(e).newShape);let r=Ae(e),i=null;e.length<=1&&r<=n?i=[1,r]:e.length===2&&e[0]<=n&&e[1]<=n?i=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?i=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?i=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?i=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(i=[e[0],e[1]*e[2]*e[3]]);const o=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(i==null||o)if(t){const a=Kp(e);let l=2,c=2;e.length&&([l,c]=Yp(e)),r=a*(l/2)*(c/2),i=mT(r).map(h=>h*2)}else i=mT(r);return i}function K1(e){return e%2==0}function Y1(e,t){if(e=e.slice(-2),t=t.slice(-2),dn(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){const n=e.slice(-1)[0],s=t.slice(-1)[0];if(n===s||K1(n)&&K1(s)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&K1(e[0])&&K1(t[0])}let LI,FI;function HIe(e){if(LI==null){const t=na(e);LI=t.getParameter(t.MAX_TEXTURE_SIZE)}return LI}function jIe(e){if(FI==null){const t=na(e);FI=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,FI)}function qIe(e){if(e===0)return 0;let t;const n=na(e);return xo(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:xo(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function xo(e,t){return e.getExtension(t)!=null}function IW(e){try{if(na(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function XIe(e){if(e===0)return!1;const t=na(e);if(e===1){if(!xo(t,"OES_texture_float"))return!1}else if(!xo(t,"EXT_color_buffer_float"))return!1;return $I(t)}function KIe(e){if(e===0)return!1;const t=na(e);if(e===1){if(!xo(t,"OES_texture_float")||!xo(t,"WEBGL_color_buffer_float"))return!1}else{if(xo(t,"EXT_color_buffer_float"))return $I(t);const s="EXT_color_buffer_half_float";if(xo(t,s)){const r=t.getExtension(s);return YIe(t,r)}return!1}return $I(t)}function $I(e){const t=PI(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);const s=1,r=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,s,r,0,t.textureFormatFloat,t.textureTypeFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(i),o}function YIe(e,t){const n=PI(e,t),s=e.createTexture();e.bindTexture(e.TEXTURE_2D,s);const r=1,i=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,r,i,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,s,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(s),e.deleteFramebuffer(o),a}function QIe(e){return e!==2?!1:na(e).fenceSync!=null}function I0(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&W(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ht=xe();ht.registerFlag("HAS_WEBGL",()=>ht.getNumber("WEBGL_VERSION")>0);ht.registerFlag("WEBGL_VERSION",()=>IW(2)?2:IW(1)?1:0);ht.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ht.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ht.get("WEBGL_VERSION")===2);ht.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ht.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ht.registerFlag("WEBGL_PACK",()=>ht.getBool("HAS_WEBGL"));ht.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_PACK_CLIP",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_PACK_REDUCE",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_LAZILY_UNPACK",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_CONV_IM2COL",()=>ht.getBool("WEBGL_PACK"));ht.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>HIe(ht.getNumber("WEBGL_VERSION")));ht.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>jIe(ht.getNumber("WEBGL_VERSION")));ht.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=ht.getNumber("WEBGL_VERSION");return e===0?0:qIe(e)});ht.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ht.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!CB());ht.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>XIe(ht.getNumber("WEBGL_VERSION")));ht.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ht.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ht.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ht.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>KIe(ht.getNumber("WEBGL_VERSION")));ht.registerFlag("WEBGL_FENCE_API_ENABLED",()=>QIe(ht.getNumber("WEBGL_VERSION")));ht.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ht.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ht.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});ht.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>CB()?1:-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});ht.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ht.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ht.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ht.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);ht.registerFlag("WEBGL_EXP_CONV",()=>!1);ht.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>ht.getBool("IS_TEST"));ht.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);ht.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);ht.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);ht.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cr(){let e,t,n,s,r,i,o,a,l,c;return xe().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",s="in",r="texture",i="outputColor",o="out vec4 outputColor;",a=xe().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",s="varying",r="texture2D",i="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:s,texture2D:r,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dh(e,t,n="index"){const s=gt(t);return s.map((r,i)=>{const o=`int ${e[i]} = ${n} / ${r}`,a=i===s.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${r}`:`index -= ${e[i]} * ${r}`;return`${o}; ${a};`}).join("")}function Q1(e,t,n="index"){const s=gt(t);return s.map((r,i)=>{const o=`int ${e[i]} = ${n} / outShapeStrides[${i}]`,a=i===s.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * outShapeStrides[${i}]`:`index -= ${e[i]} * outShapeStrides[${i}]`;return`${o}; ${a};`}).join("")}function ZIe(e,t){const n=e.length,s=e.map(i=>`${t}[${i}]`),r=new Array(n-1);r[n-2]=s[n-1];for(let i=n-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function JIe(e,t,n="index"){const s=e.map((i,o)=>o),r=ZIe(s,t);return r.map((i,o)=>{const a=`int ${e[o]} = ${n} / ${r[o]}`,l=o===r.length-1?`int ${e[o+1]} = ${n} - ${e[o]} * ${r[o]}`:`index -= ${e[o]} * ${r[o]}`;return`${a}; ${l};`}).join("")}function BI(e){const t=gt(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function zI(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const NW=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:kW}=ebe;function eNe(e,t,n){const s=[];if(e.forEach(p=>{const f=Ae(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?s.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(s.push(`uniform sampler2D ${p.name};`),s.push(`uniform int offset${p.name};`)),n.enableShapeUniforms){const{uniformShape:g}=UI(n.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(g.length){case 1:s.push(`uniform int ${p.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${p.name}Shape;`);break}s.push(`uniform ivec2 ${p.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(p=>{s.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const r=s.join(`
`),i=e.map(p=>tNe(p,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),o=t.texShape,a=Cr(),l=rNe(a);let c,h,u=aNe(a);return t.isPacked?(c=nNe(t.logicalShape,o,n.enableShapeUniforms),h=oNe(a)):(c=sNe(t.logicalShape,o,n.enableShapeUniforms),h=iNe(a)),n.packedInputs&&(u+=hNe),[u,l,h,r,c,i,n.userCode].join(`
`)}function Qp(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return _Ne(e,t);case 1:return TNe(e,t);case 2:return ANe(e,t);case 3:return NNe(e,t);case 4:return DNe(e,t);case 5:return MNe(e);case 6:return PNe(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function DW(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return SNe(e);case 1:return CNe(e,t);case 2:return ENe(e,t);case 3:return INe(e,t);default:return kNe(e,t)}}function tNe(e,t,n=!1,s){let r="";n?r+=DW(e,s):r+=Qp(e,s);const i=e.shapeInfo.logicalShape,o=t.logicalShape;return i.length<=o.length&&(n?r+=ONe(e,t):r+=RNe(e,t)),r}function nNe(e,t,n){switch(e.length){case 0:return MW();case 1:return dNe(e,t,n);case 2:return bNe(e,t,n);case 3:return fNe(e,t,n);default:return gNe(e,t,n)}}function sNe(e,t,n){switch(e.length){case 0:return MW();case 1:return pNe(e,t,n);case 2:return wNe(e,t,n);case 3:return mNe(e,t,n);case 4:return yNe(e,t,n);case 5:return vNe(e,t);case 6:return xNe(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function rNe(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function iNe(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function oNe(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function aNe(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${lNe}
    ${cNe}
    ${uNe}
  `}const lNe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,cNe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,uNe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,hNe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function MW(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function dNe(e,t,n){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return s[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function pNe(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function fNe(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),i=r*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function mNe(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Q1(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;const s=Dh(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function gNe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),i=r*Math.ceil(e[e.length-2]/2);let o=i,a="",l="b, r, c";for(let c=2;c<e.length-1;c++)o*=e[e.length-c-1],a=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+a,l=`b${c}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${e.length}(${l});
    }
  `}function yNe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Q1(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Dh(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function vNe(e,t){const n=Dh(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function xNe(e,t){const n=Dh(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function bNe(e,t,n){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(dn(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function wNe(e,t,n){return dn(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Mh(e){return`offset${e}`}function SNe(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),s=Cr();return`
    vec4 ${n}() {
      return ${s.texture2D}(${t}, halfCR);
    }
  `}function _Ne(e,t){const n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${s}() {return ${n};}`;const[r,i]=e.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const o=Mh(n);if(t)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});
      return sampleTexture(${n}, uv);
    }
  `;const[a,l]=e.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${n}, uv);
    }
  `}function CNe(e,t){const n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,i=Cr();if(t)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${n}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${n}, uv);
    }
  `}function TNe(e,t){const n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Zp(e)}
      }
    `;const r=e.shapeInfo.texShape,i=r[0],o=r[1];if(o===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const a=Mh(n);return o===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);
        return sampleTexture(${n}, uv);
      }
    `:i===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${a});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});
      return sampleTexture(${n}, uv);
    }
  `}function ENe(e,t){const n=e.shapeInfo.logicalShape,s=e.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e.shapeInfo.texShape,o=i[0],a=i[1],l=Cr();if(i!=null&&dn(n,i))return t?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(t)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],h=Math.ceil(n[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${h}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function ANe(e,t){const n=e.shapeInfo.logicalShape,s=e.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e.shapeInfo.texShape;if(i!=null&&dn(n,i)){if(t)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const d=i[0],p=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:a}=kc(n),l=o;if(l.length<n.length){const d=Jp(e,l),p=["row","col"];return`
      ${Qp(d,t)}
      float ${r}(int row, int col) {
        return ${r}(${ef(p,a)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Zp(e)}
      }
    `;const c=i[0],h=i[1],u=Mh(s);return h===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${u}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${u}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${u}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${u}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:t?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${u};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${u};
    vec2 uv = uvFromFlat(${c}, ${h}, index);
    return sampleTexture(${s}, uv);
  }
`}function INe(e,t){const n=e.shapeInfo.logicalShape,s=e.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(n[0]===1){const d=n.slice(1),p=[1,2],f=Jp(e,d),g=["b","row","col"];return`
        ${DW(f,t)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${ef(g,p)});
        }
      `}const a=Cr();if(t)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;const l=o[0],c=o[1],h=Math.ceil(n[2]/2),u=h*Math.ceil(n[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${u}, ${h}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `}function NNe(e,t){const n=e.shapeInfo.logicalShape,s=e.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n[1]*n[2],o=n[2],{newShape:a,keptDims:l}=kc(n),c=a;if(c.length<n.length){const g=Jp(e,c),m=["row","col","depth"];return`
        ${Qp(g,t)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${ef(m,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${Zp(e)}
      }
    `;const h=e.shapeInfo.texShape,u=h[0],d=h[1],p=e.shapeInfo.flatOffset;if(d===i&&p==null)return t?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${u}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(d===o&&p==null)return t?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${u}.0);
      return sampleTexture(${s}, uv);
    }
  `;const f=Mh(s);return t?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${f};
        vec2 uv = uvFromFlat(${u}, ${d}, index);
        return sampleTexture(${s}, uv);
      }
  `}function kNe(e,t){const n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=Cr();if(t)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);
    }
  `;const i=e.shapeInfo.logicalShape,o=i.length,a=e.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],h=l[1],u=Math.ceil(i[o-1]/2);let d=u*Math.ceil(i[o-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${u} + (col / 2)`;for(let g=2;g<o-1;g++)p=`int b${g}, `+p,d*=i[o-g-1],f=`b${g} * ${d} + `+f;return`
    vec4 ${s}(${p}) {
      int index = ${f};
      int texR = index / ${h};
      int texC = index - texR * ${h};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${c});
      return ${r.texture2D}(${n}, uv);
    }
  `}function DNe(e,t){const n=e.shapeInfo.logicalShape,s=e.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n[3],o=n[2]*i,a=n[1]*o,{newShape:l,keptDims:c}=kc(n);if(l.length<n.length){const v=Jp(e,l),b=["row","col","depth","depth2"];return`
      ${Qp(v,t)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${ef(b,c)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${i}, 1)));
        ${Zp(e)}
      }
    `;const h=e.shapeInfo.flatOffset,u=e.shapeInfo.texShape,d=u[0],p=u[1],f=`int stride2 = ${s}Shape[3];`,g=`int stride1 = ${s}Shape[2] * stride2;`,m=`int stride0 = ${s}Shape[1] * stride1;`;if(p===a&&h==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${f}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(p===i&&h==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;const y=Mh(s);return t?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${g}
      ${m}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${y});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${d}, ${p}, index + ${y});
      return sampleTexture(${s}, uv);
    }
  `}function MNe(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],i=t[3]*r,o=t[2]*i,a=t[1]*o,{newShape:l,keptDims:c}=kc(t);if(l.length<t.length){const g=Jp(e,l),m=["row","col","depth","depth2","depth3"];return`
      ${Qp(g)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${ef(m,c)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${i}, ${r})) +
          depth3;
        ${Zp(e)}
      }
    `;const h=e.shapeInfo.flatOffset,u=e.shapeInfo.texShape,d=u[0],p=u[1];if(p===a&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===r&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;const f=Mh(n);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${i} +
          depth2 * ${r} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function PNe(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:i}=kc(t);if(r.length<t.length){const m=Jp(e,r),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Qp(m)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${ef(y,i)});
      }
    `}const o=t[5],a=t[4]*o,l=t[3]*a,c=t[2]*l,h=t[1]*c;if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${h}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Zp(e)}
      }
    `;const u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];if(f===h&&u==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===o&&u==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;const g=Mh(n);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${h} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${g};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Zp(e){const t=e.name,n=Ae(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function ONe(e,t){const n=e.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",i=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,a=kW(e.shapeInfo.logicalShape,t.logicalShape),l=Mn(o),c=o-i;let h;const u=["x","y","z","w","u","v"];i===0?h="":o<2&&a.length>=1?h="coords = 0;":h=a.map(v=>`coords.${u[v+c]} = 0;`).join(`
`);let d="";o<2&&i>0?d="coords":d=e.shapeInfo.logicalShape.map((v,b)=>`coords.${u[b+c]}`).join(", ");let p="return outputValue;";const g=Ae(e.shapeInfo.logicalShape)===1,y=Ae(t.logicalShape)===1;if(i===1&&!g&&!y)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!y)o===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(a.length){const v=i-2,b=i-1;a.indexOf(v)>-1&&a.indexOf(b)>-1?p="return vec4(outputValue.x);":a.indexOf(v)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(b)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${h}
      vec4 outputValue = get${s}(${d});
      ${p}
    }
  `}function RNe(e,t){const n=e.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",i=t.texShape,o=e.shapeInfo.texShape,a=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&a===l&&e.shapeInfo.flatOffset==null&&dn(o,i))return`
      float ${r}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const c=Mn(l),h=kW(e.shapeInfo.logicalShape,t.logicalShape),u=l-a;let d;const p=["x","y","z","w","u","v"];a===0?d="":l<2&&h.length>=1?d="coords = 0;":d=h.map(g=>`coords.${p[g+u]} = 0;`).join(`
`);let f="";return l<2&&a>0?f="coords":f=e.shapeInfo.logicalShape.map((g,m)=>`coords.${p[m+u]}`).join(", "),`
    float ${r}() {
      ${c} coords = getOutputCoords();
      ${d}
      return get${s}(${f});
    }
  `}function Mn(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function UI(e,t,n){const{newShape:s,keptDims:r}=kc(t),i=t.length,o=e&&i===3&&t[0]===1,a=o?t.slice(1):s,l=!e&&i>1&&!dn(t,n)&&s.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:r}}function Jp(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function ef(e,t){return t.map(n=>e[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LNe(e,t,n,s){const r=n.map((h,u)=>{const d={logicalShape:h.shape,texShape:h.isUniform?null:h.texData.texShape,isUniform:h.isUniform,isPacked:h.isUniform?!1:h.texData.isPacked,flatOffset:null};return h.texData!=null&&h.texData.slice!=null&&h.texData.slice.flatOffset>0&&(d.flatOffset=h.texData.slice.flatOffset),{name:t.variableNames[u],shapeInfo:d}}),i=r.map(h=>h.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},a=eNe(r,o,t),l=NIe(e.gl,a),c=e.createProgram(l);return xe().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o},PW(e,t,c))}function PW(e,t,n){const s={},r={},i={},o=[];let a,l,c,h=null,u=null;u=e.getUniformLocation(n,"NAN",!1),xe().getNumber("WEBGL_VERSION")===1&&(h=e.getUniformLocation(n,"INFINITY",!1));const d=!1;for(let p=0;p<t.variableNames.length;p++){const f=t.variableNames[p];s[f]=e.getUniformLocation(n,f,d),s[`offset${f}`]=e.getUniformLocation(n,`offset${f}`,d),t.enableShapeUniforms&&(r[`${f}Shape`]=e.getUniformLocation(n,`${f}Shape`,d),i[`${f}TexShape`]=e.getUniformLocation(n,`${f}TexShape`,d))}return t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",d),c=e.getUniformLocation(n,"outShapeStrides",d),l=e.getUniformLocation(n,"outTexShape",d)),t.customUniforms&&t.customUniforms.forEach((p,f)=>{o[f]=e.getUniformLocation(n,p.name,d)}),{uniformLocations:s,customUniformLocations:o,infLoc:h,nanLoc:u,inShapesLocations:r,inTexShapesLocations:i,outShapeLocation:a,outShapeStridesLocation:c,outTexShapeLocation:l}}function OW(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,s)=>{const r=n.logicalShape,i=t[s],o=i.shape;if(!dn(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(n.isUniform&&i.isUniform)return;const a=n.texShape,l=i.isUniform?null:i.texData.texShape;if(!dn(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function FNe(e,t,n,s,r){t.program.enableShapeUniforms||(OW(t.inShapeInfos,n),OW([t.outShapeInfo],[s]));const i=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?e.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):e.setOutputMatrixTexture(i.texture,o[0],o[1]),e.setProgram(t.webGLProgram),xe().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach((l,c)=>{const h=t.program.variableNames[c],u=t.uniformLocations[h],d=t.uniformLocations[`offset${h}`],p=t.inShapesLocations[`${h}Shape`],f=t.inTexShapesLocations[`${h}TexShape`];if(p){const{uniformShape:g}=UI(t.program.packedInputs,l.shape,l.texData.texShape);switch(g.length){case 1:e.gl.uniform1iv(p,new Int32Array(g));break;case 2:e.gl.uniform2iv(p,new Int32Array(g));break;case 3:e.gl.uniform3iv(p,new Int32Array(g));break;case 4:e.gl.uniform4iv(p,new Int32Array(g));break}}if(f&&e.gl.uniform2i(f,l.texData.texShape[0],l.texData.texShape[1]),u!=null){if(l.isUniform){if(Ae(l.shape)<2)e.gl.uniform1f(u,l.uniformValues[0]);else{let g=l.uniformValues;g instanceof Float32Array||(g=new Float32Array(g)),e.gl.uniform1fv(u,g)}return}l.texData.slice!=null&&d!=null&&e.gl.uniform1i(d,l.texData.slice.flatOffset),e.setInputMatrixTexture(l.texData.texture.texture,u,c)}});const a=t.outShapeLocation;if(a)switch(s.shape.length){case 1:e.gl.uniform1iv(a,new Int32Array(s.shape));break;case 2:e.gl.uniform2iv(a,new Int32Array(s.shape));break;case 3:e.gl.uniform3iv(a,new Int32Array(s.shape));break;case 4:e.gl.uniform4iv(a,new Int32Array(s.shape));break}if(t.outShapeStridesLocation){const l=gt(s.shape);switch(s.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),t.program.customUniforms&&r&&t.program.customUniforms.forEach((l,c)=>{const h=t.customUniformLocations[c],u=r[c];if(l.type==="float")e.gl.uniform1fv(h,u);else if(l.type==="vec2")e.gl.uniform2fv(h,u);else if(l.type==="vec3")e.gl.uniform3fv(h,u);else if(l.type==="vec4")e.gl.uniform4fv(h,u);else if(l.type==="int")e.gl.uniform1iv(h,u);else if(l.type==="ivec2")e.gl.uniform2iv(h,u);else if(l.type==="ivec3")e.gl.uniform3iv(h,u);else if(l.type==="ivec4")e.gl.uniform4iv(h,u);else throw Error(`uniform type ${l.type} is not supported yet.`)}),e.executeProgram()}function $Ne(e,t,n){let s="";t.concat(n).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:h,keptDims:u}=UI(e.packedInputs,o.shape,l);let d="",p="",f="";if(h.length===1&&e.packedInputs){const w=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${w[0]>1}_${w[1]>1}`}else if(h.length===2&&!e.packedInputs)p=`${h[0]>1}_${h[1]>1}`;else if(h.length>2&&!e.packedInputs){const w=gt(h);f=`${w[0]===l[1]}_${w[w.length-1]===l[1]}`}const g=o.shape.length,m=h.length===2&&dn(o.shape,l),y=Ae(o.shape)===1,v=kp(o.shape,n.shape),b=!e.packedInputs&&g===n.shape.length&&dn(l,n.texData.texShape),x=e.packedInputs||h.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${g}_${b}_${c?u:""}_${h.length}_${y}_${v}_${m}_${d}_${p}_${f}_${x}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${l}_${a}`}});const r=e.userCode;let i=e.constructor.name;return i+="_"+s+"_"+r+`${xe().getNumber("WEBGL_VERSION")}`,i}function Tr(e){return xe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BNe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=E0.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Cr();this.outputShape=t,this.enableShapeUniforms=Tr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Q1(["r","c","d"],t):Dh(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zNe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=E0.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Cr();this.outputShape=t,this.enableShapeUniforms=Tr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Q1(["r","c","d"],t):Dh(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UNe{constructor(t){this.variableNames=["A"],this.outTexUsage=Bi.DOWNLOAD;const n=Cr();this.outputShape=t,this.userCode=`
      ${NW}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VNe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Bi.DOWNLOAD;const n=Cr();this.outputShape=t,this.userCode=`
      ${NW}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GNe={R:0,G:1,B:2,A:3};class RW{constructor(t,n=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Cr();this.outputShape=t,this.enableShapeUniforms=Tr(this.outputShape.length);let i="result";n&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<s.length;a++){const l=s[a];o+=`
          if(offset == ${a}) {
            result = values[${GNe[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?zI():BI(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${o}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WNe{constructor(t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Cr();this.outputShape=t,this.enableShapeUniforms=Tr(this.outputShape.length);let r="",i="result";n&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?zI():BI(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HNe(e){const t=Cr(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return IIe(e,n)}function jNe(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return PIe(e,t)}function qNe(e){const t=new Uint16Array([0,1,2,2,1,3]);return OIe(e,t)}function N0(e,t,n,s,r,i){LIe(t,n);const o=RIe(e),a=e.TEXTURE_2D;return tt(e,()=>e.bindTexture(a,o)),tt(e,()=>e.texParameteri(a,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),tt(e,()=>e.texParameteri(a,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),tt(e,()=>e.texParameteri(a,e.TEXTURE_MIN_FILTER,e.NEAREST)),tt(e,()=>e.texParameteri(a,e.TEXTURE_MAG_FILTER,e.NEAREST)),xe().getNumber("WEBGL_VERSION")===1?tt(e,()=>e.texImage2D(a,0,s,t,n,0,r,i,null)):tt(e,()=>e.texStorage2D(a,1,s,t,n)),tt(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:o,texShape:[n,t]}}function LW(e){return e.internalFormatFloat}function XNe(e,t,n,s){const[r,i]=A0(t,n);return N0(e,r,i,LW(s),s.textureFormatFloat,e.FLOAT)}function FW(e){return e.internalFormatHalfFloat}function KNe(e,t,n,s){const[r,i]=A0(t,n);return N0(e,r,i,FW(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function $W(e){return e.downloadTextureFormat}function YNe(e,t,n,s){const[r,i]=A0(t,n);return N0(e,r,i,$W(s),e.RGBA,e.UNSIGNED_BYTE)}function BW(e){return e.internalFormatPackedFloat}function QNe(e,t,n,s){const[r,i]=Xp(t,n);return N0(e,r,i,BW(s),e.RGBA,e.FLOAT)}function zW(e){return e.internalFormatPackedHalfFloat}function ZNe(e,t,n,s){const[r,i]=Xp(t,n);return N0(e,r,i,zW(s),e.RGBA,s.textureTypeHalfFloat)}function JNe(e,t,n){const s=0,r=3*4,i=3*4+2*4;return tt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),EW(e,t,"clipSpacePos",n,3,i,s)&&EW(e,t,"uv",n,2,i,r)}function eke(e,t,n,s,r,i){tt(e,()=>e.bindTexture(e.TEXTURE_2D,t));let o,a,l;r instanceof Uint8Array?(o=new Uint8Array(n*s*4),a=e.UNSIGNED_BYTE,l=e.RGBA):(o=new Float32Array(n*s*4),a=e.FLOAT,l=i.internalFormatPackedFloat),o.set(r),xe().getNumber("WEBGL_VERSION")===2?tt(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,s,e.RGBA,a,o)):tt(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,s,0,e.RGBA,a,o)),tt(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function tke(e,t,n){tt(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?xe().getNumber("WEBGL_VERSION")===2?tt(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):tt(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):xe().getNumber("WEBGL_VERSION")===2?tt(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):tt(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),tt(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function nke(e,t,n,s){const r=e.createBuffer();tt(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r));const a=4*4*t*n;return tt(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ)),tt(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),tt(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),r}function ske(e,t,n){const s=e,r=new Float32Array(n);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function rke(e,t,n,s){const[r,i]=A0(t,n),o=4,a=new Uint8Array(wIe(t*n,o));return tt(e,()=>e.readPixels(0,0,r,i,s.downloadTextureFormat,e.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function ike(e,t,n,s,r,i,o,a){const l=e,c=new Float32Array(SIe(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function oke(e,t,n){const s=new Float32Array(t*n*4);return tt(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VI{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=xe().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,vIe(n,t)):this.gl=na(n),t=this.gl,xe().getNumber("WEBGL_VERSION")===2){const i=t;this.createVertexArray=()=>tt(i,()=>i.createVertexArray()),this.bindVertexArray=o=>tt(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>tt(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>tt(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(t!=null){const i=t.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>tt(t,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>tt(t,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>tt(t,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>tt(t,()=>t.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),xe().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=j1(this.gl,i),xo(this.gl,o))this.textureHalfFloatExtension=j1(this.gl,o);else if(xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),xo(this.gl,r))this.colorBufferHalfFloatExtension=j1(this.gl,r);else if(xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",xo(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(xo(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=jNe(this.gl),this.indexBuffer=qNe(this.gl),this.framebuffer=FIe(this.gl),this.textureConfig=PI(this.gl,this.textureHalfFloatExtension)}get debug(){return xe().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;tt(t,()=>t.finish()),tt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),tt(t,()=>t.deleteFramebuffer(this.framebuffer)),tt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),tt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),tt(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,n){return this.throwIfDisposed(),XNe(this.gl,t,n,this.textureConfig)}createFloat16MatrixTexture(t,n){return this.throwIfDisposed(),KNe(this.gl,t,n,this.textureConfig)}createUnsignedBytesMatrixTexture(t,n){return this.throwIfDisposed(),YNe(this.gl,t,n,this.textureConfig)}uploadPixelDataToTexture(t,n){this.throwIfDisposed(),tke(this.gl,t,n)}uploadDenseMatrixToTexture(t,n,s,r){this.throwIfDisposed(),eke(this.gl,t,n,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,n){return this.throwIfDisposed(),ZNe(this.gl,t,n,this.textureConfig)}createPackedMatrixTexture(t,n){return this.throwIfDisposed(),QNe(this.gl,t,n,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(AW(this.gl,this.framebuffer),this.outputTexture=null),tt(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,n,s){return this.downloadMatrixDriver(t,()=>rke(this.gl,n,s,this.textureConfig))}downloadPackedMatrixFromBuffer(t,n,s,r,i,o){return ike(this.gl,t,n,s,r,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,n){return ske(this.gl,t,n)}createBufferFromTexture(t,n,s){this.bindTextureToFrameBuffer(t);const r=nke(this.gl,n,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let n,s;if(xe().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),s=()=>{const o=r.clientWaitSync(i,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},n=i}else xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(n,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:n,isFencePassed:s}}downloadMatrixFromPackedTexture(t,n,s){return this.downloadMatrixDriver(t,()=>oke(this.gl,n,s))}createProgram(t){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=HNe(n));const s=DIe(n);tt(n,()=>n.attachShader(s,this.vertexShader)),tt(n,()=>n.attachShader(s,t)),MIe(n,s);let r;return r=Object.assign(s,{vao:this.createVertexArray()}),this.bindVertexArray(r.vao),tt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(JNe(n,r,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&OI(n,r),this.setProgram(r),r}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(tt(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&(this.bindVertexArray(this.program.vao),this.debug&&OI(this.gl,this.program)),tt(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,n,s=!0){return this.throwIfDisposed(),s?BIe(this.gl,t,n):zIe(this.gl,t,n)}getAttributeLocation(t,n){return this.throwIfDisposed(),tt(this.gl,()=>this.gl.getAttribLocation(t,n))}getUniformLocationNoThrow(t,n){return this.throwIfDisposed(),this.gl.getUniformLocation(t,n)}setInputMatrixTexture(t,n,s){this.throwIfDisposed(),this.throwIfNoProgram(),UIe(this.gl,t,n,s)}setOutputMatrixTexture(t,n,s){this.setOutputMatrixTextureDriver(t,s,n)}setOutputPackedMatrixTexture(t,n,s){this.throwIfDisposed();const[r,i]=Xp(n,s);this.setOutputMatrixTextureDriver(t,r,i)}setOutputMatrixWriteRegion(t,n,s,r){this.setOutputMatrixWriteRegionDriver(s,t,r,n)}setOutputPackedMatrixWriteRegion(t,n,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&OI(this.gl,this.program),q1(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}tt(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),tt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=j1(this.gl,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const t=this.getQueryTimerExtensionWebGL1(),n=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,n),n}endQuery(){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,s=this.getQueryTimerExtensionWebGL2();n.endQuery(s.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await T$(()=>this.disposed||this.isQueryAvailable(t,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,n){if(n===0)return null;if(n===2){const s=this.gl;return s.getQueryParameter(t,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(t,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,n){if(n===0)return!0;if(n===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(t,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(t,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(t){return new Promise(n=>{this.addItemToPoll(()=>t.isFencePassed(),()=>n())})}pollItems(){const t=ake(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=t;++n){const{resolveFn:s}=this.itemsToPoll[n];s()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,n){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:n}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in xe().platform&&(s=xe().platform.setTimeoutCustom.bind(xe().platform)),T$(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),RI(this.gl,t,this.framebuffer),this.debug&&q1(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(RI(this.gl,this.outputTexture,this.framebuffer),this.debug&&q1(this.gl)):AW(this.gl,this.framebuffer)}downloadMatrixDriver(t,n){this.bindTextureToFrameBuffer(t);const s=n();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(t,n,s){this.throwIfDisposed();const r=this.gl;RI(r,t,this.framebuffer),this.debug&&q1(r),this.outputTexture=t,tt(r,()=>r.viewport(0,0,n,s)),tt(r,()=>r.scissor(0,0,n,s))}setOutputMatrixWriteRegionDriver(t,n,s,r){this.throwIfDisposed(),tt(this.gl,()=>this.gl.scissor(t,n,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function ake(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:lke,bincountImpl:UW,bincountReduceImpl:cke,castImpl:uke,ceilImpl:hke,concatImpl:dke,equalImpl:pke,expImpl:fke,expm1Impl:mke,floorImpl:gke,gatherNdImpl:yke,gatherV2Impl:vke,greaterImpl:xke,greaterEqualImpl:bke,lessImpl:wke,lessEqualImpl:Ske,linSpaceImpl:_ke,logImpl:Cke,maxImpl:Tke,maximumImpl:Eke,minimumImpl:Ake,multiplyImpl:Ike,negImpl:Nke,notEqualImpl:kke,prodImpl:Dke,raggedGatherImpl:Mke,raggedRangeImpl:Pke,raggedTensorToTensorImpl:Oke,rangeImpl:Rke,rsqrtImpl:Lke,scatterImpl:Fke,sigmoidImpl:$ke,simpleAbsImpl:VW,sliceImpl:Bke,sparseFillEmptyRowsImpl:zke,sparseReshapeImpl:Uke,sparseSegmentReductionImpl:GW,sqrtImpl:Vke,stridedSliceImpl:Gke,stringNGramsImpl:Wke,stringSplitImpl:Hke,stringToHashBucketFastImpl:jke,subImpl:qke,tileImpl:Xke,topKImpl:Kke,transposeImpl:GI,uniqueImpl:Yke}=n2e;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WW(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function Er(e,t){return t===1?[e]:WW(e,t)}function Qke(e,t){if(e===1)return"rc";let n="";for(let s=0;s<e;s++)n+=t[s],s<e-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zke{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Tr(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=Er("rc",this.rank),s=Mn(this.rank),r=this.getOutOfBoundsCondition(n),i=this.getSetup(n),o=this.getOutput(n);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(t){const n=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${t[t.length-1-o]},`+i;n.push(i)}return n}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let s=this.rank-2;s<this.rank;s++)n+=`${t[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(n+="||");return n}getSetup(t){if(this.rank===1)return"";const n=t.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(t){const n=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HW{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Tr(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2==1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${Jke(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?zI():BI(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${s}

        setOutput(result);
      }
    `}}function Jke(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?JIe(["r","c","d"],"inputShape"):Dh(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eDe{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,n,s){const r=qW(n,s),i=XW(t,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=jW(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].shift();return this.usedTextures[i].push(l),l}let a;return r===Js.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===Js.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===Js.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===Js.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===Js.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(t,n,s,r){if(this.freeTextures==null)return;const i=qW(s,r),o=XW(n,i,r);o in this.freeTextures||(this.freeTextures[o]=[]);const a=jW(n,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=xe().get("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],h=c.indexOf(t);if(h<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(h,1),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function tDe(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function jW(e,t,n,s,r){const i=nDe(t,s);let o;if(r){const[l,c]=Xp(e[0],e[1]);o=l*c}else{const[l,c]=A0(e[0],e[1]);o=l*c}const a=tDe(n,i);return o*a}function nDe(e,t){switch(e){case Js.PACKED_2X2_FLOAT32:return BW(t);case Js.PACKED_2X2_FLOAT16:return zW(t);case Js.UNPACKED_FLOAT32:return LW(t);case Js.UNPACKED_FLOAT16:return FW(t);case Js.PACKED_4X1_UNSIGNED_BYTE:return $W(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function sDe(e){return xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?Js.PACKED_2X2_FLOAT32:Js.UNPACKED_FLOAT32:e?Js.PACKED_2X2_FLOAT16:Js.UNPACKED_FLOAT16}function qW(e,t){if(e===Bi.UPLOAD)return Js.PACKED_2X2_FLOAT32;if(e===Bi.RENDER||e==null)return sDe(t);if(e===Bi.DOWNLOAD||e===Bi.PIXELS)return Js.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function XW(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nl{constructor(t,n){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Tr(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const bo="if (isnan(x)) return x;",rDe="return x;",KW="return abs(x);",iDe="return (x >= 0.0) ? x : (exp(x) - 1.0);",oDe=bo+`
  return (x < 0.0) ? 0.0 : x;
`,aDe=bo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Qc="return x;",lDe="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cDe="return x;",uDe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,hDe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,dDe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,pDe="return 1.0 / (1.0 + exp(-1.0 * x));";class Zc{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Tr(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fDe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Tr(this.outputShape.length);const n=t.length,s=Er("rc",n),r=Mn(n),i=Qke(n,s),o=s.slice(-2),a=n<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mDe=Cz,gDe=1e-7,yDe=1e-4,Z1={};function vDe(e){return e in Z1||(Z1[e]={}),Z1[e]}const xDe=xe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),bDe=600;function wDe(){return xe().global.screen==null?1024:xe().global.screen.height*xe().global.screen.width*window.devicePixelRatio*bDe/1024/1024}class J1 extends dT{constructor(t){super();if(this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!xe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof VI)n=t;else{const s=na(xe().getNumber("WEBGL_VERSION"),t);n=new VI(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=na(xe().getNumber("WEBGL_VERSION"));n=new VI(s),this.binaryCache=vDe(xe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new eDe(this.gpgpu),this.numMBBeforeWarning=wDe(),this.texData=new _$(this,Wa())}nextDataId(){return J1.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,s,r,i,o){const a=this.makeTensorInfo(n,s),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[r,i]},l.texShape=[r,i];const c=X1(n),h=new RW(c,!1,o),u=this.runWebGLProgram(h,[a],s,[[r,i]]);return u.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(a),u.dataId}write(t,n,s){if((xe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||xe().getBool("DEBUG"))&&this.checkNumericalProblems(t),s==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:s,values:t,usage:Bi.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){const n=this.texData.get(t);n.refCount--}}move(t,n,s,r,i){if(xe().getBool("DEBUG")&&this.checkNumericalProblems(n),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:s,dtype:r,values:n,usage:Bi.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const n=this.texData.get(t),{values:s,dtype:r,complexTensorInfos:i,slice:o,shape:a,isPacked:l}=n;if(o!=null){let d;l?d=new Zc(a,Qc):d=new nl(a,Qc);const p=this.runWebGLProgram(d,[{dataId:t,shape:a,dtype:r}],r),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(s!=null)return this.convertAndCacheOnCPU(t);if(r==="string")return s;const c=this.activeTimers!=null;let h;c&&(h=Wr());let u;if(r==="complex64"){const d=this.readSync(i.real.dataId),p=this.readSync(i.imag.dataId);u=Ol(d,p)}else u=this.getValuesFromTexture(t);return c&&(this.downloadWaitMs+=Wr()-h),this.convertAndCacheOnCPU(t,u)}async read(t){if(this.pendingRead.has(t)){const f=this.pendingRead.get(t);return new Promise(g=>f.push(g))}const n=this.texData.get(t),{values:s,shape:r,slice:i,dtype:o,complexTensorInfos:a,isPacked:l}=n;if(i!=null){let f;l?f=new Zc(r,Qc):f=new nl(r,Qc);const g=this.runWebGLProgram(f,[{dataId:t,shape:r,dtype:o}],o),m=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),m}if(s!=null)return this.convertAndCacheOnCPU(t);if(xe().getBool("DEBUG")&&!xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&xe().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,h;if(o!=="complex64"&&xe().get("WEBGL_BUFFER_SUPPORTED")){h=this.decode(t);const f=this.texData.get(h.dataId);c=this.gpgpu.createBufferFromTexture(f.texture.texture,...H1(r))}this.pendingRead.set(t,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let u;if(o==="complex64"){const f=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),g=f[0],m=f[1];u=Ol(g,m)}else if(c==null)u=this.getValuesFromTexture(t);else{const f=Ae(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,f)}if(h!=null&&this.disposeIntermediateTensorInfo(h),c!=null){const f=this.gpgpu.gl;tt(f,()=>f.deleteBuffer(c))}const d=this.convertAndCacheOnCPU(t,u),p=this.pendingRead.get(t);return this.pendingRead.delete(t),p.forEach(f=>f(d)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&Wa().removeDataId(t,this),this.pendingDeletes--),d}readToGPU(t,n={}){const s=this.texData.get(t),{values:r,shape:i,slice:o,dtype:a,isPacked:l,texture:c}=s;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let p;l?p=new Zc(i,Qc):p=new nl(i,Qc);const f=this.runWebGLProgram(p,[{dataId:t,shape:i,dtype:a}],a),g=this.readToGPU(f,n);return this.disposeIntermediateTensorInfo(f),g}if(c==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const h=this.decode(t,n.customTexShape),u=Wa().makeTensorFromTensorInfo(h),d=this.texData.get(h.dataId);return Object.assign({tensorRef:u},d.texture)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string")try{const s=n.map(r=>Oc(r));return jt(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return jt(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){const s=t[n];if(!EIe(s))throw xe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:n,dtype:s,isPacked:r}=this.texData.get(t),i=Ae(n);if(xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(t),p=this.texData.get(d.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...H1(n)).subarray(0,i);return this.disposeIntermediateTensorInfo(d),f}const o=xe().getBool("WEBGL_PACK")&&r===!0,a=o?X1(n):n,l=o?new VNe(a):new UNe(a),c=this.runWebGLProgram(l,[{shape:a,dtype:s,dataId:t}],"float32"),h=this.texData.get(c.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),u}timerAvailable(){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const n=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,t();const i=rh(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=rh(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(i);a.kernelMs=Cfe(l),a.getExtraProfileInfo=()=>l.map((c,h)=>({name:o[h],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Wr(),endMs:null}}endTimer(t){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=Wr(),t)}async getQueryTime(t){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:s}=this.texData.get(t);return s!=null&&(this.disposeData(s.real.dataId,n),this.disposeData(s.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:n,dtype:s,texShape:r,usage:i,isPacked:o,slice:a}=this.texData.get(t),l=a&&a.origDataId||t,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(n,r,i,o)));const h=this.texData.get(t);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=xDe){return xe().getBool("WEBGL_CPU_FORWARD")&&t.every(s=>this.texData.get(s.dataId).texture==null&&Ae(s.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){Mi("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=t.dataSync();return mDe(t.shape,n)}packedUnaryOp(t,n,s){const r=new Zc(t.shape,n),i=this.compileAndRun(r,[t],s);return Wa().makeTensorFromTensorInfo(i)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const r=VW(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(xe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,KW,t.dtype);const n=new nl(t.shape,KW),s=this.compileAndRun(n,[t]);return Wa().makeTensorFromTensorInfo(s)}makeTensorInfo(t,n,s){let r;if(n==="string"&&s!=null&&s.length>0&&Xm(s[0])){const i=s.map(o=>Pc(o));r=this.write(i,t,n)}else r=this.write(s,t,n);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:n}}makeOutput(t,n,s){return Wa().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,s),this)}unpackTensor(t){const n=new fDe(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){const n=new Zke(t.shape),s=!0;return this.runWebGLProgram(n,[t],t.dtype,null,s)}packedReshape(t,n){const s=[Kp(t.shape),...Yp(t.shape)],r={dtype:t.dtype,shape:s,dataId:t.dataId},i=[Kp(n),...Yp(n)],o=new HW(i,s),a=!0,l=[s],c=this.runWebGLProgram(o,[r],t.dtype,l,a);return{dataId:c.dataId,shape:n,dtype:c.dtype}}decode(t,n){const s=this.texData.get(t),{isPacked:r,shape:i,dtype:o}=s;if(n!=null){const d=Ae(i),p=n[0]*n[1]*4;W(d<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=X1(i);let l;r?l=new zNe(a):l=new BNe(a);const c=!0,h=[n!=null?n:H1(a)],u=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:t}],o,h,c,n);return{dtype:o,shape:i,dataId:u.dataId}}runWebGLProgram(t,n,s,r,i=!1,o){const a=this.makeTensorInfo(t.outputShape,s),l=this.texData.get(a.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===E0.DENSE){const y=o!=null?o:H1(t.outputShape);l.texShape=y.map(v=>v*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),Ae(a.shape)===0)return l.values=Ys(a.dtype,0),a;const c=[],h=n.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let v=this.texData.get(y.dataId);if(v.texture==null){if(!t.packedInputs&&Ae(y.shape)<=xe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:v.values};t.packedInputs&&(v.isPacked=!0,v.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!v.isPacked!=!!t.packedInputs)y=v.isPacked?this.unpackTensor(y):this.packTensor(y),c.push(y),v=this.texData.get(y.dataId);else if(v.isPacked&&!Y1(v.shape,y.shape)){const b=y,x=y.shape;y.shape=v.shape,y=this.packedReshape(y,x),c.push(y),v=this.texData.get(y.dataId),b.shape=x}return{shape:y.shape,texData:v,isUniform:!1}});this.uploadToGPU(a.dataId);const u={shape:a.shape,texData:l,isUniform:!1},d=$Ne(t,h,u),p=this.getAndSaveBinary(d,()=>LNe(this.gpgpu,t,h,u)),f=this.activeTimers!=null;let g;f&&(g=this.startTimer()),xe().get("ENGINE_COMPILE_ONLY")||FNe(this.gpgpu,p,h,u,r),c.forEach(y=>this.disposeIntermediateTensorInfo(y)),f&&(g=this.endTimer(g),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(g)}));const m=xe().get("WEBGL_FLUSH_THRESHOLD");if(m>0){const y=Wr();y-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!xe().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){const y=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),y}return a}compileAndRun(t,n,s,r,i=!1){return s=s||n[0].dtype,this.runWebGLProgram(t,n,s,r,i)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(xe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ye(()=>{if(!xe().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=xe().getBool("DEBUG");xe().set("DEBUG",!1);const n=this.abs(fn(1e-8)).dataSync()[0];if(xe().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?gDe:yDe}uploadToGPU(t){const n=this.texData.get(t),{shape:s,dtype:r,values:i,texture:o,usage:a,isPacked:l}=n;if(o!=null)return;const c=this.activeTimers!=null;let h;c&&(h=Wr());let u=n.texShape;if(u==null&&(u=WIe(s,l),n.texShape=u),i!=null){const d=X1(s);let p,f=u[1],g=u[0];const m=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!m)&&([f,g]=Xp(u[0],u[1])),l?p=new WNe(d,m):p=new RW(d,m);const y=m?[g,f]:u,v=this.makeTensorInfo(y,r),b=this.texData.get(v.dataId);m?b.usage=Bi.PIXELS:b.usage=Bi.UPLOAD,b.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(v.dataId),f,g,i);const x=[[g,f]],w=!0,S=this.runWebGLProgram(p,[v],r,x,w),C=this.texData.get(S.dataId);n.texShape=C.texShape,n.isPacked=C.isPacked,n.usage=C.usage,xe().get("ENGINE_COMPILE_ONLY")?this.disposeData(S.dataId):(n.texture=C.texture,n.values=null,this.texData.delete(S.dataId)),this.disposeIntermediateTensorInfo(v),c&&(this.uploadWaitMs+=Wr()-h)}else{const d=this.acquireTexture(u,a,r,l);n.texture=d}}convertAndCacheOnCPU(t,n){const s=this.texData.get(t),{dtype:r}=s;return n!=null&&(s.values=SDe(n,r)),s.values}acquireTexture(t,n,s,r){if(this.numBytesInGPU+=this.computeBytes(t,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,r)}computeBytes(t,n){return t[0]*t[1]*Vx(n)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(const[,n]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(n),r(!0)}catch(i){throw i}});t.push(s)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await Qz(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(TW(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,t]of Object.entries(this.binaryCache)){const{uniformLocations:n,customUniformLocations:s,infLoc:r,nanLoc:i,inShapesLocations:o,inTexShapesLocations:a,outShapeLocation:l,outShapeStridesLocation:c,outTexShapeLocation:h}=PW(this.gpgpu,t.program,t.webGLProgram);t.uniformLocations=n,t.customUniformLocations=s,t.infLoc=r,t.nanLoc=i,t.inShapesLocations=o,t.inTexShapesLocations=a,t.outShapeLocation=l,t.outShapeStridesLocation=c,t.outTexShapeLocation=h}}createTensorFromGPUData(t,n,s){t.channels=t.channels||"RGBA";const{texture:r,height:i,width:o,channels:a}=t,l=Wa().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(r,n,s,i,o,a);return Wa().makeTensorFromDataId(c,n,s,l)}}J1.nextDataId=0;function SDe(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){const n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let s=0;s<n.length;++s)n[s]=Math.round(e[s]);return n}else throw new Error(`Unknown dtype ${t}`)}/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */TB()&&VB("webgl",()=>new J1,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WI=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class tf{constructor(t,n,s){this.variableNames=["A","B"],this.outputShape=Ft(n,s),this.enableShapeUniforms=Tr(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k0=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class D0{constructor(t,n,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ft(n,s);const i=this.outputShape.length;this.enableShapeUniforms=Tr(i);let o="";if(r)if(i===0||Ae(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Mn(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Er("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pi(e){const{inputs:t,backend:n}=e,{x:s}=t;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const _De={kernelName:gg,backendName:"webgl",kernelFunc:pi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jc(e){const{inputs:t,backend:n}=e,{real:s,imag:r}=t,i=n.makeTensorInfo(s.shape,"complex64"),o=n.texData.get(i.dataId),a=pi({inputs:{x:s},backend:n}),l=pi({inputs:{x:r},backend:n});return o.complexTensorInfos={real:a,imag:l},i}const CDe={kernelName:NT,backendName:"webgl",kernelFunc:Jc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YW="return (a < 0.) ? b * a : a;",QW=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function TDe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{alpha:i}=s,o=n.makeTensorInfo([],"float32",Mc(i,"float32")),a=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new D0(QW,r.shape,o.shape):new tf(YW,r.shape,o.shape),l=n.runWebGLProgram(a,[r,o],"float32");return n.disposeIntermediateTensorInfo(o),l}const EDe={kernelName:cb,backendName:"webgl",kernelFunc:TDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZW="return (a < 0.) ? b * a : a;",JW=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function ADe(e){const{inputs:t,backend:n}=e,{x:s,alpha:r}=t,i=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new D0(JW,s.shape,r.shape):new tf(ZW,s.shape,r.shape);return n.runWebGLProgram(i,[s,r],"float32")}const IDe={kernelName:Ib,backendName:"webgl",kernelFunc:ADe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nf="if (isnan(x)) return x;";function en({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:s}){return({inputs:r,backend:i})=>{const{x:o}=r,a=i,l=s||o.dtype;if(a.shouldExecuteOnCPU([o])&&n!=null){const u=a.texData.get(o.dataId),d=n(u.values,l);return a.makeTensorInfo(o.shape,l,d)}const c=xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let h;return c?h=new Zc(o.shape,t):h=new nl(o.shape,e),a.runWebGLProgram(h,[o],l)}}function er({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,h=a;if(s&&l.dtype==="complex64"){const f=h.texData.get(l.dataId),g=h.texData.get(c.dataId),[m,y]=[[f.complexTensorInfos.real,g.complexTensorInfos.real],[f.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(b=>{const[x,w]=b,S={dataId:x.dataId,dtype:x.dtype,shape:l.shape},C={dataId:w.dataId,dtype:w.dtype,shape:c.shape},_=new tf(e,l.shape,c.shape);return h.runWebGLProgram(_,[S,C],li(x.dtype,w.dtype))}),v=Jc({inputs:{real:m,imag:y},backend:h});return h.disposeIntermediateTensorInfo(m),h.disposeIntermediateTensorInfo(y),v}const u=i||li(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||h.shouldExecuteOnCPU([l,c]))&&r!=null){const f=h.texData.get(l.dataId).values,g=h.texData.get(c.dataId).values,m=l.dtype==="string"?bh(f):f,y=l.dtype==="string"?bh(g):g,[v,b]=r(l.shape,c.shape,m,y,u),x=h.makeTensorInfo(b,u),w=h.texData.get(x.dataId);return w.values=v,x}const d=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let p;return d?p=new D0(t,l.shape,c.shape,n):p=new tf(e,l.shape,c.shape),h.runWebGLProgram(p,[l,c],u)}}function M0(e,t=!1){if(e==="linear")return t?cDe:rDe;if(e==="relu")return t?hDe:oDe;if(e==="elu")return t?uDe:iDe;if(e==="relu6")return t?dDe:aDe;if(e==="prelu")return t?JW:ZW;if(e==="leakyrelu")return t?QW:YW;if(e==="sigmoid")return t?pDe:lDe;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e5{constructor(t,n,s,r=!1,i=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Tr(this.outputShape.length);const h=r?t[1]:t[2],u=Math.ceil(h/2),d=r?"i * 2, rc.y":"rc.y, i * 2",p=i?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",y="";a&&(l?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:m=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");const v=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let b="rc.x",x="rc.x";t[0]<n[0]?b=`imod(rc.x, ${t[0]})`:n[0]<t[0]&&(x=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${u}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${b};
        int batchB = ${x};
        for (int i = 0; i < ${u}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${g[0]});
          result += (${f[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${v}

        ${y}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t5={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class n5{constructor(t,n,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ft(n,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s5="return a * b;";function HI(e){const{inputs:t,backend:n}=e,{a:s,b:r}=t,i=li(s.dtype,r.dtype);if(s.dtype==="complex64"){const a=n.texData.get(s.dataId),l=n.texData.get(r.dataId),c=new n5(t5.REAL,s.shape,r.shape),h=new n5(t5.IMAG,s.shape,r.shape),u=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],d=n.runWebGLProgram(c,u,"float32"),p=n.runWebGLProgram(h,u,"float32"),f=Jc({inputs:{real:d,imag:p},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}if(n.shouldExecuteOnCPU([s,r])){const a=n.texData.get(s.dataId),l=n.texData.get(r.dataId),[c,h]=Ike(s.shape,r.shape,a.values,l.values,i),u=n.makeTensorInfo(h,i),d=n.texData.get(u.dataId);return d.values=c,u}let o;return xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new D0(s5,s.shape,r.shape):o=new tf(s5,s.shape,r.shape),n.runWebGLProgram(o,[s,r],i)}const NDe={kernelName:Tg,backendName:"webgl",kernelFunc:HI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kDe(e,t,n){const s=[Kp(e.shape),...Yp(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},i=[Kp(t),...Yp(t)],o=new HW(i,s),a=!0,l=[s],c=n.runWebGLProgram(o,[r],e.dtype,l,a);return{dataId:c.dataId,shape:t,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ze(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{shape:i}=s,o=n,a=Ae(r.shape),l=E$(i,a),c=Ae(l);W(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const h=o.texData.get(r.dataId);return h.isPacked&&!Y1(r.shape,l)&&!(h.texture!==null&&Y1(h.shape,l))?kDe(r,l,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const DDe={kernelName:kb,backendName:"webgl",kernelFunc:Ze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r5{constructor(t,n){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=t;this.outputShape=[r,o];const a=Math.floor(s/4)*4,l=s%4;let c="sumValue += dot(values, ones);";if(n!=null){const u=1/n;c=`sumValue += dot(values * ${yp(u)?u.toPrecision(2):u}, ones);`}let h="";i%s>0&&(h=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MDe{constructor(t,n){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=t;this.outputShape=[r,o];let a="0.0",l="";n==="prod"?a="1.0":n==="min"?(a="1.0 / 1e-20",l="min"):n==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?c="sumValue":n==="prod"?c="prodValue":n==="all"?c="allValue":n==="any"&&(c="anyValue");const h=Math.floor(s/4)*4,u=s%4;let d=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";n==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):n==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";i%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${h};
        if (${u===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${u===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${u===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PDe(e){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const n=t.length?t[t.length-1].outSize:e[1],s=h1(n);t.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return t}function Ph(e,t,n,s){const r=PDe(e.shape);let i=e;for(let o=0;o<r.length;o++){const{inSize:a,windowSize:l,outSize:c}=r[o];let h,u;n==="mean"?h=o===0?new r5({windowSize:l,inSize:a,batchSize:e.shape[0],outSize:c},a):new r5({windowSize:l,inSize:a,batchSize:e.shape[0],outSize:c}):h=new MDe({windowSize:l,inSize:a,batchSize:e.shape[0],outSize:c},n),u=i,i=s.runWebGLProgram(h,[i],t),u.dataId!==e.dataId&&s.disposeIntermediateTensorInfo(u)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ODe{constructor(t,n){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[n[o]];this.outputShape=s,this.rank=s.length;const r=Mn(this.rank),i=RDe(n);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function RDe(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let r=0;r<e.length;r++)s[e[r]]=n[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LDe{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(t.length);for(let h=0;h<s.length;h++)s[h]=t[n[h]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Mn(this.rank),i=WW("rc",this.rank),o=new Array(this.rank);for(let h=0;h<n.length;h++)o[n[h]]=i[h];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ew(e,t,n){const s=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new LDe(e.shape,t):new ODe(e.shape,t);return n.runWebGLProgram(s,[e],e.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FDe(e,t,n,s){const r=t,i=e.shape.length,o=Ht(r,e.shape);let a=o;const l=Yn(a,i),c=l!=null;let h=e;c&&(h=ew(e,l,s),a=cs(a.length,i)),Zs("sum",a,i);const[u,d]=$s(h.shape,a);let p=u;n&&(p=vs(u,o));const f=Ae(d),m=Ae(e.shape)/f,y=Ze({inputs:{x:h},attrs:{shape:[m,f]},backend:s}),v=xE(e.dtype),b=Ph(y,v,"sum",s),x=Ze({inputs:{x:b},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(b),c&&s.disposeIntermediateTensorInfo(h),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tw(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:o}=s;return FDe(r,i,o,n)}const $De={kernelName:Lb,backendName:"webgl",kernelFunc:tw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ar(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{perm:i}=s,o=n,a=r.shape.length,l=new Array(a);for(let h=0;h<l.length;h++)l[h]=r.shape[i[h]];let c;if(o.shouldExecuteOnCPU([r])){const u=o.texData.get(r.dataId).values,d=GI(u,r.shape,r.dtype,i,l);c=o.makeTensorInfo(l,r.dtype);const p=o.texData.get(c.dataId);p.values=d}else c=ew(r,i,o);return c}const BDe={kernelName:wp,backendName:"webgl",kernelFunc:Ar};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i5=1e3;function nw({a:e,b:t,transposeA:n,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=e.shape.length,h=t.shape.length,u=n?e.shape[c-2]:e.shape[c-1],d=s?t.shape[h-1]:t.shape[h-2],p=n?e.shape[c-1]:e.shape[c-2],f=s?t.shape[h-2]:t.shape[h-1],g=e.shape.slice(0,-2),m=t.shape.slice(0,-2),y=Ae(g),v=Ae(m),x=Ft(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);W(u===d,()=>`Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${s} must match.`);const w=n?[y,u,p]:[y,p,u],S=s?[v,f,d]:[v,d,f],C=Ze({inputs:{x:e},backend:r,attrs:{shape:w}}),_=Ze({inputs:{x:t},backend:r,attrs:{shape:S}}),T=[C,_],E=Math.max(y,v),A=n?C.shape[1]:C.shape[2],D=i!=null,O=o!=null,P=l==="leakyrelu",L=l!=null?M0(l,!0):null,B=D||O||P||L!=null;let F;if((p===1||f===1)&&A>i5&&B===!1){let U=C,z=_;n&&(U=Ar({inputs:{x:C},backend:r,attrs:{perm:[0,2,1]}}),T.push(U)),s&&(z=Ar({inputs:{x:_},backend:r,attrs:{perm:[0,2,1]}}),T.push(z));const $=f!==1,R=f===1;let H=U;$&&(H=Ze({inputs:{x:U},backend:r,attrs:{shape:[E,A,1]}}),T.push(H));const K=f===1?2:1;let Y=z;R&&(Y=Ze({inputs:{x:z},backend:r,attrs:{shape:[E,1,A]}}),T.push(Y));const X=HI({inputs:{a:H,b:Y},backend:r});F=tw({inputs:{x:X},backend:r,attrs:{axis:K,keepDims:!0}}),T.push(X)}else{const U=li(e.dtype,t.dtype),z=new e5(w,S,[E,p,f],n,s,D,L,O,P),$=[C,_];if(i!=null&&$.push(i),O&&$.push(o),P){const R=r.makeTensorInfo([],"float32",Mc(a,"float32"));$.push(R),T.push(R)}F=r.runWebGLProgram(z,$,U)}const M=Ze({inputs:{x:F},backend:r,attrs:{shape:x}});T.push(F);for(const U of T)r.disposeIntermediateTensorInfo(U);return M}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zDe(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:u}=s;return nw({a:r,b:i,transposeA:l,transposeB:c,backend:n,bias:o,preluActivationWeights:a,leakyreluAlpha:u,activation:h})}const UDe={kernelName:Gb,backendName:"webgl",kernelFunc:zDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o5="return abs(x);";function VDe(e){const{inputs:t,backend:n}=e,{x:s}=t;if(n.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=n.texData.get(s.dataId),o=VW(i.values);return n.makeTensorInfo(s.shape,s.dtype,o)}let r;return xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Zc(s.shape,o5):r=new nl(s.shape,o5),n.runWebGLProgram(r,[s],s.dtype)}const GDe={kernelName:Gx,backendName:"webgl",kernelFunc:VDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WDe=bo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,HDe=en({opSnippet:WDe}),jDe={kernelName:Ym,backendName:"webgl",kernelFunc:HDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qDe=bo+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,XDe=en({opSnippet:qDe}),KDe={kernelName:Qm,backendName:"webgl",kernelFunc:XDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a5="return a + b;",YDe=er({opSnippet:a5,packedOpSnippet:a5,supportsComplex:!0,cpuKernelImpl:lke}),QDe={kernelName:bp,backendName:"webgl",kernelFunc:YDe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZDe{constructor(t,n){this.outputShape=[],this.outputShape=t,this.variableNames=n.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JDe{constructor(t,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=n.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sw(e){const{inputs:t,backend:n}=e,s=t;if(s.length===1)return pi({inputs:{x:s[0]},backend:n});if(s.length>xe().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),c=sw({inputs:s.slice(0,l),backend:n}),h=sw({inputs:s.slice(l),backend:n});return sw({inputs:[c,h],backend:n})}const r=s.map(l=>l.dtype).reduce((l,c)=>li(l,c)),i=s.map(l=>l.shape),a=xe().getBool("WEBGL_PACK")?new JDe(s[0].shape,i):new ZDe(s[0].shape,i);return n.runWebGLProgram(a,s,r)}const eMe={kernelName:_T,backendName:"webgl",kernelFunc:sw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tMe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:o}=s,a=r.shape.length,l=Ht(i,r.shape);let c=l;const h=Yn(c,a);let u=r;h!=null&&(u=Ar({inputs:{x:r},backend:n,attrs:{perm:h}}),c=cs(c.length,a)),Zs("all",c,a);const[d,p]=$s(u.shape,c),f=Ae(p),g=Ze({inputs:{x:u},backend:n,attrs:{shape:[-1,f]}}),m=Ph(g,g.dtype,"all",n);let y;if(o){const v=vs(d,l);y=Ze({inputs:{x:m},backend:n,attrs:{shape:v}})}else y=Ze({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),h!=null&&n.disposeIntermediateTensorInfo(u),y}const nMe={kernelName:CT,backendName:"webgl",kernelFunc:tMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sMe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:o}=s,a=r.shape.length,l=Ht(i,r.shape);let c=l;const h=Yn(c,a);let u=r;h!=null&&(u=Ar({inputs:{x:r},backend:n,attrs:{perm:h}}),c=cs(c.length,a)),Zs("any",c,a);const[d,p]=$s(u.shape,c),f=Ae(p),g=Ze({inputs:{x:u},backend:n,attrs:{shape:[-1,f]}}),m=Ph(g,g.dtype,"any",n);let y;if(o){const v=vs(d,l);y=Ze({inputs:{x:m},backend:n,attrs:{shape:v}})}else y=Ze({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),h!=null&&n.disposeIntermediateTensorInfo(u),y}const rMe={kernelName:TT,backendName:"webgl",kernelFunc:sMe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iMe{constructor(t,n,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:o}=t;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const a=n==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oMe{constructor(t,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,W(t.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=t[t.length-1],o=Math.ceil(i/n);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=Mn(l),h=Er("coords",l);let u,d;if(o===1){d=l+1;const _=Mn(d);u=`
        ${_} sourceLocR = ${_}(${h.join()}, 0);
        ++${h[l-1]};
        ${_} sourceLocG = ${_}(${h.join()}, 0);
        ++${h[l-2]};
        ${_} sourceLocA = ${_}(${h.join()}, 0);
        --${h[l-1]};
        ${_} sourceLocB = ${_}(${h.join()}, 0);
        --${h[l-2]};`}else d=l,u=`
        ${c} sourceLocR = coords;
        ++${h[l-1]};
        ${c} sourceLocG = coords;
        ++${h[l-2]};
        ${c} sourceLocA = coords;
        --${h[l-1]};
        ${c} sourceLocB = coords;
        --${h[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,d),f="."+p[d-1],g=p.map(_=>"int "+_),m=Er("sourceLocR",d-1).concat("inIdx.r"),y=Er("sourceLocG",d-1).concat("inIdx.g"),v=Er("sourceLocB",d-1).concat("inIdx.b"),b=Er("sourceLocA",d-1).concat("inIdx.a"),x=s==="max"?"greaterThan":"lessThan",w=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${b.join()})));`,S=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${v.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,C=r?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${C}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${h[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${h[l-2]} < ${a[l-2]-1};
        ${u}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${S};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${w}
          vec4 candidate = ${S};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l5(e,t,n,s=null){let r=t.shape[0],i=t.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const o=h1(i),a={windowSize:o,inSize:i,batchSize:r,outSize:Math.ceil(i/o)},l=new iMe(a,n,s==null),c=[t];s!=null&&c.push(s);const h=e.runWebGLProgram(l,c,"int32");if(h.shape[1]===1)return h;const u=l5(e,t,n,h);return e.disposeIntermediateTensorInfo(h),u}function c5(e,t,n,s=null){const r=s!=null?s.shape:t.shape,i=r[r.length-1],o=h1(i),a=new oMe(r,o,n,s==null),l=s==null?[t]:[t,s],c=e.runWebGLProgram(a,l,"int32");if(c.shape.length===t.shape.length){const h=c5(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}return c}function u5(e,t,n,s){const r=[n];if(Zs("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,t.shape.length),!xe().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const i=[],o=e.texData.get(t.dataId),a=o!==null&&o.isPacked;let l=t;a&&(l=e.unpackTensor(t),i.push(l));const[c,h]=$s(l.shape,r),u=Ae(h),d=Ze({inputs:{x:l},backend:e,attrs:{shape:[-1,u]}});i.push(d);const p=l5(e,d,s);i.push(p);const f=Ze({inputs:{x:p},backend:e,attrs:{shape:c}});return i.forEach(g=>e.disposeIntermediateTensorInfo(g)),f}return c5(e,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aMe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i}=s;let o=Ht(i,r.shape);const a=Yn(o,r.shape.length);let l=r;const c=[];a!=null&&(l=Ar({inputs:{x:r},backend:n,attrs:{perm:a}}),c.push(l),o=cs(o.length,l.shape.length)),Zs("argMax",[o[0]],l.shape.length);const h=u5(n,l,o[0],"max");return c.forEach(u=>n.disposeIntermediateTensorInfo(u)),h}const lMe={kernelName:Wx,backendName:"webgl",kernelFunc:aMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cMe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i}=s;let o=Ht(i,r.shape);const a=Yn(o,r.shape.length);let l=r;const c=[];a!=null&&(l=Ar({inputs:{x:r},backend:n,attrs:{perm:a}}),c.push(l),o=cs(o.length,l.shape.length)),Zs("argMin",[o[0]],l.shape.length);const h=u5(n,l,o[0],"min");return c.forEach(u=>n.disposeIntermediateTensorInfo(u)),h}const uMe={kernelName:Hx,backendName:"webgl",kernelFunc:cMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hMe=bo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,dMe=en({opSnippet:hMe}),pMe={kernelName:Zm,backendName:"webgl",kernelFunc:dMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fMe=bo+"return log(x + sqrt(x * x + 1.0));",mMe=en({opSnippet:fMe}),gMe={kernelName:Jm,backendName:"webgl",kernelFunc:mMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yMe=bo+`
  return atan(x);
`,vMe=en({opSnippet:yMe}),xMe={kernelName:eg,backendName:"webgl",kernelFunc:vMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bMe=WI+`
  return atan(a, b);
`,wMe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+k0+`
  return result;
`,SMe=er({opSnippet:bMe,packedOpSnippet:wMe}),_Me={kernelName:ng,backendName:"webgl",kernelFunc:SMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CMe=bo+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,TMe=en({opSnippet:CMe}),EMe={kernelName:tg,backendName:"webgl",kernelFunc:TMe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class P0{constructor(t,n,s,r=!1,i=!1){if(this.variableNames=["x"],n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,h=t.dilationWidth,u=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=t.padInfo.top,f=t.padInfo.left;this.outputShape=t.outShape;const g=n==="avg",m=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,y=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let v="0.0";if(g||(v="-1.0 / 1e-20"),s){const _=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${u};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${h}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${_} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?m:y:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const b="max";let x=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(x="avgValue / max(count, 1.0)");const w=Math.floor(o/4)*4,S=o%4,C=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${u};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${w}; wC += 4) {
            int xC = xCCorner + wC * ${h};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              getValue(batch, xR, xC + 3 * ${h}, d)
            );

            ${C}
          }

          int xC = xCCorner + ${w};
          if (${S===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${C}
          } else if (${S===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              initializationValue,
              initializationValue
            );

            ${C}
          } else if (${S===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              initializationValue
            );

            ${C}
          }
        }
        setOutput(${x});
      }
    `}}class jI{constructor(t,n,s,r=!1,i=!1){if(this.variableNames=["x"],n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideDepth,l=t.strideHeight,c=t.strideWidth,h=t.dilationDepth,u=t.dilationHeight,d=t.dilationWidth,p=t.effectiveFilterDepth,f=t.effectiveFilterHeight,g=t.effectiveFilterWidth,m=t.padInfo.front,y=t.padInfo.top,v=t.padInfo.left;this.outputShape=t.outShape;const b=n==="avg";let x="0.0";if(b||(x="-1.0 / 1e-20"),s){const E=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${m}, ${y}, ${v});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${h}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${u}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${E} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${f} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const w="max";let S=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(S="avgValue / max(count, 1.0)");const C=Math.floor(o/4)*4,_=o%4,T=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${m}, ${y}, ${v});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${h}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${C}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${T}
            }

            int xC = xCCorner + ${C};
            if (${_===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${T}
            } else if (${_===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${T}
            } else if (${_===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${T}
            }
          }
        }
        setOutput(${S});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AMe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;I0(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=1;W(cr(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=uo(r.shape,i,o,c,a,l);if(h.filterWidth===1&&h.filterHeight===1&&dn(h.inShape,h.outShape))return pi({inputs:{x:r},backend:n});const u=new P0(h,"avg",!1);return n.runWebGLProgram(u,[r],"float32")}const IMe={kernelName:jx,backendName:"webgl",kernelFunc:AMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NMe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s,h=[1,1,1],u=kl(r.shape,i,o,h,a,l,c),d=new jI(u,"avg",!1);return n.runWebGLProgram(d,[r],"float32")}const kMe={kernelName:qx,backendName:"webgl",kernelFunc:NMe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DMe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterHeight,s=t.filterWidth,r=t.strideHeight,i=t.strideWidth,o=t.dilationHeight,a=t.dilationWidth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,h=l-1-t.padInfo.top,u=c-1-t.padInfo.left,d=1/(n*s);this.userCode=`
      const ivec2 pads = ivec2(${h}, ${u});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class MMe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterDepth,s=t.filterHeight,r=t.filterWidth,i=t.strideDepth,o=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,u=t.effectiveFilterDepth,d=t.effectiveFilterHeight,p=t.effectiveFilterWidth,f=u-1-t.padInfo.front,g=d-1-t.padInfo.top,m=p-1-t.padInfo.left,y=1/(n*s*r);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${g}, ${m});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${h}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PMe(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i}=t,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:h}=s,u=[1,1,1],d=kl(o.shape,a,l,u,c,h),p=new MMe(d);return n.runWebGLProgram(p,[r],o.dtype)}const OMe={kernelName:AT,backendName:"webgl",kernelFunc:PMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RMe(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i}=t,o=i;I0([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s,h=uo(o.shape,a,l,1,c),u=new DMe(h);return n.runWebGLProgram(u,[r],o.dtype)}const LMe={kernelName:ET,backendName:"webgl",kernelFunc:RMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FMe(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:i}=t,{transposeA:o,transposeB:a}=s;return nw({a:r,b:i,transposeA:o,transposeB:a,backend:n})}const $Me={kernelName:Xx,backendName:"webgl",kernelFunc:FMe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BMe{constructor(t,n,s,r,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Ft(t,n),Ft(t,s);let a="0.0";r!=null&&(Ft(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";i!=null&&(Ft(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zMe{constructor(t,n,s,r,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ft(t,n),Ft(t,s);let a="vec4(0.0)";r!=null&&(Ft(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";i!=null&&(Ft(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UMe=({inputs:e,backend:t,attrs:n})=>{const{x:s,mean:r,variance:i,offset:o,scale:a}=e;W(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),W(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),W(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const c=[s,r,i];let h=null;o!=null&&(h=o.shape,c.push(o));let u=null;a!=null&&(u=a.shape,c.push(a));const d=xe().getBool("WEBGL_PACK_NORMALIZATION")?new zMe(s.shape,r.shape,i.shape,h,u,l):new BMe(s.shape,r.shape,i.shape,h,u,l);return t.runWebGLProgram(d,c,c[0].dtype)},VMe={kernelName:ob,backendName:"webgl",kernelFunc:UMe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GMe{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const n=Mn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=WMe(this.rank);let r;const i=t.map((o,a)=>`sourceLoc.${qI[a]} = start[${a}] + coords.${qI[a]};`);r=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const qI=["x","y","z","w","u","v"];function WMe(e){if(e===1)return"sourceLoc";if(e<=6)return qI.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HMe{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Mn(this.rank),s=Er("coords",this.rank),r=Er("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${i})`,a=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${t[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${n}(${t.map((h,u)=>`start[${u}]`).join()});`:t.map((h,u)=>`${r[u]} = ${s[u]} + start[${u}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jMe(e,t,n,s){const r=s.texData.get(e.dataId),i=s.makeTensorInfo(n,e.dtype),o=s.texData.get(i.dataId);Object.assign(o,r),o.refCount=1,o.shape=n,o.dtype=e.dtype;let a=mA(t,gt(e.shape));r.slice&&(a+=r.slice.flatOffset),o.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||e.dataId};const l=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,l+1),i}function sf(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:i,size:o}=s,[a,l]=u1(r,i,o);if(dA(r,a,l),Ae(l)===0)return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||r.dtype==="string"){const u=n.texData.get(r.dataId),d=Bke(u.values,a,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,d)}const{isPacked:c}=n.texData.get(r.dataId),h=fA(r.shape,a,l);if(c||!h){const u=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new HMe(l):new GMe(l),d=[a];return n.runWebGLProgram(u,[r],r.dtype,d)}return n.uploadToGPU(r.dataId),jMe(r,a,l,n)}const qMe={kernelName:Rb,backendName:"webgl",kernelFunc:sf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XMe=e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:i,crops:o}=s;W(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((v,b)=>v*b),l=r0(r.shape,i,a),c=i0(l.length,i.length),h=o0(r.shape,i,a),u=bA(o,i.length),d=wA(h,o,i.length),p=[],f=Ze({inputs:{x:r},backend:n,attrs:{shape:l}}),g=Ar({inputs:{x:f},backend:n,attrs:{perm:c}}),m=Ze({inputs:{x:g},backend:n,attrs:{shape:h}}),y=sf({inputs:{x:m},backend:n,attrs:{begin:u,size:d}});return p.push(f),p.push(g),p.push(m),p.forEach(v=>n.disposeIntermediateTensorInfo(v)),y},KMe={kernelName:Kx,backendName:"webgl",kernelFunc:XMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YMe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:i}=t,{size:o}=s,a=n.readSync(r.dataId),l=n.readSync(i.dataId),c=UW(a,l,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,c)}const QMe={kernelName:IT,backendName:"webgl",kernelFunc:YMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZMe(e){const{inputs:t,backend:n}=e,{s0:s,s1:r}=t,i=n.readSync(s.dataId),o=n.readSync(r.dataId),a=Ft(Array.from(i),Array.from(o));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const JMe={kernelName:P$,backendName:"webgl",kernelFunc:ZMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e3e="return float(a != b);",h5=er({opSnippet:e3e,cpuKernelImpl:kke,dtype:"bool"}),t3e={kernelName:_b,backendName:"webgl",kernelFunc:h5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O0(e){const{inputs:t,backend:n}=e,{input:s}=t,r=n.texData.get(s.dataId);return pi({inputs:{x:r.complexTensorInfos.real},backend:n})}const n3e={kernelName:eE,backendName:"webgl",kernelFunc:O0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s3e="return float(int(x));";function r3e(e,t){const n=new nl(e.shape,s3e),s=t.runWebGLProgram(n,[e],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XI(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return pi({inputs:{x:r},backend:n});const o=Bs(r.shape),a=XI({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),l=Jc({inputs:{real:a,imag:o},backend:n});return o.dispose(),n.disposeIntermediateTensorInfo(a),l}if(r.dtype==="complex64"){const o=O0({inputs:{input:r},backend:n}),a=XI({inputs:{x:o},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(o),a}if(!A$(r.dtype,i)){const o=pi({inputs:{x:r},backend:n});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(n.shouldExecuteOnCPU([r])){const o=n.texData.get(r.dataId).values,[a,l,c]=uke(o,r.shape,r.dtype,i);return n.makeTensorInfo(a,l,c)}if(i==="int32")return r3e(r,n);if(i==="bool"){const o=n.makeTensorInfo([],"bool",Ys("bool",1)),l=h5({inputs:{a:r,b:o},backend:n});return n.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const i3e={kernelName:sg,backendName:"webgl",kernelFunc:XI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d5="return ceil(x);",o3e=en({opSnippet:d5,packedOpSnippet:d5,cpuKernelImpl:hke}),a3e={kernelName:rg,backendName:"webgl",kernelFunc:o3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l3e{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class c3e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u3e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{clipValueMin:i,clipValueMax:o}=s;let a;xe().getBool("WEBGL_PACK_CLIP")?a=new c3e(r.shape):a=new l3e(r.shape);const l=[[i],[o]];return n.runWebGLProgram(a,[r],r.dtype,l)}const h3e={kernelName:ig,backendName:"webgl",kernelFunc:u3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d3e{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p5(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function p3e(e){const{inputs:t,backend:n}=e,{x:s}=t,r=n.texData.get(s.dataId),i=new d3e(s.shape),o=[p5(s,r.complexTensorInfos.real),p5(s,r.complexTensorInfos.imag)];return n.runWebGLProgram(i,o,o[0].dtype)}const f3e={kernelName:Yx,backendName:"webgl",kernelFunc:p3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m3e{constructor(t){this.outputShape=[],this.outputShape=Xa(t,1),this.variableNames=t.map((o,a)=>`T${a}`);const n=new Array(t.length-1);n[0]=t[0][1];for(let o=1;o<n.length;o++)n[o]=n[o-1]+t[o][1];const s=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<n.length;o++){const a=n[o-1];s.push(`else if (yC < ${n[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const r=n.length,i=n[n.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g3e{constructor(t,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Xa(t,n);const s=this.outputShape,r=s.length,i=Mn(r),o=Er("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((g,m)=>`T${m}`);const l=new Array(t.length-1);l[0]=t[0][n];for(let g=1;g<l.length;g++)l[g]=l[g-1]+t[g][n];const c=a[n],h=a.slice(-2),u=a.join();let d=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${u}), vec2(${h.join()}));
        }`;for(let g=1;g<l.length;g++){const m=l[g-1];d+=`
        if (${c} < ${l[g]}  && ${c} >= ${l[g-1]}) {
          return getChannel(
            getT${g}(${rw(a,c,m)}),
            vec2(${rw(h,c,m)}));
        }`}const p=l.length,f=l[l.length-1];d+=`
        return getChannel(
          getT${p}(${rw(a,c,f)}),
          vec2(${rw(h,c,f)}));`,this.userCode=`
      float getValue(${a.map(g=>"int "+g)}) {
        ${d}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${s[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${s[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${s[r-2]} &&
            ${o[r-1]} < ${s[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function rw(e,t,n){const s=e.indexOf(t);return e.map((i,o)=>o===s?`${i} - ${n}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iw(e){const{inputs:t,backend:n}=e,{input:s}=t,r=n.texData.get(s.dataId);return pi({inputs:{x:r.complexTensorInfos.imag},backend:n})}const y3e={kernelName:jT,backendName:"webgl",kernelFunc:iw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R0(e,t,n){const s=e[0].dtype;if(s==="complex64"){const p=e.map(v=>O0({inputs:{input:v},backend:n})),f=e.map(v=>iw({inputs:{input:v},backend:n})),g=R0(p,t,n),m=R0(f,t,n),y=Jc({inputs:{real:g,imag:m},backend:n});return p.forEach(v=>n.disposeIntermediateTensorInfo(v)),f.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),y}let r=n.shouldExecuteOnCPU(e);if(s==="string"&&(r=!0),r){const p=e.map(x=>{const w=Ae(x.shape.slice(t));return Ze({inputs:{x},backend:n,attrs:{shape:[-1,w]}})}),f=p.map(x=>({vals:n.readSync(x.dataId),shape:x.shape})),g=Xa(p.map(x=>x.shape),1),m=p[0].shape[0]===1,y=dke(f,g,s,m),v=Xa(e.map(x=>x.shape),t),b=n.makeTensorInfo(v,s,y);return p.forEach(x=>n.disposeIntermediateTensorInfo(x)),b}const i=e.filter(p=>Ae(p.shape)>0),o=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const p=o?new nl(e[0].shape,Qc):new Zc(e[0].shape,Qc);return n.runWebGLProgram(p,e,s)}const a=xe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const p=[];for(let g=0;g<i.length;g+=a){const m=i.slice(g,g+a);p.push(R0(m,t,n))}const f=R0(p,t,n);for(const g of p)n.disposeIntermediateTensorInfo(g);return f}if(o){const p=new g3e(i.map(f=>f.shape),t);return n.runWebGLProgram(p,i,s)}const{tensors2D:l,outShape:c}=v3e(i,t,n),h=new m3e(l.map(p=>p.shape)),u=n.runWebGLProgram(h,l,s);l.forEach(p=>n.disposeIntermediateTensorInfo(p));const d=Ze({inputs:{x:u},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(u),d}function v3e(e,t,n){const s=Xa(e.map(i=>i.shape),t);return{tensors2D:e.map(i=>Ze({inputs:{x:i},attrs:{shape:[-1,Ae(i.shape.slice(t))]},backend:n})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f5(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s,i=Ht(r,t[0].shape)[0],o=t.map(c=>c.shape);yA(o,i);const a=Xa(t.map(c=>c.shape),i);if(Ae(a)===0)return n.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(c=>Ae(c.shape)>0);return l.length===1?pi({inputs:{x:l[0]},backend:n}):R0(l,i,n)}const x3e={kernelName:Qx,backendName:"webgl",kernelFunc:f5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m5{constructor(t,n=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,c=t.strideWidth,h=t.dilationHeight,u=t.dilationWidth,d=t.filterHeight,p=t.filterWidth,f=Math.floor(t.inChannels/4)*4,g=t.inChannels%4,m=t.dataFormat==="channelsLast",y=m?1:2,v=m?2:3,b=m?3:1;let x="",w="";s&&(r?x=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?x=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:x=`
          float activation(float x) {
            ${s}
          }
        `,w="result = activation(result);");const S=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${v}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${h};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${u};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${S}
        ${w}
        setOutput(result);
      }
    `}}class b3e{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const n=t.padInfo.front,s=t.padInfo.top,r=t.padInfo.left,i=t.strideDepth,o=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,u=t.filterDepth,d=t.filterHeight,p=t.filterWidth,f=Math.floor(t.inChannels/4)*4,g=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${a});
      const ivec3 pads = ivec3(${n}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${u}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${h};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g5{constructor(t,n=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Tr(this.outputShape.length);const o=t.padInfo.left,a=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,h=t.filterWidth,u=h;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<h;m++)d+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;d+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let m=0;m<h;m++)d+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(u+1)/2;m++){const y=m*2;if(d+=`
           xC = xCCorner + ${y*l};
           `,a===1){if(y<h&&(o%2==1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,l===1&&y>0?d+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<h)){const v=o%2==0?pT(l):l;l%2==0&&o%2==1||l%2!=0&&o%2!=1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${v};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,l>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:d+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):v===1?d+=`
                     xC${y+1} = xTexelC${y};
                     `:d+=`
                     xCOffset = xC + ${v};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<h&&(o%2==1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<h&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<h&&(d+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<h&&(d+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<h&&(d+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let p="",f="";s&&(r?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:p=`vec4 activation(vec4 x) {
           ${s}
         }`,f="result = activation(result);");const g=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${f}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class w3e{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Tr(this.outputShape.length);const{dataFormat:s}=n,r=Cr(),i=s==="channelsLast",o=i?1:2,a=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let c="";for(let h=0;h<=1;h++)for(let u=0;u<=1;u++)c+=`
          blockIndex = rc.z + ${u};
          pos = rc.y + ${h};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${h*2+u}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${h*2+u}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ow(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function y5({x:e,filter:t,convInfo:n,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=e.shape,c=s.texData.get(e.dataId),h=n.inChannels,u=l[0]*l[1]*l[2],d=n.outChannels,p=n.dataFormat==="channelsLast",f=!1,g=!1;let m;const y=[];if(i!=null){const x=ow(i.shape,p);x!=null&&(i=Ze({inputs:{x:i},backend:s,attrs:{shape:x}}),y.push(i))}if(r!=null){const x=ow(r.shape,p);x!=null&&(r=Ze({inputs:{x:r},backend:s,attrs:{shape:x}}),y.push(r))}if(!((u===1||d===1)&&h>i5)&&c.isPacked&&p&&c.texture!=null&&l[2]%2!=0&&dn(c.shape.slice(-3),l.slice(-3))){const x=l[0]*l[1]*(l[2]+1),w={dataId:e.dataId,shape:[1,x,n.inChannels],dtype:e.dtype},S=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,W(Y1(c.shape,w.shape),()=>`packed reshape ${c.shape} to ${w.shape} isn't free`);const C=Ze({inputs:{x:t},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(C);const _=nw({a:w,b:C,backend:s,transposeA:f,transposeB:g,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),T=s.texData.get(_.dataId);W(T.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=S,T.shape=n.outShape,m=pi({inputs:{x:_},backend:s}),m.shape=n.outShape,y.push(_)}else{const x=n.outHeight*n.outWidth,w=Ze({inputs:{x:e},backend:s,attrs:{shape:p?[n.batchSize,x,n.inChannels]:[n.batchSize,n.inChannels,x]}}),S=Ze({inputs:{x:t},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}}),C=nw({a:p?w:S,b:p?S:w,transposeA:!p,transposeB:g,backend:s,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o});m=Ze({inputs:{x:C},backend:s,attrs:{shape:n.outShape}}),y.push(w),y.push(S),y.push(C)}for(const x of y)s.disposeIntermediateTensorInfo(x);return m}function v5({x:e,filter:t,convInfo:n,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:h,outWidth:u,outHeight:d,dataFormat:p}=n,f=p==="channelsLast",g=l*c*h,m=d*u,y=[n.batchSize,g,m],v=!0,b=!1,x=[];if(i!=null){const M=ow(i.shape,f);M!=null&&(i=Ze({inputs:{x:i},backend:s,attrs:{shape:M}}),x.push(i))}if(r!=null){const M=ow(r.shape,f);M!=null&&(r=Ze({inputs:{x:r},backend:s,attrs:{shape:M}}),x.push(r))}const w=Ze({inputs:{x:t},backend:s,attrs:{shape:[1,g,Ae(t.shape)/g]}});x.push(w);const S=new w3e(y,n),C=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],_=s.runWebGLProgram(S,[e],"float32",C),T=Ze({inputs:{x:_},backend:s,attrs:{shape:y}});x.push(_),x.push(T);const E=r!=null,A=i!=null,D=a==="leakyrelu",O=a?M0(a,!0):null,P=new e5(f?T.shape:w.shape,f?w.shape:T.shape,f?[n.batchSize,m,n.outChannels]:[n.batchSize,n.outChannels,m],v,b,E,O,A,D),L=f?[T,w]:[w,T];if(r&&L.push(r),A&&L.push(i),D){const M=s.makeTensorInfo([],"float32",Mc(o,"float32"));L.push(M),x.push(M)}const B=s.runWebGLProgram(P,L,"float32"),F=Ze({inputs:{x:B},backend:s,attrs:{shape:n.outShape}});x.push(B);for(const M of x)s.disposeIntermediateTensorInfo(M);return F}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S3e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:h}=s,u=Dl(l),d=Qs(r.shape,i.shape,o,c,a,h,!1,u);let p;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))p=y5({x:r,filter:i,convInfo:d,backend:n});else if(d.strideWidth<=2&&u==="channelsLast"&&xe().getBool("WEBGL_EXP_CONV")){const g=new g5(d),m=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(g,[r,i],"float32",m)}else if(xe().getBool("WEBGL_CONV_IM2COL"))p=v5({x:r,filter:i,convInfo:d,backend:n});else{const g=new m5(d);p=n.runWebGLProgram(g,[r,i],"float32")}const f=Ze({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}const _3e={kernelName:Zx,backendName:"webgl",kernelFunc:S3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C3e{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideHeight,s=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,o=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              if (${o}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class T3e{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,s=t.filterWidth,r=t.strideHeight,i=t.strideWidth,o=t.dataFormat==="channelsLast",a=n-1-t.padInfo.top,l=s-1-t.padInfo.left,c=o?1:2,h=o?2:3,u=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${u}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${h}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class E3e{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideDepth,s=t.strideHeight,r=t.strideWidth,i=t.padInfo.front,o=t.padInfo.top,a=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${i};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class A3e{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterDepth,s=t.filterHeight,r=t.filterWidth,i=t.strideDepth,o=t.strideHeight,a=t.strideWidth,l=n-1-t.padInfo.front,c=s-1-t.padInfo.top,h=r-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I3e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:h}=s,u=Dl(l),d=Qs(r.shape,h,o,1,a,c,!1,u),p=new C3e(d);return n.runWebGLProgram(p,[r,i],"float32")}const N3e={kernelName:kT,backendName:"webgl",kernelFunc:I3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k3e(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:h}=s,u=Dl(c),d=Qs(o,i.shape,a,1,l,h,!1,u),p=new T3e(d);return n.runWebGLProgram(p,[r,i],"float32")}const D3e={kernelName:Jx,backendName:"webgl",kernelFunc:k3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M3e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l}=s,c=Lc(r.shape,i.shape,o,l,a),h=new b3e(c);return n.runWebGLProgram(h,[r,i],"float32")}const P3e={kernelName:eb,backendName:"webgl",kernelFunc:M3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O3e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:i}=t,{strides:o,pad:a,filterShape:l}=s,c=Lc(r.shape,l,o,1,a),h=new E3e(c);return n.runWebGLProgram(h,[r,i],"float32")}const R3e={kernelName:DT,backendName:"webgl",kernelFunc:O3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L3e(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:i}=t,{pad:o,strides:a,inputShape:l}=s,c=Lc(l,i.shape,a,1,o),h=new A3e(c);return n.runWebGLProgram(h,[r,i],"float32")}const F3e={kernelName:MT,backendName:"webgl",kernelFunc:L3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $3e=nf+`
  return cos(x);
`,B3e=en({opSnippet:$3e}),z3e={kernelName:og,backendName:"webgl",kernelFunc:B3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U3e=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,V3e=en({opSnippet:U3e}),G3e={kernelName:ag,backendName:"webgl",kernelFunc:V3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class W3e{constructor(t,n,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=t,[h]=n,[u,d]=s;this.outputShape=[h,u,d,c];const p=r==="bilinear"?1:0,[f,g]=[`${a-1}.0`,`${l-1}.0`],[m,y,v]=u>1?[`${(a-1)/(u-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[b,x,w]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${x};

        float in_y = ${v};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${w};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H3e=e=>{const{inputs:t,backend:n,attrs:s}=e,{image:r,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=s,h=new W3e(r.shape,i.shape,a,l,c);return n.runWebGLProgram(h,[r,i,o],"float32")},j3e={kernelName:OT,backendName:"webgl",kernelFunc:H3e};var L0;(function(e){e.Prod="*",e.Sum="+"})(L0||(L0={}));class x5{constructor(t,n,s,r){this.op=t,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===L0.Prod?"1.0":"0.0",a=s?o:`getX(${b5(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",h="";s?(c=r?`end != ${l-1}`:"end != 0",h=r?"end + 1":"end - 1"):(c=r?`end + pow2 < ${l}`:"end >= pow2",h=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Mn(i)} coords = getOutputCoords();
        int end = ${w5(i,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${h};
          ${w5(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${b5(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function b5(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function w5(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S5(e,t,n,s,r,i){const o=t.shape.length,a=Yn([s],o);let l=t;a!=null&&(l=Ar({inputs:{x:t},backend:n,attrs:{perm:a}}));const c=cs(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const h=l.shape[c];let u=pi({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(h))-1;d++){const p=new x5(e,l.shape,!1,i),f=[[d]],g=u;u=n.runWebGLProgram(p,[u],u.dtype,f),n.disposeIntermediateTensorInfo(g)}if(r){const d=new x5(e,l.shape,r,i),p=u;u=n.runWebGLProgram(d,[u],u.dtype),n.disposeIntermediateTensorInfo(p)}if(a!=null){const d=Fc(a),p=Ar({inputs:{x:u},backend:n,attrs:{perm:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),p}return u}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q3e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,exclusive:o,reverse:a}=s;return S5(L0.Prod,r,n,i,o,a)}const X3e={kernelName:PT,backendName:"webgl",kernelFunc:q3e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K3e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,exclusive:o,reverse:a}=s;return S5(L0.Sum,r,n,i,o,a)}const Y3e={kernelName:tb,backendName:"webgl",kernelFunc:K3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q3e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:i}=t,{size:o,binaryOutput:a}=s;if(r.shape.length===1){const l=n.readSync(r.dataId),c=n.readSync(i.dataId),h=UW(l,c,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,h)}else if(r.shape.length===2){const l=n.bufferSync(r),c=n.bufferSync(i),h=cke(l,c,o,a);return n.makeTensorInfo(h.shape,i.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Z3e={kernelName:RT,backendName:"webgl",kernelFunc:Q3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class J3e{constructor(t,n,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=n,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ePe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockSize:i,dataFormat:o}=s,a=r.shape[0],l=o==="NHWC"?r.shape[1]:r.shape[2],c=o==="NHWC"?r.shape[2]:r.shape[3],h=o==="NHWC"?r.shape[3]:r.shape[1],u=l*i,d=c*i,p=h/(i*i),f=o==="NHWC"?[a,u,d,p]:[a,p,u,d],g=new J3e(f,i,o);return n.runWebGLProgram(g,[r],r.dtype)}const tPe={kernelName:LT,backendName:"webgl",kernelFunc:ePe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _5{constructor(t,n=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Tr(this.outputShape.length);const o=t.filterHeight,a=t.filterWidth,l=t.outChannels/t.inChannels;let c="",h="";s&&(r?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:c=`
          float activation(float x) {
            ${s}
          }
        `,h="result = activation(result);");const u=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${u}
        ${h}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C5{constructor(t,n=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Tr(this.outputShape.length);const o=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,c=t.dilationWidth,h=t.filterHeight,u=t.filterWidth,d=u;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<u;y++)p+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;p+=`
    for (int r = 0; r < ${h}; r++) {
      `;for(let y=0;y<u;y++)p+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(d+1)/2;y++){const v=y*2;if(p+=`
          xC = xCCorner + ${v*c};
          `,l===1){if(v<u&&(a%2==1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }
              `,c===1&&v>0?p+=`
                xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                  } else {
                    xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xC${v} = xTexelC${v};
                `,v+1<u)){const b=a%2==0?pT(c):c;c%2==0&&a%2==1||c%2!=0&&a%2!=1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                    xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${v+1}.zw = vec2(0.0);
                    }
                    xTexelC${v+1}Ready = 1;
                  }
                  `,c>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                    } else {
                     xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                    }
                    `:p+=`
                    xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                    `):b===1?p+=`
                    xC${v+1} = xTexelC${v};
                    `:p+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                      xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${v+1}.zw = vec2(0.0);
                      }
                      xTexelC${v+1}Ready = 1;
                    }

                    xC${v+1} = xTexelC${v+1};
                    `}}else v<u&&(a%2==1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.0);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
              `,v+1<u&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(
                  xTexelC${v}.xy, xTexelC${v+1}.xy);
              `,v+1<u&&(p+=`
                  xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                `)));v<u&&(p+=`
            wTexel = getW(r, ${v}, d1, q);
            dotProd += xC${v} * vec4(wTexel.xz, wTexel.xz);
          `,v+1<u&&(p+=`
              wTexel = getW(r, ${v+1}, d1, q);
              dotProd += xC${v+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",g="";s&&(r?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:f=`vec4 activation(vec4 x) {
          ${s}
        }`,g="result = activation(result);");const m=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nPe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=s;let h=l;h==null&&(h=[1,1]),W(cr(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const u=Qs(r.shape,i.shape,o,h,a,c,!0);let d;xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&u.strideWidth<=2&&u.outChannels/u.inChannels==1?d=new C5(u):d=new _5(u);const p=[[u.padInfo.top,u.padInfo.left],[u.strideHeight,u.strideWidth],[u.dilationHeight,u.dilationWidth],[u.inHeight,u.inWidth]];return n.runWebGLProgram(d,[r,i],"float32",p)}const sPe={kernelName:nb,backendName:"webgl",kernelFunc:nPe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rPe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideHeight,s=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,o=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class iPe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,s=t.filterWidth,r=t.strideHeight,i=t.strideWidth,o=n-1-t.padInfo.top,a=s-1-t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oPe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:h}=s,u=Qs(r.shape,h,o,a,l,c,!0),d=new rPe(u);return n.runWebGLProgram(d,[r,i],"float32")}const aPe={kernelName:FT,backendName:"webgl",kernelFunc:oPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lPe(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:h}=s,u=Qs(h,i.shape,o,a,l,c,!0),d=new iPe(u);return n.runWebGLProgram(d,[r,i],"float32")}const cPe={kernelName:$T,backendName:"webgl",kernelFunc:lPe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uPe{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hPe(e){const{inputs:t,backend:n}=e,{x:s}=t,r=[...s.shape,...s.shape],i=Ae(s.shape),o=Ze({inputs:{x:s},backend:n,attrs:{shape:[i]}}),a=new uPe(i),l=n.runWebGLProgram(a,[o],o.dtype),c=Ze({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}const dPe={kernelName:O$,backendName:"webgl",kernelFunc:hPe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pPe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:n,inWidth:s,padInfo:r,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:h}=t,{top:u,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${u}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${h};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fPe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i}=t,{strides:o,pad:a,dilations:l}=s,c=Kg(r.shape,i.shape,o,a,"NHWC",l);let h;const u=new pPe(c);h=n.runWebGLProgram(u,[r,i],"float32");const d=Ze({inputs:{x:h},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(h),d}const mPe={kernelName:sb,backendName:"webgl",kernelFunc:fPe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gPe(e){const{inputs:t,backend:n,attrs:s}=e,{equation:r}=s,i=t,{allDims:o,summedDims:a,idDims:l}=kA(r,i.length);MA(o.length,l,i);const{path:c,steps:h}=PA(a,l),u=h.length;let d=null,p=o.length;const f=[];for(let g=0;g<u;++g){for(const m of h[g]){const{permutationIndices:y,expandDims:v}=DA(p,l[m]);let b;OA(y)?b=i[m]:(b=Ar({inputs:{x:i[m]},backend:n,attrs:{perm:y}}),f.push(b));const x=b.shape.slice();for(let w=0;w<v.length;++w)x.splice(v[w],0,1);dn(b.shape,x)||(b=Ze({inputs:{x:b},backend:n,attrs:{shape:x}}),f.push(b)),d===null?d=b:(d=HI({inputs:{a:b,b:d},backend:n}),f.push(d))}g<u-1&&(c[g]>=0&&(d=tw({inputs:{x:d},backend:n,attrs:{axis:c[g]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}const yPe={kernelName:R$,backendName:"webgl",kernelFunc:gPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vPe="return (x >= 0.0) ? x : (exp(x) - 1.0);",xPe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,bPe=en({opSnippet:vPe,packedOpSnippet:xPe}),wPe={kernelName:cg,backendName:"webgl",kernelFunc:bPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SPe="return (b >= 1.0) ? a : a * (b + 1.0);",_Pe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,CPe=e=>{const{inputs:t,backend:n}=e,{dy:s,y:r}=t,i=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new D0(_Pe,s.shape,r.shape):new tf(SPe,s.shape,r.shape);return n.runWebGLProgram(i,[s,r],s.dtype)},TPe={kernelName:UT,backendName:"webgl",kernelFunc:CPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EPe=`
  return vec4(equal(a, b));
`,APe="return float(a == b);",IPe=er({opSnippet:APe,packedOpSnippet:EPe,dtype:"bool",cpuKernelImpl:pke}),NPe={kernelName:rb,backendName:"webgl",kernelFunc:IPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kPe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${SA};
  float a1 = ${_A};
  float a2 = ${CA};
  float a3 = ${TA};
  float a4 = ${EA};
  float a5 = ${AA};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,DPe=en({opSnippet:kPe}),MPe={kernelName:ug,backendName:"webgl",kernelFunc:DPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PPe=nf+`
  return exp(x);
`,OPe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,T5=en({opSnippet:PPe,packedOpSnippet:OPe,cpuKernelImpl:fke,dtype:"float32"}),RPe={kernelName:hg,backendName:"webgl",kernelFunc:T5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KI(e){const{inputs:t,attrs:n,backend:s}=e,{dim:r}=n,{input:i}=t,o=i.shape.length,a=i.shape.slice();let l=r;return r<0&&(W(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),Ze({inputs:{x:i},backend:s,attrs:{shape:a}})}const LPe={kernelName:ib,backendName:"webgl",kernelFunc:KI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E5="return exp(x) - 1.0;",FPe=en({opSnippet:E5,packedOpSnippet:E5,cpuKernelImpl:mke}),$Pe={kernelName:dg,backendName:"webgl",kernelFunc:FPe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A5{constructor(t,n,s){this.variableNames=["real","imag"];const r=n[1];this.outputShape=n;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${r}.0`:"1.0";let a;if(t==="real")a="return real * expR - imag * expI;";else if(t==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I5(e,t,n){const s=n.texData.get(e.dataId),r=Ae(e.shape),i=e.shape[e.shape.length-1],o=r/i,a=Ze({inputs:{x:e},backend:n,attrs:{shape:[o,i]}}),l=a.shape,c=new A5("real",l,t),h=new A5("imag",l,t),u=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],d=n.runWebGLProgram(c,u,"float32"),p=n.runWebGLProgram(h,u,"float32"),f=Jc({inputs:{real:d,imag:p},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p);const g=Ze({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(f),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BPe(e){const{inputs:t,backend:n}=e,{input:s}=t;return I5(s,!1,n)}const zPe={kernelName:VT,backendName:"webgl",kernelFunc:BPe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UPe{constructor(t,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F0(e){const{backend:t,attrs:n}=e,{shape:s,value:r}=n;let{dtype:i}=n;if(i=i||Km(r),i==="string"){const o=gs(i,Ae(s));return o.fill(r),t.makeTensorInfo(s,i,o)}else{const o=new UPe(s,r),a=[[r]];return t.runWebGLProgram(o,[],i,a)}}const VPe={kernelName:GT,backendName:"webgl",kernelFunc:F0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GPe{constructor(t){this.variableNames=["Image"],this.outputShape=[];const n=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WPe={kernelName:WT,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,s=t,r=new GPe(n.shape);return s.runWebGLProgram(r,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N5="return floor(x);",HPe=en({opSnippet:N5,packedOpSnippet:N5,cpuKernelImpl:gke}),jPe={kernelName:pg,backendName:"webgl",kernelFunc:HPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qPe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,XPe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,KPe=er({opSnippet:qPe,packedOpSnippet:XPe,dtype:"int32"}),YPe={kernelName:fg,backendName:"webgl",kernelFunc:KPe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QPe{constructor(t){this.variableNames=["A"];const n=Cr(),[s,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZPe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=Cr(),[s,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JPe={kernelName:$fe,backendName:"webgl",kernelFunc:eOe};let rf,YI=xe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function eOe(e){const{inputs:t,backend:n,attrs:s}=e;let{pixels:r}=t;const{numChannels:i}=s,o=typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement,[l,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],h=[c,l],u=[c,l,i];if(a||o){const g=xe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(rf==null||g!==YI)&&(YI=g,rf=document.createElement("canvas").getContext("2d",{willReadFrequently:YI})),rf.canvas.width=l,rf.canvas.height=c,rf.drawImage(r,0,0,l,c),r=rf.canvas}const d=n.makeTensorInfo(h,"int32");n.texData.get(d.dataId).usage=Bi.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),r);const p=xe().getBool("WEBGL_PACK")?new ZPe(u):new QPe(u),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tOe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:h,dilations:u,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,g=Dl(h),m=Qs(r.shape,i.shape,l,u,c,d,!1,g);let y;const v=[],b=o!=null,x=a!=null,w=p==="leakyrelu",S=()=>{const _=[r,i],T=(E,A)=>{if(A==="NCHW"&&E.shape.length===1&&E.shape[0]!==1){const D=Ze({inputs:{x:E},backend:n,attrs:{shape:[E.shape[0],1,1]}});return v.push(D),D}return E};if(b&&_.push(T(o,h)),x&&_.push(T(a,h)),w){const E=n.makeTensorInfo([],"float32",Mc(f,"float32"));_.push(E),v.push(E)}return _};if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))y=y5({x:r,filter:i,convInfo:m,backend:n,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else if(m.strideWidth<=2&&g==="channelsLast"&&xe().getBool("WEBGL_EXP_CONV")){const _=p?M0(p,!0):null,T=new g5(m,b,_,x,w),E=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],A=S();y=n.runWebGLProgram(T,A,"float32",E)}else if(xe().getBool("WEBGL_CONV_IM2COL"))y=v5({x:r,filter:i,convInfo:m,backend:n,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const _=p?M0(p,!1):null,T=new m5(m,b,_,x,w),E=S();y=n.runWebGLProgram(T,E,"float32")}const C=Ze({inputs:{x:y},backend:n,attrs:{shape:m.outShape}});return v.push(y),v.forEach(_=>n.disposeIntermediateTensorInfo(_)),C}const nOe={kernelName:Wb,backendName:"webgl",kernelFunc:tOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sOe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dilations:h,dimRoundingMode:u,activation:d,leakyreluAlpha:p}=s,f=[];let g=h;g==null&&(g=[1,1]),W(cr(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const m=Qs(r.shape,i.shape,l,g,c,u,!0),y=xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels==1,v=d?M0(d,y):null,b=[r,i],x=o!=null,w=a!=null,S=d==="leakyrelu";if(x&&b.push(o),w&&b.push(a),S){const E=n.makeTensorInfo([],"float32",Mc(p,"float32"));b.push(E),f.push(E)}let C;y?C=new C5(m,x,v,w,S):C=new _5(m,x,v,w,S);const _=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],T=n.runWebGLProgram(C,b,"float32",_);return f.forEach(E=>n.disposeIntermediateTensorInfo(E)),T}const rOe={kernelName:J$,backendName:"webgl",kernelFunc:sOe};class iOe{constructor(t,n,s,r){this.sliceDim=t,this.strides=n,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=Mn(s.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oOe(e){const{inputs:t,backend:n}=e,{params:s,indices:r}=t,i=r.shape,o=i[i.length-1],a=Ae(s.shape),[l,c,h,u]=uA(s,r),d=Ze({inputs:{x:r},backend:n,attrs:{shape:[c,o]}}),p=Ze({inputs:{x:s},backend:n,attrs:{shape:[Ae(s.shape)/h,h]}});if(n.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const y=n.readSync(r.dataId),v=n.bufferSync(s),b=yke(y,v,s.dtype,c,o,h,u,s.shape,a);return n.makeTensorInfo(l,s.dtype,b.values)}const f=new iOe(o,u,[c,h],s.shape),g=n.runWebGLProgram(f,[p,d],p.dtype),m=Ze({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),m}const aOe={kernelName:L$,backendName:"webgl",kernelFunc:oOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lOe{constructor(t,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const s=Mn(this.rank),r=cOe(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function cOe(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<e.length;r++)r===2?s.push("index"):s.push(`${n[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k5(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,indices:i}=t,{axis:o,batchDims:a}=s,l=Ht(o,r.shape)[0];if(xe().get("DEBUG")){const v=n.readSync(i.dataId),b=r.shape[l];for(let x=0;x<v.length;++x){const w=v[x];W(w<=b-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${b-1}]`)}}const c=FA(r,i,l,a),h=Ae(i.shape),u=[],d=Ze({inputs:{x:r},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=Ze({inputs:{x:i},backend:n,attrs:{shape:[c.batchSize,h/c.batchSize]}});u.push(d),u.push(p);const f=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const v=n.bufferSync(p),b=n.bufferSync(d),x=vke(b,v,f);return u.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.makeTensorInfo(c.outputShape,x.dtype,x.values)}const g=new lOe(d.shape,f),m=n.runWebGLProgram(g,[d,p],d.dtype);u.push(m);const y=Ze({inputs:{x:m},backend:n,attrs:{shape:c.outputShape}});return u.forEach(v=>n.disposeIntermediateTensorInfo(v)),y}const uOe={kernelName:ab,backendName:"webgl",kernelFunc:k5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hOe="return float(a > b);",dOe=`
  return vec4(greaterThan(a, b));
`,pOe=er({opSnippet:hOe,packedOpSnippet:dOe,cpuKernelImpl:xke,dtype:"bool"}),fOe={kernelName:lb,backendName:"webgl",kernelFunc:pOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mOe="return float(a >= b);",gOe=`
  return vec4(greaterThanEqual(a, b));
`,yOe=er({opSnippet:mOe,packedOpSnippet:gOe,dtype:"bool",cpuKernelImpl:bke}),vOe={kernelName:mg,backendName:"webgl",kernelFunc:yOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xOe(e){const{inputs:t,backend:n}=e,{input:s}=t;return I5(s,!0,n)}const bOe={kernelName:HT,backendName:"webgl",kernelFunc:xOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wOe="return float(!isnan(x) && !isinf(x));",SOe=en({opSnippet:wOe,dtype:"bool"}),_Oe={kernelName:yg,backendName:"webgl",kernelFunc:SOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const COe="return float(isinf(x));",TOe=en({opSnippet:COe,dtype:"bool"}),EOe={kernelName:vg,backendName:"webgl",kernelFunc:TOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AOe="return float(isnan(x));",IOe=en({opSnippet:AOe,dtype:"bool"}),NOe={kernelName:xg,backendName:"webgl",kernelFunc:IOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kOe="return float(a < b);",DOe=`
  return vec4(lessThan(a, b));
`,MOe=er({opSnippet:kOe,packedOpSnippet:DOe,cpuKernelImpl:wke,dtype:"bool"}),POe={kernelName:ub,backendName:"webgl",kernelFunc:MOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OOe="return float(a <= b);",ROe=`
  return vec4(lessThanEqual(a, b));
`,LOe=er({opSnippet:OOe,packedOpSnippet:ROe,cpuKernelImpl:Ske,dtype:"bool"}),FOe={kernelName:hb,backendName:"webgl",kernelFunc:LOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Oe(e){const{backend:t,attrs:n}=e,{start:s,stop:r,num:i}=n,o=_ke(s,r,i);return t.makeTensorInfo([o.length],"float32",o)}const BOe={kernelName:F$,backendName:"webgl",kernelFunc:$Oe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zOe=nf+`
  return x < 0.0 ? 0./0. : log(x);
`,UOe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,VOe=en({opSnippet:zOe,packedOpSnippet:UOe,cpuKernelImpl:Cke}),GOe={kernelName:bg,backendName:"webgl",kernelFunc:VOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WOe=nf+`
  return log(1.0 + x);
`,HOe=en({opSnippet:WOe}),jOe={kernelName:wg,backendName:"webgl",kernelFunc:HOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qOe="return float(a >= 1.0 && b >= 1.0);",XOe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,KOe=er({opSnippet:qOe,packedOpSnippet:XOe,dtype:"bool"}),YOe={kernelName:db,backendName:"webgl",kernelFunc:KOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QOe="return float(!(x >= 1.0));",ZOe=en({opSnippet:QOe}),JOe={kernelName:pb,backendName:"webgl",kernelFunc:ZOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eRe="return float(a >= 1.0 || b >= 1.0);",tRe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,nRe=er({opSnippet:eRe,packedOpSnippet:tRe,dtype:"bool"}),sRe={kernelName:fb,backendName:"webgl",kernelFunc:nRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rRe{constructor(t,n,s,r,i){this.variableNames=["x"],this.outputShape=[];const o=n,a=t[3]-1;this.outputShape=t;let l;const c=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iRe{constructor(t,n,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=n,a=t[3]-1;this.outputShape=t;let l;const c=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oRe=e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=s,c=xe().getBool("WEBGL_PACK_NORMALIZATION")?new iRe(r.shape,i,o,a,l):new rRe(r.shape,i,o,a,l);return n.runWebGLProgram(c,[r],r.dtype)},aRe={kernelName:mb,backendName:"webgl",kernelFunc:oRe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lRe{constructor(t,n,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=n,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cRe=e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:h}=s,u=new lRe(r.shape,a,l,c,h);return n.runWebGLProgram(u,[r,i,o],r.dtype)},uRe={kernelName:qT,backendName:"webgl",kernelFunc:cRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hRe(e,t,n,s){const r=Ae(t),o=Ae(e.shape)/r,a=Ze({inputs:{x:e},attrs:{shape:[o,r]},backend:s}),l=Ph(a,e.dtype,"max",s),c=Ze({inputs:{x:l},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D5(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reductionIndices:i,keepDims:o}=s,a=r.shape.length,l=Ht(i,r.shape);let c=l;const h=Yn(c,a),u=h!=null,d=n.shouldExecuteOnCPU([r]);let p=r;if(u){if(d){const b=n.texData.get(p.dataId).values,x=new Array(a);for(let C=0;C<x.length;C++)x[C]=r.shape[h[C]];const w=GI(b,r.shape,r.dtype,h,x);p=n.makeTensorInfo(x,r.dtype);const S=n.texData.get(p.dataId);S.values=w}else p=ew(r,h,n);c=cs(c.length,a)}Zs("max",c,a);const[f,g]=$s(p.shape,c);let m=f;o&&(m=vs(f,l));let y;if(d){const b=n.texData.get(p.dataId).values,x=Tke(b,Ae(g),m,r.dtype);y=n.makeTensorInfo(m,r.dtype);const w=n.texData.get(y.dataId);w.values=x}else y=hRe(p,g,m,n);return u&&n.disposeIntermediateTensorInfo(p),y}const dRe={kernelName:gb,backendName:"webgl",kernelFunc:D5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pRe=WI+`
  return max(a, b);
`,fRe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+k0+`
  return result;
`,mRe=er({opSnippet:pRe,packedOpSnippet:fRe,cpuKernelImpl:Eke}),gRe={kernelName:Sg,backendName:"webgl",kernelFunc:mRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yRe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;I0(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=1;W(cr(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=uo(r.shape,i,o,c,a,l);if(h.filterWidth===1&&h.filterHeight===1&&dn(h.inShape,h.outShape))return pi({inputs:{x:r},backend:n});const u=new P0(h,"max",!1);return n.runWebGLProgram(u,[r],r.dtype)}const vRe={kernelName:yb,backendName:"webgl",kernelFunc:yRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xRe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=s,h=[1,1,1],u=kl(r.shape,i,o,h,a,c,l),d=new jI(u,"max",!1);return n.runWebGLProgram(d,[r],r.dtype)}const bRe={kernelName:vb,backendName:"webgl",kernelFunc:xRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wRe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const n=t.strideHeight,s=t.strideWidth,r=t.dilationHeight,i=t.effectiveFilterHeight,o=t.effectiveFilterWidth,a=i-1-t.padInfo.top,l=o-1-t.padInfo.left,c=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class SRe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const n=t.strideDepth,s=t.strideHeight,r=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,a=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,u=l-1-t.padInfo.front,d=c-1-t.padInfo.top,p=h-1-t.padInfo.left,f=l*c*h-1;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${h} +
                  wR * ${h} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Re(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i}=t,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:h}=s,u=[1,1,1],d=kl(o.shape,a,l,u,c,h),p=new jI(d,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),g=new SRe(d),m=n.runWebGLProgram(g,[r,f],o.dtype);return n.disposeIntermediateTensorInfo(f),m}const CRe={kernelName:KT,backendName:"webgl",kernelFunc:_Re};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TRe(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i,output:o}=t,a=i;I0([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:h,dimRoundingMode:u}=s,d=uo(a.shape,l,c,1,h,u),p=!0,f=new P0(d,"max",p),g=n.runWebGLProgram(f,[a],a.dtype),m=new wRe(d),y=n.runWebGLProgram(m,[r,g],a.dtype);return n.disposeIntermediateTensorInfo(g),y}const ERe={kernelName:XT,backendName:"webgl",kernelFunc:TRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ARe(e,t,n,s){let r=new P0(n,"max",!1);const i=s.runWebGLProgram(r,[e],"float32");r=new P0(n,"max",!0,!0,t);const o=s.runWebGLProgram(r,[e],"float32");return[i,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IRe={kernelName:$$,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:s}=e,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=t,l=n;W(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];W(cr(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=uo(s.shape,r,i,c,o),[u,d]=ARe(s,a,h,l);return[u,d]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NRe(e,t,n,s){const r=Ae(t),o=Ae(e.shape)/r,a=Ze({inputs:{x:e},attrs:{shape:[o,r]},backend:s}),l=Ph(a,"float32","mean",s),c=Ze({inputs:{x:l},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kRe={kernelName:xb,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:s}=e,{keepDims:r,axis:i}=t,o=n,a=s.shape.length,l=Ht(i,s.shape);let c=l;const h=Yn(c,a),u=h!=null,d=o.shouldExecuteOnCPU([s]),p=[];let f=s;if(u){if(d){const x=o.texData.get(f.dataId).values,w=new Array(a);for(let _=0;_<w.length;_++)w[_]=s.shape[h[_]];const S=GI(x,s.shape,s.dtype,h,w);f=o.makeTensorInfo(w,s.dtype);const C=o.texData.get(f.dataId);C.values=S}else f=ew(s,h,o);p.push(f),c=cs(c.length,a)}Zs("sum",c,a);const[g,m]=$s(f.shape,c);let y=g;r&&(y=vs(g,l));const v=NRe(f,m,y,o);for(const b of p)o.disposeIntermediateTensorInfo(b);return v}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DRe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:o}=s,a=r.shape.length,l=Ht(i,r.shape);let c=l;const h=Yn(c,a);let u=r;h!=null&&(u=Ar({inputs:{x:r},backend:n,attrs:{perm:h}}),c=cs(c.length,r.shape.length)),Zs("min",c,a);const[d,p]=$s(u.shape,c),f=Ae(p),g=Ze({inputs:{x:u},backend:n,attrs:{shape:[-1,f]}}),m=Ph(g,g.dtype,"min",n);let y;if(o){const v=vs(d,l);y=Ze({inputs:{x:m},backend:n,attrs:{shape:v}})}else y=Ze({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),h!=null&&n.disposeIntermediateTensorInfo(u),y}const MRe={kernelName:bb,backendName:"webgl",kernelFunc:DRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PRe=WI+`
  return min(a, b);
`,ORe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+k0+`
  return result;
`,RRe=er({opSnippet:PRe,packedOpSnippet:ORe,cpuKernelImpl:Ake}),LRe={kernelName:_g,backendName:"webgl",kernelFunc:RRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FRe{constructor(t,n,s){this.variableNames=["x"],this.outputShape=n.map((h,u)=>h[0]+t[u]+h[1]);const r=t.length,i=Mn(r),o=n.map(h=>h[0]).join(","),a=n.map((h,u)=>h[0]+t[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $Re{constructor(t,n,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((f,g)=>f[0]+t[g]+f[1]);const r=t.length,i=Mn(r),o=n.map(f=>f[0]).join(","),a=n.map((f,g)=>f[0]+t[g]).join(","),l=Er("rc",r),c=Er("source",r),h=`${l[r-1]} < ${this.outputShape[r-1]}`,u=r===1?"source":`vec2(${c.slice(-2).join()})`,d=s==="reflect"?0:1;let p="";if(r===1){const f=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${i} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${u});
        ${l[r-1]} += 1;
        if(${h}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${u});
        }
      `}else{const f=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${i} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${u});
        ${l[r-1]} += 1;
        if(${h}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${u});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${f}
          result[2] = getChannel(getX(${c.join()}), ${u});
          ${l[r-1]} += 1;
          if(${h}) {
            ${f}
            result[3] = getChannel(getX(${c.join()}), ${u});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BRe=({inputs:e,backend:t,attrs:n})=>{const{x:s}=e,{paddings:r,mode:i}=n,o=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $Re(s.shape,r,i):new FRe(s.shape,r,i);return t.runWebGLProgram(o,[s],s.dtype)},zRe={kernelName:wb,backendName:"webgl",kernelFunc:BRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const URe=`if (b == 0.0) return NAN;
  return mod(a, b);`,VRe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+k0+`
  return result;
`,GRe=er({opSnippet:URe,packedOpSnippet:VRe}),WRe={kernelName:Cg,backendName:"webgl",kernelFunc:GRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HRe{constructor(t,n,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jRe=`
if (a == b) {
  return 1.0;
};
return a / b;`,qRe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,M5=er({opSnippet:jRe,packedOpSnippet:qRe,checkOutOfBounds:!0}),XRe={kernelName:lg,backendName:"webgl",kernelFunc:M5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P5="return a - b;",O5=er({opSnippet:P5,packedOpSnippet:P5,supportsComplex:!0,cpuKernelImpl:qke}),KRe={kernelName:zg,backendName:"webgl",kernelFunc:O5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R5(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{dim:i}=s,o=Ht([i],r.shape),a=D5({inputs:{x:r},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=vs(a.shape,o),c=Ze({inputs:{x:a},backend:n,attrs:{shape:l}}),h=O5({inputs:{a:r,b:c},backend:n}),u=T5({inputs:{x:h},backend:n}),d=tw({inputs:{x:u},backend:n,attrs:{axis:o,keepDims:!1}}),p=Ze({inputs:{x:d},backend:n,attrs:{shape:l}}),f=M5({inputs:{a:u,b:p},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const YRe={kernelName:Bb,backendName:"webgl",kernelFunc:R5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QRe(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{numSamples:i,seed:o,normalized:a}=s,l=a?r:R5({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),c=l.shape[0],h=l.shape[1],u=new HRe(c,h,i),d=[[o]],p=n.runWebGLProgram(u,[l],"int32",d);return a||n.disposeIntermediateTensorInfo(l),p}const ZRe={kernelName:B$,backendName:"webgl",kernelFunc:QRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JRe=bo+`
  return -x;
`,eLe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function tLe(e){const{inputs:t,backend:n}=e,{x:s}=t;if(n.shouldExecuteOnCPU([s])){const i=n.texData.get(s.dataId),[o,a]=Nke(i.values,s.shape,s.dtype);return n.makeTensorInfo(a,s.dtype,o)}let r;return xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Zc(s.shape,eLe):r=new nl(s.shape,JRe),n.runWebGLProgram(r,[s],s.dtype)}const nLe={kernelName:Sb,backendName:"webgl",kernelFunc:tLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sLe=rA;function rLe(e){Mi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s,c=n.readSync(r.dataId),h=n.readSync(i.dataId),{selectedIndices:u}=sLe(c,h,o,a,l);return n.makeTensorInfo([u.length],"int32",new Int32Array(u))}const iLe={kernelName:YT,backendName:"webgl",kernelFunc:rLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oLe=iA;function aLe(e){Mi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=s,h=n.readSync(r.dataId),u=n.readSync(i.dataId),{selectedIndices:d,validOutputs:p}=oLe(h,u,o,a,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}const lLe={kernelName:QT,backendName:"webgl",kernelFunc:aLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cLe=oA;function uLe(e){Mi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s,h=n.readSync(r.dataId),u=n.readSync(i.dataId),d=o,p=a,f=l,g=c,{selectedIndices:m,selectedScores:y}=cLe(h,u,d,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const hLe={kernelName:ZT,backendName:"webgl",kernelFunc:uLe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dLe{constructor(t,n,s,r){this.variableNames=["indices"],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pLe=e=>{const{inputs:t,backend:n,attrs:s}=e,{indices:r}=t,{dtype:i,depth:o,onValue:a,offValue:l}=s,c=Ae(r.shape),h=new dLe(c,o,a,l),u=Ze({inputs:{x:r},backend:n,attrs:{shape:[c]}}),d=n.runWebGLProgram(h,[u],i);n.disposeIntermediateTensorInfo(u);const p=[...r.shape,o],f=Ze({inputs:{x:d},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(d),f},fLe={kernelName:Tb,backendName:"webgl",kernelFunc:pLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aw(e){const{inputs:t,backend:n}=e,{x:s}=t;if(s.dtype==="complex64"){const r=O0({inputs:{input:s},backend:n}),i=aw({inputs:{x:r},backend:n}),o=iw({inputs:{input:s},backend:n}),a=aw({inputs:{x:o},backend:n}),l=Jc({inputs:{real:i,imag:a},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}else return F0({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:n})}const mLe={kernelName:Vb,backendName:"webgl",kernelFunc:aw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L5(e){const{inputs:t,backend:n}=e,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=O0({inputs:{input:s},backend:n}),i=L5({inputs:{x:r},backend:n}),o=iw({inputs:{input:s},backend:n}),a=aw({inputs:{x:o},backend:n}),l=Jc({inputs:{real:i,imag:a},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}else return F0({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:n})}const gLe={kernelName:Cb,backendName:"webgl",kernelFunc:L5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yLe(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s;if(t.length===1)return KI({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const i=t[0].shape,o=t[0].dtype;t.forEach(h=>{fT(i,h.shape,"All tensors passed to stack must have matching shapes"),W(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=t.map(h=>{const u=KI({inputs:{input:h},backend:n,attrs:{dim:r}});return a.push(u),u}),c=f5({inputs:l,backend:n,attrs:{axis:r}});return a.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}const vLe={kernelName:Eb,backendName:"webgl",kernelFunc:yLe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xLe{constructor(t,n,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((c,h)=>c[0]+t[h]+c[1]);const r=t.length,i=Mn(r),o=n.map(c=>c[0]).join(","),a=n.map((c,h)=>c[0]+t[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bLe{constructor(t,n,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((g,m)=>g[0]+t[m]+g[1]);const r=t.length,i=Mn(r),o=n.map(g=>g[0]).join(","),a=n.map((g,m)=>g[0]+t[m]).join(","),l=Er("rc",r),c=Er("source",r),h=`${l[r-1]} < ${this.outputShape[r-1]}`,u=r===1?"source":`vec2(${c.slice(-2).join()})`,d=[`${i} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${h}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${h}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let g=0,m=r===1?2:4;g<m;g++)f+=`
        ${d[g]}
        if (${p}) {
          result[${g}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${g}] = getChannel(getX(${c.join()}), ${u});
        }
      `;f+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F5=e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:i,constantValue:o}=s;if(Ae(r.shape)===0){const c=i.map((h,u)=>h[0]+r.shape[u]+h[1]);return F0({backend:n,attrs:{shape:c,value:o,dtype:r.dtype}})}const a=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new bLe(r.shape,i,o):new xLe(r.shape,i,o),l=[[o]];return n.runWebGLProgram(a,[r],r.dtype,l)},wLe={kernelName:Ab,backendName:"webgl",kernelFunc:F5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SLe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,_Le=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+k0+`
  return result;
`,CLe=er({opSnippet:SLe,packedOpSnippet:_Le}),TLe={kernelName:Eg,backendName:"webgl",kernelFunc:CLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ELe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:o}=s,a=r.shape.length,l=[],c=Ht(i,r.shape);let h=c;const u=Yn(h,a);let d=r;u!=null&&(d=Ar({inputs:{x:r},backend:n,attrs:{perm:u}}),h=cs(h.length,a),l.push(d)),Zs("prod",h,a);let p;if(n.shouldExecuteOnCPU([d])){const f=n.texData.get(d.dataId).values,{outVals:g,outShape:m,outDtype:y}=Dke(d.shape,d.dtype,f,h);p=n.makeTensorInfo(m,y,g)}else{const[f,g]=$s(d.shape,h),m=Ae(g),y=Ze({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),v=xE(r.dtype),b=Ph(y,v,"prod",n);p=Ze({inputs:{x:b},backend:n,attrs:{shape:f}}),l.push(y),l.push(b)}if(o){l.push(p);const f=vs(p.shape,c);p=Ze({inputs:{x:p},backend:n,attrs:{shape:f}})}return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}const ALe={kernelName:Nb,backendName:"webgl",kernelFunc:ELe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ILe(e){const{inputs:t,backend:n,attrs:s}=e,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:a}=s,l=r.map(y=>n.readSync(y.dataId)),c=r.map(y=>y.shape),h=n.readSync(i.dataId),u=n.readSync(o.dataId),[d,p,f]=Mke(l,c,h,i.shape,i.dtype,u,o.shape,a),g=d.map(y=>n.makeTensorInfo([y.length],"int32",y)),m=n.makeTensorInfo(f,i.dtype,p);return g.concat([m])}const NLe={kernelName:z$,backendName:"webgl",kernelFunc:ILe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kLe(e){const{inputs:t,backend:n}=e,{starts:s,limits:r,deltas:i}=t,o=n.readSync(s.dataId),a=n.readSync(r.dataId),l=n.readSync(i.dataId),[c,h]=Pke(o,s.shape,s.dtype,a,r.shape,l,i.shape),u=n.makeTensorInfo([c.length],"int32",c),d=n.makeTensorInfo([h.length],s.dtype,h);return[u,d]}const DLe={kernelName:U$,backendName:"webgl",kernelFunc:kLe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MLe(e){const{inputs:t,backend:n,attrs:s}=e,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=s,c=n.readSync(r.dataId),h=n.readSync(i.dataId),u=n.readSync(o.dataId),d=a.map(m=>n.readSync(m.dataId)),p=a.map(m=>m.shape),[f,g]=Oke(c,r.shape,h,i.shape,i.dtype,u,o.shape,d,p,l);return n.makeTensorInfo(f,i.dtype,g)}const PLe={kernelName:V$,backendName:"webgl",kernelFunc:MLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $5=e=>{const{backend:t,attrs:n}=e,{start:s,stop:r,step:i,dtype:o}=n,a=Rke(s,r,i,o);return t.makeTensorInfo([a.length],o,a)},OLe={kernelName:JT,backendName:"webgl",kernelFunc:$5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RLe="return 1.0 / x;",LLe=en({opSnippet:RLe}),FLe={kernelName:Ag,backendName:"webgl",kernelFunc:LLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Le=bo+`
  return (x < 0.0) ? 0.0 : x;
`,BLe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,zLe=en({opSnippet:$Le,packedOpSnippet:BLe}),ULe={kernelName:Ig,backendName:"webgl",kernelFunc:zLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VLe=bo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,GLe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,WLe=en({opSnippet:VLe,packedOpSnippet:GLe}),HLe={kernelName:Ng,backendName:"webgl",kernelFunc:WLe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jLe{constructor(t,n,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,n,s,c];const h=[r&&n>1?a-1:a,r&&s>1?l-1:l],u=[r&&n>1?n-1:n,r&&s>1?s-1:s];let d;i?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/u[0]},
          ${h[1]/u[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qLe{constructor(t,n,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,n,s,c];const h=[r&&n>1?a-1:a,r&&s>1?l-1:l],u=[r&&n>1?n-1:n,r&&s>1?s-1:s];let d;i?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/u[0]},
          ${h[1]/u[1]},
          ${h[1]/u[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XLe(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,c]=a,h=xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qLe(r.shape,l,c,i,o):new jLe(r.shape,l,c,i,o);return n.runWebGLProgram(h,[r],"float32")}const KLe={kernelName:Mb,backendName:"webgl",kernelFunc:XLe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YLe{constructor(t,n,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,r,i]=n,[,o,a]=t,l=[s&&o>1?r-1:r,s&&a>1?i-1:i],c=[s&&o>1?o-1:o,s&&a>1?a-1:a],h=l[0]/c[0],u=l[1]/c[1],d=1/h,p=1/u,f=Math.ceil(d)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${u});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QLe(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:i}=t,{alignCorners:o}=s,a=new YLe(i.shape,r.shape,o);return n.runWebGLProgram(a,[i],i.dtype)}const ZLe={kernelName:nE,backendName:"webgl",kernelFunc:QLe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JLe{constructor(t,n,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,n,s,c];const h=[r&&n>1?a-1:a,r&&s>1?l-1:l],u=[r&&n>1?n-1:n,r&&s>1?s-1:s],d=r?"0.5":"0.0";let p;i?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/u[0]},
          ${h[1]/u[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eFe{constructor(t,n,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,n,s,c];const h=[r&&n>1?a-1:a,r&&s>1?l-1:l],u=[r&&n>1?n-1:n,r&&s>1?s-1:s],d=r?"0.5":"0.0";let p;i?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/u[0]},
          ${h[1]/u[1]},
          ${h[1]/u[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tFe(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,c]=a,h=xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new eFe(r.shape,l,c,i,o):new JLe(r.shape,l,c,i,o);return n.runWebGLProgram(h,[r],r.dtype)}const nFe={kernelName:Db,backendName:"webgl",kernelFunc:tFe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sFe{constructor(t,n,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,r,i]=n,[,o,a]=t,l=[s&&o>1?r-1:r,s&&a>1?i-1:i],c=[s&&o>1?o-1:o,s&&a>1?a-1:a],h=l[0]/c[0],u=l[1]/c[1],d=1/h,p=1/u,f=Math.ceil(d)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${u});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rFe(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:i}=t,{alignCorners:o}=s,a=new sFe(i.shape,r.shape,o);return n.runWebGLProgram(a,[i],i.dtype)}const iFe={kernelName:tE,backendName:"webgl",kernelFunc:rFe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oFe{constructor(t,n){this.variableNames=["x"];const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=t,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const r=a=>n.indexOf(a)!==-1&&t[a]!==1?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`,i=t.map((a,l)=>r(l)).join(","),o=Mn(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aFe{constructor(t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=t;const r=Er("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,a=Mn(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${i}){
            result.g = ${c(r.slice())};
          }
          if(${o}) {
            result.b = ${h(r.slice())};
            if(${i}) {
              result.a = ${u(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(f){return d(f)}function c(f){return f[s-1]="("+f[s-1]+" + 1)",d(f)}function h(f){return f[s-2]="("+f[s-2]+" + 1)",d(f)}function u(f){return f[s-1]="("+f[s-1]+" + 1)",f[s-2]="("+f[s-2]+" + 1)",d(f)}function d(f){const g=t.map((v,b)=>p(b,f)),m=g.join(","),y=g.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${y}))`}function p(f,g){return n.indexOf(f)!==-1&&t[f]!==1?`${t[f]} - ${g[f]} - 1`:`${g[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lFe(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dims:i}=s,o=r.shape.length,a=Ht(i,r.shape);if(o===0)return pi({inputs:{x:r},backend:n});const l=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new aFe(r.shape,a):new oFe(r.shape,a);return n.runWebGLProgram(l,[r],r.dtype)}const cFe={kernelName:Pb,backendName:"webgl",kernelFunc:lFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uFe{constructor(t,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=t[1],r=t[2];this.outputShape=t;let i="";typeof n=="number"?i=`float outputValue = ${n.toFixed(2)};`:i=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hFe={kernelName:lE,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:s}=e,{radians:r,fillValue:i,center:o}=t,a=n,l=new uFe(s.shape,i),[c,h]=xA(o,s.shape[1],s.shape[2]),u=[[c,h,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(l,[s],s.dtype,u)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dFe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,pFe=en({opSnippet:dFe}),fFe={kernelName:kg,backendName:"webgl",kernelFunc:pFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mFe="return inversesqrt(x);",gFe=en({opSnippet:mFe,cpuKernelImpl:Lke}),yFe={kernelName:Dg,backendName:"webgl",kernelFunc:gFe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B5{constructor(t,n,s,r,i,o,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const l=Mn(i.length),c=Mn(o.length);let h="";s===1?h="i":s===2&&(h="i, j");const u=`getIndices(${h})`;let d="";r===1?d="i":r===2&&(d="i, coords[1]");const p=`getUpdates(${d})`,f=n>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${i});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${u});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vFe(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r,updates:i}=t,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:c,strides:h,outputSize:u}=s0(i,r,o),d=[u/c,c];if(u===0)return n.makeTensorInfo(o,r.dtype);const p=Ze({inputs:{x:r},backend:n,attrs:{shape:[l,a]}}),f=Ze({inputs:{x:i},backend:n,attrs:{shape:[l,c]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0])),m=new B5(l,a,p.shape.length,f.shape.length,h,d),y=n.runWebGLProgram(m,[f,p,g],f.dtype),v=Ze({inputs:{x:y},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(g),v}const xFe={kernelName:G$,backendName:"webgl",kernelFunc:vFe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bFe{constructor(t,n,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,s];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,a=xe().getNumber("WEBGL_VERSION")===2?i:o,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wFe(e){const{inputs:t,backend:n,attrs:s}=e,{sortedSequence:r,values:i}=t,{side:o}=s,a=new bFe(r.shape[0],r.shape[1],i.shape[1],o),l=[[r.shape[1]]];return n.runWebGLProgram(a,[r,i],"int32",l)}const SFe={kernelName:W$,backendName:"webgl",kernelFunc:wFe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _Fe{constructor(t,n,s){this.variableNames=["c","a","b"],this.outputShape=n;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let h=0;h<n.length;h++)c.push(`${a[h]}`),h<t&&l.push(`${a[h]}`);r=l.join(),i=c.join()}const o=Mn(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CFe(e){const{inputs:t,backend:n}=e,{condition:s,t:r,e:i}=t,o=new _Fe(s.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(o,[s,r,i],li(r.dtype,i.dtype))}const TFe={kernelName:Ob,backendName:"webgl",kernelFunc:CFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EFe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${d1};
  float scale = ${p1};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,AFe=en({opSnippet:EFe}),IFe={kernelName:Mg,backendName:"webgl",kernelFunc:AFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NFe=nf+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,kFe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,DFe=en({opSnippet:NFe,packedOpSnippet:kFe,cpuKernelImpl:$ke}),MFe={kernelName:Lg,backendName:"webgl",kernelFunc:DFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PFe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,OFe=en({opSnippet:PFe}),RFe={kernelName:Rg,backendName:"webgl",kernelFunc:OFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LFe=nf+`
  return sin(x);
`,FFe=en({opSnippet:LFe}),$Fe={kernelName:Pg,backendName:"webgl",kernelFunc:FFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BFe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,zFe=en({opSnippet:BFe}),UFe={kernelName:Og,backendName:"webgl",kernelFunc:zFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VFe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,GFe=en({opSnippet:VFe}),WFe={kernelName:Fg,backendName:"webgl",kernelFunc:GFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HFe=e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:i,paddings:o}=s;W(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((y,v)=>y*v),l=[[0,0]];l.push(...o);for(let y=1+i.length;y<r.shape.length;++y)l.push([0,0]);const c=[],h=F5({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),u=r0(h.shape,i,a,!1),d=i0(u.length,i.length,!1),p=o0(h.shape,i,a,!1),f=Ze({inputs:{x:h},backend:n,attrs:{shape:u}}),g=Ar({inputs:{x:f},backend:n,attrs:{perm:d}}),m=Ze({inputs:{x:g},backend:n,attrs:{shape:p}});return c.push(h),c.push(f),c.push(g),c.forEach(y=>n.disposeIntermediateTensorInfo(y)),m},jFe={kernelName:Fb,backendName:"webgl",kernelFunc:HFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qFe(e){const{inputs:t,backend:n}=e,{indices:s,values:r,denseShape:i,defaultValue:o}=t;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=n.readSync(s.dataId),l=n.readSync(r.dataId),c=n.readSync(i.dataId),h=n.readSync(o.dataId)[0],[u,d,p,f,g]=zke(a,s.shape,s.dtype,l,r.dtype,c,h);return[n.makeTensorInfo(d,s.dtype,u),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),n.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const XFe={kernelName:H$,backendName:"webgl",kernelFunc:qFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KFe(e){const{inputs:t,backend:n}=e,{inputIndices:s,inputShape:r,newShape:i}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(n.readSync(r.dataId)),a=n.readSync(s.dataId),l=Array.from(n.readSync(i.dataId)),[c,h,u]=Uke(a,s.shape,s.dtype,o,l);return[n.makeTensorInfo(h,s.dtype,c),n.makeTensorInfo([u.length],i.dtype,new Int32Array(u))]}const YFe={kernelName:j$,backendName:"webgl",kernelFunc:KFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QFe(e){const{inputs:t,backend:n}=e,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=n.readSync(s.dataId),a=n.readSync(r.dataId),l=n.readSync(i.dataId),[c,h]=GW(o,s.shape,s.dtype,a,l,!0);return n.makeTensorInfo(h,s.dtype,c)}const ZFe={kernelName:q$,backendName:"webgl",kernelFunc:QFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JFe(e){const{inputs:t,backend:n}=e,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=n.readSync(s.dataId),a=n.readSync(r.dataId),l=n.readSync(i.dataId),[c,h]=GW(o,s.shape,s.dtype,a,l);return n.makeTensorInfo(h,s.dtype,c)}const e$e={kernelName:X$,backendName:"webgl",kernelFunc:JFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t$e(e){const{inputs:t,backend:n,attrs:s}=e,{sparseIndices:r,sparseValues:i,defaultValue:o}=t,{outputShape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:u,outputSize:d}=s0(i,r,a),p=!1;if(i.dtype==="string"){const y=n.bufferSync(r),v=n.bufferSync(i),b=Oc(n.readSync(o.dataId)[0]),x=Fke(y,v,a,d,h,c,l,u,b,p);return n.makeTensorInfo(a,x.dtype,x.values)}const f=new B5(c,l,r.shape.length,i.shape.length,u,[d,1],p),g=n.runWebGLProgram(f,[i,r,o],i.dtype),m=Ze({inputs:{x:g},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(g),m}const n$e={kernelName:K$,backendName:"webgl",kernelFunc:t$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s$e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{numOrSizeSplits:i,axis:o}=s,a=Ht(o,r.shape)[0],l=RA(r,i,a),c=r.shape.length,h=new Array(c).fill(0),u=r.shape.slice();return l.map(d=>{const p=[...u];p[a]=d;const f=sf({inputs:{x:r},backend:n,attrs:{begin:h,size:p}});return h[a]+=d,f})}const r$e={kernelName:$b,backendName:"webgl",kernelFunc:s$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z5="return sqrt(x);",i$e=en({opSnippet:z5,packedOpSnippet:z5,cpuKernelImpl:Vke}),o$e={kernelName:$g,backendName:"webgl",kernelFunc:i$e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a$e="return x * x;",l$e=en({opSnippet:a$e}),c$e={kernelName:sE,backendName:"webgl",kernelFunc:l$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U5="return (a - b) * (a - b);",u$e=er({opSnippet:U5,packedOpSnippet:U5}),h$e={kernelName:Bg,backendName:"webgl",kernelFunc:u$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d$e({inputs:e,attrs:t,backend:n}){const{x:s}=e,r=bo+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,i=new nl(s.shape,r);return n.runWebGLProgram(i,[s],s.dtype)}const p$e={kernelName:Wg,backendName:"webgl",kernelFunc:d$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class f$e{constructor(t,n,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=Mn(s.length),o=Mn(s.length);let a="";if(r===1)a="coords * strides + begin";else{let l=0;a=s.map((c,h)=>(l++,s.length===1?`coords * strides[${h}] + begin[${h}]`:`coords[${l-1}] * strides[${h}] + begin[${h}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${t});
      ${i} strides = ${i}(${n});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m$e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:u,shrinkAxisMask:d}=s,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:v,end:b,strides:x}=gA(r.shape,i,o,a,l,c,h,u,d);let w;if(g)w=Ze({inputs:{x:r},backend:n,attrs:{shape:f}});else if(m||y){W(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const C=pA(v,b,x),_=sf({inputs:{x:r},backend:n,attrs:{begin:v,size:C}});w=Ze({inputs:{x:_},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(_)}else if(n.shouldExecuteOnCPU([r])){const _=n.readSync(r.dataId),T=jt(r.shape,r.dtype,_),E=Gke(p,T,x,v);w=n.makeTensorInfo(f,r.dtype,E.values)}else{const _=new f$e(v,x,p);w=n.runWebGLProgram(_,[r],r.dtype)}const S=Ze({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),S}const g$e={kernelName:rE,backendName:"webgl",kernelFunc:m$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y$e(e){const{inputs:t,backend:n,attrs:s}=e,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=s,{data:h,dataSplits:u}=t,d=n.readSync(h.dataId),p=n.readSync(u.dataId),[f,g]=Wke(d,p,r,i,o,a,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(u.shape,"int32",g)]}const v$e={kernelName:Y$,backendName:"webgl",kernelFunc:y$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x$e(e){const{inputs:t,backend:n,attrs:s}=e,{skipEmpty:r}=s,{input:i,delimiter:o}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=n.readSync(i.dataId),l=n.readSync(o.dataId)[0],[c,h,u]=Hke(a,l,r),d=h.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",h),n.makeTensorInfo([2],"int32",new Int32Array(u))]}const b$e={kernelName:Q$,backendName:"webgl",kernelFunc:x$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w$e(e){const{inputs:t,backend:n,attrs:s}=e,{numBuckets:r}=s,{input:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(i.dataId),a=jke(o,r);return n.makeTensorInfo(i.shape,"int32",a)}const S$e={kernelName:Z$,backendName:"webgl",kernelFunc:w$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _$e="return tan(x);",C$e=en({opSnippet:_$e}),T$e={kernelName:Ug,backendName:"webgl",kernelFunc:C$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E$e=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,A$e=en({opSnippet:E$e}),I$e={kernelName:Vg,backendName:"webgl",kernelFunc:A$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N$e{constructor(t,n){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[o]*n[o];this.outputShape=s,this.rank=s.length;const r=Mn(this.rank),i=k$e(t);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function k$e(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<e.length;r++)s.push(`imod(${n[r]}, ${e[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V5(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const l=n.readSync(r.dataId),c=r.dtype==="string"?l.map(d=>Oc(d)):l,h=jt(r.shape,r.dtype,c),u=Xke(h,i);return n.makeTensorInfo(u.shape,u.dtype,u.values)}const o=new N$e(r.shape,i);return n.runWebGLProgram(o,[r],r.dtype)}const D$e={kernelName:Gg,backendName:"webgl",kernelFunc:V5};class M$e{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class P$e{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oh(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function G5(e){let t=1;for(;t<e;)t*=2;return t}function O$e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{k:i,sorted:o}=s,a=xe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=xe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,h=c[c.length-1];if(n.shouldExecuteOnCPU([r])||h<a||i>l){const E=n.readSync(r.dataId),[A,D]=Kke(E,c,r.dtype,i,o);return[n.makeTensorInfo(A.shape,A.dtype,A.values),n.makeTensorInfo(D.shape,D.dtype,D.values)]}if(i===0)return c[c.length-1]=0,[n.makeTensorInfo(c,r.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(h===1)return[r,F0({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const u=n.texData.get(r.dataId),d=u!==null&&u.isPacked,p=d?n.unpackTensor(r):r,g=Ae(c)/h,m=Ze({inputs:{x:p},attrs:{shape:[g,h]},backend:n});d&&Oh(n,p);const y=G5(i),v=G5(h);let b=null;const x=()=>b===null?[m,m]:[m,b],w=(E,A,D)=>{const O=x(),P=new M$e(D),B=[[h],[b===null?1:0],[Number.NEGATIVE_INFINITY],[E],[A]],F=b;b=n.runWebGLProgram(P,O,"int32",B),Oh(n,F)};for(let E=1;E<y;E*=2){const A=E*2;for(let D=E;D>=1;D/=2)w(A,D,[g,v])}for(let E=v;E>y;E/=2){const A=x(),D=new P$e([g,E/2]),P=[[h],[b===null?1:0],[y]],L=b;b=n.runWebGLProgram(D,A,"int32",P),Oh(n,L);const B=y/2,F=B*2;for(let M=B;M>=1;M/=2)w(F,M,b.shape)}let S=b;b=sf({inputs:{x:b},backend:n,attrs:{begin:0,size:[g,i]}}),Oh(n,S);let C=k5({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});Oh(n,m);const _=c.slice(0,-1);_.push(i),S=b,b=Ze({inputs:{x:b},attrs:{shape:_},backend:n}),Oh(n,S);const T=C;return C=Ze({inputs:{x:C},attrs:{shape:_},backend:n}),Oh(n,T),[C,b]}const R$e={kernelName:iE,backendName:"webgl",kernelFunc:O$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class L$e{constructor(t,n,s,r,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=s==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${t}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F$e(e){const{inputs:t,backend:n,attrs:s}=e,{image:r,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=s,[h,u,d,p]=r.shape,[f,g]=c!=null?c:[u,d],m=[h,f,g,p],y=new L$e(u,d,o,a,l,m);return n.runWebGLProgram(y,[r,i],"float32")}const $$e={kernelName:oE,backendName:"webgl",kernelFunc:F$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B$e(e){const{inputs:t,attrs:n,backend:s}=e,{axis:r}=n,{x:i}=t;I0(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(i.dataId),{outputValues:a,outputShape:l,indices:c}=Yke(o,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,a),s.makeTensorInfo([c.length],"int32",c)]}const z$e={kernelName:aE,backendName:"webgl",kernelFunc:B$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U$e(e){const{inputs:t,backend:n,attrs:s}=e,{value:r}=t;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[i],c=new Array(a-1);let h=0;for(let g=0;g<a;g++)g!==i&&(c[h++]=o.shape[g]);const u=[],d=new Array(a).fill(0),p=o.shape.slice();p[i]=1;const f=new Array(l);for(let g=0;g<f.length;g++){d[i]=g;const m=sf({inputs:{x:o},backend:n,attrs:{begin:d,size:p}}),y=Ze({inputs:{x:m},backend:n,attrs:{shape:c}});f[g]=y,u.push(m)}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}const V$e={kernelName:zb,backendName:"webgl",kernelFunc:U$e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G$e{constructor(t,n){this.variableNames=["x","segmentIds"];const s=t.windowSize,r=t.batchSize,i=t.inSize,o=t.numSegments,a=o*Math.ceil(i/s);this.outputShape=[r,a];const l="0.0",c="sumValue",h=Math.floor(s/4)*4,u=s%4,d=`
        sumValue += dot(values, segFilter);
    `;let p="";i%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let f="";i%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${h};
        if (${u===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W$e(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,segmentIds:i}=t,{numSegments:o}=s,a=r.shape.length,l=[];let c=0;const h=Yn([c],a);let u=r;h!=null&&(u=Ar({inputs:{x:r},backend:n,attrs:{perm:h}}),l.push(u),c=cs(1,a)[0]);const d=S4(u.shape,c,o),p=Ae([u.shape[c]]),f=Ze({inputs:{x:u},backend:n,attrs:{shape:[-1,p]}});l.push(f);const g=xE(r.dtype),m=(x,w,S,C,_)=>{const T=x.shape[0],E=x.shape[1],A=w4(E,_),D={windowSize:A,inSize:E,batchSize:T,numSegments:_},O=new G$e(D,w),P=n.compileAndRun(O,[x,S],C);if(l.push(P),P.shape[1]===_)return P;const L=$5({backend:n,attrs:{start:0,stop:_,step:1,dtype:"float32"}}),B=V5({inputs:{x:L},backend:n,attrs:{reps:[E/A]}});return l.push(L),l.push(B),m(P,w,B,C,_)},y=m(f,"unsortedSegmentSum",i,g,o),v=Ze({inputs:{x:y},backend:n,attrs:{shape:d}});let b=v;if(h!=null){l.push(v);const x=Fc(h);b=Ar({inputs:{x:b},backend:n,attrs:{perm:x}})}return l.forEach(x=>n.disposeIntermediateTensorInfo(x)),b}const H$e={kernelName:Ub,backendName:"webgl",kernelFunc:W$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j$e=[UDe,GDe,jDe,KDe,QDe,eMe,nMe,rMe,lMe,uMe,pMe,gMe,xMe,_Me,EMe,IMe,kMe,OMe,LMe,$Me,VMe,KMe,QMe,JMe,i3e,a3e,h3e,CDe,f3e,x3e,_3e,N3e,D3e,P3e,R3e,F3e,z3e,G3e,j3e,X3e,Y3e,Z3e,tPe,sPe,aPe,cPe,dPe,mPe,yPe,wPe,TPe,NPe,MPe,RPe,LPe,$Pe,zPe,VPe,WPe,jPe,YPe,JPe,nOe,rOe,aOe,uOe,fOe,vOe,_De,bOe,y3e,_Oe,EOe,NOe,EDe,POe,FOe,BOe,GOe,jOe,YOe,JOe,sRe,aRe,uRe,dRe,gRe,vRe,bRe,CRe,ERe,IRe,kRe,MRe,LRe,zRe,WRe,ZRe,NDe,nLe,iLe,lLe,hLe,t3e,fLe,gLe,vLe,wLe,TLe,IDe,ALe,NLe,DLe,PLe,OLe,n3e,XRe,FLe,ULe,HLe,DDe,KLe,ZLe,nFe,iFe,cFe,hFe,fFe,yFe,xFe,SFe,TFe,IFe,MFe,RFe,$Fe,UFe,qMe,YRe,WFe,jFe,XFe,YFe,ZFe,e$e,n$e,r$e,o$e,c$e,h$e,p$e,g$e,v$e,b$e,S$e,KRe,$De,T$e,I$e,D$e,R$e,$$e,BDe,z$e,V$e,H$e,mLe];for(const e of j$e)sB(e);/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q$e=1e-7,X$e=1e-4;class K$e{refCount(t){return zi("refCount")}incRef(t){return zi("incRef")}timerAvailable(){return!0}time(t){return zi("time")}read(t){return zi("read")}readSync(t){return zi("readSync")}readToGPU(t,n){return zi("readToGPU")}numDataIds(){return zi("numDataIds")}disposeData(t,n){return zi("disposeData")}write(t,n,s){return zi("write")}move(t,n,s,r,i){return zi("move")}memory(){return zi("memory")}floatPrecision(){return zi("floatPrecision")}epsilon(){return this.floatPrecision()===32?q$e:X$e}dispose(){return zi("dispose")}}function zi(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function wo(e,t,n=""){Q(eu(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function of(e){Q(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function lw(e,t=[],n=!1){if(t==null&&(t=[]),Array.isArray(e)||sl(e)&&!n)for(let s=0;s<e.length;++s)lw(e[s],t,n);else t.push(e);return t}function tr(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function eu(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function $0(e){return e%1==0}function cw(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function uw(e,t){const n=t.length;return e=e==null?t.map((s,r)=>r):[].concat(e),Q(e.every(s=>s>=-n&&s<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),Q(e.every(s=>$0(s)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(s=>s<0?n+s:s)}function Y$e(e,t){const n=[],s=[],r=t!=null&&Array.isArray(t)&&t.length===0,i=t==null||r?null:uw(t,e).sort();let o=0;for(let a=0;a<e.length;++a){if(i!=null){if(i[o]===a&&e[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${e[a]}' is not 1`);(i[o]==null||i[o]>a)&&e[a]===1&&(n.push(e[a]),s.push(a)),i[o]<=a&&o++}e[a]!==1&&(n.push(e[a]),s.push(a))}return{newShape:n,keptDims:s}}function Q$e(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else throw new Error(`Unknown data type ${e}`);return n}function Z$e(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function J$e(e,t){for(let n=0;n<e.length;n++){const s=e[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function eBe(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function sl(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function W5(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function tBe(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function QI(e){return typeof e=="string"||e instanceof String}function nBe(e){return typeof e=="boolean"}function sBe(e){return typeof e=="number"}function ZI(e){return Array.isArray(e)?ZI(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":sBe(e)?"float32":QI(e)?"string":nBe(e)?"bool":"float32"}function H5(e){return!!(e&&e.constructor&&e.call&&e.apply)}function JI(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let s=t-3;s>=0;--s)n[s]=n[s+1]*e[s+1];return n}function j5(e,t,n,s=!1){const r=new Array;if(t.length===1){const i=t[0]*(s?2:1);for(let o=0;o<i;o++)r[o]=n[e+o]}else{const i=t[0],o=t.slice(1),a=o.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<i;l++)r[l]=j5(e+l*a,o,n,s)}return r}function eN(e,t,n=!1){if(e.length===0)return t[0];const s=e.reduce((r,i)=>r*i)*(n?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return j5(0,e,t,n)}function q5(e,t){const n=tN(e,t);for(let s=0;s<n.length;s++)n[s]=1;return n}function tN(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function X5(e){e.forEach(t=>{Q(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function af(e){return e&&e.then&&typeof e.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K5="tfjsflags";class rBe{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=iBe,this.populateURLFlags()}setPlatform(t,n){this.platform!=null&&(sn().getBool("IS_TEST")||sn().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=n}registerFlag(t,n,s){if(this.flagRegistry[t]={evaluationFn:n,setHook:s},this.urlFlags[t]!=null){const r=this.urlFlags[t];sn().getBool("IS_TEST")||sn().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const n=this.evaluateFlag(t);if(af(n))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=n,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=n,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(n)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;const t=this.getQueryParams(this.global.location.search);K5 in t&&t[K5].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=aBe(r,i)})}}function iBe(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...s)=>(oBe(t,s[0],s[1]),s.join("="))),t}function oBe(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function aBe(e,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}function sn(){return Y5}let Y5=null;function lBe(e){Y5=e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nN;function Q5(){if(nN==null){let e;if(typeof window!="undefined")e=window;else if(typeof global!="undefined")e=global;else if(typeof process!="undefined")e=process;else if(typeof self!="undefined")e=self;else throw new Error("Could not find a global object");nN=e}return nN}function cBe(){const e=Q5();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function sN(e,t){const n=cBe();if(n.has(e))return n.get(e);{const s=t();return n.set(e,s),n.get(e)}}const uBe="Abs",hBe="Acos",dBe="Acosh",Z5="Add",pBe="AddN",fBe="All",mBe="Any",gBe="ArgMax",yBe="ArgMin",vBe="Asin",xBe="Asinh",bBe="Atan",wBe="Atanh",SBe="Atan2",_Be="AvgPool",CBe="AvgPool3D",TBe="BatchMatMul",EBe="BatchToSpaceND",ABe="Bincount",IBe="BroadcastArgs",J5="Cast",NBe="Ceil",kBe="ClipByValue",DBe="Complex",MBe="ComplexAbs",PBe="Concat",OBe="Conv2D",RBe="Conv2DBackpropFilter",LBe="Conv2DBackpropInput",FBe="Conv3D",$Be="Conv3DBackpropInputV2",BBe="Cos",zBe="Cosh",UBe="Cumprod",VBe="Cumsum",GBe="CropAndResize",WBe="DenseBincount",HBe="DepthToSpace",jBe="DepthwiseConv2dNative",qBe="DepthwiseConv2dNativeBackpropFilter",XBe="DepthwiseConv2dNativeBackpropInput",KBe="Diag",YBe="Dilation2D",QBe="RealDiv",ZBe="Einsum",JBe="Elu",eze="Erf",tze="Equal",nze="Exp",sze="ExpandDims",rze="Expm1",ize="FFT",oze="Fill",aze="FlipLeftRight",lze="Floor",cze="FloorDiv",uze="FusedBatchNorm",hze="GatherV2",dze="GatherNd",pze="Greater",fze="GreaterEqual",eH="Identity",mze="IFFT",gze="Imag",yze="IsFinite",vze="IsInf",xze="IsNan",bze="LeakyRelu",wze="Less",Sze="LessEqual",_ze="LinSpace",Cze="Log",Tze="Log1p",Eze="LogicalAnd",Aze="LogicalNot",Ize="LogicalOr",Nze="LRN",kze="Max",Dze="Maximum",Mze="MaxPool",Pze="MaxPool3D",Oze="MaxPoolWithArgmax",Rze="Mean",Lze="Min",Fze="Minimum",$ze="MirrorPad",Bze="Mod",zze="Multinomial",Uze="Multiply",Vze="Neg",Gze="NotEqual",Wze="NonMaxSuppressionV3",Hze="NonMaxSuppressionV4",jze="NonMaxSuppressionV5",qze="OnesLike",Xze="OneHot",Kze="Pack",Yze="PadV2",Qze="Pow",Zze="Prelu",Jze="Prod",e4e="RaggedGather",t4e="RaggedTensorToTensor",n4e="Range",s4e="Real",r4e="Reciprocal",i4e="Relu",o4e="Reshape",a4e="ResizeNearestNeighbor",l4e="ResizeBilinear",c4e="Relu6",u4e="Reverse",h4e="Round",d4e="Rsqrt",p4e="ScatterNd",f4e="SearchSorted",m4e="Select",g4e="Selu",y4e="Slice",v4e="Sin",x4e="Sinh",b4e="Sign",w4e="Sigmoid",S4e="Softplus",_4e="Sqrt",C4e="Sum",T4e="SpaceToBatchND",E4e="SplitV",A4e="Softmax",I4e="SparseFillEmptyRows",N4e="SparseReshape",k4e="SparseSegmentMean",D4e="SparseSegmentSum",M4e="SparseToDense",P4e="SquaredDifference",O4e="StridedSlice",R4e="StringNGrams",L4e="StringSplit",F4e="StringToHashBucketFast",$4e="Sub",B4e="Tan",z4e="Tanh",tH="Tile",U4e="TopK",V4e="Transform",rN="Transpose",G4e="Unique",W4e="Unpack",H4e="UnsortedSegmentSum",j4e="ZerosLike",q4e="Step",X4e="RotateWithOffset",nH="_FusedMatMul",sH="FusedConv2D",rH="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B0(...e){sn().getBool("IS_TEST")||sn().getBool("PROD")||console.warn(...e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iH=sN("kernelRegistry",()=>new Map),K4e=sN("gradRegistry",()=>new Map);function oH(e,t){const n=Y4e(e,t);return iH.get(n)}function aH(e){return K4e.get(e)}function lH(e){const t=iH.entries(),n=[];for(;;){const{done:s,value:r}=t.next();if(s)break;const[i,o]=r,[a]=i.split("_");a===e&&n.push(o)}return n}function Y4e(e,t){return`${t}_${e}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q4e(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function cH(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=lw(e)),sn().getBool("DEBUG")&&J$e(e,t),Q4e(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){const n=new Uint8Array(e.length);for(let s=0;s<n.length;++s)Math.round(e[s])!==0&&(n[s]=1);return n}else throw new Error(`Unknown data type ${t}`)}function hw(){return sn().platform.now()}function Z4e(e,t){return sn().platform.fetch(e,t)}function J4e(e,t="utf-8"){return t=t||"utf-8",sn().platform.encode(e,t)}function uH(e,t="utf-8"){return t=t||"utf-8",sn().platform.decode(e,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eUe{constructor(t,n){this.backendTimer=t,this.logger=n,n==null&&(this.logger=new nUe)}profileKernel(t,n,s){let r;const i=()=>{r=s()};let o;const a=hw();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of r)c.dataSync();o=Promise.resolve({kernelMs:hw()-a})}if(sn().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const h=r[c];h.data().then(u=>{tUe(u,h.dtype,t)})}return{kernelName:t,outputs:r,inputs:n,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:n,outputs:s,timeMs:r,inputs:i,extraInfo:o}=t;s.forEach(a=>{Promise.all([a.data(),r,o]).then(l=>{this.logger.logKernelProfile(n,a,l[0],l[1],i,l[2])})})}}function tUe(e,t,n){if(t!=="float32")return!1;for(let s=0;s<e.length;s++){const r=e[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class nUe{logKernelProfile(t,n,s,r,i,o){const a=typeof r=="number"?cw(`${r}ms`,9):r.error,l=cw(t,25),c=n.rank,h=n.size,u=cw(n.shape.toString(),14);let d="";for(const p in i){const f=i[p];if(f!=null){const g=f.shape||n.shape,m=g.length;d+=`${p}: ${m}D ${m>0?g:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${u}	%c${h}	%c${d}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sUe(e,t,n){const s={},r={};for(let l=0;l<t.length;l++)s[t[l].id]=!0;for(let l=0;l<e.length;l++){const c=e[l],h=c.inputs;for(const u in h){const d=h[u];let p=!1;for(let f=0;f<t.length;f++)if(s[d.id]){c.outputs.forEach(g=>s[g.id]=!0),p=!0,r[c.id]=!0;break}if(p)break}}const i={};i[n.id]=!0;const o={};for(let l=e.length-1;l>=0;l--){const c=e[l],h=c.inputs;for(let u=0;u<c.outputs.length;u++)if(i[c.outputs[u].id]){for(const d in h)i[h[d].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<e.length;l++){const c=e[l];if(r[c.id]&&o[c.id]){const h={};for(const d in c.inputs){const p=c.inputs[d];s[p.id]&&(h[d]=p)}const u=Object.assign({},c);u.inputs=h,u.outputs=c.outputs,a.push(u)}}return a}function rUe(e,t,n,s){for(let r=t.length-1;r>=0;r--){const i=t[r],o=[];if(i.outputs.forEach(l=>{const c=e[l.id];c!=null?o.push(c):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=n(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const h=i.inputs[l];if(!eu(c.shape,h.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${h.shape}'`);if(e[h.id]==null)e[h.id]=c;else{const u=e[h.id];e[h.id]=s(u,c),u.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hH=20,z0=3,iN=7;function iUe(e,t,n,s){const r=JI(t),i=oUe(e,t,n,r),o=t.length,a=dw(e,t,n,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function oUe(e,t,n,s){const r=tr(t),i=s[s.length-1],o=new Array(i).fill(0),a=t.length,l=n==="complex64"?V0(e):e;if(a>1)for(let c=0;c<r/i;c++){const h=c*i;for(let u=0;u<i;u++)o[u]=Math.max(o[u],U0(l[h+u],0,n).length)}return o}function U0(e,t,n){let s;return Array.isArray(e)?s=`${parseFloat(e[0].toFixed(iN))} + ${parseFloat(e[1].toFixed(iN))}j`:QI(e)?s=`'${e}'`:n==="bool"?s=dH(e):s=parseFloat(e.toFixed(iN)).toString(),cw(s,t)}function dH(e){return e===0?"false":"true"}function dw(e,t,n,s,r,i=!0){const o=n==="complex64"?2:1,a=t[0],l=t.length;if(l===0){if(n==="complex64"){const g=V0(e);return[U0(g[0],0,n)]}return n==="bool"?[dH(e[0])]:[e[0].toString()]}if(l===1){if(a>hH){const m=z0*o;let y=Array.from(e.slice(0,m)),v=Array.from(e.slice((a-z0)*o,a*o));return n==="complex64"&&(y=V0(y),v=V0(v)),["["+y.map((b,x)=>U0(b,r[x],n)).join(", ")+", ..., "+v.map((b,x)=>U0(b,r[a-z0+x],n)).join(", ")+"]"]}const g=n==="complex64"?V0(e):Array.from(e);return["["+g.map((m,y)=>U0(m,r[y],n)).join(", ")+"]"]}const c=t.slice(1),h=s.slice(1),u=s[0]*o,d=[];if(a>hH){for(let g=0;g<z0;g++){const m=g*u,y=m+u;d.push(...dw(e.slice(m,y),c,n,h,r,!1))}d.push("...");for(let g=a-z0;g<a;g++){const m=g*u,y=m+u;d.push(...dw(e.slice(m,y),c,n,h,r,g===a-1))}}else for(let g=0;g<a;g++){const m=g*u,y=m+u;d.push(...dw(e.slice(m,y),c,n,h,r,g===a-1))}const p=l===2?",":"";d[0]="["+d[0]+p;for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+p;let f=`,
`;for(let g=2;g<l;g++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":f),d}function V0(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oN{constructor(t,n,s){if(this.dtype=n,this.shape=t.slice(),this.size=tr(t),s!=null){const r=s.length;Q(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||Z$e(n,this.size),this.strides=JI(t)}set(t,...n){n.length===0&&(n=[0]),Q(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const s=this.locToIndex(n);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let n=0;for(const r of t){if(r<0||r>=this.shape[n]){const i=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(i)}n++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let n=t[t.length-1];for(let s=0;s<t.length-1;++s)n+=this.strides[s]*t[s];return n}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const n=new Array(this.shape.length);for(let s=0;s<n.length-1;++s)n[s]=Math.floor(t/this.strides[s]),t-=n[s]*this.strides[s];return n[n.length-1]=t,n}get rank(){return this.shape.length}toTensor(){return sa().makeTensor(this.values,this.shape,this.dtype)}}let sa=null,lf=null;function aUe(e){sa=e}function lUe(e){lf=e}class ur{constructor(t,n,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=n||"float32",this.size=tr(t),this.strides=JI(t),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return lf.buffer(this.shape,this.dtype,t)}bufferSync(){return lf.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return eN(this.shape,t,this.dtype==="complex64")}arraySync(){return eN(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=sa().read(this.dataId);if(this.dtype==="string"){const n=await t;try{return n.map(s=>uH(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),sa().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=sa().readSync(this.dataId);if(this.dtype==="string")try{return t.map(n=>uH(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await sa().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(sa().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return lf.print(this,t)}clone(){return this.throwIfDisposed(),lf.clone(this)}toString(t=!1){const n=this.dataSync();return iUe(n,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),lf.cast(this,t)}variable(t=!0,n,s){return this.throwIfDisposed(),sa().makeVariable(this,t,n,s)}}Object.defineProperty(ur,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function cUe(){return sN("Tensor",()=>ur)}cUe();class aN extends ur{constructor(t,n,s,r){super(t.shape,t.dtype,t.dataId,r);this.trainable=n,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!eu(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);sa().disposeTensor(this),this.dataId=t.dataId,sa().incRef(this,null)}dispose(){sa().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(aN,Symbol.hasInstance,{value:e=>e instanceof ur&&e.assign!=null&&e.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var pH;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(pH||(pH={}));var lN;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(lN||(lN={}));var cN;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(cN||(cN={}));var uN;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(uN||(uN={}));var hN;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(hN||(hN={}));const uUe={float32:uN,int32:lN,bool:cN,complex64:hN};function hUe(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return uUe[e][t]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function es(e,t){if(e.dtype===t.dtype)return[e,t];const n=hUe(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function dUe(e,t){Q(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function fH(e){const t=[],n=new Set;return mH(e,t,n),t}function mH(e,t,n){if(e==null)return;if(e instanceof ur){t.push(e);return}if(!pUe(e))return;const s=e;for(const r in s){const i=s[r];n.has(i)||(n.add(i),mH(i,t,n))}}function pUe(e){return Array.isArray(e)||typeof e=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dN(e){return e.kernelName!=null}class gH{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class cf{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new gH}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,s=1){return t in this.registryFactory?(B0(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:n,asyncInit:s}=this.initializeBackend(t);if(!(s?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new eUe(this.backendInstance),!0}setupRegisteredKernels(){lH(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){lH(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=n.factory();if(s&&!(s instanceof K$e)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[t]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,B0(`Initialization of backend ${t} failed`),B0(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return B0(`Initialization of backend ${t} failed`),B0(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){const s=this.state.tensorInfo.get(n),r=s.backend,i=this.readSync(n),o=r.refCount(n);r.disposeData(n,!0),s.backend=t,t.move(n,i,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let s=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,n,s){t();try{const r=s();return n(),r}catch(r){throw n(),r}}nextTensorId(){return cf.nextTensorId++}nextVariableId(){return cf.nextVariableId++}clone(t){const n=de.runKernel(eH,{x:t}),s={x:t},r=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return de.runKernel(J5,l,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[n],r,i,{}),n}runKernel(t,n,s){if(this.backendName==null&&this.backend,!(oH(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,s){const r=this.backend.numDataIds();let i=0;s.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-n-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t){let n,s=[];const r=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=dN(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(dN(t)){const{kernelName:f,inputs:g,attrs:m}=t;this.backendName==null&&this.backend;const y=oH(f,this.backendName);Q(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),a=()=>{const v=this.backend.numDataIds();l=y.kernelFunc({inputs:g,attrs:m,backend:this.backend});const b=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,v,b);const x=b.map(w=>w.rank!=null?w:this.makeTensorFromTensorInfo(w));if(r){const w=this.getTensorsForGradient(f,g,x);s=this.saveTensorsForBackwardMode(w)}return x}}else{const{forwardFunc:f}=t,g=m=>{!r||(s=m.map(y=>this.keep(this.clone(y))))};a=()=>{const m=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,g));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,m,y),y}}const{inputs:h,attrs:u}=t,d=dN(t)?null:t.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=a():(p=this.profiler.profileKernel(c,h,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),n=p.outputs)}),r&&this.addTapeNode(c,h,n,d,s,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(f=>h[f]!=null?h[f].shape:null),outputShapes:n.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,n,s){const r=aH(t);if(r!=null){const i=r.inputsToSave||[],o=r.outputsToSave||[];let a;r.saveAllInputs?(Q(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(n).map(c=>n[c])):a=i.map(c=>n[c]);const l=s.filter((c,h)=>o[h]);return a.concat(l)}return[]}makeTensor(t,n,s,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=t;s==="string"&&QI(t[0])&&(i=t.map(l=>J4e(l)));const o=r.write(i,n,s),a=new ur(n,s,o,this.nextTensorId());if(this.trackTensor(a,r),s==="string"){const l=this.state.tensorInfo.get(o),c=tBe(i);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(t,n,s,r){s=s||"float32";const i={dataId:t,shape:n,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(t,n){const{dataId:s,shape:r,dtype:i}=t,o=new ur(r,i,s,this.nextTensorId());return this.trackTensor(o,n),o}makeVariable(t,n=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));const i=new aN(t,n,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*W5(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof aN||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*W5(t.dtype);this.state.numBytes-=s}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const n=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,s,r,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:s,saved:i},l=aH(t);l!=null&&(r=l.gradFunc),r!=null&&(a.gradient=c=>(c=c.map((h,u)=>{if(h==null){const d=s[u],p=tN(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return h}),r(c.length>1?c:c[0],i,o))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){const n=fH(t),s=new Set(n.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(t,n,s,r=!1){if(Q(n.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));Q(i instanceof ur,()=>"The result y returned by f() must be a tensor.");const o=sUe(this.state.activeTape,n,i);if(!r&&o.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=s==null?fUe(i.shape):s,rUe(a,o,c=>this.tidy(c),mUe);const l=n.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const h of c.saved)h.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(t){return Q(H5(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{Q(n.every(a=>a instanceof ur),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};n.forEach((a,l)=>{r[l]=a});const i=(a,l)=>(s=t(...n,l),Q(s.value instanceof ur,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Q(H5(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(a,l)=>{const c=s.gradFunc(a,l),h=Array.isArray(c)?c:[c];Q(h.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Q(h.every(d=>d instanceof ur),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const u={};return h.forEach((d,p)=>{u[p]=()=>d}),u};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){const n=hw(),s=await this.backend.time(t);return s.wallMs=hw()-n,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new gH;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}cf.nextTensorId=0;cf.nextVariableId=0;function fUe(e){const t=q5(tr(e),"float32");return de.makeTensor(t,e,"float32")}function yH(){const e=Q5();if(e._tfengine==null){const t=new rBe(e);e._tfengine=new cf(t)}return lBe(e._tfengine.ENV),aUe(()=>e._tfengine),e._tfengine}const de=yH();function mUe(e,t){const n={a:e,b:t};return de.runKernel(Z5,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gUe(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fi=sn();fi.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});fi.registerFlag("IS_BROWSER",()=>gUe());fi.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");fi.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));fi.registerFlag("PROD",()=>!1);fi.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>fi.getBool("DEBUG"));fi.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);fi.registerFlag("IS_TEST",()=>!1);fi.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);fi.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);fi.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);fi.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);fi.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tu(e,t){let n=e;if(sl(e))return t==="string"?[]:[e.length];if(!Array.isArray(e))return[];const s=[];for(;Array.isArray(n)||sl(n)&&t!=="string";)s.push(n.length),n=n[0];return Array.isArray(e)&&sn().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&vH(e,s,[]),s}function vH(e,t,n){if(n=n||[],!Array.isArray(e)&&!sl(e)){Q(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}Q(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),Q(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const s=t.slice(1);for(let r=0;r<e.length;++r)vH(e[r],s,n.concat(r))}function xH(e,t,n,s){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${s}' must be ${e} tensor, but got ${t} tensor`)}}function G(e,t,n,s="numeric"){if(e instanceof ur)return xH(s,e.dtype,t,n),e;let r=ZI(e);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),xH(s,r,t,n),e==null||!sl(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){const l=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const i=tu(e,r);!sl(e)&&!Array.isArray(e)&&(e=[e]);const a=r!=="string"?cH(e,r):lw(e,[],!0);return de.makeTensor(a,i,r)}function pw(e,t,n,s="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((i,o)=>G(i,`${t}[${o}]`,n,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bH="__op";function ee(e){const t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const s=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+bH;const r=(...i)=>{de.startScope(n);try{const o=s(...i);return af(o)&&console.error("Cannot return a Promise inside of tidy."),de.endScope(o),o}catch(o){throw de.endScope(null),o}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yUe(e,t){const n=G(e,"real","complex"),s=G(t,"imag","complex");wo(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:n,imag:s};return de.runKernel(DBe,r)}const nu=ee({complex_:yUe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function su(e,t,n,s){if(s==null&&(s=ZI(e)),s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!sl(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){X5(t);const r=tr(t),i=tr(n);Q(r===i,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${i}`);for(let o=0;o<n.length;++o){const a=n[o],l=o===n.length-1?a!==tr(t.slice(o)):!0;Q(n[o]===t[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!sl(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=s!=="string"?cH(e,s):lw(e,[],!0),de.makeTensor(e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rl(e,t,n){const s=tu(e,n);return su(e,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pN={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fw=4;async function vUe(e,t){const n=[],s=[],r=Array.isArray(e)?e.map(o=>o.name):Object.keys(e);for(let o=0;o<r.length;++o){const a=r[o],l=Array.isArray(e)?e[o].tensor:e[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const h=new Promise(async u=>{const d=await l.bytes(),p=d.reduce((m,y)=>m+y.length,0)+fw*d.length,f=new Uint8Array(p);let g=0;for(let m=0;m<d.length;m++){const y=d[m],v=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(v,g),g+=fw,f.set(y,g),g+=y.length}u(f)});s.push(h)}else s.push(l.data());t!=null&&(c.group=t),n.push(c)}const i=await Promise.all(s);return{data:xUe(i),specs:n}}function wH(e,t){const n={};let s,r=0;for(const i of t){const o=i.name,a=i.dtype,l=i.shape,c=tr(l);let h;if("quantization"in i){const u=i.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${i.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${i.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${i.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const d=pN[u.dtype],p=e.slice(r,r+c*d),f=u.dtype==="uint8"?new Uint8Array(p):new Uint16Array(p);if(a==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){h=new Float32Array(f.length);for(let g=0;g<f.length;g++){const m=f[g];h[g]=m*u.scale+u.min}}else if(u.dtype==="float16")s===void 0&&(s=TUe()),h=s(f);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(a==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);h=new Int32Array(f.length);for(let g=0;g<f.length;g++){const m=f[g];h[g]=Math.round(m*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${o}': ${a}`);r+=c*d}else if(a==="string"){const u=tr(i.shape);h=[];for(let d=0;d<u;d++){const p=new Uint32Array(e.slice(r,r+fw))[0];r+=fw;const f=new Uint8Array(e.slice(r,r+p));h.push(f),r+=p}}else{const u=pN[a],d=e.slice(r,r+c*u);if(a==="float32")h=new Float32Array(d);else if(a==="int32")h=new Int32Array(d);else if(a==="bool")h=new Uint8Array(d);else if(a==="complex64"){h=new Float32Array(d);const p=new Float32Array(h.length/2),f=new Float32Array(h.length/2);for(let y=0;y<p.length;y++)p[y]=h[y*2],f[y]=h[y*2+1];const g=rl(p,l,"float32"),m=rl(f,l,"float32");n[o]=nu(g,m),g.dispose(),m.dispose()}else throw new Error(`Unsupported dtype in weight '${o}': ${a}`);r+=c*u}a!=="complex64"&&(n[o]=rl(h,l,a))}return n}function xUe(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(i=>{if(t+=i.byteLength,n.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(t);let r=0;return n.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const fN=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function SH(e){return fN?Buffer.byteLength(e):new Blob([e]).size}function bUe(e){if(fN)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let s=0,r=t.length;s<r;s++)n+=String.fromCharCode(t[s]);return btoa(n)}function wUe(e){if(fN){const s=Buffer.from(e,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let s=0;s<t.length;++s)n.set([t.charCodeAt(s)],s);return n.buffer}function mN(e){if(e.length===1)return e[0];let t=0;e.forEach(r=>{t+=r.byteLength});const n=new Uint8Array(t);let s=0;return e.forEach(r=>{n.set(new Uint8Array(r),s),s+=r.byteLength}),n.buffer}function _H(e){const t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);const n=e.split(t);return n[n.length-1]}function CH(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function TH(e,t,n){const s={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(s.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=n}return e.signature!=null&&(s.signature=e.signature),e.userDefinedMetadata!=null&&(s.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(s.modelInitializer=e.modelInitializer),s}async function gN(e,t){let n,s;return e.weightsManifest!=null&&([n,s]=await t(e.weightsManifest)),TH(e,n,s)}function G0(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:SH(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:SH(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:e.weightData.byteLength}}function EH(e){const t=[];for(const n of e)t.push(...n.weights);return t}function SUe(){const e=n=>{let s=n<<13,r=0;for(;(s&8388608)==0;)r-=8388608,s<<=1;return s&=~8388608,r+=947912704,s|r},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function _Ue(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function CUe(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function TUe(){const e=SUe(),t=_Ue(),n=CUe();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let o=0;o<s.length;o++){const a=s[o],l=e[n[a>>10]+(a&1023)]+t[a>>10];i[o]=l}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Zn.instance==null&&(Zn.instance=new Zn),Zn.instance}static registerSaveRouter(t){Zn.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Zn.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Zn.getHandlers(t,"save")}static getLoadHandlers(t,n){return Zn.getHandlers(t,"load",n)}static getHandlers(t,n,s){const r=[];return(n==="load"?Zn.getInstance().loadRouters:Zn.getInstance().saveRouters).forEach(o=>{const a=o(t,s);a!==null&&r.push(a)}),r}}const EUe=e=>Zn.registerSaveRouter(e),AUe=e=>Zn.registerLoadRouter(e),IUe=e=>Zn.getSaveHandlers(e),NUe=(e,t)=>Zn.getLoadHandlers(e,t);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yN="tensorflowjs",vN=1,Rh="models_store",ru="model_info_store";function AH(){if(!sn().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e=typeof window=="undefined"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function xN(e){const t=e.result;t.createObjectStore(Rh,{keyPath:"modelPath"}),t.createObjectStore(ru,{keyPath:"modelPath"})}class Lh{constructor(t){if(this.indexedDB=AH(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise((s,r)=>{const i=this.indexedDB.open(yN,vN);i.onupgradeneeded=()=>xN(i),i.onsuccess=()=>{const o=i.result;if(n==null){const a=o.transaction(Rh,"readonly"),c=a.objectStore(Rh).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=h=>(o.close(),r(c.error)),a.oncomplete=()=>o.close()}else{const a=G0(n),l=o.transaction(ru,"readwrite");let c=l.objectStore(ru);const h=c.put({modelPath:this.modelPath,modelArtifactsInfo:a});let u;h.onsuccess=()=>{u=o.transaction(Rh,"readwrite");const p=u.objectStore(Rh).put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:a});p.onsuccess=()=>s({modelArtifactsInfo:a}),p.onerror=f=>{c=l.objectStore(ru);const g=c.delete(this.modelPath);g.onsuccess=()=>(o.close(),r(p.error)),g.onerror=m=>(o.close(),r(p.error))}},h.onerror=d=>(o.close(),r(h.error)),l.oncomplete=()=>{u==null?o.close():u.oncomplete=()=>o.close()}}},i.onerror=o=>r(i.error)})}}Lh.URL_SCHEME="indexeddb://";const IH=e=>sn().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Lh.URL_SCHEME)?kUe(e.slice(Lh.URL_SCHEME.length)):null;Zn.registerSaveRouter(IH);Zn.registerLoadRouter(IH);function kUe(e){return new Lh(e)}function DUe(e){return e.startsWith(Lh.URL_SCHEME)?e.slice(Lh.URL_SCHEME.length):e}class MUe{constructor(){this.indexedDB=AH()}async listModels(){return new Promise((t,n)=>{const s=this.indexedDB.open(yN,vN);s.onupgradeneeded=()=>xN(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(ru,"readonly"),a=i.objectStore(ru).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;t(l)},a.onerror=l=>(r.close(),n(a.error)),i.oncomplete=()=>r.close()},s.onerror=r=>n(s.error)})}async removeModel(t){return t=DUe(t),new Promise((n,s)=>{const r=this.indexedDB.open(yN,vN);r.onupgradeneeded=()=>xN(r),r.onsuccess=()=>{const i=r.result,o=i.transaction(ru,"readwrite"),a=o.objectStore(ru),l=a.get(t);let c;l.onsuccess=()=>{if(l.result==null)return i.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const h=a.delete(t),u=()=>{c=i.transaction(Rh,"readwrite");const p=c.objectStore(Rh).delete(t);p.onsuccess=()=>n(l.result.modelArtifactsInfo),p.onerror=f=>s(l.error)};h.onsuccess=u,h.onerror=d=>(u(),i.close(),s(l.error))}},l.onerror=h=>(i.close(),s(l.error)),o.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $l="/",uf="tensorflowjs_models",NH="info",PUe="model_topology",OUe="weight_specs",RUe="weight_data",LUe="model_metadata";function kH(e){return{info:[uf,e,NH].join($l),topology:[uf,e,PUe].join($l),weightSpecs:[uf,e,OUe].join($l),weightData:[uf,e,RUe].join($l),modelMetadata:[uf,e,LUe].join($l)}}function DH(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function FUe(e){const t=e.split($l);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join($l)}function $Ue(e){return e.startsWith(Fh.URL_SCHEME)?e.slice(Fh.URL_SCHEME.length):e}class Fh{constructor(t){if(!sn().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=kH(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),r=G0(t);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,bUe(t.weightData));const i={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:r}}catch{throw DH(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);n.format=a.format,n.generatedBy=a.generatedBy,n.convertedBy=a.convertedBy,a.signature!=null&&(n.signature=a.signature),a.userDefinedMetadata!=null&&(n.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(n.modelInitializer=a.modelInitializer),a.trainingConfig!=null&&(n.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=wUe(o),n}}Fh.URL_SCHEME="localstorage://";const MH=e=>sn().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Fh.URL_SCHEME)?BUe(e.slice(Fh.URL_SCHEME.length)):null;Zn.registerSaveRouter(MH);Zn.registerLoadRouter(MH);function BUe(e){return new Fh(e)}class zUe{constructor(){Q(sn().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Q(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},n=uf+$l,s=$l+NH;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(n)&&i.endsWith(s)){const o=FUe(i);t[o]=JSON.parse(this.LS.getItem(i))}}return t}async removeModel(t){t=$Ue(t);const n=kH(t);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(n.info));return DH(n),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hf="://";class Ir{constructor(){this.managers={}}static getInstance(){return Ir.instance==null&&(Ir.instance=new Ir),Ir.instance}static registerManager(t,n){Q(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(hf)&&(t=t.slice(0,t.indexOf(hf))),Q(t.length>0,()=>"scheme must not be an empty string.");const s=Ir.getInstance();Q(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=n}static getManager(t){const n=Ir.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(Ir.getInstance().managers)}}function mw(e){if(e.indexOf(hf)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ir.getSchemes().join(",")}`);return{scheme:e.split(hf)[0],path:e.split(hf)[1]}}async function PH(e,t,n=!1){Q(e!==t,()=>`Old path and new path are the same: '${e}'`);const s=Zn.getLoadHandlers(e);Q(s.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),Q(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${e}.`);const r=s[0],i=Zn.getSaveHandlers(t);Q(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),Q(i.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${t}.`);const o=i[0],a=mw(e).scheme,l=mw(e).path,c=a===mw(e).scheme,h=await r.load();n&&c&&await Ir.getManager(a).removeModel(l);const u=await o.save(h);return n&&!c&&await Ir.getManager(a).removeModel(l),u.modelArtifactsInfo}async function UUe(){const e=Ir.getSchemes(),t={};for(const n of e){const s=await Ir.getManager(n).listModels();for(const r in s){const i=n+hf+r;t[i]=s[r]}}return t}async function VUe(e){const t=mw(e);return Ir.getManager(t.scheme).removeModel(t.path)}async function GUe(e,t){return PH(e,t,!1)}async function WUe(e,t){return PH(e,t,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HUe{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}setTimeoutCustom(t,n){if(!window||!sn().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,n);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{s.source===window&&s.data.name===this.messageName&&(s.stopPropagation(),this.functionRefs[s.data.index](),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0))}}if(sn().get("IS_BROWSER")){sn().setPlatform("browser",new HUe);try{Ir.registerManager(Fh.URL_SCHEME,new zUe)}catch{}try{Ir.registerManager(Lh.URL_SCHEME,new MUe)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jUe={importFetch:()=>require("node-fetch")};let bN;class qUe{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,n){return sn().global.fetch!=null?sn().global.fetch(t,n):(bN==null&&(bN=jUe.importFetch()),bN(t,n))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(t)}decode(t,n){return t.length===0?"":new this.util.TextDecoder(n).decode(t)}}sn().get("IS_NODE")&&!sn().get("IS_BROWSER")&&sn().setPlatform("node",new qUe);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bl(e,t="float32",n){return t=t||"float32",X5(e),new oN(e,t,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XUe(e,t){const n=G(e,"x","cast");if(!eBe(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:n},r={dtype:t};return de.runKernel(J5,s,r)}const Vs=ee({cast_:XUe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KUe(e){const n={x:G(e,"x","clone","string_or_numeric")};return de.runKernel(eH,n)}const iu=ee({clone_:KUe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OH(e,t=!1){console.log(e.toString(t))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */yH();const YUe={buffer:Bl,cast:Vs,clone:iu,print:OH};lUe(YUe);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QUe="model",ZUe=".json",JUe=".weights.bin";function RH(e){return new Promise(t=>setTimeout(t)).then(e)}class $h{constructor(t){if(!sn().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith($h.URL_SCHEME)&&(t=t.slice($h.URL_SCHEME.length)),(t==null||t.length===0)&&(t=QUe),this.modelJsonFileName=t+ZUe,this.weightDataFileName=t+JUe}async save(t){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],r=CH(t,s),i=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await RH(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){const a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=n,await RH(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:G0(t)}}}}$h.URL_SCHEME="downloads://";class eVe{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,n)=>{const s=new FileReader;s.onload=r=>{const i=JSON.parse(r.target.result),o=i.modelTopology;if(o==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:o});return}const l=gN(i,c=>this.loadWeights(c));t(l)},s.onerror=r=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(t){const n=[],s=[];for(const o of t)n.push(...o.weights),s.push(...o.paths);const r=this.checkManifestAndWeightFiles(t),i=s.map(o=>this.loadWeightsFile(o,r[o]));return Promise.all(i).then(o=>[n,mN(o)])}loadWeightsFile(t,n){return new Promise((s,r)=>{const i=new FileReader;i.onload=o=>{const a=o.target.result;s(a)},i.onerror=o=>r(`Failed to weights data from file of path '${t}'.`),i.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(t){const n=[],s=this.weightsFiles.map(i=>_H(i.name)),r={};for(const i of t)i.paths.forEach(o=>{const a=_H(o);if(n.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(n.push(a),s.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);r[o]=this.weightsFiles[s.indexOf(a)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const tVe=e=>sn().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith($h.URL_SCHEME)?nVe(e.slice($h.URL_SCHEME.length)):null;Zn.registerSaveRouter(tVe);function nVe(e="model"){return new $h(e)}function sVe(e){return new eVe(e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LH(e,t,n,s){o(e),n=n==null?0:n,s=s==null?1:s,a(n,s);let r=0;const i=l=>(l.then(c=>{const h=n+ ++r/e.length*(s-n);return t(h),c}),l);function o(l){Q(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){Q(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),Q(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),Q(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(e.map(i))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function FH(e,t){t==null&&(t={});const n=t.fetchFunc==null?sn().platform.fetch:t.fetchFunc,s=e.map(u=>n(u,t.requestInit,{isBinary:!0})),r=0,i=.5,a=(t.onProgress==null?await Promise.all(s):await LH(s,t.onProgress,r,i)).map(u=>u.arrayBuffer()),l=.5,c=1;return t.onProgress==null?await Promise.all(a):await LH(a,t.onProgress,l,c)}async function rVe(e,t="",n,s){return $H(o=>FH(o,{requestInit:s}))(e,t,n)}function $H(e){return async(t,n="",s)=>{const r=t.map(()=>!1),i={},o=s!=null?s.map(()=>!1):[],a=[];if(t.forEach((p,f)=>{let g=0;p.weights.forEach(m=>{const y="quantization"in m?m.quantization.dtype:m.dtype,v=pN[y]*tr(m.shape),b=()=>{r[f]=!0,i[f]==null&&(i[f]=[]),i[f].push({manifestEntry:m,groupOffset:g,sizeBytes:v})};s!=null?s.forEach((x,w)=>{x===m.name&&(b(),o[w]=!0)}):b(),a.push(m.name),g+=v})}),!o.every(p=>p)){const p=s.filter((f,g)=>!o[g]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=r.reduce((p,f,g)=>(f&&p.push(g),p),[]),c=[];l.forEach(p=>{t[p].paths.forEach(f=>{const g=n+(n.endsWith("/")?"":"/")+f;c.push(g)})});const h=await e(c),u={};let d=0;return l.forEach(p=>{const f=t[p].paths.length;let g=0;for(let x=0;x<f;x++)g+=h[d+x].byteLength;const m=new ArrayBuffer(g),y=new Uint8Array(m);let v=0;for(let x=0;x<f;x++){const w=new Uint8Array(h[d+x]);y.set(w,v),v+=w.byteLength}i[p].forEach(x=>{const w=m.slice(x.groupOffset,x.groupOffset+x.sizeBytes),S=wH(w,[x.manifestEntry]);for(const C in S)u[C]=S[C]}),d+=f}),u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iVe="application/octet-stream",oVe="application/json";class wN{constructor(t,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.onProgress=n.onProgress,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(Q(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=sn().platform.fetch,Q(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&Q(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r=CH(t,s);n.body.append("model.json",new Blob([JSON.stringify(r)],{type:oVe}),"model.json"),t.weightData!=null&&n.body.append("model.weights.bin",new Blob([t.weightData],{type:iVe}),"model.weights.bin");const i=await this.fetch(this.path,n);if(i.ok)return{modelArtifactsInfo:G0(t),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await t.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=n.modelTopology,r=n.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return gN(n,i=>this.loadWeights(i))}async loadWeights(t){const n=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=aVe(n),i=this.weightPathPrefix||s,o=EH(t),a=[],l=[];for(const h of t)for(const u of h.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(u)):a.push(i+u+r);this.weightUrlConverter&&a.push(...await Promise.all(l));const c=await FH(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,mN(c)]}}wN.URL_SCHEME_REGEX=/^https?:\/\//;function aVe(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),s=e.substring(0,t),r=n>t?e.substring(n):"";return[s+"/",r]}function SN(e){return e.match(wN.URL_SCHEME_REGEX)!=null}const BH=(e,t)=>{if(typeof fetch=="undefined"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(s=>SN(s)):n=SN(e),n)return _N(e,t)}return null};Zn.registerSaveRouter(BH);Zn.registerLoadRouter(BH);function _N(e,t){return new wN(e,t)}function lVe(e,t){return _N(e,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CN{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class zH{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class cVe{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=n=>Promise.resolve(t.save(n)))}}function uVe(e,t,n,s){const r=arguments;return new cVe(UH(...r))}function UH(e,t,n,s){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new CN(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new CN({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new CN({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:s}))}function hVe(e){return new zH(e)}function dVe(e){return new zH(e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var VH=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",browserFiles:sVe,browserHTTPRequest:lVe,concatenateArrayBuffers:mN,decodeWeights:wH,encodeWeights:vUe,fromMemory:uVe,fromMemorySync:UH,getLoadHandlers:NUe,getModelArtifactsForJSON:gN,getModelArtifactsForJSONSync:TH,getModelArtifactsInfoForJSON:G0,getSaveHandlers:IUe,getWeightSpecs:EH,http:_N,isHTTPScheme:SN,loadWeights:rVe,registerLoadRouter:AUe,registerSaveRouter:EUe,weightsLoaderFactory:$H,withSaveHandler:hVe,withSaveHandlerSync:dVe,copyModel:GUe,listModels:UUe,moveModel:WUe,removeModel:VUe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pVe(e,t,n=!1,s=!1){let r=G(e,"a","matMul"),i=G(t,"b","matMul");[r,i]=es(r,i);const o={a:r,b:i},a={transposeA:n,transposeB:s};return de.runKernel(TBe,o,a)}const Cn=ee({matMul_:pVe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fVe(e,t,n=1,s=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:G(e,"indices","oneHot","int32")},a={dtype:r,depth:t,onValue:n,offValue:s};return de.runKernel(Xze,o,a)}const mVe=ee({oneHot_:fVe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function So(e,t){return de.tidy(e,t)}function gVe(e){fH(e).forEach(n=>n.dispose())}function ou(e){return de.keep(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yVe(e){const n={input:G(e,"input","imag")};return de.runKernel(gze,n)}const gw=ee({imag_:yVe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vVe(e){const n={x:G(e,"x","neg")};return de.runKernel(Vze,n)}const zl=ee({neg_:vVe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xVe(e){const n={input:G(e,"input","real")};return de.runKernel(s4e,n)}const W0=ee({real_:xVe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bVe(e,t,n){const s=G(e,"x","transpose");if(t==null&&(t=s.shape.map((o,a)=>a).reverse()),Q(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(o=>{Q(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:t};return s.dtype==="complex64"?So(()=>{let o=W0(s),a=gw(s);return o=de.runKernel(rN,{x:o},i),a=de.runKernel(rN,{x:a},i),n&&(a=zl(a)),nu(o,a)}):de.runKernel(rN,r,i)}const TN=ee({transpose_:bVe});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wVe(e,t){const n=[];for(let s=0;s<t.length;s++){const r=e[e.length-s-1],i=t.length-s-1,o=t[i];(r==null||r===1&&o>1)&&n.unshift(i)}return n}function Gs(e,t){const n=[],s=Math.max(e.length,t.length);for(let r=0;r<s;r++){let i=e[e.length-r-1];i==null&&(i=1);let o=t[t.length-r-1];if(o==null&&(o=1),i===1)n.unshift(o);else if(o===1)n.unshift(i);else if(i!==o){const a=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(a)}else n.unshift(i)}return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SVe(e,t,n){if(of(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=tu(e,n);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return su(e,t,s,n)}function _Ve(e,t,n){const s=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(i+` update.rank < ${r}. `);if(e.length<s+(n.rank-r))throw new Error(i+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+e.length-s)throw new Error(i+` update.rank != ${r+e.length-s}`);for(let o=0;o<r;++o)if(n.shape[o]!==t.shape[o])throw new Error(i+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<n.rank-r;++o)if(n.shape[o+r]!==e[o+s])throw new Error(i+` updates.shape[${o+r}] (${n.shape[o+r]}) != shape[${o+r}] (${e[o+r]})`)}function CVe(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}_Ve(n,t,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TVe(e,t){let n=G(e,"a","add"),s=G(t,"b","add");[n,s]=es(n,s);const r={a:n,b:s};return de.runKernel(Z5,r)}const Ws=ee({add_:TVe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EVe(e,t){let n=G(e,"a","floorDiv"),s=G(t,"b","floorDiv");[n,s]=es(n,s);const r={a:n,b:s};return de.runKernel(cze,r)}const GH=ee({floorDiv_:EVe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AVe(e,t){let n=G(e,"a","div"),s=G(t,"b","div");if([n,s]=es(n,s),n.dtype==="int32"&&s.dtype==="int32")return GH(n,s);const r={a:n,b:s},i={};return de.runKernel(QBe,r,i)}const Nr=ee({div_:AVe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IVe(e,t){let n=G(e,"a","mul"),s=G(t,"b","mul");[n,s]=es(n,s);const r={a:n,b:s};return de.runKernel(Uze,r)}const Wt=ee({mul_:IVe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NVe(e){const t=G(e,"x","abs");if(t.dtype==="complex64"){const n={x:t};return de.runKernel(MBe,n)}else{const n={x:t};return de.runKernel(uBe,n)}}const _o=ee({abs_:NVe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kVe(e){const n={x:G(e,"x","acos")};return de.runKernel(hBe,n)}const DVe=ee({acos_:kVe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MVe(e){const n={x:G(e,"x","acosh")};return de.runKernel(dBe,n)}const PVe=ee({acosh_:MVe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OVe(e){Q(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),Q(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);const t=e.map((r,i)=>G(r,`tensors${i}`,"addN")),n=t[0];t.forEach(r=>{if(r.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(r=>{if(!eu(r.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=t;return de.runKernel(pBe,s)}const RVe=ee({addN_:OVe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LVe(e,t=null,n=!1){const r={x:G(e,"x","all","bool")},i={axis:t,keepDims:n};return de.runKernel(fBe,r,i)}const FVe=ee({all_:LVe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ve(e,t=null,n=!1){const r={x:G(e,"x","any","bool")},i={axis:t,keepDims:n};return de.runKernel(mBe,r,i)}const BVe=ee({any_:$Ve});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zVe(e,t=0){const s={x:G(e,"x","argMax")},r={axis:t};return de.runKernel(gBe,s,r)}const UVe=ee({argMax_:zVe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VVe(e,t=0){const s={x:G(e,"x","argMin")},r={axis:t};return de.runKernel(yBe,s,r)}const GVe=ee({argMin_:VVe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WVe(e){const n={x:G(e,"x","asin")};return de.runKernel(vBe,n)}const HVe=ee({asin_:WVe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jVe(e){const n={x:G(e,"x","asinh")};return de.runKernel(xBe,n)}const qVe=ee({asinh_:jVe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XVe(e){const n={x:G(e,"x","atan")};return de.runKernel(bBe,n)}const KVe=ee({atan_:XVe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YVe(e,t){let n=G(e,"a","atan2"),s=G(t,"b","atan2");[n,s]=es(n,s);const r={a:n,b:s};return de.runKernel(SBe,r)}const QVe=ee({atan2_:YVe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZVe(e){const n={x:G(e,"x","atanh")};return de.runKernel(wBe,n)}const JVe=ee({atanh_:ZVe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eGe(e,t,n,s,r,i,o="channelsLast"){const[a,l]=yw(t);let c;if(o==="channelsLast")c=[a,l,e[3],e[3]];else if(o==="channelsFirst")c=[a,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${o}`);return EN(e,c,n,s,r,i,!1,o)}function EN(e,t,n,s,r,i,o=!1,a="channelsLast"){let[l,c,h,u]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,h,u]=e;else if(a==="channelsFirst")[l,u,c,h]=e;else throw new Error(`Unknown dataFormat ${a}`);const[d,p,,f]=t,[g,m]=yw(n),[y,v]=yw(s),b=AN(d,y),x=AN(p,v),{padInfo:w,outHeight:S,outWidth:C}=sGe(r,c,h,g,m,b,x,i,a),_=o?f*u:f;let T;return a==="channelsFirst"?T=[l,_,S,C]:a==="channelsLast"&&(T=[l,S,C,_]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:h,inChannels:u,outHeight:S,outWidth:C,outChannels:_,padInfo:w,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:b,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:v,inShape:e,outShape:T,filterShape:t}}function tGe(e,t,n,s,r){s==null&&(s=nGe(e,t,n));const i=e[0],o=e[1],a=vw((i-t+2*s)/n+1,r),l=vw((o-t+2*s)/n+1,r);return[a,l]}function nGe(e,t,n,s=1){const r=AN(t,s);return Math.floor((e[0]*(n-1)-n+r)/2)}function yw(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function AN(e,t){return t<=1?e:e+(e-1)*(t-1)}function sGe(e,t,n,s,r,i,o,a,l){let c,h,u;if(typeof e=="number"){c={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};const p=tGe([t,n],i,s,e,a);h=p[0],u=p[1]}else if(e==="same"){h=Math.ceil(t/s),u=Math.ceil(n/r);const d=Math.max(0,(h-1)*s+i-t),p=Math.max(0,(u-1)*r+o-n),f=Math.floor(d/2),g=d-f,m=Math.floor(p/2),y=p-m;c={top:f,bottom:g,left:m,right:y,type:"SAME"}}else if(e==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((t-i+1)/s),u=Math.ceil((n-o+1)/r);else if(typeof e=="object"){const d=l==="channelsLast"?e[1][0]:e[2][0],p=l==="channelsLast"?e[1][1]:e[2][1],f=l==="channelsLast"?e[2][0]:e[3][0],g=l==="channelsLast"?e[2][1]:e[3][1];c={top:d,bottom:p,left:f,right:g,type:d===0&&p===0&&f===0&&g===0?"VALID":"EXPLICIT"},h=vw((t-i+d+p)/s+1,a),u=vw((n-o+f+g)/r+1,a)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:c,outHeight:h,outWidth:u}}function vw(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function xw(e){const[t,n,s]=yw(e);return t===1&&n===1&&s===1}function au(e,t){return xw(e)||xw(t)}function ra(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")Q($0(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(r=>{Q($0(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rGe(e,t){const s={x:G(e,"x","reshape","string_or_numeric")},r={shape:t};return de.runKernel(o4e,s,r)}const Oe=ee({reshape_:rGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iGe(e,t,n,s,r){const i=G(e,"x","avgPool","float32"),o=1;Q(au(n,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let a=i,l=!1;i.rank===3&&(l=!0,a=Oe(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Q(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),ra("avgPool",s,r);const c={x:a},h={filterSize:t,strides:n,pad:s,dimRoundingMode:r};let u=de.runKernel(_Be,c,h);return u=Vs(u,i.dtype),l?Oe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const WH=ee({avgPool_:iGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oGe(e,t,n,s,r,i="NDHWC"){const o=G(e,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=Oe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Q(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),Q(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),ra("avgPool3d",s,r);const c={x:a},h={filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:i};let u=de.runKernel(CBe,c,h);return u=Vs(u,a.dtype),l?Oe(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}const aGe=ee({avgPool3d_:oGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lGe(e,t=0){Q(e.length>=1,()=>"Pass at least one tensor to concat");const n=pw(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),n.length===1)return iu(n[0]);const s=n,r={axis:t};return de.runKernel(PBe,s,r)}const kr=ee({concat_:lGe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cGe(e){const n={x:G(e,"x","sigmoid","float32")};return de.runKernel(w4e,n)}const df=ee({sigmoid_:cGe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uGe(e,t,n){const s=G(e,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:t,size:n};return de.runKernel(y4e,r,i)}const Pn=ee({slice_:uGe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hGe(e){const n={x:G(e,"x","tanh","float32")};return de.runKernel(z4e,n)}const IN=ee({tanh_:hGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dGe(e,t,n,s,r,i){const o=G(e,"forgetBias","basicLSTMCell"),a=G(t,"lstmKernel","basicLSTMCell"),l=G(n,"lstmBias","basicLSTMCell"),c=G(s,"data","basicLSTMCell"),h=G(r,"c","basicLSTMCell"),u=G(i,"h","basicLSTMCell"),d=kr([c,u],1),p=Cn(d,a),f=Ws(p,l),g=f.shape[0],m=f.shape[1]/4,y=[g,m],v=Pn(f,[0,0],y),b=Pn(f,[0,m],y),x=Pn(f,[0,m*2],y),w=Pn(f,[0,m*3],y),S=Ws(Wt(df(v),IN(b)),Wt(h,df(Ws(o,x)))),C=Wt(IN(S),df(w));return[S,C]}const pGe=ee({basicLSTMCell_:dGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fGe(e,t,n){const s=G(e,"x","batchToSpaceND"),r=t.reduce((a,l)=>a*l);Q(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),Q(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),Q(s.shape[0]%r==0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);const i={x:s},o={blockShape:t,crops:n};return de.runKernel(EBe,i,o)}const HH=ee({batchToSpaceND_:fGe});function mGe(e){let t;return e.rank===0||e.rank===1?t=Oe(e,[1,1,1,e.size]):e.rank===2?t=Oe(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=Oe(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gGe(e,t,n,s,r,i){i==null&&(i=.001);const o=G(e,"x","batchNorm"),a=G(t,"mean","batchNorm"),l=G(n,"variance","batchNorm");let c;r!=null&&(c=G(r,"scale","batchNorm"));let h;s!=null&&(h=G(s,"offset","batchNorm")),Q(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Q(h==null||a.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Q(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:mGe(o),scale:c,offset:h,mean:a,variance:l},p={varianceEpsilon:i},f=de.runKernel(uze,d,p);return Oe(f,o.shape)}const bw=ee({batchNorm_:gGe});function yGe(e,t,n,s,r,i){const o=G(e,"x","batchNorm"),a=G(t,"mean","batchNorm"),l=G(n,"variance","batchNorm");let c;r!=null&&(c=G(r,"scale","batchNorm"));let h;return s!=null&&(h=G(s,"offset","batchNorm")),Q(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),Q(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),Q(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&Q(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),h!=null&&Q(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`),bw(o,a,l,h,c,i)}const vGe=ee({batchNorm2d_:yGe});function xGe(e,t,n,s,r,i){const o=G(e,"x","batchNorm"),a=G(t,"mean","batchNorm"),l=G(n,"variance","batchNorm");let c;r!=null&&(c=G(r,"scale","batchNorm"));let h;return s!=null&&(h=G(s,"offset","batchNorm")),Q(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),Q(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),Q(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&Q(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),h!=null&&Q(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`),bw(o,a,l,h,c,i)}const bGe=ee({batchNorm3d_:xGe});function wGe(e,t,n,s,r,i){const o=G(e,"x","batchNorm"),a=G(t,"mean","batchNorm"),l=G(n,"variance","batchNorm");let c;r!=null&&(c=G(r,"scale","batchNorm"));let h;return s!=null&&(h=G(s,"offset","batchNorm")),Q(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),Q(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),Q(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&Q(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),h!=null&&Q(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`),bw(o,a,l,h,c,i)}const SGe=ee({batchNorm4d_:wGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ge(e,t,n){const s=G(e,"x","bincount"),r=G(t,"weights","bincount");Q(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),Q(n>=0,()=>`size must be non-negative, but got ${n}.`),Q(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},o={size:n};return de.runKernel(ABe,i,o)}const jH=ee({bincount_:_Ge});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CGe(e,t){const n=G(e,"s0","broadcastArgs","int32"),s=G(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:n,s1:s};return de.runKernel(IBe,r)}const TGe=ee({broadcastArgs_:CGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EGe(e,t){let n=G(e,"broadcastTo","x");const s=n.shape;if(t.some(c=>!(c>0)||c%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const c=n.shape.slice();for(;c.length<t.length;)c.unshift(1);n=Oe(n,c)}const r=n.shape,i=Array.from(t);for(let c=t.length-1;c>=0;c--)if(r[c]===t[c])i[c]=1;else if(n.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(i.map((c,h)=>c>1?h:-1).filter(c=>c>=0).length===0)return iu(n);const a={x:n},l={reps:i};return de.runKernel(tH,a,l)}const ww=ee({broadcastTo_:EGe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AGe(e){const n={x:G(e,"x","ceil","float32")};return de.runKernel(NBe,n)}const IGe=ee({ceil_:AGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sw(e,t,n){const s={shape:e,value:t,dtype:n};return de.runKernel(oze,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NGe(e,t,n){const s=G(e,"x","clipByValue");if(Q(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Sw(s.shape,t,s.dtype);const r={x:s},i={clipValueMin:t,clipValueMax:n};return de.runKernel(kBe,r,i)}const kGe=ee({clipByValue_:NGe});function DGe(e){return kr(e,0)}const MGe=ee({concat1d_:DGe});function PGe(e,t){return kr(e,t)}const OGe=ee({concat2d_:PGe});function RGe(e,t){return kr(e,t)}const LGe=ee({concat3d_:RGe});function FGe(e,t){return kr(e,t)}const $Ge=ee({concat4d_:FGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BGe(e,t,n,s,r="NHWC",i=[1,1],o){const a=G(e,"x","conv2d","float32"),l=G(t,"filter","conv2d","float32");let c=a,h=!1;a.rank===3&&(h=!0,c=Oe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Q(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),Q(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),ra("conv2d",s,o);const u=r==="NHWC"?c.shape[3]:c.shape[1];Q(u===l.shape[2],()=>`Error in conv2d: depth of input (${u}) must match input depth for filter ${l.shape[2]}.`),Q(au(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);const d={x:c,filter:l},p={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},f=de.runKernel(OBe,d,p);return h?Oe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const _w=ee({conv2d_:BGe});function zGe(e,t,n,s,r="NWC",i=1,o){const a=G(e,"x","conv1d"),l=G(t,"filter","conv1d");let c=a,h=!1;a.rank===2&&(h=!0,c=Oe(a,[1,a.shape[0],a.shape[1]])),Q(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),Q(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),ra("conv1d",s,o),Q(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),Q(au(n,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`),Q(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const u=Oe(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=Oe(c,[c.shape[0],1,c.shape[1],c.shape[2]]),m=_w(d,u,[1,n],s,"NHWC",[1,i],o);return h?Oe(m,[m.shape[2],m.shape[3]]):Oe(m,[m.shape[0],m.shape[2],m.shape[3]])}const UGe=ee({conv1d_:zGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VGe(e,t,n,s,r,i="NHWC",o){Q(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,l=t,c=!1;t.rank===3&&(c=!0,l=Oe(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,e[0],e[1],e[2]]),Q(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),Q(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),Q(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const h=i==="NHWC"?a[3]:a[1],u=i==="NHWC"?l.shape[3]:l.shape[1];Q(h===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${n.shape[2]}.`),Q(u===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[3]}.`),ra("conv2dDerInput",r,o);const d={dy:l,filter:n},p={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:a},f=de.runKernel(LBe,d,p);return c?Oe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const qH=ee({conv2DBackpropInput_:VGe});function GGe(e,t,n,s,r,i){const o=G(e,"x","conv2dTranspose"),a=G(t,"filter","conv2dTranspose");return qH(n,o,a,s,r,"NHWC",i)}const WGe=ee({conv2dTranspose_:GGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HGe(e,t,n,s,r="NDHWC",i=[1,1,1]){const o=G(e,"x","conv3d"),a=G(t,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=Oe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Q(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),Q(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),Q(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),Q(au(n,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Q(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);const h={x:l,filter:a},u={strides:n,pad:s,dataFormat:r,dilations:i},d=de.runKernel(FBe,h,u);return c?Oe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const jGe=ee({conv3d_:HGe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qGe(e,t,n,s,r){Q(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let i=e,o=t,a=!1;t.rank===4&&(a=!0,o=Oe(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,e[0],e[1],e[2],e[3]]);const l=i[4],c=o.shape[4];Q(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),Q(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),Q(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),Q(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),Q(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const h={dy:o,filter:n},u={pad:r,strides:s,inputShape:i},d=de.runKernel($Be,h,u);return a?Oe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const XGe=ee({conv3DBackpropInput_:qGe});function KGe(e,t,n,s,r){const i=G(e,"x","conv3dTranspose"),o=G(t,"filter","conv3dTranspose");return XGe(n,i,o,s,r)}const YGe=ee({conv3dTranspose_:KGe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QGe(e){const n={x:G(e,"x","cos","float32")};return de.runKernel(BBe,n)}const ZGe=ee({cos_:QGe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JGe(e){const n={x:G(e,"x","cosh","float32")};return de.runKernel(zBe,n)}const eWe=ee({cosh_:JGe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tWe(e,t=0,n=!1,s=!1){const i={x:G(e,"x","cumprod")},o={axis:t,exclusive:n,reverse:s};return de.runKernel(UBe,i,o)}const nWe=ee({cumprod_:tWe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sWe(e,t=0,n=!1,s=!1){const i={x:G(e,"x","cumsum")},o={axis:t,exclusive:n,reverse:s};return de.runKernel(VBe,i,o)}const rWe=ee({cumsum_:sWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iWe(e,t,n,s=!1){const r=G(e,"x","denseBincount"),i=G(t,"weights","denseBincount");Q(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),Q(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),Q(n>=0,()=>`size must be non-negative, but got ${n}.`),Q(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const o={x:r,weights:i},a={size:n,binaryOutput:s};return de.runKernel(WBe,o,a)}const oWe=ee({denseBincount_:iWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aWe(e,t,n="NHWC"){const s=G(e,"x","depthToSpace","float32"),r=n==="NHWC"?s.shape[1]:s.shape[2],i=n==="NHWC"?s.shape[2]:s.shape[3],o=n==="NHWC"?s.shape[3]:s.shape[1];Q(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),Q(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${s.shape}`),Q(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t} for depthToSpace with input shape
        ${s.shape}`),Q(o%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${s.shape}`);const a={x:s},l={blockSize:t,dataFormat:n};return de.runKernel(HBe,a,l)}const lWe=ee({depthToSpace_:aWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cWe(e,t,n,s,r="NHWC",i=[1,1],o){const a=G(e,"x","depthwiseConv2d","float32"),l=G(t,"filter","depthwiseConv2d","float32");let c=a,h=!1;a.rank===3&&(h=!0,c=Oe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Q(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),Q(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const u=r==="NHWC"?c.shape[3]:c.shape[1];Q(u===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${u}) must match the inChannels dimension in filter ${l.shape[2]}.`),ra("depthwiseConv2d",s,o);const d={x:c,filter:l},p={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},f=de.runKernel(jBe,d,p);return h?Oe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const NN=ee({depthwiseConv2d_:cWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uWe(e){const n={x:G(e,"x","diag")};return de.runKernel(KBe,n)}const hWe=ee({diag_:uWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dWe(e,t,n,s,r=[1,1],i="NHWC"){const o=G(e,"x","dilation2d"),a=G(t,"filter","dilation2d");Q(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),Q(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),Q(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,c=!1;o.rank===3&&(l=Oe(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0);const h={x:l,filter:a},u={strides:n,pad:s,dilations:r},d=de.runKernel(YBe,h,u);return c?Oe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const pWe=ee({dilation2d_:dWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fWe(e,t){let n=G(e,"a","equal","string_or_numeric"),s=G(t,"b","equal","string_or_numeric");[n,s]=es(n,s),Gs(n.shape,s.shape);const r={a:n,b:s};return de.runKernel(tze,r)}const XH=ee({equal_:fWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mWe(e,t,n){const s=G(t,"a","where"),r=G(n,"b","where"),i=G(e,"condition","where","bool"),o=Gs(Gs(i.shape,s.shape),r.shape),a=ww(i,o),l=ww(s,o),c=ww(r,o),h={condition:a,t:l,e:c};return de.runKernel(m4e,h)}const pf=ee({where_:mWe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gWe(e){const n={x:G(e,"x","zerosLike")};return de.runKernel(j4e,n)}const kN=ee({zerosLike_:gWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yWe(e,t){let n=G(e,"a","div"),s=G(t,"b","div");[n,s]=es(n,s);const r=Nr(n,s),i=kN(r),o=XH(s,i);return pf(o,i,r)}const vWe=ee({divNoNan_:yWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xWe(e,t){const n=G(e,"t1","dot"),s=G(t,"t2","dot");Q((n.rank===1||n.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=n.rank===1?n.size:n.shape[1],i=s.rank===1?s.size:s.shape[0];if(Q(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),n.rank===1&&s.rank===1){const o=Oe(n,[1,-1]),a=Oe(s,[-1,1]),l=Cn(o,a);return Oe(l,[])}else if(n.rank===1&&s.rank===2){const o=Oe(n,[1,-1]),a=Oe(s,[s.shape[0],s.shape[1]]),l=Cn(o,a);return Oe(l,[l.size])}else if(n.rank===2&&s.rank===1){const o=Oe(s,[-1,1]),a=Cn(n,o);return Oe(a,[a.size])}else{const o=Oe(s,[s.shape[0],s.shape[1]]);return Cn(n,o)}}const bWe=ee({dot_:xWe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wWe(e,...t){const n=t.map((r,i)=>G(r,`tensors${i}`,"einsum")),s={equation:e};return de.runKernel(ZBe,n,s)}const SWe=ee({einsum_:wWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _We(e){const n={x:G(e,"x","elu","float32")};return de.runKernel(JBe,n)}const KH=ee({elu_:_We});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CWe(e){let t=G(e,"x","erf");Q(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Vs(t,"float32"));const n={x:t};return de.runKernel(eze,n)}const TWe=ee({erf_:CWe});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EWe(e,t,n){const s=e.length+t.length,r=[];let i=0,o=0;for(let a=0;a<s;a++)n.indexOf(a)===-1?r.push(e[i++]):r.push(t[o++]);return r}function Cw(e,t){const n=t.map(s=>1);return EWe(e,n,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AWe(e,t=null,n=!1){const r={x:G(e,"x","max")},i={reductionIndices:t,keepDims:n};return de.runKernel(kze,r,i)}const ff=ee({max_:AWe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IWe(e,t=null,n=!1){const r={x:G(e,"x","min")},i={axis:t,keepDims:n};return de.runKernel(Lze,r,i)}const DN=ee({min_:IWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NWe(e,t){let n=G(e,"base","pow"),s=G(t,"exp","pow");[n,s]=es(n,s);const r={a:n,b:s};return de.runKernel(Qze,r)}const MN=ee({pow_:NWe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mn(e,t){if((sl(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&sl(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return su(e,[],[],t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kWe(e){const n={x:G(e,"x","sqrt","float32")};return de.runKernel(_4e,n)}const PN=ee({sqrt_:kWe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DWe(e){const t=G(e,"x","square"),n={};return de.runKernel("Square",{x:t},n)}const Tw=ee({square_:DWe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MWe(e,t=null,n=!1){let s=G(e,"x","sum");s.dtype==="bool"&&(s=Vs(s,"int32"));const r={x:s},i={axis:t,keepDims:n};return de.runKernel(C4e,r,i)}const Vn=ee({sum_:MWe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PWe(e,t="euclidean",n=null,s=!1){e=G(e,"x","norm");const r=YH(e,t,n);let i=r.shape;if(s){const o=uw(n,e.shape);i=Cw(r.shape,o)}return Oe(r,i)}function YH(e,t,n=null){if(e.rank===0)return _o(e);if(e.rank!==1&&n===null)return YH(Oe(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return Vn(_o(e),n);if(t===1/0)return ff(_o(e),n);if(t===-1/0)return DN(_o(e),n);if(t==="euclidean"||t===2)return PN(Vn(MN(_o(e),mn(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return ff(Vn(_o(e),n[0]),n[1]-1);if(t===1/0)return ff(Vn(_o(e),n[1]),n[0]);if(t===-1/0)return DN(Vn(_o(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return PN(Vn(Tw(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Ew=ee({norm_:PWe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OWe(e,t=null,n=!1){return Ew(e,"euclidean",t,n)}const RWe=ee({euclideanNorm_:OWe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LWe(e){const n={x:G(e,"x","exp")};return de.runKernel(nze,n)}const Bh=ee({exp_:LWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FWe(e,t=0){const n=G(e,"x","expandDims","string_or_numeric");Q(t<=n.rank,()=>"Axis must be <= rank of the tensor");const s={input:n},r={dim:t};return de.runKernel(sze,s,r)}const zh=ee({expandDims_:FWe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $We(e){const n={x:G(e,"x","expm1")};return de.runKernel(rze,n)}const BWe=ee({expm1_:$We});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zWe(e,t){const n=G(e,"x","tile","string_or_numeric");Q(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);const s={x:n},r={reps:t};return de.runKernel(tH,s,r)}const H0=ee({tile_:zWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UWe(e,t,n,s="float32"){t==null&&(t=e);const r=Bl([e,t],s),i=e<=t?e:t;for(let a=0;a<i;++a)r.set(1,a,a);const o=Oe(r.toTensor(),[e,t]);if(n==null)return o;if(n.length===1)return H0(zh(o,0),[n[0],1,1]);if(n.length===2)return H0(zh(zh(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return H0(zh(zh(zh(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const QH=ee({eye_:UWe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VWe(e){const n={x:G(e,"x","floor","float32")};return de.runKernel(lze,n)}const ZH=ee({floor_:VWe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GWe(e,t,n=0,s=0){const r=G(e,"x","gather"),i=G(t,"indices","gather","int32"),o={x:r,indices:i},a={axis:n,batchDims:s};return de.runKernel(hze,o,a)}const JH=ee({gather_:GWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WWe(e,t){let n=G(e,"a","greater","string_or_numeric"),s=G(t,"b","greater","string_or_numeric");[n,s]=es(n,s),Gs(n.shape,s.shape);const r={a:n,b:s};return de.runKernel(pze,r)}const Aw=ee({greater_:WWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HWe(e,t){let n=G(e,"a","greaterEqual","string_or_numeric"),s=G(t,"b","greaterEqual","string_or_numeric");[n,s]=es(n,s),Gs(n.shape,s.shape);const r={a:n,b:s};return de.runKernel(fze,r)}const ej=ee({greaterEqual_:HWe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jWe(e){const n={x:G(e,"x","isFinite")};return de.runKernel(yze,n)}const qWe=ee({isFinite_:jWe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XWe(e){const n={x:G(e,"x","isInf")};return de.runKernel(vze,n)}const KWe=ee({isInf_:XWe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YWe(e){const n={x:G(e,"x","isNaN")};return de.runKernel(xze,n)}const QWe=ee({isNaN_:YWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZWe(e,t=.2){const s={x:G(e,"x","leakyRelu")},r={alpha:t};return de.runKernel(bze,s,r)}const tj=ee({leakyRelu_:ZWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JWe(e,t){let n=G(e,"a","less","string_or_numeric"),s=G(t,"b","less","string_or_numeric");[n,s]=es(n,s),Gs(n.shape,s.shape);const r={a:n,b:s};return de.runKernel(wze,r)}const e5e=ee({less_:JWe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t5e(e,t){let n=G(e,"a","lessEqual","string_or_numeric"),s=G(t,"b","lessEqual","string_or_numeric");[n,s]=es(n,s),Gs(n.shape,s.shape);const r={a:n,b:s};return de.runKernel(Sze,r)}const ON=ee({lessEqual_:t5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n5e(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const s={start:e,stop:t,num:n};return de.runKernel(_ze,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s5e(e,t=5,n=1,s=1,r=.5){const i=G(e,"x","localResponseNormalization");Q(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),Q($0(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=i,a=!1;i.rank===3&&(a=!0,o=Oe(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:o},c={depthRadius:t,bias:n,alpha:s,beta:r},h=de.runKernel(Nze,l,c);return a?Oe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const r5e=ee({localResponseNormalization_:s5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i5e(e){const n={x:G(e,"x","log","float32")};return de.runKernel(Cze,n)}const j0=ee({log_:i5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o5e(e){const n={x:G(e,"x","log1p")};return de.runKernel(Tze,n)}const nj=ee({log1p_:o5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ul(e){return de.customGrad(e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a5e(e){const n={x:G(e,"x","softplus")};return de.runKernel(S4e,n)}const sj=ee({softplus_:a5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l5e(e){const t=G(e,"x","logSigmoid");return Ul(s=>({value:zl(sj(zl(s))),gradFunc:o=>Wt(o,df(zl(s)))}))(t)}const c5e=ee({logSigmoid_:l5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u5e(e,t){let n=G(e,"a","sub"),s=G(t,"b","sub");[n,s]=es(n,s);const r={a:n,b:s};return de.runKernel($4e,r)}const cn=ee({sub_:u5e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h5e(e,t=-1){const n=G(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Ul((r,i)=>{const o=!0,a=ff(r,t,!0),l=cn(r,a),c=cn(Vs(l,"float32"),j0(Vn(Bh(l),t,o)));return i([c]),{value:c,gradFunc:(u,d)=>{const[p]=d,f=!0,g=Bh(p);return cn(u,Wt(Vn(u,t,f),g))}}})(n)}const d5e=ee({logSoftmax_:h5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p5e(e,t=null,n=!1){const s=G(e,"x","logSumExp"),r=uw(t,s.shape),i=ff(s,r,!0),o=cn(s,i),a=Bh(o),l=Vn(a,r),c=j0(l),h=Ws(Oe(i,c.shape),c);if(n){const u=Cw(h.shape,r);return Oe(h,u)}return h}const rj=ee({logSumExp_:p5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f5e(e,t){const n=G(e,"a","logicalAnd","bool"),s=G(t,"b","logicalAnd","bool");Gs(n.shape,s.shape);const r={a:n,b:s};return de.runKernel(Eze,r)}const Iw=ee({logicalAnd_:f5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m5e(e){const n={x:G(e,"x","logicalNot","bool")};return de.runKernel(Aze,n)}const ij=ee({logicalNot_:m5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g5e(e,t){const n=G(e,"a","logicalOr","bool"),s=G(t,"b","logicalOr","bool");Gs(n.shape,s.shape);const r={a:n,b:s};return de.runKernel(Ize,r)}const oj=ee({logicalOr_:g5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y5e(e,t){const n=G(e,"a","logicalXor","bool"),s=G(t,"b","logicalXor","bool");return Gs(n.shape,s.shape),Iw(oj(e,t),ij(Iw(e,t)))}const v5e=ee({logicalXor_:y5e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nw=2147483648;function x5e(e,t,n="left"){const s=G(e,"sortedSequence","searchSorted"),r=G(t,"values","searchSorted"),i=s.shape[s.shape.length-1],o=r.shape[r.shape.length-1],a=Oe(s,[-1,i]),l=Oe(r,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(tr(l.shape)>=Nw)throw new Error(`values tensor size must less than ${Nw}`);if(a.shape[1]>=Nw)throw new Error(`trailing dim_size must less than ${Nw} for int32 output type, was ${a.shape[1]}`);const c={sortedSequence:a,values:l},h={side:n};return de.runKernel(f4e,c,h)}const RN=ee({searchSorted_:x5e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b5e(e,t){return RN(e,t,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w5e(e,t,n,s,r){const i=G(e,"x","maxPool"),o=1;let a=i,l=!1;i.rank===3&&(l=!0,a=Oe(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Q(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),Q(au(n,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),ra("maxPool",s,r);const c={x:a},h={filterSize:t,strides:n,pad:s,dimRoundingMode:r},u=de.runKernel(Mze,c,h);return l?Oe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const aj=ee({maxPool_:w5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S5e(e,t=[1,1,1],n,s,r,i="NDHWC"){const o=G(e,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=Oe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Q(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),Q(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),ra("maxPool3d",s,r);const c={x:a},h={filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:i},u=de.runKernel(Pze,c,h);return l?Oe(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}const _5e=ee({maxPool3d_:S5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C5e(e,t,n,s,r=!1){const o={x:G(e,"x","maxPoolWithArgmax")},a={filterSize:t,strides:n,pad:s,includeBatchInIndex:r},l=de.runKernel(Oze,o,a);return{result:l[0],indexes:l[1]}}const T5e=ee({maxPoolWithArgmax_:C5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E5e(e,t){let n=G(e,"a","maximum"),s=G(t,"b","maximum");[n,s]=es(n,s),n.dtype==="bool"&&(n=Vs(n,"int32"),s=Vs(s,"int32")),Gs(n.shape,s.shape);const r={a:n,b:s};return de.runKernel(Dze,r)}const A5e=ee({maximum_:E5e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I5e(e,t=null,n=!1){const r={x:G(e,"x","mean")},i={axis:t,keepDims:n};return de.runKernel(Rze,r,i)}const kw=ee({mean_:I5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mf(e,t="float32"){if(t==="complex64"){const s=mf(e,"float32"),r=mf(e,"float32");return nu(s,r)}const n=tN(tr(e),t);return de.makeTensor(n,e,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function il(e,t="float32"){if(t==="complex64"){const s=il(e,"float32"),r=mf(e,"float32");return nu(s,r)}const n=q5(tr(e),t);return de.makeTensor(n,e,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N5e(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let s=G(e,"x","meshgrid",e instanceof ur?e.dtype:"float32");if(t===void 0)return[s];let r=G(t,"y","meshgrid",t instanceof ur?t.dtype:"float32");const i=tr(s.shape),o=tr(r.shape);return n==="xy"?(s=Oe(s,[1,-1]),r=Oe(r,[-1,1]),[Cn(il([o,1],s.dtype),s),Cn(r,il([1,i],r.dtype))]):(s=Oe(s,[-1,1]),r=Oe(r,[1,-1]),[Cn(s,il([1,o],s.dtype)),Cn(il([i,1],r.dtype),r)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k5e(e,t){let n=G(e,"a","minimum"),s=G(t,"b","minimum");[n,s]=es(n,s),n.dtype==="bool"&&(n=Vs(n,"int32"),s=Vs(s,"int32")),Gs(n.shape,s.shape);const r={a:n,b:s};return de.runKernel(Fze,r)}const lj=ee({minimum_:k5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D5e(e,t,n){Q(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=G(e,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Q(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const r=n==="reflect"?1:0;for(let a=0;a<s.rank;a++)Q(t[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Q(t[a][0]>=0&&t[a][0]<=s.shape[a]-r&&t[a][1]>=0&&t[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:t,mode:n},o={x:s};return de.runKernel($ze,o,i)}const M5e=ee({mirrorPad_:D5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P5e(e,t){let n=G(e,"a","mod"),s=G(t,"b","mod");[n,s]=es(n,s);const r={a:n,b:s};return de.runKernel(Bze,r)}const O5e=ee({mod_:P5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R5e(e,t=null,n=!1){e=G(e,"x","moments");const s=uw(t,e.shape),r=kw(e,s,n);let i=r.shape;n||(i=Cw(r.shape,s));const o=Tw(cn(Vs(e,"float32"),Oe(r,i))),a=kw(o,s,n);return{mean:r,variance:a}}const L5e=ee({moments_:R5e});function F5e(e,t,n,s){const r=G(t,"data","multiRNNCell"),i=pw(n,"c","multiRNNCell"),o=pw(s,"h","multiRNNCell");let a=r;const l=[];for(let u=0;u<e.length;u++){const d=e[u](a,i[u],o[u]);l.push(d[0]),l.push(d[1]),a=d[1]}const c=[],h=[];for(let u=0;u<l.length;u+=2)c.push(l[u]),h.push(l[u+1]);return[c,h]}const $5e=ee({multiRNNCell_:F5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B5e(e,t,n,s=!1){const r=G(e,"logits","multinomial"),i=r.size,o=r.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const l={logits:o===1?Oe(r,[1,-1]):r},c={numSamples:t,seed:n,normalized:s},h=de.runKernel(zze,l,c);return o===1?Oe(h,[h.size]):h}const z5e=ee({multinomial_:B5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U5e(e,t){let n=G(e,"a","notEqual","string_or_numeric"),s=G(t,"b","notEqual","string_or_numeric");[n,s]=es(n,s),Gs(n.shape,s.shape);const r={a:n,b:s};return de.runKernel(Gze,r)}const cj=ee({notEqual_:U5e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V5e(e){const n={x:G(e,"x","onesLike")};return de.runKernel(qze,n)}const G5e=ee({onesLike_:V5e});function W5e(e,t){const n=G(e,"v1","outerProduct"),s=G(t,"v2","outerProduct");Q(n.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${s.rank}.`);const r=Oe(n,[-1,1]),i=Oe(s,[1,-1]);return Cn(r,i)}const H5e=ee({outerProduct_:W5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j5e(e,t,n=0){const s=G(e,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},i={x:s};return de.runKernel(Yze,i,r)}const q0=ee({pad_:j5e});function q5e(e,t,n=0){return Q(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),q0(e,[t],n)}const X5e=ee({pad1d_:q5e});function K5e(e,t,n=0){return Q(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),q0(e,t,n)}const Y5e=ee({pad2d_:K5e});function Q5e(e,t,n=0){return Q(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),q0(e,t,n)}const Z5e=ee({pad3d_:Q5e});function J5e(e,t,n=0){return Q(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),q0(e,t,n)}const eHe=ee({pad4d_:J5e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tHe(e,t,n){const s=G(e,"x","spaceToBatchND");Q(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),Q(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),Q(s.shape.reduce((o,a,l)=>l>0&&l<=t.length?o&&(a+n[l-1][0]+n[l-1][1])%t[l-1]==0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);const r={x:s},i={blockShape:t,paddings:n};return de.runKernel(T4e,r,i)}const uj=ee({spaceToBatchND_:tHe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nHe(e,t,n,s,r,i,o){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const a=G(e,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=Oe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Q(au(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const h=eGe(l.shape,t,i,r,s),u=[h.dilationHeight,h.dilationWidth];let d;s==="same"?d=rHe([h.filterHeight,h.filterWidth],u):d=[[0,0],[0,0]];const p=u[0]===1&&u[1]===1,[f,g]=sHe([h.inHeight,h.inWidth],u,d),m=p?s:"valid",y=p?l:uj(l,u,f),b=(n==="avg"?()=>WH(y,t,i,m,o):()=>aj(y,t,i,m,o))(),x=p?b:HH(b,u,g);return c?Oe(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function sHe(e,t,n){const s=n.map(h=>h[0]),r=n.map(h=>h[1]),i=e.concat(s,r),o=t.map((h,u)=>(h-i[u]%h)%h),a=r.map((h,u)=>h+o[u]),l=t.map((h,u)=>[s[u],a[u]]),c=t.map((h,u)=>[0,o[u]]);return[l,c]}function rHe(e,t){const s=e.map((o,a)=>o+(o-1)*(t[a]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),i=s.map((o,a)=>o-r[a]);return s.map((o,a)=>[r[a],i[a]])}const iHe=ee({pool_:nHe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oHe(e,t){const n=G(e,"x","prelu"),s=G(t,"alpha","prelu"),r={x:n,alpha:s};return de.runKernel(Zze,r)}const hj=ee({prelu_:oHe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aHe(e,t=null,n=!1){let s=G(e,"x","prod");s.dtype==="bool"&&(s=Vs(s,"int32"));const r={x:s},i={axis:t,keepDims:n};return de.runKernel(Jze,r,i)}const lHe=ee({prod_:aHe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cHe(e,t,n,s){const r=e.map((h,u)=>G(h,`tensors${u}`,"raggedGather","int32")),i=G(t,"paramsDenseValues","raggedGather"),o=G(n,"indices","raggedGather","int32"),a={paramsNestedSplits:r,paramsDenseValues:i,indices:o},l={outputRaggedRank:s},c=de.runKernel(e4e,a,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const uHe=ee({raggedGather_:cHe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hHe(e,t,n,s,r){const i=G(e,"shape","raggedTensorToTensor","int32"),o=G(t,"values","raggedTensorToTensor"),a=G(n,"defaultValue","raggedTensorToTensor",o.dtype),l=s.map((u,d)=>G(u,`tensors${d}`,"raggedTensorToTensor","int32")),c={shape:i,values:o,defaultValue:a,rowPartitionTensors:l},h={rowPartitionTypes:r};return de.runKernel(t4e,c,h)}const dHe=ee({raggedTensorToTensor_:hHe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pHe(e,t,n){const s=tr(e);let r=null;if(n==null||n==="float32")r=new Float32Array(s);else if(n==="int32")r=new Int32Array(s);else if(n==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${n}`);for(let i=0;i<s;i++)r[i]=t();return de.makeTensor(r,e,n)}const fHe=ee({rand_:pHe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LN{constructor(t,n,s,r,i){this.mean=t,this.stdDev=n,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=Op.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let t,n,s=!1;for(;!s;){let r,i,o;do r=2*this.random()-1,i=2*this.random()-1,o=r*r+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*r*a,n=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class mHe{constructor(t,n,s,r){this.alpha=t,this.beta=1/n,this.dtype=s;const i=r||Math.random();this.randu=Op.alea(i.toString()),this.randn=new LN(0,1,s,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,n,s,r,i,o;for(;;){do r=this.randn.nextValue(),o=1+this.c*r;while(o<=0);if(o*=o*o,t=r*r,n=1-.331*t*t,s=.5*t+this.d*(1-o+Math.log(o)),i=this.randu(),i<n||Math.log(i)<s)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}}class gHe{constructor(t=0,n=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=n-t,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${n} <= 1 and dtype is not float`);this.random=Op.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yHe(e,t,n=1,s="float32",r){if(n==null&&(n=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const i=new mHe(t,n,s,r),o=Bl(e,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const vHe=ee({randomGamma_:yHe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xHe(e,t=0,n=1,s,r){if(s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new LN(t,n,s,!1,r),o=Bl(e,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const dj=ee({randomNormal_:xHe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bHe(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return dj(e,0,1,t,n)}const wHe=ee({randomStandardNormal_:bHe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SHe(e,t=0,n=1,s="float32",r){const i=Bl(e,s),o=new gHe(t,n,null,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const pj=ee({randomUniform_:SHe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X0(e,t,n=1,s="float32"){if(n===0)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:s};return de.runKernel(n4e,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _He(e){const n={x:G(e,"x","reciprocal")};return de.runKernel(r4e,n)}const CHe=ee({reciprocal_:_He});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function THe(e){const n={x:G(e,"x","relu")};return de.runKernel(i4e,n)}const Dw=ee({relu_:THe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EHe(e){const n={x:G(e,"x","relu6")};return de.runKernel(c4e,n)}const fj=ee({relu6_:EHe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AHe(e,t){const s={x:G(e,"x","reverse")},r={dims:t};return de.runKernel(u4e,s,r)}const Uh=ee({reverse_:AHe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IHe(e){const t=G(e,"x","reverse");return Q(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Uh(t,0)}const NHe=ee({reverse1d_:IHe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kHe(e,t){const n=G(e,"x","reverse");return Q(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Uh(n,t)}const DHe=ee({reverse2d_:kHe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MHe(e,t){const n=G(e,"x","reverse");return Q(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Uh(n,t)}const PHe=ee({reverse3d_:MHe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OHe(e,t){const n=G(e,"x","reverse");return Q(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Uh(n,t)}const RHe=ee({reverse4d_:OHe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LHe(e){const n={x:G(e,"x","round")};return de.runKernel(h4e,n)}const mj=ee({round_:LHe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FHe(e){const n={x:G(e,"x","rsqrt","float32")};return de.runKernel(d4e,n)}const $He=ee({rsqrt_:FHe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BHe(e){const n={x:G(e,"x","selu")};return de.runKernel(g4e,n)}const zHe=ee({selu_:BHe});function UHe(e,t,n,s,r,i=[1,1],o="NHWC"){const a=G(e,"x","separableConv2d"),l=G(t,"depthwiseFilter","separableConv2d"),c=G(n,"pointwiseFilter","separableConv2d");let h=a,u=!1;if(a.rank===3&&(u=!0,h=Oe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Q(h.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),Q(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),Q(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),Q(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),Q(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const d=l.shape[2],p=l.shape[3];Q(c.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${c.shape[2]}.`);const f=NN(h,l,s,r,o,i),m=_w(f,c,1,"valid",o);return u?Oe(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const VHe=ee({separableConv2d_:UHe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function GHe(e,t){const n=G(e,"x","setdiff1d"),s=G(t,"y","setdiff1d");Q(n.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${s.dtype}).`),Q(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),Q(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await n.data(),i=await s.data(),o=new Set(i);let a=0;for(let h=0;h<r.length;h++)o.has(r[h])||a++;const l=new oN([a],n.dtype),c=new oN([a],"int32");for(let h=0,u=0;h<r.length;h++)o.has(r[h])||(l.values[u]=r[h],c.values[u]=h,u++);return[l.toTensor(),c.toTensor()]}const WHe=GHe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HHe(e){const n={x:G(e,"x","sign")};return de.runKernel(b4e,n)}const jHe=ee({sign_:HHe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qHe(e){const n={x:G(e,"x","sin","float32")};return de.runKernel(v4e,n)}const XHe=ee({sin_:qHe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KHe(e){const n={x:G(e,"x","sinh")};return de.runKernel(x4e,n)}const YHe=ee({sinh_:KHe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QHe(e,t,n){const s=G(e,"x","slice1d");return Q(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Pn(s,[t],[n])}const ZHe=ee({slice1d_:QHe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JHe(e,t,n){const s=G(e,"x","slice2d");return Q(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Pn(s,t,n)}const eje=ee({slice2d_:JHe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tje(e,t,n){const s=G(e,"x","slice3d");return Q(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Pn(s,t,n)}const nje=ee({slice3d_:tje});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sje(e,t,n){const s=G(e,"x","slice4d");return Q(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Pn(s,t,n)}const rje=ee({slice4d_:sje});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ije(e,t=-1){const n=G(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const s={logits:n},r={dim:t};return de.runKernel(A4e,s,r)}const oje=ee({softmax_:ije});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aje(e){Q(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);const t={input:e};return de.runKernel(ize,t)}const FN=ee({fft_:aje});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lje(e){Q(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);const t={input:e};return de.runKernel(mze,t)}const Mw=ee({ifft_:lje});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cje(e){const t=e.shape[e.shape.length-1],n=e.size/t;let s;if(t<=2){const r=Oe(e,[n,t]);s=Mw(r)}else{const r=[n,2*(t-1)],i=Oe(W0(e),[n,t]),o=Oe(gw(e),[n,t]),a=Uh(Pn(i,[0,1],[n,t-2]),1),l=Wt(Uh(Pn(o,[0,1],[n,t-2]),1),mn(-1)),c=kr([i,a],1),h=kr([o,l],1),u=Oe(nu(c,h),[r[0],r[1]]);s=Mw(u)}if(s=W0(s),e.rank===3&&e.shape[0]!==0){const r=s,i=e.shape[0];s=Oe(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const gj=ee({irfft_:cje});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uje(e,t,n=0){const r={x:G(e,"x","split")},i={numOrSizeSplits:t,axis:n};return de.runKernel(E4e,r,i)}const K0=ee({split_:uje});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hje(e,t){Q(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const s=e.size/n;let r;if(t!=null&&t<n){const f=e.shape.map(m=>0),g=e.shape.map(m=>m);g[e.shape.length-1]=t,r=Pn(e,f,g),n=t}else if(t!=null&&t>n){const f=e.shape.map(g=>g);f[e.shape.length-1]=t-n,r=kr([e,mf(f)],e.shape.length-1),n=t}else r=e;const i=kN(r),o=Oe(nu(r,i),[s,n]),a=FN(o),l=Math.floor(n/2)+1,c=W0(a),h=gw(a),u=K0(c,[l,n-l],c.shape.length-1),d=K0(h,[l,n-l],h.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,Oe(nu(u[0],d[0]),p)}const $N=ee({rfft_:hje});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dje(e,t){let n=G(e,"a","squaredDifference"),s=G(t,"b","squaredDifference");[n,s]=es(n,s),Gs(n.shape,s.shape);const r={a:n,b:s},i={};return de.runKernel(P4e,r,i)}const yj=ee({squaredDifference_:dje});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pje(e,t){const n=G(e,"x","squeeze","string_or_numeric");return Oe(n,Y$e(n.shape,t).newShape)}const BN=ee({squeeze_:pje});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fje(e,t=0){const n=pw(e,"tensors","stack","string_or_numeric");Q(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&Q(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const s=n,r={axis:t};return de.runKernel(Kze,s,r)}const Vl=ee({stack_:fje});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mje(e,t=0){const s={x:G(e,"x","step")},r={alpha:t};return de.runKernel(q4e,s,r)}const vj=ee({step_:mje});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gje(e,t,n,s,r=0,i=0,o=0,a=0,l=0){const h={x:G(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:s,beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return de.runKernel(O4e,h,u)}const yje=ee({stridedSlice_:gje});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vje(e){const n={x:G(e,"x","tan","float32")};return de.runKernel(B4e,n)}const xje=ee({tan_:vje});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ia(e,t){of(e);const n=tu(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return su(e,null,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lu(e,t,n){if(of(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=tu(e,n);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return su(e,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bje(e,t,n){if(of(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=tu(e,n);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return su(e,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wje(e,t,n){if(of(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=tu(e,n);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return su(e,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sje(e,t,n){if(of(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=tu(e,n);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||s,su(e,t,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _je(e,t=1,n=!0){const s=G(e,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const i={x:s},o={k:t,sorted:n},[a,l]=de.runKernel(U4e,i,o);return{values:a,indices:l}}const Cje=ee({topk_:_je});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tje(e,t=0,n=1,s,r){if(s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new LN(t,n,s,!0,r),o=Bl(e,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const Eje=ee({truncatedNormal_:Tje});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aje(e,t=0){const n=G(e,"x","unique","string_or_numeric");Q(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:t},[i,o]=de.runKernel(G4e,s,r);return{values:i,indices:o}}const Ije=ee({unique_:Aje});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nje(e,t,n){const s=G(e,"x","unsortedSegmentSum"),r=G(t,"segmentIds","unsortedSegmentSum","int32");Q($0(n),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},o={numSegments:n};return de.runKernel(H4e,i,o)}const kje=ee({unsortedSegmentSum_:Nje});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dje(e,t=0){const n=G(e,"x","unstack","string_or_numeric");Q(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);const s={value:n},r={axis:t};return de.runKernel(W4e,s,r)}const Vh=ee({unstack_:Dje});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mje(e,t){return RN(e,t,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pje(e,t=!0,n,s){return de.makeVariable(e,t,n,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oje(e,t){const n=[];for(let i=0;i<t.length;i++)t[i]&&n.push(i);const s=Bl(e,"int32"),r=Bl([n.length,e.length],"int32");for(let i=0;i<n.length;i++){const o=s.indexToLoc(n[i]),a=i*e.length;r.values.set(o,a)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Rje(e){const t=G(e,"condition","whereAsync","bool"),n=await t.data(),s=Oje(t.shape,n);return e!==t&&t.dispose(),s}const xj=Rje;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Lje(e,t,n){const s=G(e,"tensor","boolMask"),r=G(t,"mask","boolMask","bool"),i=n==null?0:n,o=r.rank,a=s.shape;Q(o>0,()=>"mask cannot be scalar"),wo(a.slice(i,i+o),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let g=i;g<i+o;g++)l*=a[g];const c=a.slice(0,i).concat([l],a.slice(i+o)),h=Oe(s,c),u=Oe(r,[-1]),d=await xj(u),p=BN(d,[1]),f=JH(h,p,i);return e!==s&&s.dispose(),t!==r&&r.dispose(),p.dispose(),h.dispose(),u.dispose(),d.dispose(),f}const Fje=Lje;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $je(e,t,n,s,r=!0){const i=G(e,"v","movingAverage"),o=G(t,"x","movingAverage"),a=G(n,"decay","movingAverage");dUe(i,o),Q(eu(i.shape,o.shape),()=>"Shape mismatch in v and x");const l=mn(1),c=cn(l,a);let h=Wt(cn(o,i),c);if(r){Q(s!=null,()=>"When using zeroDebias: true, step is required.");const u=G(s,"step","movingAverage");h=Nr(h,cn(l,MN(a,u)))}return Ws(i,h)}const Bje=ee({movingAverage_:$je});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zje(e,t,n){const s=G(e,"indices","scatterND","int32"),r=G(t,"updates","scatterND");CVe(r,s,n);const i={indices:s,updates:r},o={shape:n};return de.runKernel(p4e,i,o)}const Uje=ee({scatterND_:zje});function Vje(e,t,n,s){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const r=e.rank>0?e.shape[0]:1,i=e.rank>1?e.shape[1]:1;if(n.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${i}.`);const o=t.size;if(!(t.rank===0||t.rank===1&&o===r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gje(e,t,n,s=0){const r=G(e,"sparseIndices","sparseToDense","int32"),i=G(t,"sparseValues","sparseToDense","string_or_numeric"),o=G(s,"defaultValue","sparseToDense",i.dtype);Vje(r,i,n,o);const a={sparseIndices:r,sparseValues:i,defaultValue:o},l={outputShape:n};return de.runKernel(M4e,a,l)}const Wje=ee({sparseToDense_:Gje});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hje(e,t){const n=G(t,"indices","gatherND","int32"),r={params:G(e,"x","gatherND","string_or_numeric"),indices:n};return de.runKernel(dze,r)}const jje=ee({gatherND_:Hje});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qje(e,t){if(t==null)return e.shape.slice();if(eu(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let s=0;s<e.shape.length;s++)t[s]==null&&e.shape[s]!=null?n.push(e.shape[s]):n.push(t[s]);return n}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xje(e,t,n,s){const r=G(e,"x","dropout");if(Q(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),Q(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof ur?r.clone():r;const i=qje(r,n),o=1-t,a=Nr(ZH(Ws(pj(i,0,1,"float32",s),o)),o);return Wt(r,a)}const Kje=ee({dropout_:Xje});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bj(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function zN(e,t,n){const s=1-e%2,r=new Float32Array(e);for(let i=0;i<e;++i){const o=2*Math.PI*i/(e+s-1);r[i]=t-n*Math.cos(o)}return ia(r,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Yje(e,t,n=1){const s=G(e,"predictions","inTopK"),r=G(t,"targets","inTopK");Q(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),Q(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),wo(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=s.shape[s.shape.length-1];Q(n>0&&n<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${n}`);const o=await s.data(),a=await r.data(),[l,c]=[o.length/i,i],h=Q$e("bool",l);for(let u=0;u<l;u++){const d=u*c,p=o.subarray(d,d+c),f=[];for(let g=0;g<p.length;g++)f.push({value:p[g],index:g});f.sort((g,m)=>m.value-g.value),h[u]=0;for(let g=0;g<n;g++)if(f[g].index===a[u]){h[u]=1;break}}return e!==s&&s.dispose(),t!==r&&r.dispose(),rl(h,r.shape,"bool")}const Qje=Yje;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zje(e,t,n,s,r,i="NHWC",o){let a=e;e.rank===3&&(a=Oe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=Oe(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Q(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),Q(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),Q(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c=i==="NHWC"?a.shape[3]:a.shape[1],h=i==="NHWC"?l.shape[3]:l.shape[1];Q(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),Q(h===n[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${n[3]}).`),ra("conv2dDerFilter",r,o);const u={x:a,dy:l},d={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:n};return de.runKernel(RBe,u,d)}const Jje=ee({conv2DBackpropFilter_:Zje});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UN(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return Wt(e,vj(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function VN(e,t){let n=t;const s=wVe(e.shape,t.shape);return s.length>0&&(n=Vn(n,s)),Oe(n,e.shape)}function GN(e,t,n,s){if(t==="linear")return e;if(t==="relu")return Dw(e);if(t==="elu")return KH(e);if(t==="relu6")return fj(e);if(t==="prelu")return hj(e,n);if(t==="leakyrelu")return tj(e,s);if(t==="sigmoid")return df(e);throw new Error(`Unknown fused activation ${t}.`)}const WN=(e,t)=>!(e>0)||t==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e6e({x:e,filter:t,strides:n,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(l=l||"linear",WN(de.state.gradientDepth,l)===!1){Q(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let S=_w(e,t,n,s,r,i,o);return a!=null&&(S=Ws(S,a)),GN(S,l,c,h)}const u=G(e,"x","conv2d","float32"),d=G(t,"filter","conv2d","float32");let p=u,f=!1;u.rank===3&&(f=!0,p=Oe(u,[1,u.shape[0],u.shape[1],u.shape[2]])),Q(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),Q(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),ra("fused conv2d",s,o);const g=r==="NHWC"?p.shape[3]:p.shape[1];Q(d.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${d.shape[2]}.`),Q(au(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);const m=EN(p.shape,d.shape,n,i,s,o);let y;a!=null&&(y=G(a,"bias","fused conv2d"),[y]=es(y,u),r==="NHWC"?Gs(m.outShape,y.shape):(Q(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),Q(y.shape.length===0||y.shape[0]===m.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${m.outChannels})`)));let v;if(c!=null){const S=c.shape;if(Q(S.length<=1||S.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${S.length}.`),S.length===1)Q(S[0]===1||S[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the number of output channels (${m.outChannels}).`);else if(S.length===3)try{Gs(S,m.outShape)}catch{const _=`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the output shape of the conv2d (${m.outShape}).`;throw Error(_)}v=G(c,"prelu weights","fused conv2d")}const b=(S,C)=>{Q(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[_,T,E,A]=C,D=UN(S,E,l);Q(xw(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const O=qH(T.shape,D,_,n,s),P=Jje(T,D,_.shape,n,s),L=[O,P];if(A!=null){const B=VN(A,D);L.push(B)}return L},x={x:p,filter:d,bias:y,preluActivationWeights:v},w={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:h};return a==null?Ul((C,_,T)=>{let E=de.runKernel(sH,x,w);return T([_,C,E]),f&&(E=Oe(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:b}})(p,d):Ul((C,_,T,E)=>{let A=de.runKernel(sH,x,w);return E([_,C,A,T]),f&&(A=Oe(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:b}})(p,d,y)}const t6e=ee({fusedConv2d_:e6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n6e(e,t,n,s,r,i=[1,1],o){let a=e;e.rank===3&&(a=Oe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=Oe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={x:a,dy:l},h={strides:s,pad:r,dimRoundingMode:o,dilations:i,filterShape:n};return de.runKernel(qBe,c,h)}const s6e=ee({depthwiseConv2dNativeBackpropFilter_:n6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r6e(e,t,n,s,r,i=[1,1],o){let a=t,l=!1;t.rank===3&&(l=!0,a=Oe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={dy:a,filter:n},h={strides:s,pad:r,dimRoundingMode:o,dilations:i,inputShape:e},u=de.runKernel(XBe,c,h);return l?Oe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const i6e=ee({depthwiseConv2dNativeBackpropInput_:r6e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o6e({x:e,filter:t,strides:n,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(WN(de.state.gradientDepth,l)===!1){let w=NN(e,t,n,s,r,i,o);return a!=null&&(w=Ws(w,a)),GN(w,l,c,h)}const u=G(e,"x","depthwiseConv2d","float32"),d=G(t,"filter","depthwiseConv2d","float32");let p=u,f=!1;u.rank===3&&(f=!0,p=Oe(u,[1,u.shape[0],u.shape[1],u.shape[2]])),Q(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),Q(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),Q(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),i==null&&(i=[1,1]),Q(au(n,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),ra("fused depthwiseConv2d",s,o);const g=EN(p.shape,d.shape,n,i,s,o,!0);let m;a!=null&&(m=G(a,"bias","fused conv2d"),[m]=es(m,u),Gs(g.outShape,m.shape));let y;c!=null&&(y=G(c,"prelu weights","fused depthwiseConv2d"));const v=(w,S)=>{Q(xw(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[C,_,T,E]=S,A=UN(w,T,l),D=i6e(_.shape,A,C,n,s,i,o),O=s6e(_,A,C.shape,n,s,i,o);if(E!=null){const P=VN(m,A);return[D,O,P]}return[D,O]},b={x:p,filter:d,bias:m,preluActivationWeights:y},x={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:h};return a==null?Ul((S,C,_)=>{let T=de.runKernel(rH,b,x);return _([C,S,T]),f&&(T=Oe(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:v}})(p,d):Ul((S,C,_,T)=>{let E=de.runKernel(rH,b,x);return T([C,S,E,_]),f&&(E=Oe(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:v}})(p,d,m)}const a6e=ee({fusedDepthwiseConv2d_:o6e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l6e({a:e,b:t,transposeA:n=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(WN(de.state.gradientDepth,i)===!1){let A=Cn(e,t,n,s);return r!=null&&(A=Ws(A,r)),GN(A,i,o,a)}let l=G(e,"a","fused matMul"),c=G(t,"b","fused matMul");[l,c]=es(l,c);const h=n?l.shape[l.rank-2]:l.shape[l.rank-1],u=s?c.shape[c.rank-1]:c.shape[c.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?c.shape[c.rank-2]:c.shape[c.rank-1],f=l.shape.slice(0,-2),g=c.shape.slice(0,-2),m=tr(f),y=tr(g);Q(h===u,()=>`Error in fused matMul: inner shapes (${h}) and (${u}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${n} and transposeB=${s} must match.`);const b=Gs(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([d,p]),x=n?Oe(l,[m,h,d]):Oe(l,[m,d,h]),w=s?Oe(c,[y,p,u]):Oe(c,[y,u,p]);let S;r!=null&&(S=G(r,"bias","fused matMul"),[S]=es(S,l),Gs(b,S.shape));let C;o!=null&&(C=G(o,"prelu weights","fused matMul"));const _=(A,D)=>{const[O,P,L,B]=D,F=UN(Oe(A,L.shape),L,i);let M,U;if(!n&&!s?(M=Cn(F,P,!1,!0),U=Cn(O,F,!0,!1)):!n&&s?(M=Cn(F,P,!1,!1),U=Cn(F,O,!0,!1)):n&&!s?(M=Cn(P,F,!1,!0),U=Cn(O,F,!1,!1)):(M=Cn(P,F,!0,!0),U=Cn(F,O,!0,!0)),r!=null){const z=VN(B,F);return[M,U,z]}else return[M,U]},T={a:x,b:w,bias:S,preluActivationWeights:C},E={transposeA:n,transposeB:s,activation:i,leakyreluAlpha:a};return r==null?Ul((D,O,P)=>{const L=de.runKernel(nH,T,E);return P([D,O,L]),{value:Oe(L,b),gradFunc:_}})(x,w):Ul((D,O,P,L)=>{const B=de.runKernel(nH,T,E);return L([D,O,B,P]),{value:Oe(B,b),gradFunc:_}})(x,w,S)}const c6e=ee({fusedMatMul_:l6e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var u6e=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",conv2d:t6e,depthwiseConv2d:a6e,matMul:c6e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h6e(e){return zN(e,.54,.46)}const d6e=ee({hammingWindow_:h6e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p6e(e){return zN(e,.5,.5)}const wj=ee({hannWindow_:p6e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f6e(e,t,n,s=!1,r=0){let i=0;const o=[];for(;i+t<=e.size;)o.push(Pn(e,i,t)),i+=n;if(s)for(;i<e.size;){const a=i+t-e.size,l=kr([Pn(e,i,t-a),Sw([a],r)]);o.push(l),i+=n}return o.length===0?lu([],[0,t]):Oe(kr(o),[o.length,t])}const Sj=ee({frame_:f6e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m6e(e,t,n,s,r=wj){s==null&&(s=bj(t));const i=Sj(e,t,n),o=Wt(i,r(t));return $N(o,s)}const g6e=ee({stft_:m6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y6e(e,t,n,s,r="bilinear",i=0){const o=G(e,"image","cropAndResize"),a=G(t,"boxes","cropAndResize","float32"),l=G(n,"boxInd","cropAndResize","int32"),c=a.shape[0];Q(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),Q(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),Q(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),Q(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),Q(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),Q(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const h={image:o,boxes:a,boxInd:l},u={method:r,extrapolationValue:i,cropSize:s};return de.runKernel(GBe,h,u)}const v6e=ee({cropAndResize_:y6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x6e(e){const t=G(e,"image","flipLeftRight","float32");Q(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const n={image:t};return de.runKernel(aze,n,{})}const b6e=ee({flipLeftRight_:x6e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w6e(e){const t=G(e,"image","grayscaleToRGB"),n=t.rank-1,s=t.shape[n];Q(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),Q(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,H0(t,r)}const S6e=ee({grayscaleToRGB_:w6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _6e(e,t,n=0,s=.5){const r=G(e,"image","rotateWithOffset","float32");Q(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},o={radians:t,fillValue:n,center:s};return de.runKernel(X4e,i,o)}const C6e=ee({rotateWithOffset_:_6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gf(e,t,n,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=e.shape[0];return n=Math.min(n,o),Q(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),Q(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),Q(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),Q(t.rank===1,()=>"scores must be a 1D tensor"),Q(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),Q(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T6e(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY){const i=G(e,"boxes","nonMaxSuppression","float32"),o=G(t,"scores","nonMaxSuppression","float32"),a=gf(i,o,n,s,r);n=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l={maxOutputSize:n,iouThreshold:s,scoreThreshold:r};return de.runKernel(Wze,{boxes:i,scores:o},l)}const E6e=ee({nonMaxSuppression_:T6e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A6e(e,t,n){const s=I6e(e,t,n),r=s<0?-(s+1):s;e.splice(r,0,t)}function I6e(e,t,n){return k6e(e,t,n||N6e)}function N6e(e,t){return e>t?1:e<t?-1:0}function k6e(e,t,n){let s=0,r=e.length,i=0,o=!1;for(;s<r;){i=s+(r-s>>>1);const a=n(t,e[i]);a>0?s=i+1:(r=i,o=!a)}return o?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D6e(e,t,n,s,r){return HN(e,t,n,s,r,0)}function M6e(e,t,n,s,r,i){return HN(e,t,n,s,r,0,!1,i,!0)}function P6e(e,t,n,s,r,i){return HN(e,t,n,s,r,i,!0)}function HN(e,t,n,s,r,i,o=!1,a=!1,l=!1){const c=[];for(let m=0;m<t.length;m++)t[m]>r&&c.push({score:t[m],boxIndex:m,suppressBeginIndex:0});c.sort(_j);const h=i>0?-.5/i:0,u=[],d=[];for(;u.length<n&&c.length>0;){const m=c.pop(),{score:y,boxIndex:v,suppressBeginIndex:b}=m;if(y<r)break;let x=!1;for(let w=u.length-1;w>=b;--w){const S=O6e(e,v,u[w]);if(S>=s){x=!0;break}if(m.score=m.score*R6e(s,h,S),m.score<=r)break}m.suppressBeginIndex=u.length,x||(m.score===y?(u.push(v),d.push(m.score)):m.score>r&&A6e(c,m,_j))}const p=u.length,f=n-p;a&&f>0&&(u.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:u};return o&&(g.selectedScores=d),l&&(g.validOutputs=p),g}function O6e(e,t,n){const s=e.subarray(t*4,t*4+4),r=e.subarray(n*4,n*4+4),i=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(r[0],r[2]),h=Math.min(r[1],r[3]),u=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(a-i)*(l-o),f=(u-c)*(d-h);if(p<=0||f<=0)return 0;const g=Math.max(i,c),m=Math.max(o,h),y=Math.min(a,u),v=Math.min(l,d),b=Math.max(y-g,0)*Math.max(v-m,0);return b/(p+f-b)}function R6e(e,t,n){const s=Math.exp(t*n*n);return n<=e?s:0}function _j(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function L6e(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY){const i=G(e,"boxes","nonMaxSuppressionAsync"),o=G(t,"scores","nonMaxSuppressionAsync"),a=gf(i,o,n,s,r);n=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),c=l[0],h=l[1],{selectedIndices:u}=D6e(c,h,n,s,r);return i!==e&&i.dispose(),o!==t&&o.dispose(),ia(u,"int32")}const F6e=L6e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $6e(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=G(e,"boxes","nonMaxSuppression"),a=G(t,"scores","nonMaxSuppression"),l=gf(o,a,n,s,r,i);n=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c={boxes:o,scores:a},h={maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},u=de.runKernel(jze,c,h);return{selectedIndices:u[0],selectedScores:u[1]}}const B6e=ee({nonMaxSuppressionWithScore_:$6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function z6e(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=G(e,"boxes","nonMaxSuppressionAsync"),a=G(t,"scores","nonMaxSuppressionAsync"),l=gf(o,a,n,s,r,i);n=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),h=c[0],u=c[1],{selectedIndices:d,selectedScores:p}=P6e(h,u,n,s,r,i);return o!==e&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:ia(d,"int32"),selectedScores:ia(p)}}const U6e=z6e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V6e(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=G(e,"boxes","nonMaxSuppression"),a=G(t,"scores","nonMaxSuppression"),l=gf(o,a,n,s,r,null),c=l.maxOutputSize,h=l.iouThreshold,u=l.scoreThreshold,d={boxes:o,scores:a},p={maxOutputSize:c,iouThreshold:h,scoreThreshold:u,padToMaxOutputSize:i},f=de.runKernel(Hze,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}const G6e=ee({nonMaxSuppressionPadded_:V6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function W6e(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=G(e,"boxes","nonMaxSuppressionAsync"),a=G(t,"scores","nonMaxSuppressionAsync"),l=gf(o,a,n,s,r,null),c=l.maxOutputSize,h=l.iouThreshold,u=l.scoreThreshold,[d,p]=await Promise.all([o.data(),a.data()]),{selectedIndices:f,validOutputs:g}=M6e(d,p,c,h,u,i);return o!==e&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:ia(f,"int32"),validOutputs:mn(g,"int32")}}const H6e=W6e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j6e(e,t,n=!1,s=!1){const r=G(e,"images","resizeBilinear");Q(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),Q(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),Q(s===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=Oe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:n,halfPixelCenters:s,size:t},c=de.runKernel(l4e,a,l);return o?Oe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const q6e=ee({resizeBilinear_:j6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X6e(e,t,n=!1,s=!1){const r=G(e,"images","resizeNearestNeighbor");Q(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),Q(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),Q(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),Q(s===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=Oe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:n,halfPixelCenters:s,size:t},c=de.runKernel(a4e,a,l);return o?Oe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const K6e=ee({resizeNearestNeighbor_:X6e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y6e(e,t="binary",n=!1,s=.5){const r=G(e,"image","threshold"),i=.2989,o=.587,a=.114,l=r.shape[0]*r.shape[1];let c=Wt(ia([s]),255),h,u,d,p;if(Q(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),Q(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),Q(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),Q(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[h,u,d]=K0(r,[1,1,1],-1);const m=Wt(h,i),y=Wt(u,o),v=Wt(d,a);p=Ws(Ws(m,y),v)}else p=e;if(t==="otsu"){const m=jH(Vs(mj(p),"int32"),rl([]),256);c=Q6e(m,l)}const f=n?ON(p,c):Aw(p,c);return Vs(Wt(f,255),"int32")}function Q6e(e,t){let n=ia([-1]),s=ia([0]),r=ia([0]),i,o,a,l,c,h;for(let u=0;u<e.size-1;u++){i=Pn(e,0,u+1),o=Pn(e,u+1),c=Nr(Vn(i),t),h=Nr(Vn(o),t);const d=Vn(Wt(i,X0(0,i.size)));a=Nr(d,Vn(i));const p=Sw(o.shape,i.size),f=Ws(X0(0,o.size),p),g=Wt(o,f);l=Nr(Vn(g),Vn(o));const m=cn(a,l),y=cn(a,l),v=Wt(c,h);r=Wt(Wt(v,m),y);const b=Aw(r,s);s=pf(b,r,s),n=pf(b,ia([u]),n)}return n}const Z6e=ee({threshold_:Y6e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J6e(e,t,n="nearest",s="constant",r=0,i){const o=G(e,"image","transform","float32"),a=G(t,"transforms","transform","float32");Q(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),Q(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Q(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:o,transforms:a},c={interpolation:n,fillMode:s,fillValue:r,outputShape:i};return de.runKernel(V4e,l,c)}const e8e=ee({transform_:J6e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t8e(e,t,n){Q(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Q(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const s=G(e,"a","bandPart");Q(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,o]=s.shape.slice(-2);if(!(t<=i))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);t<0&&(t=i),n<0&&(n=o);const a=Oe(X0(0,i,1,"int32"),[-1,1]),l=X0(0,o,1,"int32"),c=cn(a,l),h=Iw(ON(c,mn(+t,"int32")),ej(c,mn(-n,"int32"))),u=mf([i,o],s.dtype);return Oe(Vl(Vh(Oe(s,[-1,i,o])).map(d=>pf(h,d,u))),r)}const n8e=ee({bandPart_:t8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s8e(e){let t;if(Array.isArray(e)){t=!1,Q(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=e[0].shape[0];for(let i=1;i<e.length;++i)Q(e[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[i].shape[0]} vs. ${r})`)}else t=!0,e=K0(e,e.shape[0],0).map(r=>BN(r,[0]));Q(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],s=e;for(let r=0;r<e.length;++r)n.push(de.tidy(()=>{let i=s[r];if(r>0)for(let o=0;o<r;++o){const a=Wt(Vn(Wt(n[o],i)),n[o]);i=cn(i,a)}return Nr(i,Ew(i,"euclidean"))}));return t?Vl(n,0):n}const r8e=ee({gramSchmidt_:s8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i8e(e,t=!1){if(Q(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return Cj(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((l,c)=>l*c),s=Vh(Oe(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],i=[];s.forEach(l=>{const[c,h]=Cj(l,t);r.push(c),i.push(h)});const o=Oe(Vl(r,0),e.shape),a=Oe(Vl(i,0),e.shape);return[o,a]}}function Cj(e,t=!1){return de.tidy(()=>{Q(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],s=e.shape[1];let r=QH(n),i=iu(e);const o=lu([[1]],[1,1]);let a=iu(o);const l=n>=s?s:n;for(let c=0;c<l;++c){const h=i,u=a,d=r;[a,i,r]=de.tidy(()=>{const p=Pn(i,[c,c],[n-c,1]),f=Ew(p),g=Pn(i,[c,c],[1,1]),m=pf(Aw(g,0),lu([[-1]]),lu([[1]])),y=cn(g,Wt(m,f)),v=Nr(p,y);v.shape[0]===1?a=iu(o):a=kr([o,Pn(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);const b=zl(Nr(Cn(m,y),f)),x=Pn(i,[c,0],[n-c,s]),w=Wt(b,a),S=TN(a);if(c===0)i=cn(x,Cn(w,Cn(S,x)));else{const T=cn(x,Cn(w,Cn(S,x)));i=kr([Pn(i,[0,0],[c,s]),T],0)}const C=TN(w),_=Pn(r,[0,c],[n,r.shape[1]-c]);if(c===0)r=cn(_,Cn(Cn(_,a),C));else{const T=cn(_,Cn(Cn(_,a),C));r=kr([Pn(r,[0,0],[n,c]),T],1)}return[a,i,r]}),gVe([h,u,d])}return!t&&n>s&&(r=Pn(r,[0,0],[n,s]),i=Pn(i,[0,0],[s,s])),[r,i]})}const o8e=ee({qr_:i8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Yr;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Yr||(Yr={}));function a8e(e,t,n=Yr.SUM_BY_NONZERO_WEIGHTS){const s=G(e,"losses","computeWeightedLoss");let r=null;t!=null&&(r=G(t,"weights","computeWeightedLoss"));const i=r==null?s:Wt(s,r);if(n===Yr.NONE)return i;if(n===Yr.SUM)return Vn(i);if(n===Yr.MEAN){if(r==null)return kw(i);{const o=s.size/r.size,a=Nr(Vn(i),Vn(r));return o>1?Nr(a,mn(o)):a}}if(n===Yr.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Nr(Vn(i),mn(s.size));{const o=Wt(r,il(s.shape)),a=Vs(Vn(cj(o,mn(0))),"float32");return Nr(Vn(i),a)}}throw Error(`Unknown reduction: ${n}`)}const Gl=ee({computeWeightedLoss_:a8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l8e(e,t,n,s=Yr.SUM_BY_NONZERO_WEIGHTS){const r=G(e,"labels","absoluteDifference"),i=G(t,"predictions","absoluteDifference");let o=null;n!=null&&(o=G(n,"weights","absoluteDifference")),wo(r.shape,i.shape,"Error in absoluteDifference: ");const a=_o(cn(r,i));return Gl(a,o,s)}const c8e=ee({absoluteDifference_:l8e});function u8e(e,t,n,s,r=Yr.SUM_BY_NONZERO_WEIGHTS){const i=G(e,"labels","cosineDistance"),o=G(t,"predictions","cosineDistance");let a=null;s!=null&&(a=G(s,"weights","cosineDistance")),wo(i.shape,o.shape,"Error in cosineDistance: ");const l=mn(1),c=cn(l,Vn(Wt(i,o),n,!0));return Gl(c,a,r)}const h8e=ee({cosineDistance_:u8e});function d8e(e,t,n,s=Yr.SUM_BY_NONZERO_WEIGHTS){let r=G(e,"labels","hingeLoss");const i=G(t,"predictions","hingeLoss");let o=null;n!=null&&(o=G(n,"weights","hingeLoss")),wo(r.shape,i.shape,"Error in hingeLoss: ");const a=mn(1);r=cn(Wt(mn(2),r),a);const l=Dw(cn(a,Wt(r,i)));return Gl(l,o,s)}const p8e=ee({hingeLoss_:d8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f8e(e,t,n,s=1,r=Yr.SUM_BY_NONZERO_WEIGHTS){const i=G(e,"labels","huberLoss"),o=G(t,"predictions","huberLoss");let a=null;n!=null&&(a=G(n,"weights","huberLoss")),wo(i.shape,o.shape,"Error in huberLoss: ");const l=mn(s),c=_o(cn(o,i)),h=lj(c,l),u=cn(c,h),d=Ws(Wt(mn(.5),Tw(h)),Wt(l,u));return Gl(d,a,r)}const m8e=ee({huberLoss_:f8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g8e(e,t,n,s=1e-7,r=Yr.SUM_BY_NONZERO_WEIGHTS){const i=G(e,"labels","logLoss"),o=G(t,"predictions","logLoss");let a=null;n!=null&&(a=G(n,"weights","logLoss")),wo(i.shape,o.shape,"Error in logLoss: ");const l=mn(1),c=mn(s),h=zl(Wt(i,j0(Ws(o,c)))),u=Wt(cn(l,i),j0(Ws(cn(l,o),c))),d=cn(h,u);return Gl(d,a,r)}const y8e=ee({logLoss_:g8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v8e(e,t,n,s=Yr.SUM_BY_NONZERO_WEIGHTS){const r=G(e,"labels","meanSquaredError"),i=G(t,"predictions","meanSquaredError");let o=null;n!=null&&(o=G(n,"weights","meanSquaredError")),wo(r.shape,i.shape,"Error in meanSquaredError: ");const a=yj(r,i);return Gl(a,o,s)}const x8e=ee({meanSquaredError_:v8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b8e(e,t){const n=G(e,"labels","sigmoidCrossEntropyWithLogits"),s=G(t,"logits","sigmoidCrossEntropyWithLogits");wo(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=Dw(s),i=Wt(s,n),o=nj(Bh(zl(_o(s))));return Ws(cn(r,i),o)}function w8e(e,t,n,s=0,r=Yr.SUM_BY_NONZERO_WEIGHTS){let i=G(e,"multiClassLabels","sigmoidCrossEntropy");const o=G(t,"logits","sigmoidCrossEntropy");let a=null;if(n!=null&&(a=G(n,"weights","sigmoidCrossEntropy")),wo(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),s>0){const c=mn(s),h=mn(1),u=mn(.5);i=Ws(Wt(i,cn(h,c)),Wt(u,c))}const l=b8e(i,o);return Gl(l,a,r)}const S8e=ee({sigmoidCrossEntropy_:w8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _8e(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Ul((r,i,o)=>{const l=rj(i,[n],!0),c=cn(Vs(i,"float32"),l);o([r,c]);const h=zl(Wt(c,r));return{value:Vn(h,[n]),gradFunc:(p,f)=>{const[g,m]=f,y=Cw(p.shape,[n]);return[Wt(Oe(p,y),cn(Vs(g,"float32"),Bh(m))),Wt(Oe(p,y),cn(Bh(m),Vs(g,"float32")))]}}})(e,t)}function C8e(e,t,n,s=0,r=Yr.SUM_BY_NONZERO_WEIGHTS){let i=G(e,"onehotLabels","softmaxCrossEntropy");const o=G(t,"logits","softmaxCrossEntropy");let a=null;if(n!=null&&(a=G(n,"weights","softmaxCrossEntropy")),wo(i.shape,o.shape,"Error in softmaxCrossEntropy: "),s>0){const c=mn(s),h=mn(1),u=mn(i.shape[1]);i=Ws(Wt(i,cn(h,c)),Nr(c,u))}const l=_8e(i,o);return Gl(l,a,r)}const T8e=ee({softmaxCrossEntropy_:C8e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E8e(e,t,n,s){const r=G(e,"indices","sparseFillEmptyRows","int32"),i=G(t,"values","sparseFillEmptyRows"),o=G(n,"denseShape","sparseFillEmptyRows","int32"),a=G(s,"defaultValue","sparseFillEmptyRows",i.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:r,values:i,denseShape:o,defaultValue:a},c=de.runKernel(I4e,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const A8e=ee({sparseFillEmptyRows_:E8e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I8e(e,t,n){const s=G(e,"inputIndices","sparseReshape","int32"),r=G(t,"inputShape","sparseReshape","int32"),i=G(n,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const o={inputIndices:s,inputShape:r,newShape:i},a=de.runKernel(N4e,o);return{outputIndices:a[0],outputShape:a[1]}}const N8e=ee({sparseReshape_:I8e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k8e(e,t,n){const s=G(e,"data","sparseSegmentMean"),r=G(t,"indices","sparseSegmentMean","int32"),i=G(n,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const o={data:s,indices:r,segmentIds:i};return de.runKernel(k4e,o)}const D8e=ee({sparseSegmentMean_:k8e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M8e(e,t,n){const s=G(e,"data","sparseSegmentSum"),r=G(t,"indices","sparseSegmentSum","int32"),i=G(n,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const o={data:s,indices:r,segmentIds:i};return de.runKernel(D4e,o)}const P8e=ee({sparseSegmentSum_:M8e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O8e(e,t,n,s,r,i,o,a){const l=G(e,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=G(t,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const h={separator:n,nGramWidths:s,leftPad:r,rightPad:i,padWidth:o,preserveShortSequences:a},u={data:l,dataSplits:c},d=de.runKernel(R4e,u,h);return{nGrams:d[0],nGramsSplits:d[1]}}const R8e=ee({stringNGrams_:O8e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L8e(e,t,n=!0){const s=G(e,"input","stringSplit","string"),r=G(t,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const i={skipEmpty:n},o={input:s,delimiter:r},a=de.runKernel(L4e,o,i);return{indices:a[0],values:a[1],shape:a[2]}}const F8e=ee({stringSplit_:L8e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $8e(e,t){const n=G(e,"input","stringToHashBucketFast","string"),s={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return de.runKernel(F4e,r,s)}const B8e=ee({stringToHashBucketFast_:$8e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z8e={fft:FN,ifft:Mw,rfft:$N,irfft:gj},U8e={hammingWindow:d6e,hannWindow:wj,frame:Sj,stft:g6e},V8e={flipLeftRight:b6e,grayscaleToRGB:S6e,resizeNearestNeighbor:K6e,resizeBilinear:q6e,rotateWithOffset:C6e,cropAndResize:v6e,nonMaxSuppression:E6e,nonMaxSuppressionAsync:F6e,nonMaxSuppressionWithScore:B6e,nonMaxSuppressionWithScoreAsync:U6e,nonMaxSuppressionPadded:G6e,nonMaxSuppressionPaddedAsync:H6e,threshold:Z6e,transform:e8e},G8e={bandPart:n8e,gramSchmidt:r8e,qr:o8e},W8e={absoluteDifference:c8e,computeWeightedLoss:Gl,cosineDistance:h8e,hingeLoss:p8e,huberLoss:m8e,logLoss:y8e,meanSquaredError:x8e,sigmoidCrossEntropy:S8e,softmaxCrossEntropy:T8e},H8e={sparseFillEmptyRows:A8e,sparseReshape:N8e,sparseSegmentMean:D8e,sparseSegmentSum:P8e},j8e={stringNGrams:R8e,stringSplit:F8e,stringToHashBucketFast:B8e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q8e=sn();q8e.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Co;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(Co||(Co={}));var Tj;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(Tj||(Tj={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X8e={};function Ej(e){return X8e[e]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N(e,t,n,s,r){const i=t.inputParams[e];if(i&&i.inputIndexStart!==void 0){const a=i.inputIndexStart,l=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?a+1:i.inputIndexEnd;if(i.type==="tensor")return Dr(t.inputNames[i.inputIndexStart],n,s,r);if(i.type==="tensors")return t.inputNames.slice(a,l).map(d=>Dr(d,n,s,r));const c=Dr(t.inputNames.slice(a)[0],n,s,r),h=c.dataSync();return i.type==="number"?h[0]:eN(c.shape,h)}const o=t.attrParams[e];return o&&o.value}function Dr(e,t,n,s){const[r,i]=mi(e);if(s!=null){const a=s.getHashTableHandleByName(r);if(a!=null)return a}const o=n.currentContextIds.find(a=>!!t[Pw(r,a)]);return o!==void 0?t[Pw(r,o)][i]:void 0}function K8e(e,t,n){return t[Pw(e,n.currentContextId)]}function ol(e,t){const[n,s,r]=mi(e);return[Pw(n,t&&t.currentContextId),s,r]}function Pw(e,t){return t?`${e}-${t}`:e}function mi(e){const t=e.split(":");if(t.length===1)return[e,0,void 0];const n=t[0],s=t.length===3?t[1]:void 0,r=Number(t[t.length-1]);return[n,r,s]}function Ow(e,t,n){let s=N("pad",e,t,n);if(s==="explicit"){s=N("explicitPaddings",e,t,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)r[i][0]=s[i*2],r[i][1]=s[i*2+1];return r}return s}function Wl(e){return e.kept?e:iu(e)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y8e=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var Q8e=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:Y8e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z8e=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var J8e=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:Z8e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eqe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var tqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:eqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nqe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var sqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:nqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rqe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var iqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:rqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oqe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var aqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:oqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lqe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var cqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:lqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uqe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var hqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:uqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dqe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var pqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:dqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fqe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var mqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:fqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gqe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var yqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:gqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vqe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var xqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:vqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bqe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var wqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:bqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sqe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var _qe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:Sqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cqe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var Tqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:Cqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eqe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var Aqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:Eqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iqe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var Nqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:Iqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kqe=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var Dqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:kqe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mqe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var Pqe=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:Mqe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Aj{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[Q8e,J8e,tqe,sqe,iqe,aqe,cqe,hqe,pqe,mqe,yqe,xqe,wqe,_qe,Tqe,Aqe,Nqe,Dqe,Pqe],n=[].concat(...t.map(s=>s.json));this.opMappers=n.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(t,n={}){const s=t.node,r=[],i=[],o=[],a=s.reduce((g,m)=>(g[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?r.push(g[m.name]):m.op==="Const"?i.push(g[m.name]):(m.input==null||m.input.length===0)&&o.push(g[m.name]),g),{});let l=[];const c=[];let h={},u={};n!=null&&(h=this.mapSignatureEntries(n.inputs),u=this.mapSignatureEntries(n.outputs));const d=Object.keys(a);d.forEach(g=>{const m=a[g];m.inputNames.forEach((y,v)=>{const[b,,x]=ol(y),w=a[b];if(w.outputs!=null){const S=w.outputs.indexOf(x);if(S!==-1){const C=`${b}:${S}`;m.inputNames[v]=C}}m.inputs.push(w),w.children.push(m)})}),Object.keys(u).length===0?d.forEach(g=>{const m=a[g];m.children.length===0&&c.push(m)}):Object.keys(u).forEach(g=>{const[m]=ol(g),y=a[m];y!=null&&(y.signatureKey=u[g],c.push(y))}),Object.keys(h).length>0?Object.keys(h).forEach(g=>{const[m]=ol(g),y=a[m];y&&(y.signatureKey=h[g],l.push(y))}):l=r;let p={};t.library!=null&&t.library.function!=null&&(p=t.library.function.reduce((g,m)=>(g[m.signature.name]=this.mapFunction(m),g),{}));const f={nodes:a,inputs:l,outputs:c,weights:i,placeholders:r,signature:n,functions:p};return o.length>0&&(f.initNodes=o),f}mapSignatureEntries(t){return Object.keys(t||{}).reduce((n,s)=>(n[t[s].name]=s,n),{})}mapNode(t){const n=Ej(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});const s={name:t.name,op:t.op,category:n.category,inputNames:(t.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:n.outputs};return n.inputs!=null&&(s.inputParams=n.inputs.reduce((r,i)=>(r[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},r),{})),n.attrs!=null&&(s.attrParams=n.attrs.reduce((r,i)=>{const o=i.type;let a;switch(i.type){case"string":a=jN(t.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=jN(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":a=ek(t.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=ek(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":a=XN(t.attr,i.tfName,i.defaultValue||0),a===void 0&&!!i.tfDeprecatedName&&(a=XN(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":a=JN(t.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=JN(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":a=qN(t.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=qN(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":a=nk(t.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=nk(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":a=ZN(t.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=ZN(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":a=tk(t.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=tk(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":a=YN(t.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=YN(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":a=QN(t.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=QN(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":a=Nj(t.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=Nj(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${t.op}`)}return r[i.name]={value:a,type:o},r},{})),s}mapFunction(t){const n=t.nodeDef,s=[],r=[];let i={};n!=null&&(i=n.reduce((u,d)=>(u[d.name]=this.mapNode(d),d.op==="Const"&&r.push(u[d.name]),u),{}));const o=[],a=[];t.signature.inputArg.forEach(u=>{const[d]=ol(u.name),p={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:KN(u.type),type:"dtype"}},children:[]};p.signatureKey=u.name,o.push(p),i[d]=p}),Object.keys(i).forEach(u=>{const d=i[u];d.inputNames.forEach((p,f)=>{const[g,,m]=ol(p),y=i[g];if(y.outputs!=null){const v=y.outputs.indexOf(m);if(v!==-1){const b=`${g}:${v}`;d.inputNames[f]=b}}d.inputs.push(y),y.children.push(d)})});const c=t.ret;t.signature.outputArg.forEach(u=>{const[d,p]=ol(c[u.name]),f=i[d];f!=null&&(f.defaultOutput=p,a.push(f))});const h=this.mapArgsToSignature(t);return{nodes:i,inputs:o,outputs:a,weights:r,placeholders:s,signature:h}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s),n),{}),outputs:t.signature.outputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s,t.ret),n),{})}}mapArgToTensorInfo(t,n){let s=t.name;return n!=null&&(s=n[s]),{name:s,dtype:t.type}}}function Oqe(e){const t=sn().global;if(typeof t.atob!="undefined")return t.atob(e);if(typeof Buffer!="undefined")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Ij(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):Oqe(e);return t?n:n.toLowerCase()}function jN(e,t,n,s=!1){const r=e[t];return r!=null?Ij(r.s,s):n}function qN(e,t,n){const s=e[t];return s?s.b:n}function XN(e,t,n){const s=e[t]||{},r=s.i!=null?s.i:s.f!=null?s.f:n;return typeof r=="number"?r:parseInt(r,10)}function KN(e){switch(typeof e=="string"&&(e=Co[e]),e){case Co.DT_FLOAT:case Co.DT_HALF:return"float32";case Co.DT_INT32:case Co.DT_INT64:case Co.DT_INT8:case Co.DT_UINT8:return"int32";case Co.DT_BOOL:return"bool";case Co.DT_DOUBLE:return"float32";case Co.DT_STRING:return"string";default:return null}}function Nj(e,t,n){const s=e[t];return s&&s.func?s.func.name:n}function YN(e,t,n){const s=e[t];return s&&s.type?KN(s.type):n}function QN(e,t,n){const s=e[t];return s&&s.list&&s.list.type?s.list.type.map(r=>KN(r)):n}function kj(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function ZN(e,t,n){const s=e[t];return s&&s.shape?kj(s.shape):n}function JN(e,t,n){const s=e[t];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):n}function ek(e,t,n,s=!1){const r=e[t];return r&&r.list&&r.list.s?r.list.s.map(i=>Ij(i,s)):n}function tk(e,t,n){const s=e[t];return s&&s.list&&s.list.shape?s.list.shape.map(r=>kj(r)):n}function nk(e,t,n){const s=e[t];return s&&s.list&&s.list.b?s.list.b:n}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rqe{constructor(t,n,s){this.node=t,this.tensorMap=n,this.context=s,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(r=>this.getInput(r)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((r,i)=>(r[i]=this.getAttr(i),r),{}))}getInput(t){return Dr(t,this.tensorMap,this.context)}getAttr(t,n){const s=this.node.rawAttrs[t];if(s.tensor!=null)return Dr(t,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return XN(this.node.rawAttrs,t,n);if(s.s!=null)return jN(this.node.rawAttrs,t,n);if(s.b!=null)return qN(this.node.rawAttrs,t,n);if(s.shape!=null)return ZN(this.node.rawAttrs,t,n);if(s.type!=null)return YN(this.node.rawAttrs,t,n);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return JN(this.node.rawAttrs,t,n);if(s.list.s!=null)return ek(this.node.rawAttrs,t,n);if(s.list.shape!=null)return tk(this.node.rawAttrs,t,n);if(s.list.b!=null)return nk(this.node.rawAttrs,t,n);if(s.list.type!=null)return QN(this.node.rawAttrs,t,n)}return n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var hr=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",abs:_o,acos:DVe,acosh:PVe,add:Ws,addN:RVe,all:FVe,any:BVe,argMax:UVe,argMin:GVe,asin:HVe,asinh:qVe,atan:KVe,atan2:QVe,atanh:JVe,avgPool:WH,avgPool3d:aGe,basicLSTMCell:pGe,batchToSpaceND:HH,batchNorm:bw,batchNorm2d:vGe,batchNorm3d:bGe,batchNorm4d:SGe,bincount:jH,broadcastArgs:TGe,broadcastTo:ww,buffer:Bl,cast:Vs,ceil:IGe,clipByValue:kGe,clone:iu,complex:nu,concat:kr,concat1d:MGe,concat2d:OGe,concat3d:LGe,concat4d:$Ge,conv1d:UGe,conv2d:_w,conv2dTranspose:WGe,conv3d:jGe,conv3dTranspose:YGe,cos:ZGe,cosh:eWe,cumprod:nWe,cumsum:rWe,denseBincount:oWe,depthToSpace:lWe,depthwiseConv2d:NN,diag:hWe,dilation2d:pWe,div:Nr,divNoNan:vWe,dot:bWe,einsum:SWe,elu:KH,equal:XH,erf:TWe,euclideanNorm:RWe,exp:Bh,expandDims:zh,expm1:BWe,eye:QH,fill:Sw,floor:ZH,floorDiv:GH,gather:JH,greater:Aw,greaterEqual:ej,imag:gw,isFinite:qWe,isInf:KWe,isNaN:QWe,leakyRelu:tj,less:e5e,lessEqual:ON,linspace:n5e,localResponseNormalization:r5e,log:j0,log1p:nj,logSigmoid:c5e,logSoftmax:d5e,logSumExp:rj,logicalAnd:Iw,logicalNot:ij,logicalOr:oj,logicalXor:v5e,lowerBound:b5e,matMul:Cn,max:ff,maxPool:aj,maxPool3d:_5e,maxPoolWithArgmax:T5e,maximum:A5e,mean:kw,meshgrid:N5e,min:DN,minimum:lj,mirrorPad:M5e,mod:O5e,moments:L5e,mul:Wt,multiRNNCell:$5e,multinomial:z5e,neg:zl,notEqual:cj,oneHot:mVe,ones:il,onesLike:G5e,outerProduct:H5e,pad:q0,pad1d:X5e,pad2d:Y5e,pad3d:Z5e,pad4d:eHe,pool:iHe,pow:MN,prelu:hj,print:OH,prod:lHe,raggedGather:uHe,raggedTensorToTensor:dHe,rand:fHe,randomGamma:vHe,randomNormal:dj,randomStandardNormal:wHe,randomUniform:pj,range:X0,real:W0,reciprocal:CHe,relu:Dw,relu6:fj,reshape:Oe,reverse:Uh,reverse1d:NHe,reverse2d:DHe,reverse3d:PHe,reverse4d:RHe,round:mj,rsqrt:$He,scalar:mn,selu:zHe,separableConv2d:VHe,setdiff1dAsync:WHe,sigmoid:df,sign:jHe,sin:XHe,sinh:YHe,slice:Pn,slice1d:ZHe,slice2d:eje,slice3d:nje,slice4d:rje,softmax:oje,softplus:sj,spaceToBatchND:uj,fft:FN,ifft:Mw,irfft:gj,rfft:$N,split:K0,sqrt:PN,square:Tw,squaredDifference:yj,squeeze:BN,stack:Vl,step:vj,stridedSlice:yje,sub:cn,sum:Vn,tan:xje,tanh:IN,tensor:rl,tensor1d:ia,tensor2d:lu,tensor3d:SVe,tensor4d:bje,tensor5d:wje,tensor6d:Sje,tile:H0,topk:Cje,truncatedNormal:Eje,unique:Ije,unsortedSegmentSum:kje,unstack:Vh,upperBound:Mje,variable:Pje,where:pf,whereAsync:xj,zeros:mf,zerosLike:kN,op:ee,OP_SCOPE_SUFFIX:bH,booleanMaskAsync:Fje,transpose:TN,norm:Ew,movingAverage:Bje,scatterND:Uje,searchSorted:RN,sparseToDense:Wje,gatherND:jje,dropout:Kje,enclosingPowerOfTwo:bj,cosineWindow:zN,inTopKAsync:Qje,image:V8e,linalg:G8e,losses:W8e,spectral:z8e,fused:u6e,signal:U8e,sparse:H8e,string:j8e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lqe=(e,t,n,s=hr)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(N("a",e,t,n),N("b",e,t,n))];case"AddN":return[s.addN(N("tensors",e,t,n))];case"FloorMod":case"Mod":return[s.mod(N("a",e,t,n),N("b",e,t,n))];case"Mul":return[s.mul(N("a",e,t,n),N("b",e,t,n))];case"RealDiv":case"Div":return[s.div(N("a",e,t,n),N("b",e,t,n))];case"DivNoNan":return[s.divNoNan(N("a",e,t,n),N("b",e,t,n))];case"FloorDiv":return[s.floorDiv(N("a",e,t,n),N("b",e,t,n))];case"Sub":return[s.sub(N("a",e,t,n),N("b",e,t,n))];case"Minimum":return[s.minimum(N("a",e,t,n),N("b",e,t,n))];case"Maximum":return[s.maximum(N("a",e,t,n),N("b",e,t,n))];case"Pow":return[s.pow(N("a",e,t,n),N("b",e,t,n))];case"SquaredDifference":return[s.squaredDifference(N("a",e,t,n),N("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fqe=(e,t,n,s=hr)=>{switch(e.op){case"Abs":case"ComplexAbs":return[s.abs(N("x",e,t,n))];case"Acos":return[s.acos(N("x",e,t,n))];case"Acosh":return[s.acosh(N("x",e,t,n))];case"Asin":return[s.asin(N("x",e,t,n))];case"Asinh":return[s.asinh(N("x",e,t,n))];case"Atan":return[s.atan(N("x",e,t,n))];case"Atan2":return[s.atan2(N("x",e,t,n),N("y",e,t,n))];case"Atanh":return[s.atanh(N("x",e,t,n))];case"Ceil":return[s.ceil(N("x",e,t,n))];case"Complex":return[s.complex(N("real",e,t,n),N("imag",e,t,n))];case"Cos":return[s.cos(N("x",e,t,n))];case"Cosh":return[s.cosh(N("x",e,t,n))];case"Elu":return[s.elu(N("x",e,t,n))];case"Erf":return[s.erf(N("x",e,t,n))];case"Exp":return[s.exp(N("x",e,t,n))];case"Expm1":return[s.expm1(N("x",e,t,n))];case"Floor":return[s.floor(N("x",e,t,n))];case"Log":return[s.log(N("x",e,t,n))];case"Log1p":return[s.log1p(N("x",e,t,n))];case"Imag":return[s.imag(N("x",e,t,n))];case"Neg":return[s.neg(N("x",e,t,n))];case"Reciprocal":return[s.reciprocal(N("x",e,t,n))];case"Real":return[s.real(N("x",e,t,n))];case"Relu":return[s.relu(N("x",e,t,n))];case"Round":return[s.round(N("x",e,t,n))];case"Selu":return[s.selu(N("x",e,t,n))];case"Sigmoid":return[s.sigmoid(N("x",e,t,n))];case"Sin":return[s.sin(N("x",e,t,n))];case"Sign":return[s.sign(N("x",e,t,n))];case"Sinh":return[s.sinh(N("x",e,t,n))];case"Softplus":return[s.softplus(N("x",e,t,n))];case"Sqrt":return[s.sqrt(N("x",e,t,n))];case"Square":return[s.square(N("x",e,t,n))];case"Tanh":return[s.tanh(N("x",e,t,n))];case"Tan":return[s.tan(N("x",e,t,n))];case"ClipByValue":return[s.clipByValue(N("x",e,t,n),N("clipValueMin",e,t,n),N("clipValueMax",e,t,n))];case"Relu6":return[s.relu6(N("x",e,t,n))];case"Rsqrt":return[s.rsqrt(Dr(e.inputNames[0],t,n))];case"Prod":return[s.prod(N("x",e,t,n),N("axes",e,t,n))];case"LeakyRelu":return[s.leakyRelu(N("x",e,t,n),N("alpha",e,t,n))];case"Prelu":return[s.prelu(N("x",e,t,n),N("alpha",e,t,n))];case"IsNan":return[s.isNaN(Dr(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function To(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){Q(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let s=0;s<e.length;s++){const r=e[s],i=t[s];Q(r<0||i<0||r===i,()=>n+` Shapes ${e} and ${t} must match`)}}}function Dj(e){return!(typeof e=="number"||e.some(t=>t<0))}function Y0(e,t,n){let s=sk(e,n);const r=!Dj(s);if(r&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&t.forEach(i=>{s=sk(i.shape,s)}),!Dj(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function sk(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let s=0;s<e.length;++s){const r=e[s],i=t[s];if(r>=0&&i>=0&&r!==i)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[s]=r>=0?r:i}return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $qe{constructor(t,n,s,r,i,o,a){this.name=t,this.dtype=n,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=mn(0),ou(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const n=this.tensors[t];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(t){return t.map(n=>this.read(n))}write(t,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[t]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),To(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);s.tensor=n,ou(n),s.written=!0,this.tensors[t]=s}writeMany(t,n){if(t.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${n.length}.`);t.forEach((s,r)=>this.write(s,n[r]))}gather(t,n){if(!!n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(t)t=t.slice(0,this.size());else{t=[];for(let r=0;r<this.size();r++)t.push(r)}if(t.length===0)return rl([],[0].concat(this.elementShape));const s=this.readMany(t);return To(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Vl(s,0)}concat(t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return rl([],[0].concat(this.elementShape));const n=[];for(let r=0;r<this.size();r++)n.push(r);const s=this.readMany(n);return To(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),kr(s,0)}scatter(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const s=Math.max(...t);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(t,Vh(n,0))}split(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let s=0;const r=t.map(l=>(s+=l,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const i=s===0?0:n.size/s,o=[];So(()=>{n=Oe(n,[1,s,i]);for(let l=0;l<t.length;++l){const c=l===0?0:r[l-1],h=[0,c,0],u=[1,t[l],i];o[l]=Oe(Pn(n,h,u),this.elementShape)}return o});const a=[];for(let l=0;l<t.length;l++)a[l]=l;this.writeMany(a,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gh{constructor(t,n,s,r=-1){this.tensors=t,this.elementShape=n,this.elementDtype=s,t!=null&&t.forEach(i=>{if(s!==i.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${i.dtype}`);To(n,i.shape,"TensorList shape mismatch: "),ou(i)}),this.idTensor=mn(0),this.maxNumElements=r,ou(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Gh([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,s=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);To(t,this.elementShape,"TensorList shape mismatch: ");const r=Y0(this.elementShape,this.tensors,t);return So(()=>{const i=this.tensors.map(o=>Oe(o,r));return Vl(i,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Y0(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,To(r.shape,t,"TensorList shape mismatch: "),Oe(r,s)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(To(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ou(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const n=new Gh([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let s=0;s<Math.min(this.tensors.length,t);++s)n.tensors[s]=this.tensors[s];return n}getItem(t,n,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);To(this.tensors[t].shape,n,"TensorList shape mismatch: ");const r=Y0(this.elementShape,this.tensors,n);return Oe(this.tensors[t],r)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);To(this.elementShape,n.shape,"TensorList shape mismatch: "),ou(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,s){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);To(this.elementShape,s,"TensorList shape mismatch: "),t=t.slice(0,this.size());const r=Y0(this.elementShape,this.tensors,s);return t.length===0?rl([],[0].concat(r)):So(()=>{const i=t.map(o=>Oe(this.tensors[o],r));return Vl(i,0)})}concat(t,n){if(!!t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);To(this.elementShape,n,"TensorList shape mismatch: ");const s=Y0(this.elementShape,this.tensors,n);return this.size()===0?rl([],[0].concat(s)):So(()=>{const r=this.tensors.map(i=>Oe(i,s));return kr(r,0)})}}function Bqe(e,t,n){const s=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);const r=e.shape.slice(1);To(r,t,"TensorList shape mismatch: ");const i=Vh(e);return new Gh(i,t,s)}function zqe(e,t,n,s){return new Gh([],e,t,s)}function Uqe(e,t,n,s){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const i=new Gh([],n,e.dtype,s),o=Vh(e,0);return t.forEach((a,l)=>{i.setItem(a,o[l])}),i}function Vqe(e,t,n){let s=0;const r=t.map(h=>(s+=h,s));if(s!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${e.shape}`);const i=e.shape.slice(1),o=sk(i,n),a=s===0?0:e.size/s,l=So(()=>{const h=[];e=Oe(e,[1,s,a]);for(let u=0;u<t.length;++u){const d=u===0?0:r[u-1],p=[0,d,0],f=[1,t[u],a];h[u]=Oe(Pn(e,p,f),o)}return e.dispose(),h}),c=new Gh([],n,e.dtype,t.length);for(let h=0;h<l.length;h++)c.setItem(h,l[h]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gqe=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const s=N("thenBranch",e,t,n),r=N("elseBranch",e,t,n),i=N("cond",e,t,n),o=N("args",e,t,n);return(await i.data())[0]?n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const s=N("body",e,t,n),r=N("cond",e,t,n),i=N("args",e,t,n),o=await n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap),a=i.map(h=>h.id);let l=await o[0].data();o.forEach(h=>{!h.kept&&a.indexOf(h.id)===-1&&h.dispose()});let c=i;for(;l[0];){const h=c;c=await n.functionMap[s].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);const u=c.map(p=>p.id);h.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&u.indexOf(p.id)===-1&&p.dispose()});const d=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);l=await d[0].data(),d.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&u.indexOf(p.id)===-1&&p.dispose()})}return c}case"LoopCond":{const s=N("pred",e,t,n);return[Wl(s)]}case"Switch":{const s=N("pred",e,t,n);let r=N("data",e,t,n);return r.kept||(r=Wl(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=e.inputNames.find(r=>Dr(r,t,n)!==void 0);if(s){const r=Dr(s,t,n);return[Wl(r)]}return}case"Enter":{const s=N("frameName",e,t,n),r=N("tensor",e,t,n);return n.enterFrame(s),[Wl(r)]}case"Exit":{const s=N("tensor",e,t,n);return n.exitFrame(),[Wl(s)]}case"NextIteration":{const s=N("tensor",e,t,n);return n.nextIteration(),[Wl(s)]}case"TensorArrayV3":{const s=N("size",e,t,n),r=N("dtype",e,t,n),i=N("elementShape",e,t,n),o=N("dynamicSize",e,t,n),a=N("clearAfterRead",e,t,n),l=N("identicalElementShapes",e,t,n),c=N("name",e,t,n),h=new $qe(c,r,s,i,l,o,a);return n.addTensorArray(h),[h.idTensor,mn(1)]}case"TensorArrayWriteV3":{const s=N("tensorArrayId",e,t,n),r=N("index",e,t,n),i=N("tensor",e,t,n),o=n.getTensorArray(s.id);return o.write(r,i),[o.idTensor]}case"TensorArrayReadV3":{const s=N("tensorArrayId",e,t,n),r=N("index",e,t,n);return[n.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=N("tensorArrayId",e,t,n),r=N("indices",e,t,n),i=N("dtype",e,t,n);return[n.getTensorArray(s.id).gather(r,i)]}case"TensorArrayScatterV3":{const s=N("tensorArrayId",e,t,n),r=N("indices",e,t,n),i=N("tensor",e,t,n),o=n.getTensorArray(s.id);return o.scatter(r,i),[o.idTensor]}case"TensorArrayConcatV3":{const s=N("tensorArrayId",e,t,n),r=n.getTensorArray(s.id),i=N("dtype",e,t,n);return[r.concat(i)]}case"TensorArraySplitV3":{const s=N("tensorArrayId",e,t,n),r=N("tensor",e,t,n),i=N("lengths",e,t,n),o=n.getTensorArray(s.id);return o.split(i,r),[o.idTensor]}case"TensorArraySizeV3":{const s=N("tensorArrayId",e,t,n),r=n.getTensorArray(s.id);return[mn(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=N("tensorArrayId",e,t,n),r=n.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=N("tensorListId",e,t,n),r=N("index",e,t,n),i=N("tensor",e,t,n),o=n.getTensorList(s.id);return o.setItem(r,i),[o.idTensor]}case"TensorListGetItem":{const s=N("tensorListId",e,t,n),r=N("index",e,t,n),i=N("elementShape",e,t,n),o=N("elementDType",e,t,n);return[n.getTensorList(s.id).getItem(r,i,o)]}case"TensorListScatterV2":case"TensorListScatter":{const s=N("indices",e,t,n),r=N("tensor",e,t,n),i=N("elementShape",e,t,n),o=N("numElements",e,t,n),a=Uqe(r,s,i,o);return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=N("elementShape",e,t,n),r=N("elementDType",e,t,n);let i;e.op==="TensorListReserve"?i="numElements":i="maxNumElements";const o=N(i,e,t,n),a=e.op==="TensorListReserve"?-1:o,l=zqe(s,r,o,a);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=N("tensorListId",e,t,n),r=N("indices",e,t,n),i=N("elementShape",e,t,n),o=N("elementDType",e,t,n);return[n.getTensorList(s.id).gather(r,o,i)]}case"TensorListStack":{const s=N("tensorListId",e,t,n),r=N("elementShape",e,t,n),i=N("elementDType",e,t,n),o=N("numElements",e,t,n);return[n.getTensorList(s.id).stack(r,i,o)]}case"TensorListFromTensor":{const s=N("tensor",e,t,n),r=N("elementShape",e,t,n),i=N("elementDType",e,t,n),o=Bqe(s,r,i);return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=N("tensorListId",e,t,n),r=n.getTensorList(s.id),i=N("dtype",e,t,n),o=N("elementShape",e,t,n);return[r.concat(i,o)]}case"TensorListPushBack":{const s=N("tensorListId",e,t,n),r=N("tensor",e,t,n),i=n.getTensorList(s.id);return i.pushBack(r),[i.idTensor]}case"TensorListPopBack":{const s=N("tensorListId",e,t,n),r=N("elementShape",e,t,n),i=N("elementDType",e,t,n);return[n.getTensorList(s.id).popBack(r,i)]}case"TensorListSplit":{const s=N("tensor",e,t,n),r=N("elementShape",e,t,n),i=N("lengths",e,t,n),o=Vqe(s,i,r);return n.addTensorList(o),[o.idTensor]}case"TensorListLength":{const s=N("tensorListId",e,t,n),r=n.getTensorList(s.id);return[mn(r.size(),"int32")]}case"TensorListResize":{const s=N("tensorListId",e,t,n),r=N("size",e,t,n),o=n.getTensorList(s.id).resize(r);return n.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mj(e,t,n){const[s,r]=N("fusedOps",e,t,n),i=s==="biasadd",o=!i,a=r==="prelu",l=s==="fusedbatchnorm",c=N("numArgs",e,t,n);if(i){if(a&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const h=N("strides",e,t,n),u=Ow(e,t,n),d=N("dataFormat",e,t,n).toUpperCase(),p=N("dilations",e,t,n);let[f,g]=N("args",e,t,n);o&&(g=f,f=void 0);const m=N("leakyreluAlpha",e,t,n);return{stride:h,pad:u,dataFormat:d,dilations:p,biasArg:f,preluArg:g,activationFunc:r,leakyreluAlpha:m}}const Wqe=(e,t,n,s=hr)=>{switch(e.op){case"Conv1D":{const r=N("stride",e,t,n),i=N("pad",e,t,n),o=N("dataFormat",e,t,n).toUpperCase(),a=N("dilation",e,t,n);return[s.conv1d(N("x",e,t,n),N("filter",e,t,n),r,i,o,a)]}case"Conv2D":{const r=N("strides",e,t,n),i=Ow(e,t,n),o=N("dataFormat",e,t,n).toUpperCase(),a=N("dilations",e,t,n);return[s.conv2d(N("x",e,t,n),N("filter",e,t,n),[r[1],r[2]],i,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:r,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:h,leakyreluAlpha:u}=Mj(e,t,n);return[s.fused.conv2d({x:N("x",e,t,n),filter:N("filter",e,t,n),strides:[r[1],r[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:h,preluActivationWeights:c,leakyreluAlpha:u})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:h,leakyreluAlpha:u}=Mj(e,t,n);return[s.fused.depthwiseConv2d({x:N("x",e,t,n),filter:N("filter",e,t,n),strides:[r[1],r[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:h,preluActivationWeights:c,leakyreluAlpha:u})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=N("outputShape",e,t,n),i=N("strides",e,t,n),o=Ow(e,t,n);return[s.conv2dTranspose(N("x",e,t,n),N("filter",e,t,n),r,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=N("strides",e,t,n),i=Ow(e,t,n),o=N("dilations",e,t,n),a=N("dataFormat",e,t,n).toUpperCase();return[s.depthwiseConv2d(N("input",e,t,n),N("filter",e,t,n),[r[1],r[2]],i,a,[o[1],o[2]])]}case"Conv3D":{const r=N("strides",e,t,n),i=N("pad",e,t,n),o=N("dataFormat",e,t,n).toUpperCase(),a=N("dilations",e,t,n);return[s.conv3d(N("x",e,t,n),N("filter",e,t,n),[r[1],r[2],r[3]],i,o,[a[1],a[2],a[3]])]}case"AvgPool":{const r=N("strides",e,t,n),i=N("pad",e,t,n),o=N("kernelSize",e,t,n);return[s.avgPool(N("x",e,t,n),[o[1],o[2]],[r[1],r[2]],i)]}case"MaxPool":{const r=N("strides",e,t,n),i=N("pad",e,t,n),o=N("kernelSize",e,t,n);return[s.maxPool(N("x",e,t,n),[o[1],o[2]],[r[1],r[2]],i)]}case"MaxPoolWithArgmax":{const r=N("strides",e,t,n),i=N("pad",e,t,n),o=N("kernelSize",e,t,n),a=N("includeBatchInIndex",e,t,n),{result:l,indexes:c}=s.maxPoolWithArgmax(N("x",e,t,n),[o[1],o[2]],[r[1],r[2]],i,a);return[l,c]}case"AvgPool3D":{const r=N("strides",e,t,n),i=N("pad",e,t,n),o=N("kernelSize",e,t,n);return[s.avgPool3d(N("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],i)]}case"MaxPool3D":{const r=N("strides",e,t,n),i=N("pad",e,t,n),o=N("kernelSize",e,t,n);return[s.maxPool3d(N("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],i)]}case"Dilation2D":{const r=N("strides",e,t,n),i=N("pad",e,t,n),o=N("dilations",e,t,n),a=r[1],l=r[2],c=o[1],h=o[2];return[s.dilation2d(N("x",e,t,n),N("filter",e,t,n),[a,l],i,[c,h],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hqe=(e,t,n,s=hr)=>{switch(e.op){case"Fill":{const r=N("shape",e,t,n),i=N("dtype",e,t,n),o=N("value",e,t,n);return[s.fill(r,o,i)]}case"LinSpace":{const r=N("start",e,t,n),i=N("stop",e,t,n),o=N("num",e,t,n);return[s.linspace(r,i,o)]}case"Multinomial":{const r=N("logits",e,t,n),i=N("numSamples",e,t,n),o=N("seed",e,t,n);return[s.multinomial(r,i,o)]}case"OneHot":{const r=N("indices",e,t,n),i=N("depth",e,t,n),o=N("onValue",e,t,n),a=N("offValue",e,t,n),l=N("dtype",e,t,n);return[s.oneHot(r,i,o,a,l)]}case"Ones":return[s.ones(N("shape",e,t,n),N("dtype",e,t,n))];case"OnesLike":return[s.onesLike(N("x",e,t,n))];case"RandomStandardNormal":return[s.randomStandardNormal(N("shape",e,t,n),N("dtype",e,t,n),N("seed",e,t,n))];case"RandomUniform":return[s.randomUniform(N("shape",e,t,n),N("minval",e,t,n),N("maxval",e,t,n),N("dtype",e,t,n))];case"Range":{const r=N("start",e,t,n),i=N("stop",e,t,n),o=N("step",e,t,n);return[s.range(r,i,o,N("dtype",e,t,n))]}case"TruncatedNormal":{const r=N("shape",e,t,n),i=N("mean",e,t,n),o=N("stdDev",e,t,n),a=N("seed",e,t,n);return[s.truncatedNormal(r,i,o,N("dtype",e,t,n),a)]}case"Zeros":return[s.zeros(N("shape",e,t,n),N("dtype",e,t,n))];case"ZerosLike":return[s.zerosLike(N("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rk(e,t,n){const s=N("boxes",e,t,n),r=N("scores",e,t,n),i=N("maxOutputSize",e,t,n),o=N("iouThreshold",e,t,n),a=N("scoreThreshold",e,t,n),l=N("softNmsSigma",e,t,n);return{boxes:s,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}}const jqe=async(e,t,n,s,r=hr)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c,softNmsSigma:h}=rk(e,t,n),u=await r.image.nonMaxSuppressionWithScoreAsync(i,o,a,l,c,h);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=rk(e,t,n),h=N("padToMaxOutputSize",e,t,n),u=await r.image.nonMaxSuppressionPaddedAsync(i,o,a,l,c,h);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=rk(e,t,n);return[await r.image.nonMaxSuppressionAsync(i,o,a,l,c)]}case"Where":{const i=r.cast(N("condition",e,t,n),"bool"),o=[await r.whereAsync(i)];return i.dispose(),o}case"ListDiff":return r.setdiff1dAsync(N("x",e,t,n),N("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qqe=(e,t,n,s=hr)=>{switch(e.op){case"LowerBound":{const r=N("sortedSequence",e,t,n),i=N("values",e,t,n);return[s.lowerBound(r,i)]}case"TopKV2":{const r=N("x",e,t,n),i=N("k",e,t,n),o=N("sorted",e,t,n),a=s.topk(r,i,o);return[a.values,a.indices]}case"UpperBound":{const r=N("sortedSequence",e,t,n),i=N("values",e,t,n);return[s.upperBound(r,i)]}case"Unique":{const r=N("x",e,t,n),i=s.unique(r);return[i.values,i.indices]}case"UniqueV2":{const r=N("x",e,t,n),i=N("axis",e,t,n),o=s.unique(r,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xqe=(e,t,n,s=hr)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const r=N("default",e,t,n);return[Dr(e.name,t,n)||r];case"Placeholder":return[Dr(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const h=N("x",e,t,n);return[Wl(h)]}case"IdentityN":return N("x",e,t,n).map(h=>Wl(h));case"Snapshot":const i=N("x",e,t,n);return[Wl(i)];case"Shape":return[s.tensor1d(N("x",e,t,n).shape,"int32")];case"ShapeN":return N("x",e,t,n).map(h=>s.tensor1d(h.shape));case"Size":return[s.scalar(N("x",e,t,n).size,"int32")];case"Rank":return[s.scalar(N("x",e,t,n).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const o=N("x",e,t,n),a=N("data",e,t,n),l=N("message",e,t,n),c=N("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let h=0;h<a.length;h++)console.log(Array.prototype.slice.call(a[h].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kqe{constructor(t,n){this.keyDType=t,this.valueDType=n,this.handle=mn(0),this.tensorMap=new Map,ou(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return mn(this.size(),"int32")}async import(t,n){this.checkKeyAndValueTensor(t,n);const s=await t.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),So(()=>{const r=Vh(n),i=s.length,o=r.length;Q(i===o,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${o} elements.`);for(let a=0;a<i;a++){const l=s[a],c=r[a];ou(c),this.tensorMap.set(l,c)}return this.handle})}async find(t,n){this.checkKeyAndValueTensor(t,n);const s=await t.data();return So(()=>{const r=[];for(let i=0;i<s.length;i++){const o=s[i],a=this.findWithDefault(o,n);r.push(a)}return Vl(r)})}findWithDefault(t,n){const s=this.tensorMap.get(t);return s!=null?s:n}checkKeyAndValueTensor(t,n){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yqe=async(e,t,n,s)=>{switch(e.op){case"HashTable":case"HashTableV2":{const r=N("keyDType",e,t,n),i=N("valueDType",e,t,n),o=new Kqe(r,i);return s.addHashTable(e.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const r=N("tableHandle",e,t,n,s),i=N("keys",e,t,n),o=N("values",e,t,n);return[await s.getHashTableById(r.id).import(i,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=N("tableHandle",e,t,n,s),i=N("keys",e,t,n),o=N("defaultValue",e,t,n);return[await s.getHashTableById(r.id).find(i,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=N("tableHandle",e,t,n,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qqe=(e,t,n,s=hr)=>{switch(e.op){case"ResizeBilinear":{const r=N("images",e,t,n),i=N("size",e,t,n),o=N("alignCorners",e,t,n),a=N("halfPixelCenters",e,t,n);return[s.image.resizeBilinear(r,[i[0],i[1]],o,a)]}case"ResizeNearestNeighbor":{const r=N("images",e,t,n),i=N("size",e,t,n),o=N("alignCorners",e,t,n),a=N("halfPixelCenters",e,t,n);return[s.image.resizeNearestNeighbor(r,[i[0],i[1]],o,a)]}case"CropAndResize":{const r=N("image",e,t,n),i=N("boxes",e,t,n),o=N("boxInd",e,t,n),a=N("cropSize",e,t,n),l=N("method",e,t,n),c=N("extrapolationValue",e,t,n);return[s.image.cropAndResize(r,i,o,a,l,c)]}case"ImageProjectiveTransformV3":{const r=N("images",e,t,n),i=N("transforms",e,t,n),o=N("outputShape",e,t,n),a=N("fillValue",e,t,n),l=N("interpolation",e,t,n),c=N("fillMode",e,t,n);return[s.image.transform(r,i,l.toLowerCase(),c.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zqe=(e,t,n,s=hr)=>{switch(e.op){case"Equal":return[s.equal(N("a",e,t,n),N("b",e,t,n))];case"NotEqual":return[s.notEqual(N("a",e,t,n),N("b",e,t,n))];case"Greater":return[s.greater(N("a",e,t,n),N("b",e,t,n))];case"GreaterEqual":return[s.greaterEqual(N("a",e,t,n),N("b",e,t,n))];case"Less":return[s.less(N("a",e,t,n),N("b",e,t,n))];case"LessEqual":return[s.lessEqual(N("a",e,t,n),N("b",e,t,n))];case"LogicalAnd":return[s.logicalAnd(N("a",e,t,n),N("b",e,t,n))];case"LogicalNot":return[s.logicalNot(N("a",e,t,n))];case"LogicalOr":return[s.logicalOr(N("a",e,t,n),N("b",e,t,n))];case"Select":case"SelectV2":return[s.where(N("condition",e,t,n),N("a",e,t,n),N("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jqe=(e,t,n,s=hr)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(N("a",e,t,n),N("b",e,t,n),N("transposeA",e,t,n),N("transposeB",e,t,n))];case"Einsum":return[s.einsum(N("equation",e,t,n),...N("tensors",e,t,n))];case"Transpose":return[s.transpose(N("x",e,t,n),N("perm",e,t,n))];case"_FusedMatMul":const[r,i]=N("fusedOps",e,t,n),o=r==="biasadd",a=i==="prelu",l=N("numArgs",e,t,n),c=N("leakyreluAlpha",e,t,n);if(o){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[h,u]=N("args",e,t,n);return[s.fused.matMul({a:N("a",e,t,n),b:N("b",e,t,n),transposeA:N("transposeA",e,t,n),transposeB:N("transposeB",e,t,n),bias:h,activation:i,preluActivationWeights:u,leakyreluAlpha:c})];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e7e=(e,t,n,s=hr)=>{switch(e.op){case"EuclideanNorm":return[s.euclideanNorm(N("x",e,t,n),N("axis",e,t,n),N("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(N("x",e,t,n),N("mean",e,t,n),N("variance",e,t,n),N("offset",e,t,n),N("scale",e,t,n),N("epsilon",e,t,n))];case"FusedBatchNormV3":return[s.batchNorm(N("x",e,t,n),N("mean",e,t,n),N("variance",e,t,n),N("offset",e,t,n),N("scale",e,t,n),N("epsilon",e,t,n))];case"LRN":return[s.localResponseNormalization(N("x",e,t,n),N("radius",e,t,n),N("bias",e,t,n),N("alpha",e,t,n),N("beta",e,t,n))];case"Softmax":return[s.softmax(N("x",e,t,n))];case"LogSoftmax":return[s.logSoftmax(N("x",e,t,n))];case"SparseToDense":return[s.sparseToDense(N("sparseIndices",e,t,n),N("outputShape",e,t,n),N("sparseValues",e,t,n),N("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t7e=(e,t,n,s=hr)=>{switch(e.op){case"Max":{const a=N("axis",e,t,n),l=N("keepDims",e,t,n);return[s.max(N("x",e,t,n),a,l)]}case"Mean":{const a=N("axis",e,t,n),l=N("keepDims",e,t,n);return[s.mean(N("x",e,t,n),a,l)]}case"Min":{const a=N("axis",e,t,n),l=N("keepDims",e,t,n);return[s.min(N("x",e,t,n),a,l)]}case"Sum":{const a=N("axis",e,t,n),l=N("keepDims",e,t,n);return[s.sum(N("x",e,t,n),a,l)]}case"All":{const a=N("axis",e,t,n),l=N("keepDims",e,t,n);return[s.all(N("x",e,t,n),a,l)]}case"Any":{const a=N("axis",e,t,n),l=N("keepDims",e,t,n);return[s.any(N("x",e,t,n),a,l)]}case"ArgMax":{const a=N("axis",e,t,n);return[s.argMax(N("x",e,t,n),a)]}case"ArgMin":{const a=N("axis",e,t,n);return[s.argMin(N("x",e,t,n),a)]}case"Prod":{const a=N("axis",e,t,n),l=N("keepDims",e,t,n);return[s.prod(N("x",e,t,n),a,l)]}case"Cumprod":{const a=N("axis",e,t,n),l=N("exclusive",e,t,n),c=N("reverse",e,t,n);return[s.cumprod(N("x",e,t,n),a,l,c)]}case"Cumsum":{const a=N("axis",e,t,n),l=N("exclusive",e,t,n),c=N("reverse",e,t,n);return[s.cumsum(N("x",e,t,n),a,l,c)]}case"Bincount":const r=N("x",e,t,n),i=N("weights",e,t,n),o=N("size",e,t,n);return[s.bincount(r,i,o)];case"DenseBincount":{const a=N("x",e,t,n),l=N("weights",e,t,n),c=N("size",e,t,n),h=N("binaryOutput",e,t,n);return[s.denseBincount(a,l,c,h)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n7e=(e,t,n,s=hr)=>{switch(e.op){case"ConcatV2":case"Concat":{const r=N("n",e,t,n),i=N("axis",e,t,n);let o=N("tensors",e,t,n);return o=o.slice(0,r),[s.concat(o,i)]}case"Gather":{const r=N("x",e,t,n),i=N("indices",e,t,n);return[s.gather(r,s.cast(i,"int32"),0)]}case"GatherV2":{const r=N("axis",e,t,n),i=N("batchDims",e,t,n),o=N("x",e,t,n),a=N("indices",e,t,n);return[s.gather(o,s.cast(a,"int32"),r,i)]}case"Reverse":{const r=N("dims",e,t,n),i=[];for(let a=0;a<r.length;a++)r[a]&&i.push(a);const o=N("x",e,t,n);return[s.reverse(o,i)]}case"ReverseV2":{const r=N("axis",e,t,n),i=N("x",e,t,n);return[s.reverse(i,r)]}case"Slice":{const r=N("begin",e,t,n),i=N("size",e,t,n);return[s.slice(N("x",e,t,n),r,i)]}case"StridedSlice":{const r=N("begin",e,t,n),i=N("end",e,t,n),o=N("strides",e,t,n),a=N("beginMask",e,t,n),l=N("endMask",e,t,n),c=N("ellipsisMask",e,t,n),h=N("newAxisMask",e,t,n),u=N("shrinkAxisMask",e,t,n),d=N("x",e,t,n);return[s.stridedSlice(d,r,i,o,a,l,c,h,u)]}case"Pack":return So(()=>{const r=N("axis",e,t,n),i=N("tensors",e,t,n),o=i[0].shape,a=s.squeeze(i[0]).shape,l=i.map(c=>{const h=eu(c.shape,o);if(!h&&!eu(s.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return h?c:s.reshape(c,o)});return[s.stack(l,r)]});case"Unpack":{const r=N("axis",e,t,n),i=N("tensor",e,t,n);return s.unstack(i,r)}case"Tile":{const r=N("reps",e,t,n);return[s.tile(N("x",e,t,n),r)]}case"Split":case"SplitV":{const r=N("axis",e,t,n),i=N("numOrSizeSplits",e,t,n),o=N("x",e,t,n);return s.split(o,i,r)}case"ScatterNd":{const r=N("indices",e,t,n),i=N("values",e,t,n),o=N("shape",e,t,n);return[s.scatterND(r,i,o)]}case"GatherNd":{const r=N("x",e,t,n),i=N("indices",e,t,n);return[s.gatherND(r,i)]}case"SparseToDense":{const r=N("sparseIndices",e,t,n),i=N("outputShape",e,t,n),o=N("sparseValues",e,t,n),a=N("defaultValue",e,t,n);return[s.sparseToDense(r,o,i,o.dtype===a.dtype?a:s.cast(a,o.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s7e=(e,t,n,s=hr)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:i,emptyRowIndicator:o,reverseIndexMap:a}=s.sparse.sparseFillEmptyRows(N("indices",e,t,n),N("values",e,t,n),N("denseShape",e,t,n),N("defaultValue",e,t,n));return[r,i,o,a]}case"SparseReshape":{const{outputIndices:r,outputShape:i}=s.sparse.sparseReshape(N("inputIndices",e,t,n),N("inputShape",e,t,n),N("newShape",e,t,n));return[r,i]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(N("data",e,t,n),N("indices",e,t,n),N("segmentIds",e,t,n))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(N("data",e,t,n),N("indices",e,t,n),N("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r7e=(e,t,n,s=hr)=>{switch(e.op){case"FFT":return[s.fft(N("x",e,t,n))];case"IFFT":return[s.ifft(N("x",e,t,n))];case"RFFT":return[s.rfft(N("x",e,t,n))];case"IRFFT":return[s.irfft(N("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i7e=(e,t,n,s=hr)=>{switch(e.op){case"StringNGrams":{const{nGrams:r,nGramsSplits:i}=s.string.stringNGrams(N("data",e,t,n),N("dataSplits",e,t,n),N("separator",e,t,n),N("nGramWidths",e,t,n),N("leftPad",e,t,n),N("rightPad",e,t,n),N("padWidth",e,t,n),N("preserveShortSequences",e,t,n));return[r,i]}case"StringSplit":{const{indices:r,values:i,shape:o}=s.string.stringSplit(N("input",e,t,n),N("delimiter",e,t,n),N("skipEmpty",e,t,n));return[r,i,o]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(N("input",e,t,n),N("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o7e=(e,t,n,s=hr)=>{switch(e.op){case"Cast":return[s.cast(N("x",e,t,n),N("dtype",e,t,n))];case"ExpandDims":{const r=N("axis",e,t,n);return[s.expandDims(N("x",e,t,n),r)]}case"Squeeze":{const r=N("axis",e,t,n);return[s.squeeze(N("x",e,t,n),r)]}case"Reshape":return[s.reshape(N("x",e,t,n),N("shape",e,t,n))];case"MirrorPad":return[s.mirrorPad(N("x",e,t,n),N("padding",e,t,n),N("mode",e,t,n))];case"PadV2":case"Pad":return[s.pad(N("x",e,t,n),N("padding",e,t,n),N("constantValue",e,t,n))];case"SpaceToBatchND":{const r=N("blockShape",e,t,n),i=N("paddings",e,t,n);return[s.spaceToBatchND(N("x",e,t,n),r,i)]}case"BatchToSpaceND":{const r=N("blockShape",e,t,n),i=N("crops",e,t,n);return[s.batchToSpaceND(N("x",e,t,n),r,i)]}case"DepthToSpace":{const r=N("blockSize",e,t,n),i=N("dataFormat",e,t,n).toUpperCase();return[s.depthToSpace(N("x",e,t,n),r,i)]}case"BroadcastTo":return[s.broadcastTo(N("x",e,t,n),N("shape",e,t,n))];case"BroadcastArgs":return[s.broadcastArgs(N("s0",e,t,n),N("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pj(e,t,n,s,r=So){const i=((o,a,l)=>{switch(o.category){case"arithmetic":return r(()=>Lqe(o,a,l));case"basic_math":return r(()=>Fqe(o,a,l));case"control":return Gqe(o,a,l);case"convolution":return r(()=>Wqe(o,a,l));case"creation":return r(()=>Hqe(o,a,l));case"dynamic":return jqe(o,a,l);case"evaluation":return r(()=>qqe(o,a,l));case"image":return r(()=>Qqe(o,a,l));case"graph":return r(()=>Xqe(o,a,l));case"logical":return r(()=>Zqe(o,a,l));case"matrices":return r(()=>Jqe(o,a,l));case"normalization":return r(()=>e7e(o,a,l));case"reduction":return r(()=>t7e(o,a,l));case"slice_join":return r(()=>n7e(o,a,l));case"sparse":return r(()=>s7e(o,a,l));case"spectral":return r(()=>r7e(o,a,l));case"string":return r(()=>i7e(o,a,l));case"transformation":return r(()=>o7e(o,a,l));case"hash_table":return Yqe(o,a,l,s);case"custom":const c=Ej(o.op);if(c&&c.customExecutor)return c.customExecutor(new Rqe(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return af(i)?i.then(o=>[].concat(o)):[].concat(i)}class Oj{constructor(t={},n={},s={},r={}){this.weightMap=t,this.tensorArrayMap=n,this.tensorListMap=s,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,n){return{id:t,frameName:n,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let n=0;n<this.contexts.length-1;n++){const s=this.contexts.slice(0,this.contexts.length-n);t.push(this.contextIdforContexts(s))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(t);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(t)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rj(e,t,n,s){const r=new Set,i=[];let o=null,a=null;const l=new Set,c=Object.keys(e).map(d=>mi(d)[0]);let h=[];s!=null&&(h=s.map(d=>mi(d.name)[0]));const u=[...t];for(;u.length>0;){const d=u.pop();if((Lj(d)||h7e(d)||d7e(d))&&o==null&&(o=d,a=o.children.map(p=>p.name).filter(p=>r.has(p))),r.add(d.name),n[d.name]==null&&c.indexOf(d.name)===-1&&h.indexOf(d.name)===-1){if(d.inputs.length===0){i.push(d.name);continue}d.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),u.push(p))})}}return{inputs:e,outputs:t,usedNodes:r,missingInputs:i,dynamicNode:o,syncInputs:a}}function a7e(e,t,n){const{usedNodes:s,inputs:r}=n,i=[],o=Object.keys(r).map(h=>mi(h)[0]).map(h=>e.nodes[h]),a=e.initNodes;o.forEach(h=>{s.has(h.name)&&i.push(h)}),e.weights.forEach(h=>{s.has(h.name)&&i.push(h)}),a!=null&&a.forEach(h=>{s.has(h.name)&&i.push(h)});const l=new Set,c=[];for(;i.length>0;){const h=i.pop();l.add(h.name),t[h.name]||c.push(h),h.children.forEach(u=>{!l.has(u.name)&&s.has(u.name)&&u.inputs.every(d=>l.has(d.name))&&i.push(u)})}return c}const l7e=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],c7e=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],u7e=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Lj(e){return l7e.indexOf(e.op)>=0}function h7e(e){return c7e.indexOf(e.op)>=0}function d7e(e){return u7e.indexOf(e.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rw{constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(s=>{this._functionExecutorMap[s]=new Rw(t.functions[s],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const n=Object.keys(t).map(s=>t[s].map(r=>r.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}getCompilationKey(t,n){const s=t.map(i=>i.name).sort(),r=n.map(i=>i.name).sort();return s.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(t,n){const s=Rj(t,n,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:i,syncInputs:o}=s;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(r.length>0){const a=n.map(c=>c.name),l=Object.keys(t);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${l}]. Missing the following inputs: [${r}]`)}return a7e(this.graph,this.weightMap,s)}execute(t,n){t=this.mapInputs(t);const s=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);const r=s.map(u=>this.graph.nodes[mi(u)[0]]),i=n.map(u=>mi(u)[0]);let o=i.map(u=>this.graph.nodes[u]);this.resetIntermediateTensors(),o.length===0&&(o=this._outputs);const a=this.getCompilationKey(r,o);let l=this.compiledMap.get(a);l==null&&(l=this.compile(t,o),this.compiledMap.set(a,l));const c={},h={};return So(()=>{const u=new Oj(this.weightMap,c,h,this.functionExecutorMap),d=Object.assign({},this.weightMap);Object.keys(t).forEach(g=>{const[m,y]=mi(g),v=[];v[y]=t[g],d[m]=v});const p=this.getFrozenTensorIds(d),f={};for(let g=0;g<l.length;g++){const m=l[g];if(!d[m.name]){const y=Pj(m,d,u,this._resourceManager);if(af(y))throw new Error(`The execution of the op '${m.op}' returned a promise. Please use model.executeAsync() instead.`);d[m.name]=y,this.checkTensorForDisposal(m.name,m,d,u,p,i,f)}}return this.parent==null&&u.dispose(p),n.map(g=>Dr(g,d,u))})}getFrozenTensorIds(t){const n=[].concat.apply([],Object.keys(t).map(s=>t[s]).map(s=>s.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(t,n,s,r,i,o,a){n.category==="control"||o.indexOf(t)!==-1||(s[t].forEach(l=>{l!=null&&(a[l.id]=(a[l.id]||0)+n.children.length)}),n.inputs.forEach(l=>{if(l.category!=="control"){const c=K8e(l.name,s,r);c!=null&&c.forEach(h=>{if(h&&!h.kept&&!i.has(h.id)){const u=a[h.id];if(u===1){if(!this.keepTensorForDebug)h.dispose();else{const[d,p]=ol(n.name,r);this.intermediateTensors[d]?this.intermediateTensors[d][p]=h:(this.intermediateTensors[d]=[],this.intermediateTensors[d][p]=h)}delete a[h.id]}else u!=null&&a[h.id]--}})}}))}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(t=>this.intermediateTensors[t].forEach(n=>n.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(t=>{this.tensorsMap[t].forEach(s=>{s&&!s.kept&&!s.isDisposed&&!this.keepIds.has(s.id)&&s.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const t in this.intermediateTensors)this.intermediateTensors[t].forEach(n=>n.dispose()),delete this.intermediateTensors[t]}async _executeAsync(t,n,s=!1,r={},i={}){s||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepTensorForDebug=sn().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){console.warn(h.message)}this.resetIntermediateTensors();const o=new Oj(this.weightMap,r,i,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(t,o,n,s);const a=n.map(h=>Dr(h,this.tensorsMap,o)),l=a.map(h=>h.id),c=Object.keys(t).map(h=>t[h].id);return this.keepIds=new Set([...l,...c,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&o.dispose(this.keepIds),a}async executeFunctionAsync(t,n,s){const r=t.reduce((i,o,a)=>(i[this.inputs[a].name]=o,i),{});return this._executeAsync(r,this.outputNodes,!0,n,s)}async executeWithControlFlow(t,n,s,r){const i=Object.keys(t),o=i.map(b=>this.graph.nodes[mi(b)[0]]),a=s.map(b=>mi(b)[0]);let l=a.map(b=>this.graph.nodes[b]);l.length===0&&(l=this._outputs);const{usedNodes:c,missingInputs:h,dynamicNode:u,syncInputs:d}=Rj(t,l,this.weightMap,this._initNodes),p=[...o,...this.graph.weights,...this._initNodes||[]].map(b=>({node:b,contexts:n.currentContext})),f=Object.assign({},this.weightMap);Object.keys(t).forEach(b=>{const[x,w]=mi(b),S=[];S[w]=t[b],f[x]=S});const g={},m=this.getFrozenTensorIds(f),y={};for(;p.length>0;){const b=this.processStack(o,p,n,f,y,m,a,g,c);await Promise.all(b)}u==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const v=l.filter(b=>!Lj(b)&&!Dr(b.name,f,n)).map(b=>b.name);if(v.length>0){let b="";throw u!=null&&(b=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${v}] from the provided inputs [${i}]. Consider providing the following inputs: [${h}]. ${b}`)}return f}processStack(t,n,s,r,i,o,a,l,c){const h=[];for(;n.length>0;){const u=n.pop();s.currentContext=u.contexts;let d="";if(u.node.op==="Enter"&&N("isConstant",u.node,r,s)&&([d]=ol(u.node.name,s)),r[u.node.name]==null){const p=Pj(u.node,r,s,this._resourceManager);d||([d]=ol(u.node.name,s));const f=s.currentContext;af(p)?h.push(p.then(g=>(r[d]=g,s.currentContext=f,this.checkTensorForDisposal(d,u.node,r,s,o,a,l),this.processChildNodes(u.node,n,s,r,i,c),g))):(r[d]=p,this.checkTensorForDisposal(d,u.node,r,s,o,a,l),this.processChildNodes(u.node,n,s,r,i,c))}else this.processChildNodes(u.node,n,s,r,i,c)}return h}processChildNodes(t,n,s,r,i,o){t.children.forEach(a=>{const[l]=ol(a.name,s);i[l]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(c=>!!Dr(c,r,s))&&(i[l]=!0,n.push({contexts:s.currentContext,node:a})):a.inputNames.every(c=>!!Dr(c,r,s))&&(i[l]=!0,n.push({contexts:s.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{const s=t[n],[r]=mi(n),i=this.graph.nodes[r];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value,a=o.length===s.shape.length&&s.shape.every((l,c)=>o[c]===-1||o[c]===l);Q(a,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&Q(s.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(t){const n={};for(const s in t)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[s]!=null){const r=this._signature.inputs[s];n[r.name]=t[s]}else n[s]=t[s];return n}checkInputs(t){const n=Object.keys(t).filter(s=>{const[r]=mi(s);return this.graph.nodes[r]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[n]!=null?this._signature.outputs[n].name:n,{})}checkOutputs(t){t.forEach(n=>{const[s]=mi(n);if(!this.graph.nodes[s])throw new Error(`The output '${n}' is not found in the graph`)})}}class p7e{constructor(t={},n={}){this.hashTableNameToHandle=t,this.hashTableMap=n}addHashTable(t,n){this.hashTableNameToHandle[t]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f7e="?tfjs-format=file",m7e="model.json";class g7e{constructor(t,n={},s=VH){this.modelUrl=t,this.loadOptions=n,this.version="n/a",this.io=s,n==null&&(this.loadOptions={}),this.resourceManager=new p7e}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const n=this.io.getLoadHandlers(t,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[t]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return af(t)?t.then(n=>this.loadSync(n)):this.loadSync(t)}loadSync(t){this.artifacts=t;const n=this.artifacts.modelTopology;let s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(s=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}this.signature=s,this.version=`${n.versions.producer}.${n.versions.minConsumer}`;const r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Rw(Aj.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){const i=Aj.Instance.transformGraph(t.modelInitializer);this.initializer=new Rw(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(t,n){if(typeof t=="string"){const s=this.io.getSaveHandlers(t);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`);t=s[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,n){const s=this.execute(t,this.outputNodes);if(this.structuredOutputKeys){const r=s instanceof ur?[s]:s,i={};return r.forEach((o,a)=>i[this.structuredOutputKeys[a]]=o),i}return s}normalizeInputs(t){if(!(t instanceof ur)&&!Array.isArray(t))return t;if(t=Array.isArray(t)?t:[t],t.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce((n,s,r)=>(n[s]=t[r],n),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,n){t=this.normalizeInputs(t),n=this.normalizeOutputs(n);const s=this.executor.execute(t,n);return s.length>1?s:s[0]}async executeAsync(t,n){t=this.normalizeInputs(t),n=this.normalizeOutputs(n);const s=await this.executor.executeAsync(t,n);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((n,s)=>(n[s]=[t[s]],n),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function y7e(e,t={},n=VH){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=v7e(e));const s=new g7e(e,t,n);return await s.load(),s}function v7e(e){return e.endsWith("/")||(e=e+"/"),`${e}${m7e}${f7e}`}/**
    * @license
    * Copyright 2022 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    *//*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function yf(e,t,n,s){function r(i){return i instanceof n?i:new n(function(o){o(i)})}return new(n||(n=Promise))(function(i,o){function a(h){try{c(s.next(h))}catch(u){o(u)}}function l(h){try{c(s.throw(h))}catch(u){o(u)}}function c(h){h.done?i(h.value):r(h.value).then(a,l)}c((s=s.apply(e,t||[])).next())})}function vf(e,t){var n={label:0,sent:function(){if(i[0]&1)throw i[1];return i[1]},trys:[],ops:[]},s,r,i,o;return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(c){return function(h){return l([c,h])}}function l(c){if(s)throw new TypeError("Generator is already executing.");for(;n;)try{if(s=1,r&&(i=c[0]&2?r.return:c[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,c[1])).done)return i;switch(r=0,i&&(c=[c[0]&2,i.value]),c[0]){case 0:case 1:i=c;break;case 4:return n.label++,{value:c[1],done:!1};case 5:n.label++,r=c[1],c=[0];continue;case 7:c=n.ops.pop(),n.trys.pop();continue;default:if(i=n.trys,!(i=i.length>0&&i[i.length-1])&&(c[0]===6||c[0]===2)){n=0;continue}if(c[0]===3&&(!i||c[1]>i[0]&&c[1]<i[3])){n.label=c[1];break}if(c[0]===6&&n.label<i[1]){n.label=i[1],i=c;break}if(i&&n.label<i[2]){n.label=i[2],n.ops.push(c);break}i[2]&&n.ops.pop(),n.trys.pop();continue}c=t.call(e,n)}catch(h){c=[6,h],r=0}finally{s=i=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}}var x7e="\u2581",b7e=100,w7e=101,S7e="[CLS]",Fj=102,_7e="[SEP]",C7e="NFKC",T7e="https://tfhub.dev/tensorflow/tfjs-model/mobilebert/1/",E7e=T7e+"processed_vocab.json?tfjs-format=file",$j=function(){function e(t){this.key=t,this.children={},this.end=!1}return e.prototype.getWord=function(){for(var t=[],n=this;n!=null;)n.key!=null&&t.unshift(n.key),n=n.parent;return[t,this.score,this.index]},e}(),A7e=function(){function e(){this.root=new $j(null)}return e.prototype.insert=function(t,n,s){for(var r=this.root,i=[],o=0,a=t;o<a.length;o++){var l=a[o];i.push(l)}for(var c=0;c<i.length;c++)r.children[i[c]]==null&&(r.children[i[c]]=new $j(i[c]),r.children[i[c]].parent=r),r=r.children[i[c]],c===i.length-1&&(r.end=!0,r.score=n,r.index=s)},e.prototype.find=function(t){for(var n=this.root,s=0;s<t.length&&n!=null;)n=n.children[t[s]],s++;return n},e}();function I7e(e){return/\s/.test(e)}function N7e(e){return e.charCodeAt(0)===0||e.charCodeAt(0)===65533}var k7e="[~`!@#$%^&*(){}[];:\"'<,.>?/\\|-_+=";function D7e(e){return k7e.indexOf(e)!==-1}var M7e=function(){function e(){}return e.prototype.load=function(){return yf(this,void 0,void 0,function(){var t,n,s;return vf(this,function(r){switch(r.label){case 0:return t=this,[4,this.loadVocab()];case 1:for(t.vocab=r.sent(),this.trie=new A7e,n=999;n<this.vocab.length;n++)s=this.vocab[n],this.trie.insert(s,1,n);return[2]}})})},e.prototype.loadVocab=function(){return yf(this,void 0,void 0,function(){return vf(this,function(t){return[2,Z4e(E7e).then(function(n){return n.json()})]})})},e.prototype.processInput=function(t){for(var n=this,s=[],r=this.cleanText(t,s),i=r.split(" "),o=0,a=i.map(function(h){h=h.toLowerCase();var u=n.runSplitOnPunc(h,o,s);return o+=h.length+1,u}),l=[],c=0;c<a.length;c++)l=l.concat(a[c]);return l},e.prototype.cleanText=function(t,n){for(var s=[],r=0,i=0,o=0,a=t;o<a.length;o++){var l=a[o];if(N7e(l)){r+=l.length;continue}if(I7e(l))if(s.length>0&&s[s.length-1]!==" ")s.push(" "),n[i]=r,r+=l.length;else{r+=l.length;continue}else s.push(l),n[i]=r,r+=l.length;i++}return s.join("")},e.prototype.runSplitOnPunc=function(t,n,s){for(var r=[],i=!0,o=0,a=t;o<a.length;o++){var l=a[o];D7e(l)?(r.push({text:l,index:s[n]}),n+=l.length,i=!0):(i&&(r.push({text:"",index:s[n]}),i=!1),r[r.length-1].text+=l,n+=l.length)}return r},e.prototype.tokenize=function(t){var n=[],s=this.processInput(t);s.forEach(function(y){y.text!==S7e&&y.text!==_7e&&(y.text=""+x7e+y.text.normalize(C7e))});for(var r=0;r<s.length;r++){for(var i=[],o=0,a=s[r].text;o<a.length;o++){var l=a[o];i.push(l)}for(var c=!1,h=0,u=[],d=i.length;h<d;){for(var p=d,f=void 0;h<p;){var g=i.slice(h,p).join(""),m=this.trie.find(g);if(m!=null&&m.end!=null){f=m.getWord()[2];break}p=p-1}if(f==null){c=!0;break}u.push(f),h=p}c?n.push(b7e):n=n.concat(u)}return n},e}();function P7e(){return yf(this,void 0,void 0,function(){var e;return vf(this,function(t){switch(t.label){case 0:return e=new M7e,[4,e.load()];case 1:return t.sent(),[2,e]}})})}var O7e="https://tfhub.dev/tensorflow/tfjs-model/mobilebert/1",xf=384,R7e=32,L7e=64,Bj=384,ik=5,Lw=1,F7e=4.3980759382247925,$7e=function(){function e(t){this.modelConfig=t,this.modelConfig==null&&(this.modelConfig={modelUrl:O7e,fromTFHub:!0}),this.modelConfig.fromTFHub==null&&(this.modelConfig.fromTFHub=!1)}return e.prototype.process=function(t,n,s,r,i){i===void 0&&(i=128),t=t.replace(/\?/g,""),t=t.trim(),t=t+"?";var o=this.tokenizer.tokenize(t);if(o.length>s)throw new Error("The length of question token exceeds the limit ("+s+").");for(var a=this.tokenizer.processInput(n.trim()),l=[],c=[],h=0;h<a.length;h++)for(var u=a[h].text,d=this.tokenizer.tokenize(u),p=0;p<d.length;p++){var f=d[p];l.push(h),c.push(f)}for(var g=r-o.length-3,m=[],y=0;y<c.length;){var v=c.length-y;if(v>g&&(v=g),m.push({start:y,length:v}),y+v===c.length)break;y+=Math.min(v,i)}var b=m.map(function(x){var w=[],S=[],C={};w.push(w7e),S.push(0);for(var _=0;_<o.length;_++){var T=o[_];w.push(T),S.push(0)}w.push(Fj),S.push(0);for(var _=0;_<x.length;_++){var E=_+x.start,A=c[E];w.push(A),S.push(1),C[w.length]=l[E]}w.push(Fj),S.push(1);for(var D=w,O=D.map(function(P){return 1});D.length<r;)D.push(0),O.push(0),S.push(0);return{inputIds:D,inputMask:O,segmentIds:S,origTokens:a,tokenToOrigMap:C}});return b},e.prototype.load=function(){return yf(this,void 0,void 0,function(){var t,n,s,r,i,o;return vf(this,function(a){switch(a.label){case 0:return t=this,[4,y7e(this.modelConfig.modelUrl,{fromTFHub:this.modelConfig.fromTFHub})];case 1:return t.model=a.sent(),n=1,s=il([n,xf],"int32"),r=il([1,xf],"int32"),i=il([1,xf],"int32"),this.model.execute({input_ids:s,segment_ids:r,input_mask:i,global_step:mn(1,"int32")}),o=this,[4,P7e()];case 2:return o.tokenizer=a.sent(),[2]}})})},e.prototype.findAnswers=function(t,n){return yf(this,void 0,void 0,function(){var s,r,i,o,a,l,c,h,u,d,p=this;return vf(this,function(f){switch(f.label){case 0:if(t==null||n==null)throw new Error("The input to findAnswers call is null, please pass a string as input.");return s=this.process(t,n,L7e,Bj),r=s.map(function(g){return g.inputIds}),i=s.map(function(g){return g.segmentIds}),o=s.map(function(g){return g.inputMask}),a=mn(1,"int32"),l=s.length,c=So(function(){var g=lu(r,[l,xf],"int32"),m=lu(i,[l,xf],"int32"),y=lu(o,[l,xf],"int32");return p.model.execute({input_ids:g,segment_ids:m,input_mask:y,global_step:a},["start_logits","end_logits"])}),[4,Promise.all([c[0].array(),c[1].array()])];case 1:for(h=f.sent(),a.dispose(),c[0].dispose(),c[1].dispose(),u=[],d=0;d<l;d++)u.push(this.getBestAnswers(h[0][d],h[1][d],s[d].origTokens,s[d].tokenToOrigMap,n,d));return[2,u.reduce(function(g,m){return g.concat(m)},[]).sort(function(g,m){return m.score-g.score}).slice(0,ik)]}})})},e.prototype.getBestAnswers=function(t,n,s,r,i,o){var a,l=this.getBestIndex(t),c=this.getBestIndex(n),h=[];l.forEach(function(m){c.forEach(function(y){if(r[m+Lw]&&r[y+Lw]&&y>=m){var v=y-m+1;v<R7e&&h.push({start:m,end:y,score:t[m]+n[y]})}})}),h.sort(function(m,y){return y.score-m.score});for(var u=[],d=0;d<h.length&&!(d>=ik||h[d].score<F7e);d++){var p="",f=0,g=0;h[d].start>0?(a=this.convertBack(s,r,h[d].start,h[d].end,i),p=a[0],f=a[1],g=a[2]):p="",u.push({text:p,score:h[d].score,startIndex:f,endIndex:g})}return u},e.prototype.getBestIndex=function(t){for(var n=[],s=0;s<Bj;s++)n.push([s,s,t[s]]);n.sort(function(i,o){return o[2]-i[2]});for(var r=[],s=0;s<ik;s++)r.push(n[s][0]);return r},e.prototype.convertBack=function(t,n,s,r,i){var o=s+Lw,a=r+Lw,l=n[o],c=n[a],h=t[l].index,u=c<t.length-1?t[c+1].index-1:t[c].index+t[c].text.length;return[i.slice(h,u+1).trim(),h,u]},e}();function B7e(e){return yf(this,void 0,void 0,function(){var t;return vf(this,function(n){switch(n.label){case 0:return t=new $7e(e),[4,t.load()];case 1:return n.sent(),[2,t]}})})}function z7e(){const{bgcolor:e}=he.exports.useContext(Ve),{Pcolor:t}=he.exports.useContext(Ve),{SecondaryColor:n}=he.exports.useContext(Ve),[s,r]=he.exports.useState(),[i,o]=he.exports.useState(),[a,l]=he.exports.useState(),[c,h]=he.exports.useState(""),[u,d]=he.exports.useState(),[p,f]=he.exports.useState(!1),[g,m]=he.exports.useState(!1),[y,v]=he.exports.useState("red");he.exports.useEffect(async()=>{const x=await B7e();r(x),console.log("model loaded"),v("#74ee15")},[]);async function b(){f(!0);const x=await s.findAnswers(a,i);console.log("Answers: ",x),x.length?(h(x[0].text),d(null)):(d("No result found."),h(null)),f(!1)}return ne("div",{style:{background:e,color:t,Width:"80vw",maxWidth:"700px",margin:"auto"},children:[ne("h2",{className:"Cardhead",style:{marginTop:"10vh",background:e,color:t,marginBottom:"0px"},children:["Q_&_A Bot AI",k("p",{className:"botFace",style:{display:"inline-flex",color:y},children:k("i",{className:"fa fa-robot"})})]}),ne("h2",{style:{background:"none",textAlign:"center",fontSize:"large",margin:"0 0 10px 0"},children:["ex: Unseen Passage Solver",k("br",{}),"Submit Passage \u2022 Type question \u2022 Get answer"]}),!g&&ne(vn,{children:[k("h2",{style:{background:"none"},children:"\u2022 Submit Your Passage"}),ne("div",{className:"input-group",children:[k("input",{type:"text",className:"input",placeholder:"Type Your Question...",autoComplete:"off",value:i,onChange:x=>o(x.target.value),onKeyDown:x=>{x.key==="Enter"&&m(!0)},style:{color:t}}),k("button",{className:"button--submit",onClick:()=>{m(!0)},children:"Submit"})]})]}),g&&ne(vn,{children:["\u2022 Your passage:"," ",k(mk,{className:"flex-shrink-0 h-5 w-5 text-gray-400","aria-hidden":"true",style:{display:"inline-block",background:"none",color:"var(--dblue)",margin:"5px",cursor:"pointer"},onClick:()=>m(!1)}),k("h3",{style:{maxHeight:"300px",overflow:"scroll",margin:"5px 0",padding:"5px",textAlign:"justify",background:n},children:i})]}),k("h1",{style:{background:"none",margin:"10px 0 0 0"},children:"\u2022 Type your question"}),ne("div",{className:"input-group",children:[k("input",{type:"text",className:"input",placeholder:"Type Your Question...",autoComplete:"off",value:a,onChange:x=>l(x.target.value),onKeyDown:x=>{x.key==="Enter"&&b()},style:{color:t}}),k("button",{className:"button--submit",onClick:b,children:"Search"})]}),k("p",{style:{background:"none",color:t,textAlign:"center"},children:u}),p&&k("div",{style:{margin:"auto",maxWidth:"500px"},className:"Ytloader"}),ne("h2",{style:{background:"none"},children:["Answer: "," "+c]}),k("br",{})]})}var U7e="/assets/logo.a229951f.png";function V7e(){const[e,t]=he.exports.useState(U7e),[n,s]=he.exports.useState("");he.exports.useState("");const[r,i]=he.exports.useState(Qr),[o,a]=he.exports.useState(!1),[l,c]=he.exports.useState(!1),[h,u]=he.exports.useState("red"),{bgcolor:d}=he.exports.useContext(Ve),{Pcolor:p}=he.exports.useContext(Ve),{SecondaryColor:f}=he.exports.useContext(Ve);async function g(){a(!0);const v=await fetch("https://vinayakporwal-remove-bg.hf.space/run/predict",{method:"POST",headers:{"Content-Type":"application/json",mode:"no-cors","Access-Control-Allow-Origin":"*","Access-Control-Allow-Credentials":!0},body:JSON.stringify({data:[n]})}),b=await v.json();console.log(v,b.data),i(b.data[0]),a(!1),c(!0)}function m(v){if(v.target.files.length>0){var b=URL.createObjectURL(v.target.files[0]);console.log(b),t(b),y(b).then(x=>{s(x)}),u("green")}}const y=v=>fetch(v).then(b=>b.blob()).then(b=>new Promise((x,w)=>{const S=new FileReader;S.onloadend=()=>x(S.result),S.onerror=w,S.readAsDataURL(b)}));return ne("div",{style:{background:"none",marginTop:"10vh"},children:[ne("h2",{className:"Cardhead",style:{background:d,color:p,marginBottom:"0px"},children:["BG Remover",k("p",{className:"botFace",style:{display:"inline-flex",color:h},children:k("i",{className:"fa fa-robot"})})]}),k("h2",{style:{background:"none",textAlign:"center",fontSize:"large",margin:"0 0 10px 0",color:p},children:"Remove Background of images in just one Click!"}),ne("div",{className:"CodeCard",style:{backgroundColor:f},children:[ne("div",{className:"tools",style:{backgroundColor:p},children:[k("div",{className:"circle",children:k("span",{className:`${h} box`})}),k("input",{type:"file",id:"file",accept:"image/*",onChange:v=>{m(v)},style:{background:"none",color:d}}),ne("div",{style:{background:"none",marginLeft:"auto",padding:"0 10px",color:d},children:["Free"," "]})]}),ne("div",{className:"card__content",children:[ne("div",{className:"Status  Cardhead",style:{color:p},children:[o&&k(vn,{children:" Generating..."}),l&&k(vn,{children:" Loading..."})]}),ne("div",{style:{display:"flex",background:"none",flexWrap:"wrap",width:"80vw",maxWidth:"700px"},children:[ne("div",{className:"Colorcard",style:{maxHeight:"none"},children:[k("div",{className:"Colorcard__content",children:k("img",{src:e,alt:"",className:"link",style:{display:"block"}})}),k("div",{className:"blob"}),k("div",{className:"blob"}),k("div",{className:"blob"}),k("div",{className:"blob"})]}),ne("div",{className:"Colorcard",style:{maxHeight:"none"},children:[ne("div",{className:"Colorcard__content",children:[" ",k("img",{src:r,alt:"",className:"link",onLoad:()=>c(!1),style:{display:l?"none":"block"}}),o&&k("div",{className:"spinner",children:k("div",{className:"spinnerin"})}),l&&k("div",{className:"Imgloader",children:k("div",{className:"Imgwrapper",children:k("div",{className:"line-1"})})})]}),k("div",{className:"blob"}),k("div",{className:"blob"}),k("div",{className:"blob"}),k("div",{className:"blob"})]})]}),k("button",{className:"button--submit",onClick:g,style:{minHeight:"40px",margin:"20px auto -10px auto",display:"flex",justifyContent:"center",borderRadius:"6px"},children:"Remove"})]})]})]})}function G7e(){const[e,t]=he.exports.useState(),[n,s]=he.exports.useState(Qr),[r,i]=he.exports.useState(!1),[o,a]=he.exports.useState(!1),[l,c]=he.exports.useState(),{setToken:h}=he.exports.useContext(Ve),{bgcolor:u}=he.exports.useContext(Ve),{Pcolor:d}=he.exports.useContext(Ve),{SecondaryColor:p}=he.exports.useContext(Ve);async function f(){i(!0);const g=await fetch("https://vinayakporwal-imagecreator.hf.space/run/predict",{method:"POST",headers:{"Content-Type":"application/json",mode:"no-cors","Access-Control-Allow-Origin":"*","Access-Control-Allow-Credentials":!0},body:JSON.stringify({data:[e]})}),m=await g.json();if(console.log(g,m.data),m.data){s(m.data[0]),i(!1),a(!0);const y=Date.now();h(y)}else c(m.error),i(!1)}return ne(vn,{children:[k("h2",{className:"Cardhead",style:{background:u,color:d,marginBottom:"0px"},children:"Generate Your IMAGINATION"}),k("h2",{style:{background:"none",textAlign:"center",fontSize:"large",margin:"0 0 10px 0",color:d},children:"Create image by giving Prompt"}),ne("div",{className:"input-group",children:[k("input",{type:"text",className:"input",id:"Email",placeholder:"Start Imagining...",autoComplete:"off",value:e,onChange:g=>t(g.target.value),onKeyDown:g=>{g.key==="Enter"&&f()},style:{color:d}}),k("button",{className:"button--submit",onClick:f,children:"Generate"})]}),k("p",{style:{background:"none",color:d,textAlign:"center"},children:l}),ne("div",{className:"CodeCard",style:{backgroundColor:p},children:[ne("div",{className:"tools",style:{backgroundColor:d},children:[k("div",{className:"circle",children:k("span",{className:"red box"})}),k("div",{className:"circle",children:k("span",{className:"yellow box"})}),k("div",{className:"circle",children:k("span",{className:"green box"})}),ne("div",{style:{background:"none",marginLeft:"auto",padding:" 0 10px",color:u},children:["Free"," "]})]}),ne("div",{className:"card__content",children:[ne("div",{className:"Status  Cardhead",style:{color:d},children:[r&&k(vn,{children:" Generating..."}),o&&k(vn,{children:" Loading..."})]}),k("div",{style:{display:"flex",background:"none",flexWrap:"wrap",width:"80vw",maxWidth:"700px"},children:ne("div",{className:"Colorcard",children:[ne("div",{className:"Colorcard__content",children:[k("img",{src:n,alt:"",className:"link",onLoad:()=>a(!1),style:{display:o?"none":"block"}}),r&&k("div",{className:"spinner",children:k("div",{className:"spinnerin"})}),o&&k("div",{className:"Imgloader",children:k("div",{className:"Imgwrapper",children:k("div",{className:"line-1",children:k("img",{src:Qr,alt:""})})})})]}),k("div",{className:"blob"}),k("div",{className:"blob"}),k("div",{className:"blob"}),k("div",{className:"blob"})]})})]})]})]})}function W7e(){he.exports.useContext(Ve);const{user:e}=he.exports.useContext(Ve),[t,n]=he.exports.useState("1");al(),he.exports.useEffect(()=>{var a=e;a==="true"&&console.log("Project")},[]);const{bgcolor:s}=he.exports.useContext(Ve),{Pcolor:r}=he.exports.useContext(Ve),{SecondaryColor:i}=he.exports.useContext(Ve);return ne(vn,{children:[k("div",{className:"header",children:k("div",{className:"progress-container ",id:"mytrack",children:k("div",{className:"progress-bar",id:"myBar"})})}),ne("div",{style:{display:"flex",background:s},children:[ne("div",{className:"ProjectSidebar",id:"project-side-bar",style:{background:i},children:[ne("div",{className:"SideBarLogo",style:{background:s},children:[k("img",{src:Qr,alt:""}),k("h2",{className:"Cardhead SideBarLogoName",style:{color:"var(--dblue)"},children:"Craft-X"})]}),[{name:"Games",data:[{name:"Maze-X",link:"Mazex",tab:"4"}]},{name:"Ai/ml",data:[{name:"Unseen Passage Solver Ai",link:"QnA",tab:"1"},{name:"ChatGPT",link:"ChatGptAi",tab:"1"},{name:"Background Remover",link:"RemoveBg",tab:"1"},{name:"Image Generator Free",link:"CreateImage",tab:"1"},{name:"Image Generator OpenAi",link:"DalleAi",tab:"1"},{name:"Image Classifier",link:"ImageClassify",tab:"1"}]},{name:"Projects",data:[{name:"Movie reviews App",desc:"",link:"MovieReviewApp",tab:"3"},{name:"Youtube Clone",desc:"Youtube Clone",link:"YoutubeClone",tab:"3"},{name:"PortFolio",link:"Portfolio",tab:"3"},{name:"Firebase Chat Web App",link:"ChatWebApp",tab:"3"},{name:"Weather App",desc:"",tab:"3",link:"WeatherApp"},{name:"Snake Game",desc:"",link:"SnakeGame",tab:"3"},{name:"PHP Chat Web App",link:"PhpChatApp",tab:"3"},{name:"PHP Social Web App",link:"PhpSocialApp",tab:"3"},{name:"PHP E-Book Web App",link:"PhpEbook",tab:"3"}]},{name:"Api",data:[{name:"Weather API",link:"WeatherApi",tab:"2"},{name:"OpenAi API",link:"OpenAiApi",tab:"2"},{name:"Qoute API",link:"QouteApi",tab:"2"},{name:"Movie reviews API",link:"OmdbApi",tab:"2"},{name:"Youtube Captions Scraper",link:"",tab:"2"},{name:"Youtube Downloader API",link:"YoutubeDownloadApi",tab:"2"}]}].map((a,l)=>ne("div",{className:"ApiAndTools SideBarCategory",children:[k("h2",{className:"Cardhead SideBarCategoryName",children:a.name}),a.data.map((c,h)=>k("div",{className:"Status SideBarCategoryData",onClick:()=>{n(c.tab),document.getElementById(c.link).scrollIntoView({behavior:"smooth"}),console.log(c.tab)},children:k("a",{style:{background:"none",color:r},children:c.name})},h)),k("br",{})]}))]}),k("div",{style:{position:"fixed",background:s,left:0,top:"10vh",padding:"10px",margin:"3px 0",zIndex:"5"},id:"project-SideBarButton",onClick:()=>{document.getElementById("project-side-bar").style.display==="block"?(document.getElementById("project-side-bar").style.display="none",document.getElementById("project-SideBarButton").style.background=s):(document.getElementById("project-side-bar").style.display="block",document.getElementById("project-SideBarButton").style.background=i)},children:k(n6,{className:"flex-shrink-0 h-5 w-5 text-gray-400","aria-hidden":"true",style:{background:"none",alignItems:"center",color:r}})}),ne("div",{className:"projects",style:{background:s,width:"82vw",margin:"10vh auto 0 auto"},children:[t==="0"&&ne("div",{className:"containerMainR",style:{display:"flex",margin:"0 auto",background:s,maxWidth:"90vw"},children:[ne("div",{className:"CardData",style:{height:"80vh"},children:[" ",ne("div",{className:"Catcard",children:[ne("div",{className:"item item--1",children:[ne("svg",{height:"24",width:"24",viewBox:"0 0 24 24",xmlns:"http://www.w3.org/2000/svg",children:[k("path",{d:"M0 0h24v24H0z",fill:"none"}),k("path",{fill:"rgba(149,149,255,1)",d:"M17 15.245v6.872a.5.5 0 0 1-.757.429L12 20l-4.243 2.546a.5.5 0 0 1-.757-.43v-6.87a8 8 0 1 1 10 0zm-8 1.173v3.05l3-1.8 3 1.8v-3.05A7.978 7.978 0 0 1 12 17a7.978 7.978 0 0 1-3-.582zM12 15a6 6 0 1 0 0-12 6 6 0 0 0 0 12z"})]}),k("span",{className:"quantity",children:" 3+ "}),k("span",{className:"text text--1",children:" Ai "})]}),ne("div",{className:"item item--2",children:[ne("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"24",height:"24",children:[k("path",{fill:"none",d:"M0 0L24 0 24 24 0 24z"}),k("path",{d:"M16 16c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3zM6 12c2.21 0 4 1.79 4 4s-1.79 4-4 4-4-1.79-4-4 1.79-4 4-4zm10 6c-.552 0-1 .448-1 1s.448 1 1 1 1-.448 1-1-.448-1-1-1zM6 14c-1.105 0-2 .895-2 2s.895 2 2 2 2-.895 2-2-.895-2-2-2zm8.5-12C17.538 2 20 4.462 20 7.5S17.538 13 14.5 13 9 10.538 9 7.5 11.462 2 14.5 2zm0 2C12.567 4 11 5.567 11 7.5s1.567 3.5 3.5 3.5S18 9.433 18 7.5 16.433 4 14.5 4z",fill:"rgba(252,161,71,1)"})]})," ",k("span",{className:"quantity",children:" 5+ "}),k("span",{className:"text text--2",children:" API "})]}),ne("div",{className:"item item--3",children:[ne("svg",{height:"24",width:"24",viewBox:"0 0 24 24",xmlns:"http://www.w3.org/2000/svg",children:[k("path",{d:"M0 0h24v24H0z",fill:"none"}),k("path",{fill:"rgba(66,193,110,1)",d:"M20.083 15.2l1.202.721a.5.5 0 0 1 0 .858l-8.77 5.262a1 1 0 0 1-1.03 0l-8.77-5.262a.5.5 0 0 1 0-.858l1.202-.721L12 20.05l8.083-4.85zm0-4.7l1.202.721a.5.5 0 0 1 0 .858L12 17.65l-9.285-5.571a.5.5 0 0 1 0-.858l1.202-.721L12 15.35l8.083-4.85zm-7.569-9.191l8.771 5.262a.5.5 0 0 1 0 .858L12 13 2.715 7.429a.5.5 0 0 1 0-.858l8.77-5.262a1 1 0 0 1 1.03 0zM12 3.332L5.887 7 12 10.668 18.113 7 12 3.332z"})]}),k("span",{className:"quantity",children:" 7+ "}),k("span",{className:"text text--3",children:" React Apps "})]}),ne("div",{className:"item item--4",children:[ne("svg",{height:"24",width:"24",viewBox:"0 0 24 24",xmlns:"http://www.w3.org/2000/svg",children:[k("path",{d:"M0 0h24v24H0z",fill:"none"}),k("path",{fill:"rgba(220,91,183,1)",d:"M12 20h8v2h-8C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10a9.956 9.956 0 0 1-2 6h-2.708A8 8 0 1 0 12 20zm0-10a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm-4 4a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm8 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm-4 4a2 2 0 1 1 0-4 2 2 0 0 1 0 4z"})]}),k("span",{className:"quantity",children:" 2+ "}),k("span",{className:"text text--4",children:" Servers "})]})]})]}),ne("div",{className:"Cardillustration",style:{backgroundColor:s,color:r,height:"80vh"},children:[k("h3",{className:"Cardhead",style:{background:s,color:r},children:"OUR PROJECTS"}),k("div",{className:"CardillustrationImg",style:{margin:"10px auto"},children:k("span",{className:"projectsAnimation"})})]})]}),t==="4"&&k(vn,{children:ne("div",{style:{background:"none"},id:"mazex",children:[k("br",{}),k("div",{style:{background:"none",height:"100vh"},children:k(ufe,{scene:"https://prod.spline.design/c45M7gPnoq7KQlTG/scene.splinecode",style:{background:"none"}})})]})}),t==="1"&&ne(vn,{children:[ne("div",{style:{background:"none"},id:"QnA",children:[k("br",{}),k(z7e,{})]}),ne("div",{style:{background:"none"},id:"ChatGptAi",children:[k("br",{}),k(o6,{})]}),ne("div",{style:{background:"none"},id:"RemoveBg",children:[k("br",{}),k(V7e,{})]}),ne("div",{style:{background:"none"},id:"CreateImage",children:[k("br",{}),k("br",{}),k("br",{}),k(G7e,{})]}),ne("div",{style:{background:"none"},id:"DalleAi",children:[k("br",{}),k("br",{}),k("br",{}),k(a6,{})]}),ne("div",{style:{background:"none"},id:"ImageClassify",children:[k("br",{}),k("br",{}),k(S$,{})]})]}),k("br",{}),k("br",{}),k("br",{}),k("br",{}),t==="2"&&ne(vn,{children:[ne("div",{style:{background:"none"},id:"QouteApi",children:[k("br",{}),k("br",{}),k("br",{}),k(l6,{})]}),k("br",{}),ne("div",{style:{background:"none"},id:"WeatherApi",children:[k("br",{}),k(dk,{})]}),k("br",{}),ne("div",{style:{background:"none"},id:"YoutubeDownloadApi",children:[k("br",{}),k(c6,{})]}),k("br",{})]}),t==="3"&&k(vn,{children:k(bfe,{})})]})]})]})}function H7e(e){const[t,n]=he.exports.useState({email:"",password:""});let s=al();he.exports.useEffect(()=>{sessionStorage.getItem("Loggedin")=="true"&&s("/"),document.getElementById("formstart").scrollIntoView({behavior:"smooth"})},[]);const r=document.getElementById("loading"),i=async h=>{h.preventDefault(),r.style.display="block";const d=await(await fetch("https://server-ten-iota.vercel.app/auth/login",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({email:t.email,password:t.password})})).json();setTimeout(()=>{r.style.display="none",d.message==="Acceess Granted"?(sessionStorage.setItem("token",d.authtoken),console.log(d),e.setUser(!0),sessionStorage.setItem("Loggedin",!0),sessionStorage.setItem("id",d.user_data.user.id),s("/")):alert("Invalid credentials")},500)},o=h=>{n(De(ue({},t),{[h.target.name]:h.target.value}))},{bgcolor:a}=he.exports.useContext(Ve),{Pcolor:l}=he.exports.useContext(Ve),{SecondaryColor:c}=he.exports.useContext(Ve);return ne("div",{children:[k("div",{className:"header",style:{display:"none"},children:k("div",{className:"progress-container",id:"mytrack",children:k("div",{className:"progress-bar",id:"myBar"})})}),ne("div",{id:"loading",children:[k("div",{className:"loaderback",style:{background:l}}),k("span",{className:"loader",style:{color:a},children:"Verifying"})]}),ne("form",{onSubmit:i,style:{background:a,color:l},children:[k("div",{className:"Cardillustration",style:{backgroundColor:a},children:k("img",{src:Z0,alt:"Avatar",className:"avatar",style:{backgroundColor:a}})}),ne("div",{className:"CardData",style:{background:c},id:"formstart",children:[ne("div",{className:"container",style:{padding:"10vw 10vw 0 10vw"},children:[k("label",{children:k("b",{children:"Email"})}),k("input",{type:"email",className:"form-control",value:t.email,onChange:o,id:"email",name:"email","aria-describedby":"emailHelp"}),k("label",{children:k("b",{children:"Password"})}),k("input",{type:"password",className:"form-control",value:t.password,onChange:o,name:"password",id:"password"}),k("button",{id:"logbutton",type:"submit",children:"Login"}),ne("label",{children:[k("input",{type:"checkbox",name:"remember"})," Remember me"]}),k("span",{className:"psw",children:k("a",{href:"#",children:" Forgot password?"})})]}),k("div",{className:"container",style:{maxWidth:"300px",margin:"20px auto"},children:k("button",{type:"button",className:"cancelbtn",onClick:()=>s("/signup"),children:"Go to Signup"})})]})]})]})}function j7e(){he.exports.useContext(Ve);const{Pcolor:e}=he.exports.useContext(Ve),{SecondaryColor:t}=he.exports.useContext(Ve);return ne("div",{className:"footer",style:{background:t},children:[ne("div",{style:{background:"none"},children:[k("img",{src:Qr,alt:"GrindOwl",className:"logofooter"}),k("h1",{style:{background:"none",color:e},children:"Craft-X"})]}),k("div",{style:{background:"none",display:"flex",flexWrap:"wrap"},children:ne("div",{className:"footerMid",style:{color:e},children:["Copyright @",k("span",{className:"companyfooterMid",style:{background:"none",color:e},children:"Craft-X"})]})}),ne("div",{style:{background:"none",display:"flex",flexWrap:"wrap"},children:[ne("div",{className:"footerEnd",style:{color:e},children:[k(fk,{className:"flex-shrink-0 h-5 w-5 text-gray-400","aria-hidden":"true",style:{background:"none"}})," ","Made By -"]}),k("span",{className:"companyfooterEnd",style:{background:"none",color:e},children:"Vinayak Porwal"})]})]})}function q7e(e){const[t,n]=he.exports.useState(!0),[s,r]=he.exports.useState(e.bio),[i,o]=he.exports.useState(s);async function a(){try{const d=await(await fetch("https://server-ten-iota.vercel.app/auth/update",{method:"POST",headers:{"auth-token":sessionStorage.getItem("token"),"Content-Type":"application/json"},body:JSON.stringify({bio:i})})).json();console.log(d)}catch(u){console.log(u)}}he.exports.useEffect(()=>{o(e.bio)},[e.id]),he.exports.useContext(Ve);const{Pcolor:l}=he.exports.useContext(Ve),{SecondaryColor:c}=he.exports.useContext(Ve),{userData:h}=he.exports.useContext(Ve);return k(vn,{children:ne("div",{className:"bg-none shadow overflow-hidden sm:rounded-lg",style:{background:c},children:[ne("div",{className:"px-4 py-5 sm:px-6 bg-none",style:{background:"none"},children:[ne("div",{style:{background:"none",display:"flex"},children:[ne("h3",{className:"text-lg leading-6 font-medium text-gray-900",style:{background:"none",color:l},children:[e.admin?"Admin":"User"," Information"]}),e.admin&&ne("p",{className:"SideUsers-role",style:{width:"fit-content",margin:"0 10px"},children:[" ","Mod"," "]})]}),e.id===h._id&&k(vn,{children:t?k(mk,{className:"flex-shrink-0 h-5 w-5 text-gray-400","aria-hidden":"true",style:{float:"right",background:"none",color:"var(--dblue)",margin:"5px",cursor:"pointer"},onClick:()=>{o(document.getElementById("bio").innerText),document.getElementById("bio").style.border="1px solid "+l,n(!1)}}):ne(vn,{children:[k(t6,{className:"flex-shrink-0 h-5 w-5 text-gray-400","aria-hidden":"true",style:{float:"right",background:"none",color:"var(--dblue)",margin:"5px",cursor:"pointer"},onClick:()=>{document.getElementById("bio").innerText=i,n(!0),a()}}),k(i6,{className:"flex-shrink-0 h-5 w-5 text-gray-400","aria-hidden":"true",style:{float:"right",background:"none",color:"var(--dblue)",margin:"5px",cursor:"pointer"},onClick:()=>{document.getElementById("bio").innerText=i,n(!0)}})]})}),k("p",{className:"mt-1 max-w-2xl text-sm text-gray-500",style:{background:"none"},children:"Personal details"})]}),k("div",{className:"border-t border-gray-200 bg-none",style:{background:"none"},children:ne("dl",{style:{background:"none"},children:[ne("div",{className:"bg-gray-50 px-4 py-5 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-6",style:{background:"none"},children:[k("dt",{className:"text-sm font-medium text-gray-500",style:{background:"none"},children:"Full name"}),k("dd",{className:"mt-1 text-sm text-gray-900 sm:mt-0 sm:col-span-2",style:{background:"none",color:l},children:e.name})]}),ne("div",{className:"bg-gray-50 px-4 py-5 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-6",style:{background:"none"},children:[k("dt",{className:"text-sm font-medium text-gray-500",style:{background:"none"},children:"Email address"}),k("dd",{className:"mt-1 text-sm text-gray-900 sm:mt-0 sm:col-span-2",style:{background:"none",color:l},children:e.email})]}),ne("div",{className:"bg-gray-50 px-4 py-5 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-6",style:{background:"none"},children:[k("dt",{className:"text-sm font-medium text-gray-500",style:{background:"none"},children:"About"}),t?k("dd",{className:"mt-1 text-sm text-gray-900 sm:mt-0 sm:col-span-2",style:{background:"none",color:l},id:"bio",children:i}):k("textarea",{className:"mt-1 text-sm text-gray-900 sm:mt-0 sm:col-span-2",style:{background:"none",color:l,borderRadius:"5px",padding:"2px"},autoFocus:!0,suppressContentEditableWarning:!0,id:"bio",value:i,onChange:u=>o(u.target.value)})]}),(h.Admin===!0||e.id===h._id)&&ne(vn,{children:[ne("div",{className:"bg-gray-50 px-4 py-5 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-6",style:{background:"none"},children:[k("dt",{className:"text-sm font-medium text-gray-500",style:{background:"none"},children:"Wallet"}),k("dd",{className:"mt-1 text-sm text-gray-900 sm:mt-0 sm:col-span-2",style:{background:"none",color:l},children:h.Wallet})]}),ne("div",{className:"bg-white px-4 py-5 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-6",style:{background:"none"},children:[k("dt",{className:"text-sm font-medium text-gray-500",style:{background:"none"},children:"Api Key"}),k("dd",{className:"mt-1 text-sm text-gray-900 sm:mt-0 sm:col-span-2",style:{background:"none"},children:k("ul",{role:"list",className:"border border-gray-200 rounded-md divide-y divide-gray-200",style:{background:"none"},children:ne("li",{className:"pl-3 pr-4 py-3 flex items-center justify-between text-sm",style:{background:"none"},children:[ne("div",{className:"w-0 flex-1 flex items-center",style:{background:"none"},children:[k(fk,{className:"flex-shrink-0 h-5 w-5 text-gray-400","aria-hidden":"true",style:{background:"none"}}),ne("span",{className:"ml-2 flex-1 w-0 truncate",style:{background:"none",color:l},children:["Craft-X-",e.id]})]}),k("div",{className:"ml-4 flex-shrink-0",style:{background:"none"},children:k("a",{href:"#",className:"font-medium text-indigo-600 hover:text-indigo-500",style:{background:"none"},children:"Copy"})})]})})})]})]})]})})]})})}function X7e(){he.exports.useContext(Ve);const{user:e}=he.exports.useContext(Ve);he.exports.useContext(Ve);const{bgcolor:t}=he.exports.useContext(Ve),{Pcolor:n}=he.exports.useContext(Ve),{SecondaryColor:s}=he.exports.useContext(Ve);let r=al();const i=new URLSearchParams(window.location.search),[o,a]=he.exports.useState(i.get("id"));sessionStorage.getItem("id");const[l,c]=he.exports.useState(),[h,u]=he.exports.useState(!1),[d,p]=he.exports.useState({name:"----------------",email:"---------------",Bio:"Hey! We at Grindowl are building a series of APIs that will make it much easier to build and operate Decentralized applications.We are the community in search for a better web.The world is pretty big, but it can be a whole lot smaller when you stop looking at screens.",date:"Today",_id:"ll",Admin:""});async function f(){const y=await(await fetch("https://server-ten-iota.vercel.app/auth/getusers",{method:"POST",headers:{mode:"no-cors","Access-Control-Allow-Origin":"*","Access-Control-Allow-Credentials":!0,"Content-Type":"application/json"},body:`{"id": "${o}" }`})).json();console.log(y),p(y)}async function g(){let y=await(await fetch("https://server-ten-iota.vercel.app/auth/users",{headers:{"Content-Type":"application/json"}})).json();c(y.user),u(!0)}return he.exports.useEffect(()=>{f(),g();var m=e;return m=="true"?console.log("Profile"):r("/login"),console.log(location.search),()=>{}},[o]),ne(vn,{children:[k("div",{className:"header",children:k("div",{className:"progress-container",id:"mytrack",children:k("div",{className:"progress-bar",id:"myBar"})})}),ne("div",{style:{display:"flex"},children:[ne("div",{className:"ProfileSideBar",style:{background:s},id:"profile-side-bar",children:[ne("div",{className:"SideBarLogo",style:{background:t},children:[k("img",{src:Qr,alt:""}),k("h2",{className:"Cardhead SideBarLogoName",style:{color:"var(--dblue)"},children:"Craft-X"})]}),h&&l.map((m,y)=>k("div",{class:"SideUsers-card",onClick:()=>{r("/profile?id="+m._id),a(m._id)},children:ne("div",{class:"SideUsers-card-top-part",children:[k("div",{class:"SideUsers-right-part",children:k("div",{style:{height:"55px",width:"55px",background:"var(--dblue)",borderRadius:"50%",position:"relative",padding:"5px",margin:"10px"},children:k("img",{src:`https://robohash.org/${m.name}?set=set3`,alt:"",style:{background:"none"}})})}),ne("div",{class:"SideUsers-left-part",children:[ne("div",{class:"SideUsers-user-name",children:[k("p",{class:"SideUsers-name",style:{color:n},children:m.name}),m.Admin&&k("p",{class:"SideUsers-role",children:" Mod "})]}),k("div",{class:"SideUsers-user-position",children:k("p",{class:"SideUsers-position",children:m.email})})]})]})},y))]}),ne("div",{className:"ProfilePage",style:{minHeight:"100vh",background:t,width:"-webkit-fill-available"},children:[k("div",{style:{position:"fixed",background:t,left:0,top:"10vh",padding:"10px",margin:"3px 0",zIndex:"5"},id:"profile-SideBarButton",onClick:()=>{document.getElementById("profile-side-bar").style.display==="block"?(document.getElementById("profile-side-bar").style.display="none",document.getElementById("profile-SideBarButton").style.background=t):(document.getElementById("profile-side-bar").style.display="block",document.getElementById("profile-SideBarButton").style.background=s)},children:k(r6,{className:"flex-shrink-0 h-5 w-5 text-gray-400","aria-hidden":"true",style:{background:"none",alignItems:"center",color:n}})}),k("div",{style:{background:"var(--dblue)",height:"40vh"}}),ne("div",{style:{width:"80vw",margin:"auto",maxWidth:"800px",background:"none"},children:[k("div",{style:{display:"flex",postion:"relative",background:"none",margin:"8px 0 20px 0"},children:ne("div",{style:{display:"flex",postion:"relative",flexWrap:"wrap",background:"none"},children:[k("div",{style:{height:"120px",width:"120px",background:t,borderRadius:"50%",position:"relative",padding:"10px",margin:"-60px 50px 0 50px"},children:k("img",{src:`https://robohash.org/${d.name}?set=set3`,alt:"",style:{background:"none"}})})," ",k("div",{style:{textAlign:"center",fontWeight:"bold",fontSize:"x-large",background:"none",margin:"10px 50px",color:n},children:d.name})]})}),k(q7e,{email:d.email,name:d.name,bio:d.Bio,id:d._id,admin:d.Admin}),k("br",{})]})]})]})]})}function K7e(e){const[t,n]=he.exports.useState({name:"",email:"",password:""});let s=al();he.exports.useEffect(()=>{sessionStorage.getItem("Loggedin")=="true"&&s("/")},[]);const r=async c=>{c.preventDefault(),loading.style.display="block";const u=await(await fetch("https://server-ten-iota.vercel.app/auth/signup",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({name:t.name,email:t.email,password:t.password})})).json();setTimeout(()=>{loading.style.display="none",u.message==="Used Created"?(console.log(u),e.setUser("true"),sessionStorage.setItem("Loggedin",!0),s("/")):(alert("Error :",u.message),console.log(u))},500)},{bgcolor:i}=he.exports.useContext(Ve),{Pcolor:o}=he.exports.useContext(Ve),{SecondaryColor:a}=he.exports.useContext(Ve),l=c=>{n(De(ue({},t),{[c.target.name]:c.target.value}))};return ne("div",{children:[k("div",{className:"header",style:{display:"none"},children:k("div",{className:"progress-container",id:"mytrack",children:k("div",{className:"progress-bar",id:"myBar"})})}),ne("div",{id:"loading",children:[k("div",{className:"loaderback",style:{background:o}}),k("span",{className:"loader",style:{color:i},children:"Generating Id"})]}),ne("form",{onSubmit:r,style:{background:i,color:o},children:[k("div",{className:"Cardillustration",style:{backgroundColor:i},children:k("img",{src:Z0,alt:"Avatar",className:"avatar",style:{backgroundColor:i}})}),ne("div",{className:"CardData",style:{background:a},children:[ne("div",{className:"container",style:{padding:"10vw 10vw 0 10vw"},children:[k("label",{children:k("b",{children:"Name"})}),k("input",{type:"text",className:"form-control",value:t.name,onChange:l,id:"name",name:"name","aria-describedby":"nameHelp"}),k("label",{children:k("b",{children:"Email"})}),k("input",{type:"email",className:"form-control",value:t.email,onChange:l,id:"email",name:"email","aria-describedby":"emailHelp"}),k("label",{children:k("b",{children:"Password"})}),k("input",{type:"password",className:"form-control",value:t.password,onChange:l,name:"password",id:"password"}),k("button",{id:"logbutton",type:"submit",children:"Submit"}),ne("label",{children:[k("input",{type:"checkbox",name:"remember"})," Remember me"]}),k("span",{className:"psw",children:k("a",{href:"#",children:" Forgot password?"})})]}),k("div",{className:"container",style:{maxWidth:"300px",margin:"auto"},children:k("button",{type:"button",className:"cancelbtn",onClick:()=>s("/login"),children:"Go to Login"})})]})]})]})}var Y7e="/assets/team3.c5dd6bb2.svg";function Q7e(){he.exports.useContext(Ve),al(),he.exports.useEffect(()=>{r(),console.log("Team")},[]);const[e,t]=he.exports.useState(),[n,s]=he.exports.useState(!1);async function r(){skeleton.style.display="block";let c=await(await fetch("https://server-ten-iota.vercel.app/auth/users",{headers:{"Content-Type":"application/json"}})).json();t(c.user),s(!0),skeleton.style.display="none"}const{bgcolor:i}=he.exports.useContext(Ve),{Pcolor:o}=he.exports.useContext(Ve),{SecondaryColor:a}=he.exports.useContext(Ve);return ne(vn,{children:[k("div",{className:"header",children:k("div",{className:"progress-container",id:"mytrack",children:k("div",{className:"progress-bar",id:"myBar"})})}),k("div",{style:{margin:"10vh 0 0 0",background:i},children:k(uk,{})}),ne("div",{className:"containerMain",style:{display:"flex",background:i},children:[ne("div",{className:"Cardillustration",style:{backgroundColor:i,color:o},children:[k("h3",{className:"Cardhead",style:{background:i,color:o},children:"Interact with USERS"}),k("img",{src:Y7e,alt:"",className:"CardillustrationImg"})]}),k(hk,{}),ne("div",{className:"CardData",id:"dataofpost",style:{height:"auto",background:"none",display:"grid",gridTemplateColumns:"1fr 1fr",gridTemplateRows:"1fr 1fr",gap:"15px"},children:[k("div",{id:"skeleton",className:"ChildCard",style:{background:a,display:"none"},children:k("span",{className:"Skeleton"})}),n&&e.map((l,c)=>k("div",{className:"team",style:{background:"none"},children:k("div",{className:"pcontainer left",style:{background:"none",color:o},children:ne("div",{className:"ChildCard",style:{background:a},children:[k("div",{style:{padding:"5px 10px 0 0",background:"none"},children:k("img",{src:Qr,alt:"Jane",style:{height:"30px",marginRight:"0"}})}),k("img",{src:Z0,alt:"Jane",style:{height:"100px",borderRadius:"5px"}}),ne("div",{style:{background:"none",color:o},children:[k("h2",{style:{background:"none"},children:l.id}),k("p",{className:"title",style:{background:"none",color:o},children:l.name}),k("p",{className:"title",style:{background:"none",color:o,textOverflow:"ellipsis"},children:l.email}),k("p",{style:{background:"none",color:o},children:l.date})]}),k("button",{children:"Contact"})]})})},c))]})]})]})}function Z7e(){const{myFunction:e}=he.exports.useContext(Ve),{user:t}=he.exports.useContext(Ve),{bgcolor:n}=he.exports.useContext(Ve),{Pcolor:s}=he.exports.useContext(Ve),{SecondaryColor:r}=he.exports.useContext(Ve);al(),he.exports.useEffect(()=>{var l=t;return l=="true"&&console.log("Home"),a(),o.current=setInterval(a,5),()=>clearInterval(o.current)},[]);const i=he.exports.useRef(null),o=he.exports.useRef(null);function a(){i.current.scrollLeft+=1,i.current.scrollLeft>=2860&&(i.current.scrollLeft=1)}return window.onscroll=()=>{e()},ne("div",{className:"home",style:{background:n},children:[k("div",{className:"header",children:k("div",{className:"progress-container",id:"mytrack",children:k("div",{className:"progress-bar",id:"myBar"})})}),ne("div",{className:"containerMainR",style:{display:"flex",background:"none"},children:[ne("div",{className:"homerow",style:{background:"none",color:s},children:[ne("p",{className:"medium",style:{background:"none"},children:["Some Web Services,",k("br",{})," Some Information, And",k("br",{})," Some Free Software"]}),ne("p",{className:"paragraph",style:{background:"none"},children:["Hi \u{1F609} I've created a website for all things web 3.0. We call it",k("span",{className:"company",children:" Craft-X"}),".",k("br",{})," It has several tools and services for newbies to get started quickly and easily :)"]}),k("button",{className:"homebutton",children:"Get Started"})]}),k("div",{className:"Cardillustration",style:{margin:"auto",height:"65vh",justifyContent:"center",backgroundImage:"none",background:"none"},children:ne("div",{className:"HomeCard",children:[k("img",{src:Qr,alt:"",className:"img"}),ne("div",{className:"textBox",children:[k("p",{className:"text CardHead",children:"Craft-X"}),k("span",{children:"WebServices and Tools"})]})]})})]}),k("div",{className:"Cardhead",style:{background:"none",color:s},children:"Our Services"}),k("div",{className:"Servicegroup",ref:i,style:{background:"none"},children:ne("div",{style:{display:"flex",background:"none"},children:[k("div",{className:"services",children:"Weather App"}),k("div",{className:"services",children:"Qoute App"}),k("div",{className:"services",children:"Snake Game"}),k("div",{className:"services",children:"Node js Api"}),k("div",{className:"services",children:"Node js Website"}),k("div",{className:"servicesS",children:"Weather App"}),k("div",{className:"servicesS",children:"Qoute App"}),k("div",{className:"servicesS",children:"Snake Game"}),k("div",{className:"servicesS",children:"Node js Api"}),k("div",{className:"servicesS",children:"Node js Website"}),k("div",{className:"servicesS",children:"Weather App"}),k("div",{className:"servicesS",children:"Qoute App"}),k("div",{className:"servicesS",children:"Snake Game"}),k("div",{className:"servicesS",children:"Node js Api"}),k("div",{className:"servicesS",children:"Node js Api"})]})}),k("div",{className:"Cardhead",style:{background:"none",color:s},children:"Categories"}),ne("div",{className:"Projectgroup",style:{background:n},children:[ne("div",{className:"row1",children:[k("div",{className:"projectType",style:{background:r,color:s},children:"Three js Websites"}),k("div",{className:"projectType",style:{background:r,color:s},children:"Php Server Web Sites"}),k("div",{className:"projectType",style:{background:r,color:s},children:"Node js Server Web Sites"})]}),ne("div",{className:"row2",children:[k("div",{className:"projectType",style:{background:r,color:s},children:"React Application"}),k("div",{className:"projectType",style:{background:r,color:s},children:"Next js application"}),k("div",{className:"projectType",style:{background:r,color:s},children:"Api Generation And Deploy"})]})]}),k("h2",{className:"Cardhead",style:{background:"none",color:s},children:"API we Offers"}),ne("div",{style:{display:"flex",background:"none",width:"80vw",maxWidth:"1100px",margin:"0 auto",padding:"0 0 10vh 0",justifyContent:"center",minHeight:"50vh",flexWrap:"wrap",alignItems:"center"},children:[k("div",{style:{background:"none",width:"500px"},children:k("lottie-player",{src:"https://assets8.lottiefiles.com/packages/lf20_jM2b59ngbZ.json",background:"transparent",speed:"1",style:{background:"none"},loop:!0,autoplay:!0})}),ne("div",{className:"ApiAndTools",style:{background:"none",color:s,maxWidth:"600px"},children:[k("h2",{className:"Cardhead",style:{color:s,fontSize:"x-large"},children:"EndPoints"}),ne("li",{className:"Status",style:{fontSize:"large"},children:[k("a",{style:{background:"none",color:"var(--dblue)"},children:"API "}),"/Qoutes"]}),ne("li",{className:"Status",style:{fontSize:"large"},children:[k("a",{style:{background:"none",color:"var(--dblue)"},children:"API "}),"/Qoutes/random"]}),ne("li",{className:"Status",style:{fontSize:"large"},children:[k("a",{style:{background:"none",color:"var(--dblue)"},children:"API "}),"/Weather/{cityName}",k("a",{style:{background:"none",color:"var(--dblue)",fontSize:"small"}})]}),ne("li",{className:"Status",style:{fontSize:"large"},children:[k("a",{style:{background:"none",color:"var(--dblue)"},children:"API "}),"/download?id={variable}"]}),ne("li",{className:"Status",style:{fontSize:"large"},children:[k("a",{style:{background:"none",color:"var(--dblue)"},children:"API "}),"/caption?id={variable}"]}),k("br",{})]})]}),k("h2",{className:"Cardhead",style:{background:"none",color:s},children:"Tools we Offers"}),ne("div",{style:{display:"flex",background:"none",width:"80vw",maxWidth:"1100px",margin:"0 auto",padding:"0 0 10vh 0",justifyContent:"center",minHeight:"50vh",flexWrap:"wrap",alignItems:"center"},children:[k("div",{style:{background:"none",width:"500px"},children:k("lottie-player",{src:"https://assets7.lottiefiles.com/packages/lf20_EXQ7j6b2WO.json",background:"transparent",speed:"1",style:{background:"none"},loop:!0,autoplay:!0})}),ne("div",{className:"ApiAndTools",style:{background:"none",color:s,maxWidth:"600px"},children:[k("h2",{className:"Cardhead",style:{fontSize:"x-large",color:"var(--dblue)"},children:"Tools"}),ne("li",{className:"Status",style:{fontSize:"large"},children:[k("a",{style:{background:"none",color:"var(--dblue)"},children:" "}),"ChatGpt"]}),ne("li",{className:"Status",style:{fontSize:"large"},children:[k("a",{style:{background:"none",color:"var(--dblue)"},children:" "}),"Image Generation(DallE)"]}),ne("li",{className:"Status",style:{fontSize:"large"},children:[k("a",{style:{background:"none",color:"var(--dblue)"},children:" "}),"Image Classifier"]}),ne("li",{className:"Status",style:{fontSize:"large"},children:[k("a",{style:{background:"none",color:"var(--dblue)"},children:" "}),"Youtube Video Downloader"]}),k("li",{className:"Status",style:{fontSize:"large"},children:"Weather App"}),k("h2",{className:"Cardhead",style:{fontSize:"x-large",color:"var(--yellow)"},children:"Games"}),ne("li",{className:"Status",style:{fontSize:"large"},children:[k("a",{style:{background:"none",color:"var(--dblue)"},children:" "}),"Snake Game"]}),k("br",{})]})]})]})}const Ve=he.exports.createContext();function J7e(){const[e,t]=he.exports.useState(),[n,s]=he.exports.useState("lightbulb");var[r,i]=he.exports.useState("Black"),[o,a]=he.exports.useState("white"),[l,c]=he.exports.useState("#111111"),[h,u]=he.exports.useState(0);const[d,p]=he.exports.useState({name:"",email:"",Wallet:"",Bio:""});he.exports.useEffect(async()=>{t(sessionStorage.getItem("Loggedin")),e&&console.log("Loggedin")},[e]);function f(){var g=document.body.scrollTop||document.documentElement.scrollTop,m=document.documentElement.scrollHeight-document.documentElement.clientHeight,y=g/m*100;document.getElementById("myBar").style.width=y+"%"}return k(Hj,{children:ne(Ve.Provider,{value:{userData:d,setUserData:p,setToken:u,token:h,user:e,myFunction:f,bgcolor:r,Pcolor:o,SecondaryColor:l},children:[k("div",{style:{position:"fixed",top:"0px",width:"100vw",zIndex:"2"},children:k(Yj,{user:e,setUser:t,bgcolor:r,setBgcolor:i,Pcolor:o,setPcolor:a,setSecondaryColor:c,SecondaryColor:l,mode:n,setMode:s})}),ne(jj,{children:[k(ca,{path:"/",exact:!0,element:k(Z7e,{})}),k(ca,{path:"/signup",element:k(K7e,{user:e,setUser:t})}),k(ca,{path:"/login",element:k(H7e,{user:e,setUser:t})}),k(ca,{path:"/about",element:k(Zj,{})}),k(ca,{path:"/project",element:k(W7e,{})}),k(ca,{path:"/post",element:k(Q7e,{})}),k(ca,{path:"/team",element:k(e6,{})}),k(ca,{path:"/weather",element:k(dk,{})}),k(ca,{path:"/profile",element:k(X7e,{})}),k(ca,{path:"/test",element:k(S$,{})})]}),k(j7e,{})]})})}qj.render(k(ck.StrictMode,{children:k(J7e,{})}),document.getElementById("root"))});export default e9e();
